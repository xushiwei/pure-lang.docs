

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The Pure Manual &mdash; Pure Language and Library Documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.47',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Pure Language and Library Documentation" href="index.html" />
    <link rel="next" title="Pure Library Manual" href="purelib.html" />
    <link rel="prev" title="Using PurePad" href="purepad.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="pure-modindex.html" title="Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="purelib.html" title="Pure Library Manual"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="purepad.html" title="Using PurePad"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pure Language and Library Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-pure-manual">
<h1>The Pure Manual<a class="headerlink" href="#the-pure-manual" title="Permalink to this headline">¶</a></h1>
<p>Version 0.47, January 31, 2011</p>
<p>Albert Gräf &lt;<a class="reference external" href="mailto:Dr&#46;Graef&#37;&#52;&#48;t-online&#46;de">Dr<span>&#46;</span>Graef<span>&#64;</span>t-online<span>&#46;</span>de</a>&gt;</p>
<p>Copyright (c) 2009-2011 by Albert Gräf. This document is available under the
<a class="reference external" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License</a>. Also see the <a class="reference internal" href="#copying">Copying</a> section for licensing information of the
software.</p>
<p>This manual describes the Pure programming language and how to invoke the Pure
interpreter program. To read the manual inside the interpreter, just type
<tt class="docutils literal"><span class="pre">help</span></tt> at the command prompt. See the <a class="reference internal" href="#online-help">Online Help</a> section for details.</p>
<p>There is a companion to this manual, the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> which contains the
description of the standard library operations. More information about Pure
and the latest sources can be found under the following URLs:</p>
<ul class="simple">
<li>Pure website: <a class="reference external" href="http://pure-lang.googlecode.com">http://pure-lang.googlecode.com</a></li>
<li>Pure mailing list: <a class="reference external" href="http://groups.google.com/group/pure-lang">http://groups.google.com/group/pure-lang</a></li>
</ul>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id12">Introduction</a><ul>
<li><a class="reference internal" href="#further-reading" id="id13">Further Reading</a></li>
<li><a class="reference internal" href="#typographical-conventions" id="id14">Typographical Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#invoking-pure" id="id15">Invoking Pure</a><ul>
<li><a class="reference internal" href="#options" id="id16">Options</a></li>
<li><a class="reference internal" href="#overview-of-operation" id="id17">Overview of Operation</a></li>
<li><a class="reference internal" href="#compiling-scripts" id="id18">Compiling Scripts</a></li>
<li><a class="reference internal" href="#tagging-scripts" id="id19">Tagging Scripts</a></li>
<li><a class="reference internal" href="#running-interactively" id="id20">Running Interactively</a></li>
<li><a class="reference internal" href="#verbosity-and-debugging-options" id="id21">Verbosity and Debugging Options</a></li>
<li><a class="reference internal" href="#code-generation-options" id="id22">Code Generation Options</a></li>
<li><a class="reference internal" href="#startup-files" id="id23">Startup Files</a></li>
<li><a class="reference internal" href="#environment" id="id24">Environment</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pure-overview" id="id25">Pure Overview</a><ul>
<li><a class="reference internal" href="#lexical-matters" id="id26">Lexical Matters</a></li>
<li><a class="reference internal" href="#definitions-and-symbolic-evaluation" id="id27">Definitions and Symbolic Evaluation</a></li>
<li><a class="reference internal" href="#variables-in-equations" id="id28">Variables in Equations</a></li>
<li><a class="reference internal" href="#expression-syntax" id="id29">Expression Syntax</a><ul>
<li><a class="reference internal" href="#primary-expressions" id="id30">Primary Expressions</a></li>
<li><a class="reference internal" href="#simple-expressions" id="id31">Simple Expressions</a></li>
<li><a class="reference internal" href="#special-expressions" id="id32">Special Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-forms" id="id33">Special Forms</a></li>
<li><a class="reference internal" href="#toplevel" id="id34">Toplevel</a></li>
<li><a class="reference internal" href="#scoping-rules" id="id35">Scoping Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rule-syntax" id="id36">Rule Syntax</a><ul>
<li><a class="reference internal" href="#patterns" id="id37">Patterns</a></li>
<li><a class="reference internal" href="#type-tags" id="id38">Type Tags</a></li>
<li><a class="reference internal" href="#general-rules" id="id39">General Rules</a></li>
<li><a class="reference internal" href="#type-rules" id="id40">Type Rules</a></li>
<li><a class="reference internal" href="#simple-rules" id="id41">Simple Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id42">Examples</a><ul>
<li><a class="reference internal" href="#list-comprehensions" id="id43">List Comprehensions</a></li>
<li><a class="reference internal" href="#lazy-evaluation-and-streams" id="id44">Lazy Evaluation and Streams</a></li>
<li><a class="reference internal" href="#matrix-computations" id="id45">Matrix Computations</a></li>
<li><a class="reference internal" href="#symbolic-matrices" id="id46">Symbolic Matrices</a></li>
<li><a class="reference internal" href="#record-data" id="id47">Record Data</a></li>
<li><a class="reference internal" href="#the-quote" id="id48">The Quote</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declarations" id="id49">Declarations</a><ul>
<li><a class="reference internal" href="#symbol-declarations" id="id50">Symbol Declarations</a></li>
<li><a class="reference internal" href="#modules-and-imports" id="id51">Modules and Imports</a></li>
<li><a class="reference internal" href="#namespaces" id="id52">Namespaces</a><ul>
<li><a class="reference internal" href="#using-namespaces" id="id53">Using Namespaces</a></li>
<li><a class="reference internal" href="#symbol-lookup-and-creation" id="id54">Symbol Lookup and Creation</a></li>
<li><a class="reference internal" href="#private-symbols" id="id55">Private Symbols</a></li>
<li><a class="reference internal" href="#hierarchical-namespaces" id="id56">Hierarchical Namespaces</a></li>
<li><a class="reference internal" href="#scoped-namespaces" id="id57">Scoped Namespaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#macros" id="id58">Macros</a><ul>
<li><a class="reference internal" href="#optimization-rules" id="id59">Optimization Rules</a></li>
<li><a class="reference internal" href="#recursive-macros" id="id60">Recursive Macros</a></li>
<li><a class="reference internal" href="#user-defined-special-forms" id="id61">User-Defined Special Forms</a></li>
<li><a class="reference internal" href="#macro-hygiene" id="id62">Macro Hygiene</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exception-handling" id="id63">Exception Handling</a></li>
<li><a class="reference internal" href="#c-interface" id="id64">C Interface</a><ul>
<li><a class="reference internal" href="#extern-declarations" id="id65">Extern Declarations</a></li>
<li><a class="reference internal" href="#variadic-c-functions" id="id66">Variadic C Functions</a></li>
<li><a class="reference internal" href="#c-types" id="id67">C Types</a><ul>
<li><a class="reference internal" href="#basic-c-types" id="id68">Basic C Types</a></li>
<li><a class="reference internal" href="#pointer-types" id="id69">Pointer Types</a></li>
<li><a class="reference internal" href="#pointers-and-matrices" id="id70">Pointers and Matrices</a></li>
<li><a class="reference internal" href="#pointer-examples" id="id71">Pointer Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#importing-dynamic-libraries" id="id72">Importing Dynamic Libraries</a></li>
<li><a class="reference internal" href="#importing-llvm-bitcode" id="id73">Importing LLVM Bitcode</a></li>
<li><a class="reference internal" href="#inline-code" id="id74">Inline Code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#standard-library" id="id75">Standard Library</a></li>
<li><a class="reference internal" href="#interactive-usage" id="id76">Interactive Usage</a><ul>
<li><a class="reference internal" href="#online-help" id="id77">Online Help</a></li>
<li><a class="reference internal" href="#interactive-commands" id="id78">Interactive Commands</a></li>
<li><a class="reference internal" href="#last-result" id="id79">Last Result</a></li>
<li><a class="reference internal" href="#specifying-symbol-selections" id="id80">Specifying Symbol Selections</a></li>
<li><a class="reference internal" href="#the-show-command" id="id81">The show Command</a></li>
<li><a class="reference internal" href="#definition-levels" id="id82">Definition Levels</a></li>
<li><a class="reference internal" href="#debugging" id="id83">Debugging</a></li>
<li><a class="reference internal" href="#interactive-startup" id="id84">Interactive Startup</a></li>
</ul>
</li>
<li><a class="reference internal" href="#batch-compilation" id="id85">Batch Compilation</a><ul>
<li><a class="reference internal" href="#example" id="id86">Example</a></li>
<li><a class="reference internal" href="#code-size-and-unstripped-executables" id="id87">Code Size and Unstripped Executables</a></li>
<li><a class="reference internal" href="#other-output-code-formats" id="id88">Other Output Code Formats</a></li>
<li><a class="reference internal" href="#calling-pure-functions-from-c" id="id89">Calling Pure Functions From C</a></li>
</ul>
</li>
<li><a class="reference internal" href="#caveats-and-notes" id="id90">Caveats and Notes</a><ul>
<li><a class="reference internal" href="#etymology" id="id91">Etymology</a></li>
<li><a class="reference internal" href="#backward-compatibility" id="id92">Backward Compatibility</a></li>
<li><a class="reference internal" href="#error-recovery" id="id93">Error Recovery</a></li>
<li><a class="reference internal" href="#the-show-function" id="id94">The __show__ Function</a></li>
<li><a class="reference internal" href="#non-linear-patterns" id="id95">Non-Linear Patterns</a></li>
<li><a class="reference internal" href="#as-patterns" id="id96">&#8220;As&#8221; Patterns</a></li>
<li><a class="reference internal" href="#head-function" id="id97">Head = Function</a></li>
<li><a class="reference internal" href="#with-and-when" id="id98">With and when</a></li>
<li><a class="reference internal" href="#numeric-calculations" id="id99">Numeric Calculations</a></li>
<li><a class="reference internal" href="#constant-definitions" id="id100">Constant Definitions</a></li>
<li><a class="reference internal" href="#external-c-functions" id="id101">External C Functions</a></li>
<li><a class="reference internal" href="#calling-special-forms" id="id102">Calling Special Forms</a></li>
<li><a class="reference internal" href="#laziness" id="id103">Laziness</a></li>
<li><a class="reference internal" href="#reflection" id="id104">Reflection</a></li>
<li><a class="reference internal" href="#hygienic-macros" id="id105">Hygienic Macros</a></li>
<li><a class="reference internal" href="#stack-size-and-tail-recursion" id="id106">Stack Size and Tail Recursion</a></li>
<li><a class="reference internal" href="#handling-of-asynchronous-signals" id="id107">Handling of Asynchronous Signals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#author" id="id108">Author</a></li>
<li><a class="reference internal" href="#copying" id="id109">Copying</a></li>
<li><a class="reference internal" href="#references-and-links" id="id110">References and Links</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id12">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Pure is a functional programming language based on term rewriting. This means
that all your programs are essentially just collections of symbolic equations
which the interpreter uses to reduce expressions to their simplest (&#8220;normal&#8221;)
form. This makes for a rather powerful and flexible programming model
featuring dynamic typing and general polymorphism. In addition, Pure programs
are compiled to efficient native code on the fly, using the <a class="reference internal" href="#llvm">LLVM</a> compiler
framework, so programs are executed reasonably fast and interfacing to C is
very easy. If you have the necessary 3rd party compilers installed then you
can even inline functions written in C and a number of other languages and
call them just like any other Pure function. The ease with which you can
interface to 3rd party software makes Pure useful for a wide range of
applications from symbolic algebra and scientific programming to database, web
and multimedia applications.</p>
<p>The Pure language is implemented by the <strong class="dfn">Pure interpreter</strong> program. Just like
other programming language interpreters, the Pure interpreter provides an
interactive environment in which you can type definitions and expressions,
which are executed as you type them at the interpreter&#8217;s command prompt.
However, despite its name the Pure interpreter never really &#8220;interprets&#8221; any
Pure code. Rather, it acts as a frontend to the <strong class="dfn">Pure compiler</strong>, which takes
care of incrementally compiling Pure code to native (machine) code. This has
the benefit that the compiled code runs much faster than the usual kinds of
&#8220;bytecode&#8221; that you find in traditional programming language interpreters.</p>
<p>You can use the interpreter as a sophisticated kind of &#8220;desktop calculator&#8221;
program. Simply run the program from the shell as follows:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> pure
<span class="go">Pure 0.47 (x86_64-unknown-linux-gnu) Copyright (c) 2008-2011 by Albert Graef</span>
<span class="go">(Type &#39;help&#39; for help, &#39;help copying&#39; for license information.)</span>
<span class="go">Loaded prelude from /usr/local/lib/pure/prelude.pure.</span>

<span class="gp">&gt;</span>
</pre></div>
</div>
<p>The interpreter prints its sign-on message and leaves you at its &#8216;&gt; &#8216; command
prompt, where you can start typing definitions and expressions to be
evaluated:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mi">17</span>/<span class="mi">12</span>+<span class="mi">23</span><span class="p">;</span>
<span class="mf">24.4166666666667</span>
<span class="gp">&gt; </span>fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Typing the <tt class="docutils literal"><span class="pre">quit</span></tt> command or the end-of-file character (<tt class="kbd docutils literal"><span class="pre">Ctrl-d</span></tt> on
Unix systems) at the beginning of the command line exits the interpreter and
takes you back to the shell.</p>
<p>Instead of typing definitions and evaluating expressions in an interactive
fashion as shown above, you can also put the same code in an (ASCII or UTF-8)
text file called a <strong class="dfn">Pure program</strong> or <strong class="dfn">script</strong> which can then be executed by
the interpreter in &#8220;batch mode&#8221;, or compiled to a standalone executable which
can be run directly from the command line. As an aid for writing script files,
a bunch of syntax highlighting files and programming modes for various popular
text editors are included in the Pure sources.</p>
<p>More information about invoking the Pure interpreter can be found in the
<a class="reference internal" href="#invoking-pure">Invoking Pure</a> section below. This is followed by a description of the Pure
language in <a class="reference internal" href="#pure-overview">Pure Overview</a> and subsequent sections. The interactive
facilities of the Pure interpreter are discussed in the <a class="reference internal" href="#interactive-usage">Interactive Usage</a>
section, while the <a class="reference internal" href="#batch-compilation">Batch Compilation</a> section explains how to translate Pure
programs to native executables and a number of other object file formats. The
<a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section discusses useful tips and tricks, as well as
various pitfalls and how to avoid them. The manual concludes with some
authorship and licensing information and pointers to related software.</p>
<div class="section" id="further-reading">
<h3><a class="toc-backref" href="#id13">Further Reading</a><a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h3>
<p>This manual is not intended as a general introduction to functional
programming, so at least some familiarity with this programming style is
assumed. If Pure is your first functional language then you might want to look
at the <a class="reference external" href="http://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a> wikipedia article to see what it is all about
and find pointers to current literature on the subject. In any case we hope
that you&#8217;ll find Pure helpful in exploring functional programming, as it is
fairly easy to learn but a very powerful language.</p>
<p>As already mentioned, Pure uses term rewriting as its underlying computational
model, which goes well beyond functional programming in some ways. Term
rewriting has long been used in computer algebra systems, and <a class="reference internal" href="#michael-o-donnell">Michael
O&#8217;Donnell</a> pioneered its use as a programming language already in the
1980s. But until recently implementations have not really been efficient
enough to be useful as general-purpose programming languages; Pure strives to
change that. A good introduction to the theory of the term rewriting calculus
and its applications is the book by <a class="reference internal" href="#baader-and-nipkow">Baader and Nipkow</a>.</p>
</div>
<div class="section" id="typographical-conventions">
<h3><a class="toc-backref" href="#id14">Typographical Conventions</a><a class="headerlink" href="#typographical-conventions" title="Permalink to this headline">¶</a></h3>
<p>Program examples are always set in typewriter font. Here’s how a typical code
sample may look like:</p>
<div class="highlight-pure"><div class="highlight"><pre>fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact(n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>These can either be saved to a file and then loaded into the interpreter, or
you can also just type them directly in the interpreter. If some lines start
with the interpreter prompt &#8216;&gt; &#8216;, this indicates an example interaction with
the interpreter. Everything following the prompt (excluding the &#8216;&gt; &#8216; itself)
is meant to be typed exactly as written. Lines lacking the &#8216;&gt; &#8216; prefix show
results printed by the interpreter. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact(n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Similarly, lines starting with the ‘$ ’ prompt indicate shell interactions.
For instance,</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> pure
</pre></div>
</div>
<p>indicates that you should type the command <tt class="docutils literal"><span class="pre">pure</span></tt> on your system’s command
line.</p>
<p>The grammar notation in this manual uses an extended form of BNF (Backus-Naur
form), which looks as follows:</p>
<pre>
<strong id="grammar-token-expression">expression</strong> ::=  &quot;{&quot; <a class="reference internal" href="#grammar-token-expr_list"><tt class="xref docutils literal"><span class="pre">expr_list</span></tt></a> (&quot;;&quot; <a class="reference internal" href="#grammar-token-expr_list"><tt class="xref docutils literal"><span class="pre">expr_list</span></tt></a>)* [&quot;;&quot;] &quot;}&quot;
<strong id="grammar-token-expr_list">expr_list </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> (',' <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>)*
</pre>
<p>Parentheses are used to group syntactical elements, while brackets denote
optional elements. We also use the regular expression operators <tt class="docutils literal"><span class="pre">*</span></tt> and
<tt class="docutils literal"><span class="pre">+</span></tt> to denote repetitions (as usual, <tt class="docutils literal"><span class="pre">*</span></tt> denotes zero or more, <tt class="docutils literal"><span class="pre">+</span></tt> one
or more repetitions of the preceding element). Terminals (literal elements
such as keywords and delimiters) are enclosed in double or single quotes.</p>
<p>These EBNF rules are used for both lexical and syntactical elements, but note
that the former are concerned with entities formed from single characters and
thus tokens are meant to be typed exactly as written, whereas the latter deal
with larger syntactical structures where whitespace between tokens is
generally insignificant.</p>
</div>
</div>
<div class="section" id="invoking-pure">
<h2><a class="toc-backref" href="#id15">Invoking Pure</a><a class="headerlink" href="#invoking-pure" title="Permalink to this headline">¶</a></h2>
<p>The Pure interpreter is invoked as follows:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">pure [options ...] [script ...] [-- args ...]</span>
<span class="go">pure [options ...] -x script [args ...]</span>
</pre></div>
</div>
<p>Use <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-h</span></tt> to get help about the command line options. As already
mentioned, just the <tt class="docutils literal"><span class="pre">pure</span></tt> command without any command line parameters
invokes the interpreter in interactive mode, see <a class="reference internal" href="#running-interactively">Running Interactively</a>
below for details. Some other important ways to invoke the interpreter are
summarized below.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-g</span></tt></dt>
<dd>Runs the interpreter interactively, with debugging support.</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">script</span> <span class="pre">...</span></tt></dt>
<dd>Runs the given scripts in batch mode.</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-i</span> <span class="pre">script</span> <span class="pre">...</span></tt></dt>
<dd>Runs the given scripts in batch mode as above, but then enters the
interactive command loop. (Add <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> to also get debugging support,
and <a class="reference internal" href="#cmdoption-pure-q"><em class="xref std std-option">-q</em></a> to suppress the sign-on message.)</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-x</span> <span class="pre">script</span> <span class="pre">[arg</span> <span class="pre">...]</span></tt></dt>
<dd>Runs the given script with the given parameters. The script name and command
line arguments are available in the global <tt class="docutils literal"><span class="pre">argv</span></tt> variable.</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span> <span class="pre">script</span> <span class="pre">[-o</span> <span class="pre">prog]</span></tt></dt>
<dd>Batch compilation: Runs the given script, compiling it to a native
executable <tt class="docutils literal"><span class="pre">prog</span></tt> (a.out by default).</dd>
</dl>
<p>Depending on your local setup, there may be additional ways to run the Pure
interpreter. In particular, if you have Emacs Pure mode installed, then you
can just open a script in Emacs and run it with the <tt class="kbd docutils literal"><span class="pre">C-c</span> <span class="pre">C-k</span></tt> keyboard
command. For Emacs aficionados, this is probably the most convenient way to
execute a Pure script interactively in the interpreter. Pure mode actually
turns Emacs into an advanced IDE (integrated development environment) for
Pure, which offers a lot of convenient features such as syntax highlighting,
automatic indentation, online help and different ways to interact with the
Pure interpreter.</p>
<div class="section" id="options">
<h3><a class="toc-backref" href="#id16">Options</a><a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h3>
<p>The interpreter accepts various options which are described in more detail
below.</p>
<dl class="option">
<dt id="cmdoption-pure-c">
<tt class="descname">-c</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-c" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch compilation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--ctags">
<tt class="descname">--ctags</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--ctags" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--etags">
<tt class="descname">--etags</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--etags" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tags file in ctags (vi) or etags (emacs) format.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--eager-jit">
<tt class="descname">--eager-jit</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--eager-jit" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable eager JIT compilation. This requires LLVM 2.7 or later, otherwise
this flag will be ignored.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-fPIC">
<tt class="descname">-fPIC</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-fPIC" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure-fpic">
<tt class="descname">-fpic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-fpic" title="Permalink to this definition">¶</a></dt>
<dd><p>Create position-independent code (batch compilation).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-g">
<tt class="descname">-g</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-g" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable symbolic debugging.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-h">
<tt class="descname">-h</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-h" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--help">
<tt class="descname">--help</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--help" title="Permalink to this definition">¶</a></dt>
<dd><p>Print help message and exit.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-i">
<tt class="descname">-i</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-i" title="Permalink to this definition">¶</a></dt>
<dd><p>Force interactive mode (read commands from stdin).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-I">
<tt class="descname">-I</tt><tt class="descclassname"> directory</tt><a class="headerlink" href="#cmdoption-pure-I" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a directory to be searched for included source scripts.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-L">
<tt class="descname">-L</tt><tt class="descclassname"> directory</tt><a class="headerlink" href="#cmdoption-pure-L" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a directory to be searched for dynamic libraries.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-l">
<tt class="descname">-l</tt><tt class="descclassname"> libname</tt><a class="headerlink" href="#cmdoption-pure-l" title="Permalink to this definition">¶</a></dt>
<dd><p>Library to be linked in batch compilation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--noediting">
<tt class="descname">--noediting</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--noediting" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable command-line editing.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-n">
<tt class="descname">-n</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-n" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--noprelude">
<tt class="descname">--noprelude</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--noprelude" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not load the prelude.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--norc">
<tt class="descname">--norc</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--norc" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not run the interactive startup files.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-o">
<tt class="descname">-o</tt><tt class="descclassname"> filename</tt><a class="headerlink" href="#cmdoption-pure-o" title="Permalink to this definition">¶</a></dt>
<dd><p>Output filename for batch compilation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-q">
<tt class="descname">-q</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-q" title="Permalink to this definition">¶</a></dt>
<dd><p>Quiet startup (suppresses sign-on message in interactive mode).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-T">
<tt class="descname">-T</tt><tt class="descclassname"> filename</tt><a class="headerlink" href="#cmdoption-pure-T" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags file to be written by <a class="reference internal" href="#cmdoption-pure--ctags"><em class="xref std std-option">--ctags</em></a> or <a class="reference internal" href="#cmdoption-pure--etags"><em class="xref std std-option">--etags</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-u">
<tt class="descname">-u</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-u" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not strip unused functions in batch compilation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-v">
<tt class="descname">-v</tt><tt class="descclassname">[level]</tt><a class="headerlink" href="#cmdoption-pure-v" title="Permalink to this definition">¶</a></dt>
<dd><p>Set verbosity level. See below for details.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--version">
<tt class="descname">--version</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--version" title="Permalink to this definition">¶</a></dt>
<dd><p>Print version information and exit.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-w">
<tt class="descname">-w</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-w" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable compiler warnings.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-x">
<tt class="descname">-x</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-x" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute script with given command line arguments.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--">
<tt class="descname">--</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop option processing and pass the remaining command line arguments in
the <tt class="docutils literal"><span class="pre">argv</span></tt> variable.</p>
</dd></dl>

<p>(Besides these, the interpreter also understands a number of other command
line switches for setting various code generation options; please see <a class="reference internal" href="#code-generation-options">Code
Generation Options</a> below for details.)</p>
</div>
<div class="section" id="overview-of-operation">
<h3><a class="toc-backref" href="#id17">Overview of Operation</a><a class="headerlink" href="#overview-of-operation" title="Permalink to this headline">¶</a></h3>
<p>If any source scripts are specified on the command line, they are loaded and
executed, after which the interpreter exits. Otherwise the interpreter enters
the interactive read-eval-print loop, see <a class="reference internal" href="#running-interactively">Running Interactively</a> below. You
can also use the <a class="reference internal" href="#cmdoption-pure-i"><em class="xref std std-option">-i</em></a> option to enter the interactive loop (continue
reading from stdin) even after processing some source scripts.</p>
<p>Options and source files are processed in the order in which they are given on
the command line. Processing of options and source files ends when either the
<a class="reference internal" href="#cmdoption-pure--"><em class="xref std std-option">--</em></a> or the <a class="reference internal" href="#cmdoption-pure-x"><em class="xref std std-option">-x</em></a> option is encountered. The <a class="reference internal" href="#cmdoption-pure-x"><em class="xref std std-option">-x</em></a>
option must be followed by the name of a script to be executed, which becomes
the &#8220;main script&#8221; of the application. In either case, any remaining parameters
are passed to the executing script by means of the global <tt class="docutils literal"><span class="pre">argc</span></tt> and
<tt class="docutils literal"><span class="pre">argv</span></tt> variables, denoting the number of arguments and the list of the
actual parameter strings, respectively. In the case of <a class="reference internal" href="#cmdoption-pure-x"><em class="xref std std-option">-x</em></a> this also
includes the script name as <tt class="docutils literal"><span class="pre">argv!0</span></tt>. The <a class="reference internal" href="#cmdoption-pure-x"><em class="xref std std-option">-x</em></a> option is useful, in
particular, to turn Pure scripts into executable programs by including a
&#8220;shebang&#8221; like the following as the first line in your main script. (This
trick only works with Unix shells, though.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="cp">#!/usr/local/bin/pure -x</span>
</pre></div>
</div>
<p>On startup, the interpreter also defines the <tt class="xref pure pure-var docutils literal"><span class="pre">version</span></tt> variable, which is
set to the version string of the Pure interpreter, and the <tt class="xref pure pure-var docutils literal"><span class="pre">sysinfo</span></tt>
variable, which provides a string identifying the host system. These are
useful if parts of your script depend on the particular version of the
interpreter and the system it runs on. (Moreover, Pure 0.21 and later also
define the variable <tt class="xref pure pure-var docutils literal"><span class="pre">compiling</span></tt> which indicates whether the program is
executed in a batch compilation, see <a class="reference internal" href="#compiling-scripts">Compiling Scripts</a> below.)</p>
<p>If available, the prelude script prelude.pure is loaded by the interpreter
prior to any other definitions, unless the <a class="reference internal" href="#cmdoption-pure-n"><em class="xref std std-option">-n</em></a> or
<a class="reference internal" href="#cmdoption-pure--noprelude"><em class="xref std std-option">--noprelude</em></a> option is specified. The prelude is searched for in the
directory specified with the <span class="target" id="index-0"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a> environment variable. If the
<span class="target" id="index-1"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a> variable is not set, a system-specific default is
used. Relative pathnames of other source scripts specified on the command line
are interpreted relative to the current working directory. In addition, the
executed program may load other scripts and libraries via a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a>
declaration in the source, which are searched for in a number of locations,
including the directories named with the <a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a> and <a class="reference internal" href="#cmdoption-pure-L"><em class="xref std std-option">-L</em></a>
options; see the <a class="reference internal" href="#declarations">Declarations</a> and <a class="reference internal" href="#c-interface">C Interface</a> sections for details.</p>
</div>
<div class="section" id="compiling-scripts">
<h3><a class="toc-backref" href="#id18">Compiling Scripts</a><a class="headerlink" href="#compiling-scripts" title="Permalink to this headline">¶</a></h3>
<p>The interpreter compiles scripts, as well as definitions that you enter
interactively, automatically. This is done in an incremental fashion, as the
code is needed, and is therefore known as JIT (<strong class="dfn">just in time</strong>) compilation.
Thus the interpreter never really &#8220;interprets&#8221; the source program or some
intermediate representation, it just acts as a frontend to the compiler,
taking care of compiling source code to native machine code before it gets
executed.</p>
<p>Pure&#8217;s LLVM backend does &#8220;lazy JIT compilation&#8221; by default, meaning that each
function (global or local) is compiled no sooner than it is run for the first
time. With the <a class="reference internal" href="#cmdoption-pure--eager-jit"><em class="xref std std-option">--eager-jit</em></a> option, however, it will also compile all
other (global or local) functions that may be called by the compiled
function. (The <span class="target" id="index-2"></span><a class="reference internal" href="#envvar-PURE_EAGER_JIT"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_EAGER_JIT</span></tt></a> environment variable, when set to any
value, has the same effect, so that you do not have to specify the
<a class="reference internal" href="#cmdoption-pure--eager-jit"><em class="xref std std-option">--eager-jit</em></a> option each time you run the interpreter.) Eager JIT
compilation may be more efficient in some cases (since bigger chunks of
compilation work can be done in one go) and less efficient in others (e.g.,
eager JITing may compile large chunks of code which aren&#8217;t actually called
later, except in rare circumstances).</p>
<p>Note that the eager JIT mode is only available with LLVM 2.7 or later;
otherwise this option will be ignored.</p>
<p>It is also possible to compile your scripts to native code beforehand, using
the <a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> batch compilation option. This options forces the interpreter
to non-interactive mode (unless <a class="reference internal" href="#cmdoption-pure-i"><em class="xref std std-option">-i</em></a> is specified as well, which
overrides <a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a>). Any scripts specified on the command line are then
executed as usual, but after execution the interpreter takes a snapshot of the
program and compiles it to one of several supported output formats, LLVM
assembler (.ll) or bitcode (.bc), native assembler (.s) or object (.o), or a
native executable, depending on the output filename specified with
<a class="reference internal" href="#cmdoption-pure-o"><em class="xref std std-option">-o</em></a>. If the output filename ends in the .ll extension, an LLVM
assembler file is created which can then be processed with the LLVM
toolchain. If the output filename is just &#8216;-&#8216;, the assembler file is written
to standard output, which is useful if you want to pass the generated code to
the LLVM tools in a pipeline. If the output filename ends in the .bc
extension, an LLVM bitcode file is created instead.</p>
<p>The .ll and .bc formats are supported natively by the Pure interpreter, no
external tools are required to generate these. If the target is an .s, .o or
executable file, the Pure interpreter creates a temporary bitcode file on
which it invokes the LLVM tools <strong class="program">opt</strong> and <strong class="program">llc</strong> to create a
native assembler file, and then uses <strong class="program">gcc</strong> to assemble and link the
resulting program (if requested). You can also specify additional libraries to
be linked into the executable with the <a class="reference internal" href="#cmdoption-pure-l"><em class="xref std std-option">-l</em></a> option. If the output
filename is omitted, it defaults to a.out (a.exe on Windows).</p>
<p>The <a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> option provides a convenient way to quickly turn a Pure
script into a standalone executable which can be invoked directly from the
shell. One advantage of compiling your script is that this eliminates the JIT
compilation time and thus considerably reduces the startup time of the
program. Another reason to prefer a standalone executable is that it lets you
deploy the program on systems without a full Pure installation (usually only
the runtime library is required on the target system). On the other hand,
compiled scripts also have some limitations, mostly concerning the use of the
built-in <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> function. Please see the <a class="reference internal" href="#batch-compilation">Batch Compilation</a> section
for details.</p>
<p>The <tt class="docutils literal"><span class="pre">-v64</span></tt> (or <tt class="docutils literal"><span class="pre">-v0100</span></tt>) verbosity option can be used to have the
interpreter print the commands it executes during compilation, see <a class="reference internal" href="#verbosity-and-debugging-options">Verbosity
and Debugging Options</a> below. When creating an object file, this also prints
the suggested linker command (including all the dynamic modules loaded by the
script, which also have to be linked in to create a working executable), to
which you only have to add the options describing the desired output file.</p>
</div>
<div class="section" id="tagging-scripts">
<h3><a class="toc-backref" href="#id19">Tagging Scripts</a><a class="headerlink" href="#tagging-scripts" title="Permalink to this headline">¶</a></h3>
<p>Pure programs often have declarations and definitions of global symbols
scattered out over many different source files. The <a class="reference internal" href="#cmdoption-pure--ctags"><em class="xref std std-option">--ctags</em></a> and
<a class="reference internal" href="#cmdoption-pure--etags"><em class="xref std std-option">--etags</em></a> options let you create a <a class="reference external" href="http://en.wikipedia.org/wiki/Ctags">tags</a> file which allows you to
quickly locate these items in text editors such as <strong class="program">vi</strong> and
<strong class="program">emacs</strong> which support this feature.</p>
<p>If <a class="reference internal" href="#cmdoption-pure--ctags"><em class="xref std std-option">--ctags</em></a> or <a class="reference internal" href="#cmdoption-pure--etags"><em class="xref std std-option">--etags</em></a> is specified, the interpreter enters
a special mode in which it only parses source files without executing them and
collects information about the locations of global symbol declarations and
definitions. The collected information is then written to a tags file in the
ctags or etags format used by <strong class="program">vi</strong> and <strong class="program">emacs</strong>,
respectively. The desired name of the tags file can be specified with the
<a class="reference internal" href="#cmdoption-pure-T"><em class="xref std std-option">-T</em></a> option; it defaults to tags for <a class="reference internal" href="#cmdoption-pure--ctags"><em class="xref std std-option">--ctags</em></a> and TAGS for
<a class="reference internal" href="#cmdoption-pure--etags"><em class="xref std std-option">--etags</em></a> (which matches the default tags file names used by
<strong class="program">vi</strong> and <strong class="program">emacs</strong>, respectively).</p>
<p>The tags file contains information about the global constant, variable, macro,
function and operator symbols of all scripts specified on the command line, as
well as the prelude and other scripts included via a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause.
Tagged scripts which are located in the same directory as the tags file (or,
recursively, in one of its subdirectories) are specified using relative
pathnames, while scripts outside this hierarchy (such as included scripts from
the standard library) are denoted with absolute pathnames. This scheme makes
it possible to move an entire directory together with its tags file and have
the tags information still work in the new location.</p>
</div>
<div class="section" id="running-interactively">
<h3><a class="toc-backref" href="#id20">Running Interactively</a><a class="headerlink" href="#running-interactively" title="Permalink to this headline">¶</a></h3>
<p>If the interpreter runs in interactive mode, it repeatedly prompts you for
input (which may be any legal Pure code or some special interpreter commands
provided for interactive usage), and prints computed results. This is also
known as the <strong class="dfn">read-eval-print</strong> loop and is described in much more detail in
the <a class="reference internal" href="#interactive-usage">Interactive Usage</a> section. To exit the interpreter, just type the
<tt class="docutils literal"><span class="pre">quit</span></tt> command or the end-of-file character (<tt class="kbd docutils literal"><span class="pre">Ctrl-d</span></tt> on Unix) at the
beginning of the command line.</p>
<p>The interpreter may also source a few additional interactive startup files
immediately before entering the interactive loop, unless the <a class="reference internal" href="#cmdoption-pure--norc"><em class="xref std std-option">--norc</em></a>
option is specified. First .purerc in the user&#8217;s home directory is read, then
.purerc in the current working directory. These are ordinary Pure scripts
which can be used to provide additional definitions for interactive
usage. Finally, a .pure file in the current directory (containing a dump from
a previous interactive session) is loaded if it is present.</p>
<p>When the interpreter is in interactive mode and reads from a tty, unless the
<a class="reference internal" href="#cmdoption-pure--noediting"><em class="xref std std-option">--noediting</em></a> option is specified, commands are usually read using
<strong class="program">readline</strong> or some compatible replacement, providing completion for
all commands listed under <a class="reference internal" href="#interactive-usage">Interactive Usage</a>, as well as for symbols defined
in the running program. When exiting the interpreter, the command history is
stored in ~/.pure_history, from where it is restored the next time you run the
interpreter.</p>
<p>The interpreter also provides a simple source level debugger when run in
interactive mode, see <a class="reference internal" href="#debugging">Debugging</a> for details. To enable the debugger, you need
to specify the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option when invoking the interpreter. This option
causes your script to run <em>much</em> slower, so you should only use this option if
you want to run the debugger.</p>
</div>
<div class="section" id="verbosity-and-debugging-options">
<h3><a class="toc-backref" href="#id21">Verbosity and Debugging Options</a><a class="headerlink" href="#verbosity-and-debugging-options" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#cmdoption-pure-v"><em class="xref std std-option">-v</em></a> option is useful for debugging the interpreter, or if you are
interested in the code your program gets compiled to. The level argument is
optional; it defaults to 1. Seven different levels are implemented at this
time (one more bit is reserved for future extensions). Only the first two
levels will be useful for the average Pure programmer; the remaining levels
are mostly intended for maintenance purposes.</p>
<dl class="docutils">
<dt>1 (0x1, 001)</dt>
<dd>denotes echoing of parsed definitions and expressions.</dd>
<dt>2 (0x2, 002)</dt>
<dd>adds special annotations concerning local bindings (de Bruijn indices,
subterm paths; this can be helpful to debug tricky variable binding
issues).</dd>
<dt>4 (0x4, 004)</dt>
<dd>adds descriptions of the matching automata for the left-hand sides of
equations (you probably want to see this only when working on the guts of
the interpreter).</dd>
<dt>8 (0x8, 010)</dt>
<dd>dumps the &#8220;real&#8221; output code (LLVM assembler, which is as close to the
native machine code for your program as it gets; you definitely don&#8217;t want
to see this unless you have to inspect the generated code for bugs or
performance issues).</dd>
<dt>16 (0x10, 020)</dt>
<dd>adds debugging messages from the bison(1) parser; useful for debugging the
parser.</dd>
<dt>32 (0x20, 040)</dt>
<dd>adds debugging messages from the flex(1) lexer; useful for debugging the
lexer.</dd>
<dt>64 (0x40, 0100)</dt>
<dd>turns on verbose batch compilation; this is useful if you want to see
exactly which commands get executed during batch compilation
(<a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a>).</dd>
</dl>
<p>These values can be or&#8217;ed together, and, for convenience, can be specified in
either decimal, hexadecimal or octal. Thus 0xff or 0777 always gives you full
debugging output (which isn&#8217;t likely to be used by anyone but the Pure
developers). Some useful flag combinations for experts are (in octal) 007
(echo definitions along with de Bruijn indices and matching automata), 011
(definitions and assembler code) and 021 (parser debugging output along with
parsed definitions).</p>
<p>Note that the <a class="reference internal" href="#cmdoption-pure-v"><em class="xref std std-option">-v</em></a> option is only applied after the prelude has been
loaded. If you want to debug the prelude, use the <a class="reference internal" href="#cmdoption-pure-n"><em class="xref std std-option">-n</em></a> option and
specify the prelude.pure file explicitly on the command line. Verbose output
is also suppressed for modules imported through a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause. As
a remedy, you can use the interactive <tt class="docutils literal"><span class="pre">show</span></tt> command (see the <a class="reference internal" href="#interactive-usage">Interactive
Usage</a> section) to list definitions along with additional debugging
information.</p>
<p>The <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option enables some additional warnings which are useful to
check your scripts for possible errors. Right now it will report implicit
declarations of function symbols which might indicate missing or mistyped
symbols that need to be fixed, see <a class="reference internal" href="#symbol-lookup-and-creation">Symbol Lookup and Creation</a> for details.</p>
</div>
<div class="section" id="code-generation-options">
<h3><a class="toc-backref" href="#id22">Code Generation Options</a><a class="headerlink" href="#code-generation-options" title="Permalink to this headline">¶</a></h3>
<p>Besides the options listed above, the interpreter also understands some
additional command line switches and corresponding environment variables to
control various code generation options. The options take the form <tt class="docutils literal"><span class="pre">--opt</span></tt>
and <tt class="docutils literal"><span class="pre">--noopt</span></tt>, respectively, where <tt class="docutils literal"><span class="pre">opt</span></tt> denotes the option name (see
below for a list of supported options). By default, these options are all
enabled; <tt class="docutils literal"><span class="pre">--noopt</span></tt> disables the option, <tt class="docutils literal"><span class="pre">--opt</span></tt> reenables it. In addition,
for each option <tt class="docutils literal"><span class="pre">opt</span></tt> there is also a corresponding environment variable
<tt class="docutils literal"><span class="pre">PURE_NOOPT</span></tt> (with the option name in uppercase) which, when set, disables
the option by default. (Setting this variable to any value will do, the
interpreter only checks whether the variable exists in the environment.)</p>
<p>For instance, the <tt class="docutils literal"><span class="pre">checks</span></tt> option controls stack and signal checks. Thus
<tt class="docutils literal"><span class="pre">--nochecks</span></tt> on the command line disables the option, and setting the
<tt class="docutils literal"><span class="pre">PURE_NOCHECKS</span></tt> environment variable makes this the default, in which case
you can use <tt class="docutils literal"><span class="pre">--checks</span></tt> on the command line to reenable the option.</p>
<p>Each code generation option can also be used as a <strong class="dfn">pragma</strong> (compiler
directive) in source code so that you can control it on a per-rule basis. The
pragma must be on a line by itself, starting in column 1, and takes the
following form (using <tt class="docutils literal"><span class="pre">--nochecks</span></tt> as an example):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="cp">#! --nochecks // line-oriented comment may go here</span>
</pre></div>
</div>
<p>Currently, the following code generation options are recognized:</p>
<dl class="option">
<dt id="cmdoption-pure--checks">
<tt class="descname">--checks</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--checks" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--nochecks">
<tt class="descname">--nochecks</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--nochecks" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable various extra stack and signal checks. By default, the
interpreter checks for stack overflows (if the <span class="target" id="index-3"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a>
environment variable is set) and pending signals on entry to every
function, see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a> and <a class="reference internal" href="#handling-of-asynchronous-signals">Handling of
Asynchronous Signals</a> for details. This is needed to catch these
conditions in a reliable way, so we recommend to leave this enabled.
However, these checks also make programs run a little slower (typically
some 5%, YMMV). If performance is critical then you can disable the checks
with the <a class="reference internal" href="#cmdoption-pure--nochecks"><em class="xref std std-option">--nochecks</em></a> option. (Even then, a minimal amount of
checking will be done, usually on entry to every global function.)</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--const">
<tt class="descname">--const</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--const" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--noconst">
<tt class="descname">--noconst</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--noconst" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable the precomputing of constant values in batch compilation
(cf. <a class="reference internal" href="#compiling-scripts">Compiling Scripts</a>). If enabled (which is the default), the values
of constants in <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> definitions are precomputed at compile
time (if possible) and then stored in the generated executable. This
usually yields faster startup times but bigger executables. You can disable
this option with <a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> to get smaller executables at the
expense of slower startup times. Please see the <a class="reference internal" href="#batch-compilation">Batch Compilation</a>
section for an example.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--fold">
<tt class="descname">--fold</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--fold" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--nofold">
<tt class="descname">--nofold</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--nofold" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable constant folding in the compiler frontend. This means
that constant expressions involving int and double values and the usual
arithmetic and logical operations on these are precomputed at compile
time. (This is mostly for cosmetic purposes; the LLVM backend will perform
this optimization anyway when generating machine code.) For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo x = <span class="mi">2</span>*<span class="mi">3</span>*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = <span class="mi">6</span>*x<span class="p">;</span>
</pre></div>
</div>
<p>Disabling constant folding in the frontend causes constant expressions to
be shown as you entered them:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="cp">#! --nofold</span>
<span class="gp">&gt; </span>bar x = <span class="mi">2</span>*<span class="mi">3</span>*x<span class="p">;</span>
<span class="gp">&gt; </span>show bar
bar x = <span class="mi">2</span>*<span class="mi">3</span>*x<span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--tc">
<tt class="descname">--tc</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--tc" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--notc">
<tt class="descname">--notc</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--notc" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable tail call optimization (TCO). TCO is needed to make
tail-recursive functions execute in constant stack space, so we recommend
to leave this enabled. However, at the time of this writing LLVM&#8217;s TCO
support is still bug-ridden on some platforms, so the <a class="reference internal" href="#cmdoption-pure--notc"><em class="xref std std-option">--notc</em></a>
option allows you to disable it. (Note that TCO can also be disabled when
compiling the Pure interpreter, in which case these options have no effect;
see the installation documentation for details.)</p>
</dd></dl>

<p>Besides these, there are the following special pragmas affecting the code
generation of some given function, which is specified in the pragma. These
pragmas can only be used in source code, there are no command line options for
them.</p>
<dl class="option">
<dt id="cmdoption-pure--eager">
<tt class="descname">--eager</tt><tt class="descclassname"> fun</tt><a class="headerlink" href="#cmdoption-pure--eager" title="Permalink to this definition">¶</a></dt>
<dd><p>Instruct the interpreter to JIT-compile the given function eagerly. This
means that native code will be created for the function, as well as all
other (global or local) functions that may be called by the compiled
function, as soon as the function gets recompiled. This avoids the hiccups
you get when a function is compiled on the fly if it is run for the first
time, which is particularly useful for functions which are to be run in
realtime (typically in multimedia applications). Please note that, in
difference to the <a class="reference internal" href="#cmdoption-pure--eager-jit"><em class="xref std std-option">--eager-jit</em></a> option, this feature is available
for all LLVM versions (it doesn&#8217;t require LLVM 2.7 or later).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--required">
<tt class="descname">--required</tt><tt class="descclassname"> fun</tt><a class="headerlink" href="#cmdoption-pure--required" title="Permalink to this definition">¶</a></dt>
<dd><p>Inform the batch compiler (cf. <a class="reference internal" href="#compiling-scripts">Compiling Scripts</a>) that the given
function symbol <tt class="docutils literal"><span class="pre">fun</span></tt> should never be stripped from the program. This is
useful, e.g., if a function is never called explicitly but only through
<a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>. Adding a <a class="reference internal" href="#cmdoption-pure--required"><em class="xref std std-option">--required</em></a> pragma for the function then
makes sure that the function is always linked into the program. Please see
the <a class="reference internal" href="#batch-compilation">Batch Compilation</a> section for an example.</p>
</dd></dl>

</div>
<div class="section" id="startup-files">
<h3><a class="toc-backref" href="#id23">Startup Files</a><a class="headerlink" href="#startup-files" title="Permalink to this headline">¶</a></h3>
<p>The interpreter may source various files during its startup. These are:</p>
<dl class="describe">
<dt>
<tt class="descname">~/.pure_history</tt></dt>
<dd><p>Interactive command history.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">~/.purerc, .purerc, .pure</tt></dt>
<dd><p>Interactive startup files. The latter is usually a dump from a previous
interactive session.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">prelude.pure</tt></dt>
<dd><p>Standard prelude. If available, this script is loaded before any other
definitions, unless <a class="reference internal" href="#cmdoption-pure-n"><em class="xref std std-option">-n</em></a> was specified.</p>
</dd></dl>

</div>
<div class="section" id="environment">
<h3><a class="toc-backref" href="#id24">Environment</a><a class="headerlink" href="#environment" title="Permalink to this headline">¶</a></h3>
<p>Various aspects of the interpreter can be configured through the following
shell environment variables:</p>
<dl class="envvar">
<dt id="envvar-BROWSER">
<tt class="descname">BROWSER</tt><a class="headerlink" href="#envvar-BROWSER" title="Permalink to this definition">¶</a></dt>
<dd><p>If the <span class="target" id="index-4"></span><a class="reference internal" href="#envvar-PURE_HELP"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_HELP</span></tt></a> variable is not set (see below), this specifies
a colon-separated list of browsers to try for reading the online
documentation. See <a class="reference external" href="http://catb.org/~esr/BROWSER/">http://catb.org/~esr/BROWSER/</a>.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURELIB">
<tt class="descname">PURELIB</tt><a class="headerlink" href="#envvar-PURELIB" title="Permalink to this definition">¶</a></dt>
<dd><p>Directory to search for library scripts, including the prelude. If
<span class="target" id="index-5"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a> is not set, it defaults to some location specified at
installation time.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_EAGER_JIT">
<tt class="descname">PURE_EAGER_JIT</tt><a class="headerlink" href="#envvar-PURE_EAGER_JIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable eager JIT compilation (same as <a class="reference internal" href="#cmdoption-pure--eager-jit"><em class="xref std std-option">--eager-jit</em></a>), see
<a class="reference internal" href="#compiling-scripts">Compiling Scripts</a> for details.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_HELP">
<tt class="descname">PURE_HELP</tt><a class="headerlink" href="#envvar-PURE_HELP" title="Permalink to this definition">¶</a></dt>
<dd><p>Command used to browse the Pure manual. This must be a browser capable of
displaying html files. Default is <strong class="program">w3m</strong>.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_INCLUDE">
<tt class="descname">PURE_INCLUDE</tt><a class="headerlink" href="#envvar-PURE_INCLUDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional directories (in colon-separated format) to be searched for
included scripts.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_LIBRARY">
<tt class="descname">PURE_LIBRARY</tt><a class="headerlink" href="#envvar-PURE_LIBRARY" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional directories (in colon-separated format) to be searched for
dynamic libraries.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_MORE">
<tt class="descname">PURE_MORE</tt><a class="headerlink" href="#envvar-PURE_MORE" title="Permalink to this definition">¶</a></dt>
<dd><p>Shell command to be used for paging through output of the <tt class="docutils literal"><span class="pre">show</span></tt> command,
when the interpreter runs in interactive mode. <span class="target" id="index-6"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_LESS</span></tt> does the
same for evaluation results printed by the interpreter.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_PS">
<tt class="descname">PURE_PS</tt><a class="headerlink" href="#envvar-PURE_PS" title="Permalink to this definition">¶</a></dt>
<dd><p>Command prompt used in the interactive command loop (&#8220;&gt; &#8221; by default).</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_STACK">
<tt class="descname">PURE_STACK</tt><a class="headerlink" href="#envvar-PURE_STACK" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum stack size in kilobytes (default: 0 = unlimited).</p>
</dd></dl>

<p>Besides these, the interpreter also understands a number of other environment
variables for setting various code generation options (see <a class="reference internal" href="#code-generation-options">Code Generation
Options</a> above) and commands to invoke different LLVM compilers on inline
code (see <a class="reference internal" href="#inline-code">Inline Code</a>).</p>
</div>
</div>
<div class="section" id="pure-overview">
<h2><a class="toc-backref" href="#id25">Pure Overview</a><a class="headerlink" href="#pure-overview" title="Permalink to this headline">¶</a></h2>
<p>Pure is a fairly simple yet powerful language. Programs are basically
collections of term rewriting rules, which are used to reduce expressions to
<strong class="dfn">normal form</strong> in a symbolic fashion. For convenience, Pure also offers some
extensions to the basic term rewriting calculus, like global variables and
constants, nested scopes of local function and variable definitions, anonymous
functions (lambdas), exception handling and a built-in macro facility. These
are all described below and in the following sections.</p>
<p>Most basic operations are defined in the standard <a class="reference internal" href="purelib.html#prelude"><em>prelude</em></a>.
This includes the usual arithmetic and logical operations, as well as the
basic string, list and matrix functions. The prelude is always loaded by the
interpreter, so that you can start using the interpreter as a sophisticated
kind of desktop calculator right away.  Other useful operations are provided
through separate library modules. Some of these, like the system interface and
the container data structures, are distributed with the interpreter, others
are available as separate add-on packages from the Pure website. A (very)
brief overview of some of the modules distributed with the Pure interpreter
can be found in the <a class="reference internal" href="#standard-library">Standard Library</a> section.</p>
<p>Here&#8217;s a first example which demonstrates how to define a simple recursive
function in Pure, entered interactively in the interpreter (note that the &#8216;&gt; &#8216;
symbol at the beginning of each input line is the interpreter&#8217;s default
command prompt):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="c1">// my first Pure example</span>
<span class="gp">&gt; </span>fact <span class="mi">0</span> = <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">int</span> = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = fact <span class="mi">10</span><span class="p">;</span> x<span class="p">;</span>
<span class="mi">3628800</span>
</pre></div>
</div>
<div class="section" id="lexical-matters">
<h3><a class="toc-backref" href="#id26">Lexical Matters</a><a class="headerlink" href="#lexical-matters" title="Permalink to this headline">¶</a></h3>
<p>Pure is a <strong class="dfn">free-format</strong> language, i.e., whitespace is insignificant (unless it
is used to delimit other symbols). Thus, in contrast to &#8220;layout-based&#8221;
languages like Haskell, you <em>must</em> use the proper delimiters (<tt class="docutils literal"><span class="pre">;</span></tt>) and
keywords (<a class="reference internal" href="#end"><tt class="xref std std-keyword docutils literal"><span class="pre">end</span></tt></a>) to terminate definitions and block structures. In
particular, as shown in the example above, definitions and expressions at the
toplevel have to be terminated with a semicolon, even in interactive mode.</p>
<p>Comments use the same syntax as in C++: <tt class="docutils literal"><span class="pre">//</span></tt> for line-oriented, and
<tt class="docutils literal"><span class="pre">/*</span> <span class="pre">...</span> <span class="pre">*/</span></tt> for multiline comments. The latter must not be nested. Lines
beginning with <tt class="docutils literal"><span class="pre">#!</span></tt> are treated as comments, too; as already discussed
above, on Unix-like systems this allows you to add a &#8220;shebang&#8221; to your main
script in order to turn it into an executable program.</p>
<p>A few ASCII symbols are reserved for special uses, namely the semicolon, the
&#8220;at&#8221; symbol <tt class="docutils literal"><span class="pre">&#64;</span></tt>, the equals sign <tt class="docutils literal"><span class="pre">=</span></tt>, the backslash <tt class="docutils literal"><span class="pre">\</span></tt>, the Unix pipe
symbol <tt class="docutils literal"><span class="pre">|</span></tt>, parentheses <tt class="docutils literal"><span class="pre">()</span></tt>, brackets <tt class="docutils literal"><span class="pre">[]</span></tt> and curly braces <tt class="docutils literal"><span class="pre">{}</span></tt>.
(Among these, only the semicolon is a &#8220;hard delimiter&#8221; which is always a
lexeme by itself; the other symbols can be used inside operator symbols.)
Moreover, there are some keywords which cannot be used as identifiers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">case</span>       <span class="kr">const</span>   <span class="kr">def</span>      <span class="kr">else</span>    <span class="kr">end</span>        <span class="kr">extern</span>  <span class="kr">if</span>
<span class="kr">infix</span>      <span class="kr">infixl</span>  <span class="kr">infixr</span>   <span class="kr">let</span>     <span class="kr">namespace</span>  <span class="kr">nonfix</span>  <span class="kr">of</span>
<span class="kr">otherwise</span>  <span class="kr">outfix</span>  <span class="kr">postfix</span>  <span class="kr">prefix</span>  <span class="kr">private</span>    <span class="kr">public</span>  <span class="kr">then</span>
<span class="kr">using</span>      <span class="kr">when</span>    <span class="kr">with</span>
</pre></div>
</div>
<p>Pure fully supports the <strong class="dfn">Unicode</strong> character set or, more precisely, UTF-8.
This is an ASCII extension capable of representing all Unicode characters,
which provides you with thousands of characters from most of the languages of
the world, as well as an abundance of special symbols for almost any purpose.
If your text editor supports the UTF-8 encoding (most editors do nowadays),
you can use all Unicode characters in your Pure programs, not only inside
strings, but also for denoting identifiers and special operator and constant
symbols.</p>
<p>The customary notations for identifiers, numbers and strings are all
provided. In addition, Pure also allows you to define your own operator
symbols. Identifiers and other symbols are described by the following grammar
rules in EBNF format:</p>
<pre>
<strong id="grammar-token-symbol">symbol    </strong> ::=  <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> | <a class="reference internal" href="#grammar-token-special"><tt class="xref docutils literal"><span class="pre">special</span></tt></a>
<strong id="grammar-token-identifier">identifier</strong> ::=  <a class="reference internal" href="#grammar-token-letter"><tt class="xref docutils literal"><span class="pre">letter</span></tt></a> (<a class="reference internal" href="#grammar-token-letter"><tt class="xref docutils literal"><span class="pre">letter</span></tt></a> | <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>)*
<strong id="grammar-token-special">special   </strong> ::=  <a class="reference internal" href="#grammar-token-punct"><tt class="xref docutils literal"><span class="pre">punct</span></tt></a>+
<strong id="grammar-token-letter">letter    </strong> ::=  &quot;A&quot;|...|&quot;Z&quot;|&quot;a&quot;|...|&quot;z&quot;|&quot;_&quot;|...
<strong id="grammar-token-digit">digit     </strong> ::=  &quot;0&quot;|...|&quot;9&quot;
<strong id="grammar-token-punct">punct     </strong> ::=  &quot;!&quot;|&quot;#&quot;|&quot;$&quot;|&quot;%&quot;|&quot;&amp;&quot;|...
</pre>
<p>Pure uses the following rules to distinguish &#8220;punctuation&#8221; (which may only
occur in declared operator and constant symbols) and &#8220;letters&#8221; (identifier
constituents). In addition to the punctuation symbols in the 7 bit ASCII
range, the following code points in the Unicode repertoire are considered as
punctuation: U+00A1 through U+00BF, U+00D7, U+00F7, and U+20D0 through
U+2BFF. This comprises the special symbols in the Latin-1 repertoire, as well
as the Combining Diacritical Marks for Symbols, Letterlike Symbols, Number
Forms, Arrows, Mathematical Symbols, Miscellaneous Technical Symbols, Control
Pictures, OCR, Enclosed Alphanumerics, Box Drawing, Blocks, Geometric Shapes,
Miscellaneous Symbols, Dingbats, Miscellaneous Mathematical Symbols A,
Supplemental Arrows A, Supplemental Arrows B, Miscellaneous Mathematical
Symbols B, Supplemental Mathematical Operators, and Miscellaneous Symbols and
Arrows. This should cover almost everything you&#8217;d ever want to use in an
operator symbol. All other extended Unicode characters are effectively treated
as &#8220;letters&#8221; which can be used as identifier constituents. (Charts of all
Unicode symbols can be found at the <a class="reference external" href="http://www.unicode.org/charts/">Code Charts</a> page of the <a class="reference external" href="http://www.unicode.org/">Unicode
Consortium</a>.)</p>
<p>The following are examples of valid identifiers: <tt class="docutils literal"><span class="pre">foo</span></tt>, <tt class="docutils literal"><span class="pre">foo_bar</span></tt>,
<tt class="docutils literal"><span class="pre">FooBar</span></tt>, <tt class="docutils literal"><span class="pre">BAR</span></tt>, <tt class="docutils literal"><span class="pre">bar99</span></tt>. Case is significant in identifiers, so <tt class="docutils literal"><span class="pre">Bar</span></tt>
and <tt class="docutils literal"><span class="pre">bar</span></tt> are distinct identifiers, but otherwise the case of letters
carries no meaning. Special symbols consist entirely of punctuation, such as
<tt class="docutils literal"><span class="pre">::=</span></tt>. These may be used as operator symbols, but have to be declared before
they can be used (see <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a>).</p>
<p>Pure also has a notation for qualified symbols which carry a namespace prefix.
These take the following format (note that no whitespace is permitted between
the namespace prefix and the symbol):</p>
<pre>
<strong id="grammar-token-qualified_symbol">qualified_symbol    </strong> ::=  [<a class="reference internal" href="#grammar-token-qualifier"><tt class="xref docutils literal"><span class="pre">qualifier</span></tt></a>] <a class="reference internal" href="#grammar-token-symbol"><tt class="xref docutils literal"><span class="pre">symbol</span></tt></a>
<strong id="grammar-token-qualified_identifier">qualified_identifier</strong> ::=  [<a class="reference internal" href="#grammar-token-qualifier"><tt class="xref docutils literal"><span class="pre">qualifier</span></tt></a>] <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>
<strong id="grammar-token-qualifier">qualifier           </strong> ::=  [<a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>] &quot;::&quot; (<a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> &quot;::&quot;)*
</pre>
<p>Example: <tt class="docutils literal"><span class="pre">foo::bar</span></tt>.</p>
<p>Number literals come in three flavours: integers, bigints (denoted with an
<tt class="docutils literal"><span class="pre">L</span></tt> suffix) and floating point numbers (indicated by the presence of the
decimal point and/or a base 10 scaling factor). Integers and bigints may be
written in different bases (decimal, binary, octal and hexadecimal), while
floating point numbers are always denoted in decimal.</p>
<pre>
<strong id="grammar-token-number">number   </strong> ::=  <a class="reference internal" href="#grammar-token-integer"><tt class="xref docutils literal"><span class="pre">integer</span></tt></a> | <a class="reference internal" href="#grammar-token-integer"><tt class="xref docutils literal"><span class="pre">integer</span></tt></a> &quot;L&quot; | <a class="reference internal" href="#grammar-token-float"><tt class="xref docutils literal"><span class="pre">float</span></tt></a>
<strong id="grammar-token-integer">integer  </strong> ::=  <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+
               | &quot;0&quot; (&quot;X&quot;|&quot;x&quot;) <a class="reference internal" href="#grammar-token-hex_digit"><tt class="xref docutils literal"><span class="pre">hex_digit</span></tt></a>+
               | &quot;0&quot; (&quot;B&quot;|&quot;b&quot;) <a class="reference internal" href="#grammar-token-bin_digit"><tt class="xref docutils literal"><span class="pre">bin_digit</span></tt></a>+
               | &quot;0&quot; <a class="reference internal" href="#grammar-token-oct_digit"><tt class="xref docutils literal"><span class="pre">oct_digit</span></tt></a>+
<strong id="grammar-token-oct_digit">oct_digit</strong> ::=  &quot;0&quot;|...|&quot;7&quot;
<strong id="grammar-token-hex_digit">hex_digit</strong> ::=  &quot;0&quot;|...|&quot;9&quot;|&quot;A&quot;|...|&quot;F&quot;|&quot;a&quot;|...|&quot;f&quot;
<strong id="grammar-token-bin_digit">bin_digit</strong> ::=  &quot;0&quot;|&quot;1&quot;
<strong id="grammar-token-float">float    </strong> ::=  <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+ [&quot;.&quot; <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+] <a class="reference internal" href="#grammar-token-exponent"><tt class="xref docutils literal"><span class="pre">exponent</span></tt></a>
               | <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>* &quot;.&quot; <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+ [<a class="reference internal" href="#grammar-token-exponent"><tt class="xref docutils literal"><span class="pre">exponent</span></tt></a>]
<strong id="grammar-token-exponent">exponent </strong> ::=  (&quot;E&quot;|&quot;e&quot;) [&quot;+&quot;|&quot;-&quot;] <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+
</pre>
<p>Examples: <tt class="docutils literal"><span class="pre">4711</span></tt>, <tt class="docutils literal"><span class="pre">4711L</span></tt>, <tt class="docutils literal"><span class="pre">1.2e-3</span></tt>. Numbers in different bases:
<tt class="docutils literal"><span class="pre">1000</span></tt> (decimal), <tt class="docutils literal"><span class="pre">0x3e8</span></tt> (hexadecimal), <tt class="docutils literal"><span class="pre">01750</span></tt> (octal),
<tt class="docutils literal"><span class="pre">0b1111101000</span></tt> (binary).</p>
<p>String literals are arbitrary sequences of characters enclosed in double
quotes, such as <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></tt>.</p>
<pre>
<strong id="grammar-token-string">string</strong> ::=  '&quot;' <tt class="xref docutils literal"><span class="pre">char</span></tt>* '&quot;'
</pre>
<p>Special escape sequences may be used to denote double quotes and backslashes
(<tt class="docutils literal"><span class="pre">\&quot;</span></tt>, <tt class="docutils literal"><span class="pre">\\</span></tt>), control characters (<tt class="docutils literal"><span class="pre">\b</span></tt>, <tt class="docutils literal"><span class="pre">\f</span></tt>, <tt class="docutils literal"><span class="pre">\n</span></tt>, <tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\t</span></tt>,
these have the same meaning as in C), and arbitrary Unicode characters given
by their number or <a class="reference external" href="http://www.w3.org/TR/xml-entity-names/">XML entity name</a> (e.g., <tt class="docutils literal"><span class="pre">\169</span></tt>, <tt class="docutils literal"><span class="pre">\0xa9</span></tt> and
<tt class="docutils literal"><span class="pre">\&amp;copy;</span></tt> all denote the Unicode copyright character, code point U+00A9). As
indicated, numeric escapes can be specified in any of the supported bases for
integer literals. For disambiguating purposes, these can also be enclosed in
parentheses. E.g., <tt class="docutils literal"><span class="pre">&quot;\(123)4&quot;</span></tt> is a string consisting of the character
<tt class="docutils literal"><span class="pre">\123</span></tt> followed by the digit <tt class="docutils literal"><span class="pre">4</span></tt>.</p>
</div>
<div class="section" id="definitions-and-symbolic-evaluation">
<h3><a class="toc-backref" href="#id27">Definitions and Symbolic Evaluation</a><a class="headerlink" href="#definitions-and-symbolic-evaluation" title="Permalink to this headline">¶</a></h3>
<p>On the surface, Pure is quite similar to other modern functional languages
like <a class="reference internal" href="#haskell">Haskell</a> and <a class="reference internal" href="#ml">ML</a>. But under the hood it is a much more dynamic language,
more akin to Lisp. In particular, Pure is dynamically typed, so functions can
be fully polymorphic and you can add to the definition of an existing function
at any time. For instance, we can extend our first example above to make the
<tt class="docutils literal"><span class="pre">fact</span></tt> function work with floating point numbers, too:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact <span class="mf">0.0</span> = <span class="mf">1.0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">double</span> = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mf">10.0</span><span class="p">;</span>
<span class="mf">3628800.0</span>
<span class="gp">&gt; </span>fact <span class="mi">10</span><span class="p">;</span>
<span class="mi">3628800</span>
</pre></div>
</div>
<p>Note the <tt class="docutils literal"><span class="pre">n::double</span></tt> construct on the left-hand side of the second
equation, which means that the equation is only to be applied for (double
precision) floating point values <tt class="docutils literal"><span class="pre">n</span></tt>. This construct is also called a &#8220;type
tag&#8221; in Pure parlance, which is actually a simple form of pattern matching
(see below). Similarly, our previous definition at the beginning of this
section employed the <tt class="docutils literal"><span class="pre">int</span></tt> tag to indicate that the <tt class="docutils literal"><span class="pre">n</span></tt> parameter is an
integer value. The <tt class="docutils literal"><span class="pre">int</span></tt> and <tt class="docutils literal"><span class="pre">double</span></tt> types are built into the Pure
language, but it is also possible to introduce your own type tags for
user-defined data structures. This will be explained in more detail under
<a class="reference internal" href="#type-tags">Type Tags</a> in the <a class="reference internal" href="#rule-syntax">Rule Syntax</a> section below.</p>
<p>Expressions are generally evaluated from left to right, innermost expressions
first, i.e., using call by value semantics. Pure also has a few built-in
special forms (most notably, conditional expressions, the short-circuit
logical connectives <a class="reference internal" href="#&amp;&amp;/special" title="&amp;&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;&amp;</span></tt></a> and <a class="reference internal" href="#||/special" title="||"><tt class="xref pure pure-func docutils literal"><span class="pre">||</span></tt></a>, the sequencing
operator <a class="reference internal" href="#$$" title="$$"><tt class="xref pure pure-func docutils literal"><span class="pre">$$</span></tt></a>, the lazy evaluation operator <a class="reference internal" href="#&amp;" title="&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;</span></tt></a>, and the
<a class="reference internal" href="#quote" title="quote"><tt class="xref pure pure-func docutils literal"><span class="pre">quote</span></tt></a>) which take some or all of their arguments unevaluated, using
call by name.</p>
<p>Like in Haskell and ML, functions are often defined by pattern matching, i.e.,
the left-hand side of a definition is compared to the target expression,
binding the variables in the pattern to their actual values accordingly:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo (bar x) = x-<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (bar <span class="mi">99</span>)<span class="p">;</span>
<span class="mi">98</span>
</pre></div>
</div>
<p>Due to its term rewriting semantics, Pure goes beyond most other functional
languages in that it can do symbolic evaluations just as well as &#8220;normal&#8221;
computations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>square x = x*x<span class="p">;</span>
<span class="gp">&gt; </span>square <span class="mi">4</span><span class="p">;</span>
<span class="mi">16</span>
<span class="gp">&gt; </span>square (a+b)<span class="p">;</span>
(a+b)*(a+b)
</pre></div>
</div>
<p>In fact, leaving aside the built-in support for some common data structures
such as numbers and strings, all the Pure interpreter really does is evaluate
expressions in a symbolic fashion, rewriting expressions using the equations
supplied by the programmer, until no more equations are applicable. The result
of this process is called a <strong class="dfn">normal form</strong> which represents the &#8220;value&#8221; of the
original expression. Keeping with the tradition of term rewriting, there&#8217;s no
distinction between &#8220;defined&#8221; and &#8220;constructor&#8221; function symbols in Pure.
Consequently, any function symbol or operator can be used <em>anywhere</em> on the
left-hand side of an equation, and may act as a constructor symbol if it
happens to occur in a normal form term. This enables you to work with
algebraic rules like associativity and distributivity in a direct fashion:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>(x+y)*z = x*z+y*z<span class="p">;</span> x*(y+z) = x*y+x*z<span class="p">;</span>
<span class="gp">&gt; </span>x*(y*z) = (x*y)*z<span class="p">;</span> x+(y+z) = (x+y)+z<span class="p">;</span>
<span class="gp">&gt; </span>square (a+b)<span class="p">;</span>
a*a+a*b+b*a+b*b
</pre></div>
</div>
<p>Here&#8217;s another basic symbolic algebra example, which lets you compute the
disjunctive normal form of logical expressions:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="c1">// eliminate double negations:</span>
~~a           = a<span class="p">;</span>

<span class="c1">// de Morgan&#39;s laws:</span>
~(a || b)     = ~a &amp;&amp; ~b<span class="p">;</span>
~(a &amp;&amp; b)     = ~a || ~b<span class="p">;</span>

<span class="c1">// distributivity:</span>
a &amp;&amp; (b || c) = a &amp;&amp; b || a &amp;&amp; c<span class="p">;</span>
(a || b) &amp;&amp; c = a &amp;&amp; c || b &amp;&amp; c<span class="p">;</span>

<span class="c1">// associativity:</span>
(a &amp;&amp; b) &amp;&amp; c = a &amp;&amp; (b &amp;&amp; c)<span class="p">;</span>
(a || b) || c = a || (b || c)<span class="p">;</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>a || ~(b || (c &amp;&amp; ~d))<span class="p">;</span>
a||~b&amp;&amp;~c||~b&amp;&amp;d
</pre></div>
</div>
<p>Note that the above isn&#8217;t possible in languages like Haskell and ML which
always enforce the so-called &#8220;constructor discipline&#8221;, which stipulates that
only pure constructor symbols (without any defining equations) may occur as a
subterm on the left-hand side of a definition. Thus equational definitions
like the above are forbidden in these languages. It&#8217;s possible to work around
this, but only at the cost of an extra layer of interpretation, which treats
the expressions to be evaluated as data manipulated by an evaluation function.</p>
<p>In Pure this extra layer is not necessary, you can just add equations like the
above to your Pure program. In addition, you can also reduce an expression in
a local context of algebraic equations specified in a <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> clause.
This can be done with the <a class="reference internal" href="purelib.html#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> macro defined in the prelude:</p>
<div class="highlight-pure"><div class="highlight"><pre>expand = reduce <span class="kr">with</span>
  (a+b)*c = a*c+b*c<span class="p">;</span>
  a*(b+c) = a*b+a*c<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

factor = reduce <span class="kr">with</span>
  a*c+b*c = (a+b)*c<span class="p">;</span>
  a*b+a*c = a*(b+c)<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>expand ((a+b)*<span class="mi">2</span>)<span class="p">;</span>
a*<span class="mi">2</span>+b*<span class="mi">2</span>
<span class="gp">&gt; </span>factor (a*<span class="mi">2</span>+b*<span class="mi">2</span>)<span class="p">;</span>
(a+b)*<span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="variables-in-equations">
<h3><a class="toc-backref" href="#id28">Variables in Equations</a><a class="headerlink" href="#variables-in-equations" title="Permalink to this headline">¶</a></h3>
<p>Taking a look at the above examples, you might have been wondering how the
Pure interpreter figures out what the parameters (a.k.a. &#8220;variables&#8221;) in an
equation are. This is quite obvious in rules involving just variables and
special operator symbols, such as <tt class="docutils literal"><span class="pre">(x+y)*z</span> <span class="pre">=</span> <span class="pre">x*z+y*z</span></tt>. However, what about
an equation like <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(foo</span> <span class="pre">bar)</span> <span class="pre">=</span> <span class="pre">bar</span></tt>? Since most of the time we don&#8217;t
declare any symbols in Pure, how does the interpreter know that <tt class="docutils literal"><span class="pre">foo</span></tt> is a
literal function symbol here, while <tt class="docutils literal"><span class="pre">bar</span></tt> is a variable?</p>
<p>The answer is that the interpreter considers the different positions in the
left-hand side expression of an equation. Basically, a Pure expression is just
a tree formed by applying expressions to other expressions, with the atomic
subexpressions like numbers and symbols at the leaves of the tree. (This is
true even for infix expressions like <tt class="docutils literal"><span class="pre">x+y</span></tt>, since in Pure these are always
equivalent to a function application of the form <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></tt> which has the
atomic subterms <tt class="docutils literal"><span class="pre">(+)</span></tt>, <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> at its leaves.)</p>
<p>Now the interpreter divides the leaves of the expression tree into &#8220;head&#8221; (or
&#8220;function&#8221;) and &#8220;parameter&#8221; (or &#8220;variable&#8221;) positions based on which leaves
are leftmost in a function application or not. Thus, in an expression like <tt class="docutils literal"><span class="pre">f</span>
<span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span></tt>, <tt class="docutils literal"><span class="pre">f</span></tt> is in the head or function position, while <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt> and
<tt class="docutils literal"><span class="pre">z</span></tt> are in parameter or variable positions. (Note that in an infix
expression like <tt class="docutils literal"><span class="pre">x+y</span></tt>, <tt class="docutils literal"><span class="pre">(+)</span></tt> is the head symbol, not <tt class="docutils literal"><span class="pre">x</span></tt>, as the
expression is really parsed as <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></tt>, see above.)</p>
<p>Identifiers in head positions are taken as literal function symbols by the
interpreter, while identifiers in variable positions denote, well,
variables. We also refer to this convention as the <strong class="dfn">head = function rule</strong>. It
is quite intuitive and lets us get away without declaring the variables in
equations. (There are some corner cases not covered here, however. In
particular, Pure allows you to declare special constant symbols, if you need a
symbol to be recognized as a literal even if it occurs in a variable
position. This is done by means of a <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> declaration, see
<a class="reference internal" href="#symbol-declarations">Symbol Declarations</a> for details.)</p>
</div>
<div class="section" id="expression-syntax">
<h3><a class="toc-backref" href="#id29">Expression Syntax</a><a class="headerlink" href="#expression-syntax" title="Permalink to this headline">¶</a></h3>
<p>Like in other functional languages, expressions are the central ingredient of
all Pure programs. All computation performed by a Pure program consists in the
evaluation of expressions, and expressions also form the building blocks of
the equational rules which are used to define the constants, variables,
functions and macros of a Pure program.</p>
<p>Pure&#8217;s expression syntax can be summarized in the following grammar rules:</p>
<pre>
<strong id="grammar-token-expr">expr        </strong> ::=  &quot;\&quot; <a class="reference internal" href="#grammar-token-prim_expr"><tt class="xref docutils literal"><span class="pre">prim_expr</span></tt></a>+ &quot;-&gt;&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a>
                  | &quot;case&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;of&quot; <a class="reference internal" href="#grammar-token-rules"><tt class="xref docutils literal"><span class="pre">rules</span></tt></a> &quot;end&quot;
                  | <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;when&quot; <a class="reference internal" href="#grammar-token-simple_rules"><tt class="xref docutils literal"><span class="pre">simple_rules</span></tt></a> &quot;end&quot;
                  | <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;with&quot; <a class="reference internal" href="#grammar-token-rules"><tt class="xref docutils literal"><span class="pre">rules</span></tt></a> &quot;end&quot;
                  | &quot;if&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;then&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
<strong id="grammar-token-simple_expr">simple_expr </strong> ::=  <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a> <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a> <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-application"><tt class="xref docutils literal"><span class="pre">application</span></tt></a>
<strong id="grammar-token-application">application </strong> ::=  <a class="reference internal" href="#grammar-token-application"><tt class="xref docutils literal"><span class="pre">application</span></tt></a> <a class="reference internal" href="#grammar-token-prim_expr"><tt class="xref docutils literal"><span class="pre">prim_expr</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-prim_expr"><tt class="xref docutils literal"><span class="pre">prim_expr</span></tt></a>
<strong id="grammar-token-rules">rules       </strong> ::=  <a class="reference internal" href="#grammar-token-rule"><tt class="xref docutils literal"><span class="pre">rule</span></tt></a> (&quot;;&quot; <a class="reference internal" href="#grammar-token-rule"><tt class="xref docutils literal"><span class="pre">rule</span></tt></a>)* [&quot;;&quot;]
<strong id="grammar-token-simple_rules">simple_rules</strong> ::=  <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref docutils literal"><span class="pre">simple_rule</span></tt></a> (&quot;;&quot; <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref docutils literal"><span class="pre">simple_rule</span></tt></a>)* [&quot;;&quot;]
</pre>
<p>(Note that the <a class="reference internal" href="#grammar-token-rule"><tt class="xref std std-token docutils literal"><span class="pre">rule</span></tt></a> and <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref std std-token docutils literal"><span class="pre">simple_rule</span></tt></a> elements are part of the
definition syntax, which is explained in the <a class="reference internal" href="#rule-syntax">Rule Syntax</a> section.)</p>
<pre>
<strong id="grammar-token-prim_expr">prim_expr</strong> ::=  <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>
               | <a class="reference internal" href="#grammar-token-number"><tt class="xref docutils literal"><span class="pre">number</span></tt></a>
               | <a class="reference internal" href="#grammar-token-string"><tt class="xref docutils literal"><span class="pre">string</span></tt></a>
               | &quot;(&quot; <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> &quot;)&quot;
               | &quot;(&quot; <a class="reference internal" href="#grammar-token-left_op"><tt class="xref docutils literal"><span class="pre">left_op</span></tt></a> <a class="reference internal" href="#grammar-token-right_op"><tt class="xref docutils literal"><span class="pre">right_op</span></tt></a> &quot;)&quot;
               | &quot;(&quot; <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a> <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> &quot;)&quot;
               | &quot;(&quot; <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a> &quot;)&quot;
               | &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;)&quot;
               | <a class="reference internal" href="#grammar-token-left_op"><tt class="xref docutils literal"><span class="pre">left_op</span></tt></a> <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> <a class="reference internal" href="#grammar-token-right_op"><tt class="xref docutils literal"><span class="pre">right_op</span></tt></a>
               | &quot;[&quot; <a class="reference internal" href="#grammar-token-exprs"><tt class="xref docutils literal"><span class="pre">exprs</span></tt></a> &quot;]&quot;
               | &quot;{&quot; <a class="reference internal" href="#grammar-token-exprs"><tt class="xref docutils literal"><span class="pre">exprs</span></tt></a> (&quot;;&quot; <a class="reference internal" href="#grammar-token-exprs"><tt class="xref docutils literal"><span class="pre">exprs</span></tt></a>)* [&quot;;&quot;] &quot;}&quot;
               | &quot;[&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-simple_rules"><tt class="xref docutils literal"><span class="pre">simple_rules</span></tt></a> &quot;]&quot;
               | &quot;{&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-simple_rules"><tt class="xref docutils literal"><span class="pre">simple_rules</span></tt></a> &quot;}&quot;
<strong id="grammar-token-exprs">exprs    </strong> ::=  <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a>)*
<strong id="grammar-token-op">op       </strong> ::=  <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>
<strong id="grammar-token-left_op">left_op  </strong> ::=  <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>
<strong id="grammar-token-right_op">right_op </strong> ::=  <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>
</pre>
<p>Typical examples of the different expression types are summarized in the
following table. Note that lambdas bind most weakly, followed by the special
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> constructs, followed by
conditional expressions (<a class="reference internal" href="#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a>-<a class="reference internal" href="#then"><tt class="xref std std-keyword docutils literal"><span class="pre">then</span></tt></a>-<a class="reference internal" href="#else"><tt class="xref std std-keyword docutils literal"><span class="pre">else</span></tt></a>),
followed by the simple expressions. Operators are a part of the simple
expression syntax, and are parsed according to their declared precedences and
associativities (cf. <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a>). Function application binds
stronger than all operators. Parentheses can be used to group expressions and
override default precedences as usual.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="45%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Example</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Lambda</td>
<td><tt class="docutils literal"><span class="pre">\x-&gt;x+1</span></tt></td>
<td>anonymous function</td>
</tr>
<tr class="row-odd"><td>Block</td>
<td><tt class="docutils literal"><span class="pre">case</span> <span class="pre">x</span> <span class="pre">of</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">z;</span> <span class="pre">...</span> <span class="pre">end</span></tt></td>
<td>pattern-matching conditional</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">when</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">z;</span> <span class="pre">...</span> <span class="pre">end</span></tt></td>
<td>local variable definition</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">with</span> <span class="pre">f</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">z;</span> <span class="pre">...</span> <span class="pre">end</span></tt></td>
<td>local function definition</td>
</tr>
<tr class="row-even"><td>Conditional</td>
<td><tt class="docutils literal"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">then</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">z</span></tt></td>
<td>conditional expression</td>
</tr>
<tr class="row-odd"><td>Simple</td>
<td><tt class="docutils literal"><span class="pre">x+y</span></tt>, <tt class="docutils literal"><span class="pre">-x</span></tt>, <tt class="docutils literal"><span class="pre">x</span> <span class="pre">mod</span> <span class="pre">y</span></tt></td>
<td>operator application</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">sin</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">max</span> <span class="pre">a</span> <span class="pre">b</span></tt></td>
<td>function application</td>
</tr>
<tr class="row-odd"><td>Primary</td>
<td><tt class="docutils literal"><span class="pre">4711</span></tt>, <tt class="docutils literal"><span class="pre">1.2e-3</span></tt></td>
<td>number</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!\n&quot;</span></tt></td>
<td>string</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">foo</span></tt>, <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">(+)</span></tt></td>
<td>function or variable symbol</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">[1,2,3]</span></tt>, <tt class="docutils literal"><span class="pre">{1,2;3,4}</span></tt></td>
<td>list and matrix</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">[x,-y</span> <span class="pre">|</span> <span class="pre">x=1..n;</span> <span class="pre">y=1..m;</span> <span class="pre">x&lt;y]</span></tt></td>
<td>list comprehension</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">{i==j</span> <span class="pre">|</span> <span class="pre">i=1..n;</span> <span class="pre">j=1..m}</span></tt></td>
<td>matrix comprehension</td>
</tr>
</tbody>
</table>
<div class="section" id="primary-expressions">
<h4><a class="toc-backref" href="#id30">Primary Expressions</a><a class="headerlink" href="#primary-expressions" title="Permalink to this headline">¶</a></h4>
<p>The Pure language provides built-in support for machine integers (32 bit),
bigints (implemented using <a class="reference internal" href="#gmp">GMP</a>), floating point values (double precision IEEE
754) and character strings (UTF-8 encoded). These can all be denoted using the
corresponding literals described in <a class="reference internal" href="#lexical-matters">Lexical Matters</a>. Truth values are
encoded as machine integers; as you might expect, zero denotes <em>false</em> and any
non-zero value <em>true</em>, and the prelude also provides symbolic constants
<a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> and <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-func docutils literal"><span class="pre">true</span></tt></a> to denote these. Pure also supports generic C
pointers, but these don&#8217;t have a syntactic representation in Pure, except that
the predefined constant <a class="reference internal" href="purelib.html#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> may be used to denote a generic null
pointer; other pointer values need to be created with external C functions.
Finally, Pure also provides some built-in support for compound primaries in
the form of lists and matrices, although most of the corresponding operations
are actually defined in the prelude.</p>
<p>Together, these &#8220;atomic&#8221; types of expressions make up Pure&#8217;s <strong class="dfn">primary
expression</strong> syntax. Here is a brief rundown of the primary expression types.</p>
<dl class="docutils">
<dt>Numbers: <tt class="docutils literal"><span class="pre">4711</span></tt>, <tt class="docutils literal"><span class="pre">4711L</span></tt>, <tt class="docutils literal"><span class="pre">1.2e-3</span></tt></dt>
<dd>The usual C notations for integers (decimal: <tt class="docutils literal"><span class="pre">1000</span></tt>, hexadecimal:
<tt class="docutils literal"><span class="pre">0x3e8</span></tt>, octal: <tt class="docutils literal"><span class="pre">01750</span></tt>) and floating point values are all provided.
Integers can also be denoted in base 2 by using the <tt class="docutils literal"><span class="pre">0b</span></tt> or <tt class="docutils literal"><span class="pre">0B</span></tt>
prefix: <tt class="docutils literal"><span class="pre">0b1111101000</span></tt>. Integer constants that are too large to fit into
machine integers are promoted to bigints automatically.  Moreover, integer
literals immediately followed by the uppercase letter <tt class="docutils literal"><span class="pre">L</span></tt> are always
interpreted as bigint constants, even if they fit into machine integers.
This notation is also used when printing bigint constants, to distinguish
them from machine integers.</dd>
<dt>Strings: <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!\n&quot;</span></tt></dt>
<dd>String constants are double-quoted and terminated with a null character,
like in C. In contrast to C, strings are always encoded in UTF-8, and
character escapes in Pure strings have a more flexible syntax (borrowed
from the author&#8217;s Q language) which provides notations to specify any
Unicode character. Please refer to <a class="reference internal" href="#lexical-matters">Lexical Matters</a> for details.</dd>
<dt>Function and variable symbols: <tt class="docutils literal"><span class="pre">foo</span></tt>, <tt class="docutils literal"><span class="pre">foo_bar</span></tt>, <tt class="docutils literal"><span class="pre">BAR</span></tt>, <tt class="docutils literal"><span class="pre">foo::bar</span></tt></dt>
<dd>These consist of the usual sequence of letters (including the underscore)
and digits, starting with a letter. Case is significant, thus <tt class="docutils literal"><span class="pre">foo</span></tt>,
<tt class="docutils literal"><span class="pre">Foo</span></tt> and <tt class="docutils literal"><span class="pre">FOO</span></tt> are distinct identifiers. The &#8216;<tt class="docutils literal"><span class="pre">_</span></tt>&#8216; symbol, when
occurring on the left-hand side of an equation, is special; it denotes the
<strong class="dfn">anonymous variable</strong> which matches any value without actually binding a
variable. Identifiers can also be prefixed with a namespace identifier,
like in <tt class="docutils literal"><span class="pre">foo::bar</span></tt>. (This requires that the given namespace has already
been created, as explained under <a class="reference internal" href="#namespaces">Namespaces</a> in the <a class="reference internal" href="#declarations">Declarations</a> section.)</dd>
<dt>Operator and constant symbols: <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">==</span></tt>, <tt class="docutils literal"><span class="pre">not</span></tt></dt>
<dd><p class="first">For convenience, Pure also provides you with a limited means to extend the
syntax of the language with special operator and constant symbols by means
of a corresponding <strong class="dfn">fixity</strong> declaration, as discussed in section <a class="reference internal" href="#symbol-declarations">Symbol
Declarations</a>. Besides the usual infix, prefix and postfix operators,
Pure also provides outfix (bracket) and nonfix (constant) symbols. (Nonfix
symbols actually work more or less like ordinary identifiers, but the
<a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> attribute tells the compiler that when such a symbol
occurs on the left-hand side of an equation, it is always to be
interpreted as a literal constant, cf. <a class="reference internal" href="#variables-in-equations">Variables in Equations</a>.)</p>
<p>Operator and constant symbols may take the form of an identifier or a
sequence of punctuation characters. They must always be declared before
use. Once declared, they are always special, and can&#8217;t be used as ordinary
identifiers any more. However, like in Haskell, by enclosing an operator
in parentheses, such as <tt class="docutils literal"><span class="pre">(+)</span></tt> or <tt class="docutils literal"><span class="pre">(not)</span></tt>, you can turn it into an
ordinary function symbol. Also, operators and constant symbols can be
qualified with a namespace just like normal identifiers.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The common operator symbols like <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>
etc. are all declared at the beginning of the prelude, see the
<a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for a list of these. Arithmetic and relational operators
mostly follow C conventions. However, out of necessity (<tt class="docutils literal"><span class="pre">!</span></tt>, <tt class="docutils literal"><span class="pre">&amp;</span></tt>
and <tt class="docutils literal"><span class="pre">|</span></tt> are used for other purposes in Pure) the logical and bitwise
operations, as well as the negated equality predicates are named a bit
differently: <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt> denote logical negation,
conjunction and disjunction, while the corresponding bitwise operations
are named <tt class="docutils literal"><span class="pre">not</span></tt>, <tt class="docutils literal"><span class="pre">and</span></tt> and <tt class="docutils literal"><span class="pre">or</span></tt>.  Moreover, following these
conventions, inequality is denoted <tt class="docutils literal"><span class="pre">~=</span></tt>. Also note that <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and
<tt class="docutils literal"><span class="pre">||</span></tt> are special forms which are evaluated in short-circuit mode (see
<a class="reference internal" href="#special-forms">Special Forms</a> below), whereas the bitwise connectives receive their
arguments using call-by-value, just like the other arithmetic
operations.</p>
</div>
</dd>
<dt>Lists: <tt class="docutils literal"><span class="pre">[x,y,z]</span></tt>, <tt class="docutils literal"><span class="pre">x:xs</span></tt>, <tt class="docutils literal"><span class="pre">x..y</span></tt>, <tt class="docutils literal"><span class="pre">x:y..z</span></tt></dt>
<dd><p class="first">Pure&#8217;s basic list syntax is the same as in Haskell, thus <tt class="docutils literal"><span class="pre">[]</span></tt> is the
empty list and <tt class="docutils literal"><span class="pre">x:xs</span></tt> denotes a list with head element <tt class="docutils literal"><span class="pre">x</span></tt> and tail
list <tt class="docutils literal"><span class="pre">xs</span></tt>. The infix constructor symbol &#8216;<a class="reference internal" href="purelib.html#:" title=":"><tt class="xref pure pure-cons docutils literal"><span class="pre">:</span></tt></a>&#8216; is declared in
the prelude. The usual syntactic sugar for list values in brackets is
provided, thus <tt class="docutils literal"><span class="pre">[x,y,z]</span></tt> is exactly the same as <tt class="docutils literal"><span class="pre">x:y:z:[]</span></tt>.</p>
<p class="last">There&#8217;s also a way to denote arithmetic sequences such as <tt class="docutils literal"><span class="pre">1..5</span></tt>, which
denotes the list <tt class="docutils literal"><span class="pre">[1,2,3,4,5]</span></tt>. Haskell users should note the missing
brackets. In contrast to Haskell, Pure doesn&#8217;t use any special syntax for
arithmetic sequences, the &#8216;<a class="reference internal" href="purelib.html#.." title=".."><tt class="xref pure pure-func docutils literal"><span class="pre">..</span></tt></a>&#8216; symbol is just an ordinary
infix operator declared and defined in the prelude. Sequences with
arbitrary stepsizes can be written by denoting the first two sequence
elements using the &#8216;<a class="reference internal" href="purelib.html#:" title=":"><tt class="xref pure pure-cons docutils literal"><span class="pre">:</span></tt></a>&#8216; operator, as in <tt class="docutils literal"><span class="pre">1.0:1.2..3.0</span></tt>. To
prevent unwanted artifacts due to rounding errors, the upper bound in a
floating point sequence is always rounded to the nearest grid point. Thus,
e.g., <tt class="docutils literal"><span class="pre">0.0:0.1..0.29</span></tt> actually yields <tt class="docutils literal"><span class="pre">[0.0,0.1,0.2,0.3]</span></tt>, as does
<tt class="docutils literal"><span class="pre">0.0:0.1..0.31</span></tt>.</p>
</dd>
<dt>Tuples: <tt class="docutils literal"><span class="pre">x,y,z</span></tt></dt>
<dd><p class="first">Pure&#8217;s tuples are a bit unusual: They are constructed by just &#8220;pairing&#8221;
things using the &#8216;<a class="reference internal" href="purelib.html#," title=","><tt class="xref pure pure-cons docutils literal"><span class="pre">,</span></tt></a>&#8216; operator, for which the empty tuple
<a class="reference internal" href="purelib.html#()" title="()"><tt class="xref pure pure-cons docutils literal"><span class="pre">()</span></tt></a> acts as a neutral element (i.e., <tt class="docutils literal"><span class="pre">(),x</span></tt> is just <tt class="docutils literal"><span class="pre">x</span></tt>, as is
<tt class="docutils literal"><span class="pre">x,()</span></tt>). Pairs always associate to the right, meaning that <tt class="docutils literal"><span class="pre">x,y,z</span> <span class="pre">==</span>
<span class="pre">x,(y,z)</span> <span class="pre">==</span> <span class="pre">(x,y),z</span></tt>, where <tt class="docutils literal"><span class="pre">x,(y,z)</span></tt> is the normalized representation.
This implies that tuples are always flat, i.e., there are no nested tuples
(tuples of tuples); if you need such constructs then you should use lists
instead.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p>Syntactically, tuples aren&#8217;t really primary expressions, but we
still include them here because they are closely related to lists which
are also defined in the prelude. Also, tuples are often used as a
simpler replacement for lists, in particular in function arguments and
return values, when no elaborate hierarchical structure is needed.</p>
<p class="last">Also note that parentheses are generally only used to group expressions
and are <em>not</em> part of the tuple syntax in Pure, although they will be
needed to include a tuple in a list or matrix. E.g.,
<tt class="docutils literal"><span class="pre">[(1,2),3,(4,5)]</span></tt> is a three element list consisting of the tuple
<tt class="docutils literal"><span class="pre">1,2</span></tt>, the integer <tt class="docutils literal"><span class="pre">3</span></tt>, and another tuple <tt class="docutils literal"><span class="pre">4,5</span></tt>. Likewise,
<tt class="docutils literal"><span class="pre">[(1,2,3)]</span></tt> is a list with a single element, the tuple <tt class="docutils literal"><span class="pre">1,2,3</span></tt>.</p>
</div>
</dd>
<dt>Matrices: <tt class="docutils literal"><span class="pre">{1.0,2.0,3.0}</span></tt>, <tt class="docutils literal"><span class="pre">{1,2;3,4}</span></tt>, <tt class="docutils literal"><span class="pre">{1L,y+1;foo,bar}</span></tt></dt>
<dd><p class="first">Pure also offers matrices, a kind of two-dimensional arrays, as a built-in
data structure which provides efficient storage and element access. These
work more or less like their Octave/MATLAB equivalents, but using curly
braces instead of brackets. As indicated, commas are used to separate the
columns of a matrix, semicolons for its rows. In fact, the <tt class="docutils literal"><span class="pre">{...}</span></tt>
construct is rather general and allows you to construct new matrices from
any collection of individual elements (&#8220;scalars&#8221;) and submatrices,
provided that all dimensions match up. Here, any expression which doesn&#8217;t
yield a matrix denotes a scalar, which is considered to be a 1x1 matrix
for the purpose of matrix construction. The comma arranges submatrices in
columns, while the semicolon arranges them in rows. So, if both <tt class="docutils literal"><span class="pre">x</span></tt> and
<tt class="docutils literal"><span class="pre">y</span></tt> are <tt class="docutils literal"><span class="pre">n</span></tt>x<tt class="docutils literal"><span class="pre">m</span></tt> matrices, then <tt class="docutils literal"><span class="pre">{x,y}</span></tt> becomes an <tt class="docutils literal"><span class="pre">n</span></tt> x
<tt class="docutils literal"><span class="pre">2*m</span></tt> matrix consisting of all the columns of <tt class="docutils literal"><span class="pre">x</span></tt> followed by all the
columns of <tt class="docutils literal"><span class="pre">y</span></tt>. Likewise, <tt class="docutils literal"><span class="pre">{x;y}</span></tt> becomes a <tt class="docutils literal"><span class="pre">2*n</span></tt> x <tt class="docutils literal"><span class="pre">m</span></tt> matrix
(all the rows of <tt class="docutils literal"><span class="pre">x</span></tt> above of all rows of <tt class="docutils literal"><span class="pre">y</span></tt>). In addition, <tt class="docutils literal"><span class="pre">{...}</span></tt>
constructs can be nested to an arbitrary depth. Thus <tt class="docutils literal"><span class="pre">{{1;3},{2;4}}</span></tt> is
another way to write the 2x2 matrix <tt class="docutils literal"><span class="pre">{1,2;3,4}</span></tt> in a kind of
&#8220;column-major&#8221; format (however, internally all matrices are stored in C&#8217;s
row-major format).</p>
<p>Pure supports both numeric and symbolic matrices. The former are
homogeneous arrays of double, complex double or (machine) int matrices,
while the latter can contain any mixture of Pure expressions. Pure will
pick the appropriate type for the data at hand. If a matrix contains
values of different types, or Pure values which cannot be stored in a
numeric matrix, then a symbolic matrix is created instead (this also
includes the case of bigints, which are considered as symbolic values as
far as matrix construction is concerned). Numeric matrices use an internal
data layout that is fully compatible with the <a class="reference internal" href="#gnu-scientific-library">GNU Scientific Library</a>
(GSL), and can readily be passed to GSL routines via the C interface. (The
Pure interpreter does not require GSL, however, so numeric matrices will
work even if GSL is not installed.)</p>
<p>More information about matrices and corresponding examples can be found in
the <a class="reference internal" href="#examples">Examples</a> section below.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While the <tt class="docutils literal"><span class="pre">[...]</span></tt> and <tt class="docutils literal"><span class="pre">{...}</span></tt> constructs look superficially
similar, they work in very different ways. The former is just syntactic
sugar for a corresponding constructor term and can thus be used as a
pattern on the left-hand side of an equation, cf. <a class="reference internal" href="#patterns">Patterns</a>. In
contrast, the latter is special syntax for a built-in operation which
creates objects of a special matrix type. Thus matrix expressions can
<em>not</em> be used as patterns (instead, matrix values can be matched as a
whole using the special <tt class="docutils literal"><span class="pre">matrix</span></tt> type tag).</p>
</div>
</dd>
<dt>Comprehensions: <tt class="docutils literal"><span class="pre">[x,y</span> <span class="pre">|</span> <span class="pre">x=1..n;</span> <span class="pre">y=1..m;</span> <span class="pre">x&lt;y]</span></tt>, <tt class="docutils literal"><span class="pre">{f</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">x=1..n}</span></tt></dt>
<dd><p class="first">Pure provides both list and matrix comprehensions as a convenient means to
construct list and matrix values from a &#8220;template&#8221; expression and one or
more &#8220;generator&#8221; and &#8220;filter&#8221; clauses. The former bind a pattern to values
drawn from a list or matrix, the latter are just predicates determining
which generated elements should actually be added to the result. Both list
and matrix comprehensions are in fact syntactic sugar for a combination of
nested lambdas, conditional expressions and &#8220;catmaps&#8221; (a collection of
operations which combine list or matrix construction and mapping a
function over a list or matrix, defined in the prelude), but they are
often much easier to write.</p>
<p class="last">Matrix comprehensions work pretty much like list comprehensions, but
produce matrices instead of lists. List generators in matrix
comprehensions alternate between row and column generation so that most
common mathematical abbreviations carry over quite easily. Examples of
both kinds of comprehensions can be found in the <a class="reference internal" href="#examples">Examples</a> section below.</p>
</dd>
</dl>
</div>
<div class="section" id="simple-expressions">
<h4><a class="toc-backref" href="#id31">Simple Expressions</a><a class="headerlink" href="#simple-expressions" title="Permalink to this headline">¶</a></h4>
<p>The rest of Pure&#8217;s expression syntax mostly revolves around the notion of
function applications. For convenience, Pure also allows you to declare pre-,
post-, out- and infix operator symbols, but these are in fact just syntactic
sugar for function applications; see <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a> for details.
Function and operator applications are used to combine primary expressions to
compound terms, also referred to as <strong class="dfn">simple expressions</strong>; these are the data
elements which are manipulated by Pure programs.</p>
<p>As in other modern FPLs, function applications are written simply as
juxtaposition (i.e., in &#8220;curried&#8221; form) and associate to the left. This means
that in fact all functions only take a single argument. Multi-argument
functions are represented as chains of single-argument functions. For
instance, in <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">(f</span> <span class="pre">x)</span> <span class="pre">y</span></tt> first the function <tt class="docutils literal"><span class="pre">f</span></tt> is applied to the
first argument <tt class="docutils literal"><span class="pre">x</span></tt>, yielding the function <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt> which in turn gets applied
to the second argument <tt class="docutils literal"><span class="pre">y</span></tt>. This makes it possible to derive new functions
from existing ones using <strong class="dfn">partial applications</strong> which only specify some but
not all arguments of a function. For instance, taking the <tt class="docutils literal"><span class="pre">max</span></tt> function
from the prelude as an example, <tt class="docutils literal"><span class="pre">max</span> <span class="pre">0</span></tt> is the function which, for a given
<tt class="docutils literal"><span class="pre">x</span></tt>, returns <tt class="docutils literal"><span class="pre">x</span></tt> itself if it is nonnegative and zero otherwise. This
works because <tt class="docutils literal"><span class="pre">(max</span> <span class="pre">0)</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">max</span> <span class="pre">0</span> <span class="pre">x</span></tt> is the maximum of <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The major advantage of having curried function applications is that,
without any further ado, functions become first-class objects. That is,
they can be passed around freely both as parameters and as function return
values. Functions which take other functions as arguments and/or yield them
as results are also known as <strong class="dfn">higher-order functions</strong> (HOFs). Much of the
power of functional programming languages stems from this feature, so the
treatment of functions as first-class values is generally considered as one
of the defining characteristics of functional languages.</p>
</div>
<p>Operator applications are written using prefix, postfix, outfix or infix
notation, as the declaration of the operator demands, but are just ordinary
function applications in disguise. As already mentioned, enclosing an operator
in parentheses turns it into an ordinary function symbol, thus <tt class="docutils literal"><span class="pre">x+y</span></tt> is
exactly the same as <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></tt>. For convenience, partial applications of
infix operators can also be written using so-called <strong class="dfn">operator sections</strong>. A
<em>left section</em> takes the form <tt class="docutils literal"><span class="pre">(x+)</span></tt> which is equivalent to the partial
application <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span></tt>. A <em>right section</em> takes the form <tt class="docutils literal"><span class="pre">(+x)</span></tt> and is
equivalent to the term <tt class="docutils literal"><span class="pre">flip</span> <span class="pre">(+)</span> <span class="pre">x</span></tt>. (This uses the <a class="reference internal" href="purelib.html#flip" title="flip"><tt class="xref pure pure-func docutils literal"><span class="pre">flip</span></tt></a> combinator
from the prelude which is defined as <tt class="docutils literal"><span class="pre">flip</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">y</span> <span class="pre">x</span></tt>.) Thus <tt class="docutils literal"><span class="pre">(x+)</span> <span class="pre">y</span></tt>
is equivalent to <tt class="docutils literal"><span class="pre">x+y</span></tt>, while <tt class="docutils literal"><span class="pre">(+x)</span> <span class="pre">y</span></tt> reduces to <tt class="docutils literal"><span class="pre">y+x</span></tt>. For instance,
<tt class="docutils literal"><span class="pre">(1/)</span></tt> denotes the reciprocal and <tt class="docutils literal"><span class="pre">(+1)</span></tt> the successor function. (Note
that, in contrast, <tt class="docutils literal"><span class="pre">(-x)</span></tt> always denotes an application of unary minus; the
section <tt class="docutils literal"><span class="pre">(+-x)</span></tt> can be used to indicate a function which subtracts <tt class="docutils literal"><span class="pre">x</span></tt>
from its argument.)</p>
</div>
<div class="section" id="special-expressions">
<span id="end"></span><span id="with"></span><span id="when"></span><span id="case"></span><span id="else"></span><span id="then"></span><span id="if"></span><h4><a class="toc-backref" href="#id32">Special Expressions</a><a class="headerlink" href="#special-expressions" title="Permalink to this headline">¶</a></h4>
<p>Some special notations are provided for conditional expressions as well as
anonymous functions (lambdas) and blocks of local function and variable
definitions.</p>
<dl class="docutils">
<dt>Conditional expressions: <tt class="docutils literal"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">then</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">z</span></tt></dt>
<dd>Evaluates to <tt class="docutils literal"><span class="pre">y</span></tt> or <tt class="docutils literal"><span class="pre">z</span></tt> depending on whether <tt class="docutils literal"><span class="pre">x</span></tt> is &#8220;true&#8221; (i.e., a
nonzero integer). An exception is raised if the condition is not an
integer.</dd>
<dt>Lambdas: <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">y</span></tt></dt>
<dd>These denote anonymous functions and work pretty much like in Haskell.
Pure supports multiple-argument lambdas (e.g, <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x*y</span></tt>), as well as
pattern-matching lambda abstractions which match one or more patterns
against the lambda arguments, such as <tt class="docutils literal"><span class="pre">\(x,y)</span> <span class="pre">-&gt;</span> <span class="pre">x*y</span></tt>. An exception is
raised if the actual lambda arguments do not match the given patterns.</dd>
<dt>Case expressions: <tt class="docutils literal"><span class="pre">case</span> <span class="pre">x</span> <span class="pre">of</span> <span class="pre">rule;</span> <span class="pre">...</span> <span class="pre">end</span></tt></dt>
<dd>Matches an expression, discriminating over a number of different cases,
similar to the Haskell case construct. The expression <tt class="docutils literal"><span class="pre">x</span></tt> is matched in
turn against each left-hand side pattern in the rule list, and the first
pattern which matches <tt class="docutils literal"><span class="pre">x</span></tt> gives the value of the entire expression, by
evaluating the corresponding right-hand side with the variables in the
pattern bound to their corresponding values. An exception is raised if the
target expression doesn&#8217;t match any of the patterns.</dd>
<dt>When expressions: <tt class="docutils literal"><span class="pre">x</span> <span class="pre">when</span> <span class="pre">rule;</span> <span class="pre">...</span> <span class="pre">end</span></tt></dt>
<dd>An alternative way to bind local variables by matching a collection of
subject terms against corresponding patterns, similar to <a class="reference internal" href="#aardappel">Aardappel</a>&#8216;s
<tt class="docutils literal"><span class="pre">when</span></tt> construct. A single binding such as <tt class="docutils literal"><span class="pre">x</span> <span class="pre">when</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">v</span> <span class="pre">end</span></tt> is
equivalent to <tt class="docutils literal"><span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">end</span></tt>, but the former is often more
convenient to write. A <tt class="docutils literal"><span class="pre">when</span></tt> clause may contain multiple definitions,
which are processed from left to right, so that later definitions may
refer to the variables in earlier ones. This is exactly the same as
several nested single definitions, with the first binding being the
&#8220;outermost&#8221; one.</dd>
<dt>With expressions: <tt class="docutils literal"><span class="pre">x</span> <span class="pre">with</span> <span class="pre">rule;</span> <span class="pre">...</span> <span class="pre">end</span></tt></dt>
<dd>Defines local functions. Like Haskell&#8217;s <tt class="docutils literal"><span class="pre">where</span></tt> construct, but it can be
used anywhere inside an expression (just like Aardappel&#8217;s <tt class="docutils literal"><span class="pre">where</span></tt>, but
Pure uses the keyword <tt class="docutils literal"><span class="pre">with</span></tt> which better lines up with <tt class="docutils literal"><span class="pre">case</span></tt> and
<tt class="docutils literal"><span class="pre">when</span></tt>). Several functions can be defined in a single <tt class="docutils literal"><span class="pre">with</span></tt> clause,
and the definitions can be mutually recursive and consist of as many
equations as you want.</dd>
</dl>
</div>
</div>
<div class="section" id="special-forms">
<span id="id2"></span><h3><a class="toc-backref" href="#id33">Special Forms</a><a class="headerlink" href="#special-forms" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, some operations are actually implemented as special
forms which process some or all of their arguments using call-by-name.</p>
<dl class="describe">
<dt>
<tt class="descname">if x then y else z</tt></dt>
<dd><p>The conditional expression is a special form with call-by-name arguments
<tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">z</span></tt>; only one of the branches is actually evaluated, depending
on the value of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="&amp;&amp;/special">
x <tt class="descname">&amp;&amp;</tt> y<a class="headerlink" href="#&&/special" title="Permalink to this definition">¶</a></dt>
<dt id="||/special">
x <tt class="descname">||</tt> y<a class="headerlink" href="#||/special" title="Permalink to this definition">¶</a></dt>
<dd><p>The logical connectives evaluate their operands in <strong class="dfn">short-circuit mode</strong>.
Thus the second operand is passed by name and will only be evaluated if the
first operand fails to determine the value of the expression. For instance,
<tt class="docutils literal"><span class="pre">x&amp;&amp;y</span></tt> immediately becomes false if <tt class="docutils literal"><span class="pre">x</span></tt> evaluates to false; otherwise
<tt class="docutils literal"><span class="pre">y</span></tt> is evaluated to give the value of the expression. The built-in
definitions of these operations work as if they were defined by the
following equations (but note that the second operand is indeed passed by
name):</p>
<div class="highlight-pure"><div class="highlight"><pre>x<span class="p">::</span><span class="kt">int</span> &amp;&amp; y = <span class="kr">if</span> x <span class="kr">then</span> y <span class="kr">else</span> x<span class="p">;</span>
x<span class="p">::</span><span class="kt">int</span> || y = <span class="kr">if</span> x <span class="kr">then</span> x <span class="kr">else</span> y<span class="p">;</span>
</pre></div>
</div>
<p>Note that this isn&#8217;t quite the same as in C, as the results of these
operations are <em>not</em> normalized, i.e., they may return nonzero values other
than 1 to denote &#8220;true&#8221;. (This has the advantage that these operations can
be implemented tail-recursively, see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>.)
Thus, if you need a normalized truth value then you&#8217;ll have to make sure
that either both operands are already normalized, or you&#8217;ll have to
normalize the result yourself. (A quick way to turn a machine int <tt class="docutils literal"><span class="pre">x</span></tt>
into a normalized truth value is to compute <tt class="docutils literal"><span class="pre">~~x</span></tt> or <tt class="docutils literal"><span class="pre">x~=0</span></tt>.)</p>
<p>Moreover, if the built-in definition fails because the first operand is not
a machine int, then the second operand will be evaluated anyway and the
resulting application becomes a normal form, which gives you the
opportunity to extend these operations with your own definitions just like
the other built-in operations. Note, however, that in this case the
operands are effectively passed by value.</p>
</dd></dl>

<dl class="function">
<dt id="$$">
x <tt class="descname">$$</tt> y<a class="headerlink" href="#$$" title="Permalink to this definition">¶</a></dt>
<dd><p>The sequencing operator <a class="reference internal" href="#$$" title="$$"><tt class="xref pure pure-func docutils literal"><span class="pre">$$</span></tt></a> evaluates its left operand, immediately
throws the result away and then goes on to evaluate the right operand which
gives the result of the entire expression. This operator is useful to write
imperative-style code such as the following prompt-input interaction:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>puts <span class="s">&quot;Enter a number:&quot;</span> $$ scanf <span class="s">&quot;%g&quot;</span><span class="p">;</span>
Enter a number:
<span class="mi">21</span>
<span class="mf">21.0</span>
</pre></div>
</div>
<p>We mention in passing here that the same effect can be achieved with a
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause, which also allows you to execute a function solely
for its side-effects and just ignore the return value:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>scanf <span class="s">&quot;%g&quot;</span> <span class="kr">when</span> puts <span class="s">&quot;Enter a number:&quot;</span> <span class="kr">end</span><span class="p">;</span>
Enter a number:
<span class="mi">21</span>
<span class="mf">21.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&amp;">
x <tt class="descname">&amp;</tt><a class="headerlink" href="#&" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#&amp;" title="&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;</span></tt></a> operator does lazy evaluation. This is the only postfix
operator defined in the standard prelude. It turns its operand into a kind
of parameterless anonymous closure, deferring its evaluation. These kinds
of objects are also commonly known as <strong class="dfn">thunks</strong> or <strong class="dfn">futures</strong>. When the value
of a future is actually needed (during pattern-matching, or when the value
becomes an argument of a C call), it is evaluated automatically and gets
memoized, i.e., the computed result replaces the thunk so that it only has
to be computed once.</p>
<p>Futures are useful to implement all kinds of lazy data structures in Pure,
in particular: lazy lists a.k.a. streams. A <strong class="dfn">stream</strong> is simply a list with
a thunked tail, which allows it to be infinite. The Pure prelude defines
many functions for creating and manipulating these kinds of objects;
further details and examples can be found in the <a class="reference internal" href="#examples">Examples</a> section below.</p>
</dd></dl>

<dl class="function">
<dt id="quote">
<tt class="descname">quote</tt> x<a class="headerlink" href="#quote" title="Permalink to this definition">¶</a></dt>
<dt id="'">
<tt class="descname">'</tt> x<a class="headerlink" href="#'" title="Permalink to this definition">¶</a></dt>
<dd><p>This special form quotes an expression, i.e., <tt class="docutils literal"><span class="pre">quote</span> <span class="pre">x</span></tt> (or,
equivalently, <tt class="docutils literal"><span class="pre">'x</span></tt>) returns just <tt class="docutils literal"><span class="pre">x</span></tt> itself without evaluating it. The
prelude also provides a function <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> which can be used to evaluate
a quoted expression at a later time. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> x = &#39;(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>)<span class="p">;</span> x<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>
<span class="gp">&gt; </span>eval x<span class="p">;</span>
<span class="mf">4180.0</span>
</pre></div>
</div>
<p>This enables some powerful metaprogramming techniques, which should be well
familiar to Lisp programmers. However, there are some notable differences
to Lisp&#8217;s quote, please see <a class="reference internal" href="#the-quote">The Quote</a> in the <a class="reference internal" href="#examples">Examples</a> section for
details and more examples.</p>
</dd></dl>

</div>
<div class="section" id="toplevel">
<span id="const"></span><span id="let"></span><span id="def"></span><h3><a class="toc-backref" href="#id34">Toplevel</a><a class="headerlink" href="#toplevel" title="Permalink to this headline">¶</a></h3>
<p>At the toplevel, a Pure program basically consists of rewriting rules (which
are used to define functions, macros and types), constant and variable
definitions, and expressions to be evaluated:</p>
<pre>
<strong id="grammar-token-script">script</strong> ::=  <a class="reference internal" href="#grammar-token-item"><tt class="xref docutils literal"><span class="pre">item</span></tt></a>*
<strong id="grammar-token-item">item  </strong> ::=  &quot;let&quot; <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref docutils literal"><span class="pre">simple_rule</span></tt></a> &quot;;&quot;
            | &quot;const&quot; <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref docutils literal"><span class="pre">simple_rule</span></tt></a> &quot;;&quot;
            | &quot;def&quot; <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref docutils literal"><span class="pre">simple_rule</span></tt></a> &quot;;&quot;
            | &quot;type&quot; <a class="reference internal" href="#grammar-token-type_rule"><tt class="xref docutils literal"><span class="pre">type_rule</span></tt></a> &quot;;&quot;
            | <a class="reference internal" href="#grammar-token-rule"><tt class="xref docutils literal"><span class="pre">rule</span></tt></a> &quot;;&quot;
            | <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;;&quot;
</pre>
<p>(The syntax of the <a class="reference internal" href="#grammar-token-rule"><tt class="xref std std-token docutils literal"><span class="pre">rule</span></tt></a>, <a class="reference internal" href="#grammar-token-type_rule"><tt class="xref std std-token docutils literal"><span class="pre">type_rule</span></tt></a> and <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref std std-token docutils literal"><span class="pre">simple_rule</span></tt></a>
elements is discussed in the <a class="reference internal" href="#rule-syntax">Rule Syntax</a> section below. Also, a few
additional toplevel elements are provided in the declaration syntax, see
<a class="reference internal" href="#declarations">Declarations</a>.)</p>
<dl class="describe">
<dt>
<tt class="descname">lhs = rhs;</tt></dt>
<dd><p>Rewriting rules always combine a left-hand side pattern (which must be a
simple expression) and a right-hand side (which can be any kind of Pure
expression described above). The same format is also used in
<a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions. In
toplevel rules, <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions, this basic
form can also be augmented with a condition <tt class="docutils literal"><span class="pre">if</span> <span class="pre">guard</span></tt> tacked on to the
end of the rule, where <tt class="docutils literal"><span class="pre">guard</span></tt> is an integer expression which determines
whether the rule is applicable.  Moreover, the keyword <tt class="xref std std-keyword docutils literal"><span class="pre">otherwise</span></tt>
may be used to denote an empty guard which is always true (this is
syntactic sugar to point out the &#8220;default&#8221; case of a definition; the
interpreter just treats this as a comment). Pure also provides some
abbreviations for factoring out common left-hand or right-hand sides in
collections of rules; see the <a class="reference internal" href="#rule-syntax">Rule Syntax</a> section for details.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">def lhs = rhs;</tt></dt>
<dd><p>A rule starting with the keyword <a class="reference internal" href="#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a> defines a macro
function. No guards or multiple left-hand and right-hand sides are
permitted here. Macro rules are used to preprocess expressions on the
right-hand side of other definitions at compile time, and are typically
employed to implement user-defined special forms and simple kinds of
optimization rules. See the <a class="reference internal" href="#macros">Macros</a> section below for details and examples.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">let lhs = rhs;</tt></dt>
<dd><p>Binds every variable in the left-hand side pattern to the corresponding
subterm of the right-hand side (after evaluating it). This works like a
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause, but serves to bind global variables occurring free
on the right-hand side of other function and variable definitions.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">const lhs = rhs;</tt></dt>
<dd><p>An alternative form of <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> which defines constants rather than
variables. (These are not to be confused with nonfix symbols which simply
stand for themselves!) Like <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, this construct binds the
variable symbols on the left-hand side to the corresponding values on the
right-hand side (after evaluation). The difference is that <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>
symbols can only be defined once, and thus their values do not change
during program execution. This also allows the compiler to apply some
special optimizations such as constant folding.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">expr;</tt></dt>
<dd><p>A singleton expression at the toplevel, terminated with a semicolon, simply
causes the given value to be evaluated (and the result to be printed, when
running in interactive mode).</p>
</dd></dl>

</div>
<div class="section" id="scoping-rules">
<h3><a class="toc-backref" href="#id35">Scoping Rules</a><a class="headerlink" href="#scoping-rules" title="Permalink to this headline">¶</a></h3>
<p>A few remarks about the scope of identifiers and other symbols are in order
here. Like most modern functional languages, Pure uses <strong class="dfn">lexical</strong> or <strong class="dfn">static</strong>
binding for local functions and variables. What this means is that the binding
of a local name is completely determined at compile time by the surrounding
program text, and does not change as the program is being executed. In
particular, if a function returns another (anonymous or local) function, the
returned function captures the environment it was created in, i.e., it becomes
a (lexical) <strong class="dfn">closure</strong>. For instance, the following function, when invoked with
a single argument <tt class="docutils literal"><span class="pre">x</span></tt>, returns another function which adds <tt class="docutils literal"><span class="pre">x</span></tt> to its
argument:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo x = bar <span class="kr">with</span> bar y = x+y <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> f = foo <span class="mi">99</span><span class="p">;</span> f<span class="p">;</span>
bar
<span class="gp">&gt; </span>f <span class="mi">10</span>, f <span class="mi">20</span><span class="p">;</span>
<span class="mi">109</span>,<span class="mi">119</span>
</pre></div>
</div>
<p>This works the same no matter what other bindings of <tt class="docutils literal"><span class="pre">x</span></tt> may be in effect
when the closure is invoked:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> x = <span class="mi">77</span><span class="p">;</span> f <span class="mi">10</span>, (f <span class="mi">20</span> <span class="kr">when</span> x = <span class="mi">88</span> <span class="kr">end</span>)<span class="p">;</span>
<span class="mi">109</span>,<span class="mi">119</span>
</pre></div>
</div>
<p>Global bindings of variable and function symbols work a bit differently,
though. Like many languages which are to be used interactively, Pure binds
global symbols <strong class="dfn">dynamically</strong>, so that the bindings can be changed easily at
any time during an interactive session. This is mainly a convenience for
interactive usage, but works the same no matter whether the source code is
entered interactively or being read from a script, in order to ensure
consistent behaviour between interactive and batch mode operation.</p>
<p>So, for instance, you can easily bind a global variable to a new value by just
entering a corresponding <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> command:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo x = c*x<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
c*<span class="mi">99</span>
<span class="gp">&gt; </span><span class="kr">let</span> c = <span class="mi">2</span><span class="p">;</span> foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
<span class="gp">&gt; </span><span class="kr">let</span> c = <span class="mi">3</span><span class="p">;</span> foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">297</span>
</pre></div>
</div>
<p>This works pretty much like global variables in imperative languages, but note
that in Pure the value of a global variable can only be changed with a
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> command at the toplevel. Thus referential transparency is
unimpaired; while the value of a global variable may change between different
toplevel expressions, it will always take the same value in a single
evaluation.</p>
<p>Similarly, you can also add new equations to an existing function at any
time:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact <span class="mi">0</span> = <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">int</span> = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mi">10</span><span class="p">;</span>
<span class="mi">3628800</span>
<span class="gp">&gt; </span>fact <span class="mf">10.0</span><span class="p">;</span>
fact <span class="mf">10.0</span>
<span class="gp">&gt; </span>fact <span class="mf">1.0</span> = <span class="mf">1.0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">double</span> = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mf">10.0</span><span class="p">;</span>
<span class="mf">3628800.0</span>
<span class="gp">&gt; </span>fact <span class="mi">10</span><span class="p">;</span>
<span class="mi">3628800</span>
</pre></div>
</div>
<p>(In interactive mode, it is even possible to completely erase a definition,
see section <a class="reference internal" href="#interactive-usage">Interactive Usage</a> for details.)</p>
<p>So, while the meaning of a local symbol never changes once its definition has
been processed, toplevel definitions may well evolve while the program is
being processed, and the interpreter will always use the latest definitions at
a given point in the source when an expression is evaluated. This means that,
even in a script file, you have to define all symbols needed in an evaluation
before entering the expression to be evaluated.</p>
</div>
</div>
<div class="section" id="rule-syntax">
<h2><a class="toc-backref" href="#id36">Rule Syntax</a><a class="headerlink" href="#rule-syntax" title="Permalink to this headline">¶</a></h2>
<p>Basically, the same rule syntax is used in all kinds of global and local
definitions. However, some constructs (specifically, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>,
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>, <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> and <a class="reference internal" href="#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a>) use a
variation of the basic rule syntax which does away with guards and/or multiple
left-hand or right-hand sides. The syntax of these elements is captured by the
following grammar rules:</p>
<pre>
<strong id="grammar-token-rule">rule       </strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a> (&quot;|&quot; <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a>)* &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> [<a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a>]
                 (&quot;;&quot; &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> [<a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a>])*
<strong id="grammar-token-type_rule">type_rule  </strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a> (&quot;|&quot; <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a>)* [ &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> [<a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a>] ]
<strong id="grammar-token-simple_rule">simple_rule</strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a> = <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> | <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a>
<strong id="grammar-token-pattern">pattern    </strong> ::=  <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
<strong id="grammar-token-guard">guard      </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
                 | &quot;otherwise&quot;
                 | <a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a> &quot;when&quot; <a class="reference internal" href="#grammar-token-simple_rules"><tt class="xref docutils literal"><span class="pre">simple_rules</span></tt></a> &quot;end&quot;
                 | <a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a> &quot;with&quot; <a class="reference internal" href="#grammar-token-rules"><tt class="xref docutils literal"><span class="pre">rules</span></tt></a> &quot;end&quot;
</pre>
<p>When matching against a function or macro call, or the subject term in a
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression, the rules are always considered in the order in
which they are written, and the first matching rule (whose guard evaluates to
a nonzero value, if applicable) is picked. (Again, the <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>
construct is treated differently, because each rule is actually a separate
definition.)</p>
<div class="section" id="patterns">
<h3><a class="toc-backref" href="#id37">Patterns</a><a class="headerlink" href="#patterns" title="Permalink to this headline">¶</a></h3>
<p>The left-hand side of a rule is a special kind of simple expression, called a
<strong class="dfn">pattern</strong>. Patterns consist of function and operator applications as well as
any of the &#8220;atomic&#8221; expression types (symbols, numbers, strings and list
values). <em>Not</em> permitted are any of the special expression types (lambda,
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>, <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>, conditional expressions, as
well as list and matrix comprehensions). For technical reasons, the current
implementation also forbids matrix values in patterns, but it is possible to
match a matrix value as a whole using the <tt class="docutils literal"><span class="pre">matrix</span></tt> type tag, see below.</p>
<p>As already mentioned, the &#8216;<tt class="docutils literal"><span class="pre">_</span></tt>&#8216; symbol is special in patterns; it denotes
the <strong class="dfn">anonymous variable</strong> which matches an arbitrary value (independently for
all occurrences) without actually binding a variable. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre>foo _ _ = <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This will match the application of <tt class="docutils literal"><span class="pre">foo</span></tt> to any combination of two
arguments (and just ignore the values of these arguments).</p>
<p>Constants in patterns must be matched literally. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre>foo <span class="mi">0</span> = <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>This will only match an application of <tt class="docutils literal"><span class="pre">foo</span></tt> to the machine integer <tt class="docutils literal"><span class="pre">0</span></tt>,
not <tt class="docutils literal"><span class="pre">0.0</span></tt> or <tt class="docutils literal"><span class="pre">0L</span></tt> (even though these compare equal to <tt class="docutils literal"><span class="pre">0</span></tt> using the
&#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; operator).</p>
<p>In contrast to Haskell, patterns may contain repeated variables (other than
the anonymous variable), i.e., they may be <strong class="dfn">non-linear</strong>. Thus rules like the
following are legal in Pure, and will only be matched if all occurrences of
the same variable in the left-hand side pattern are matched to the same
value:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo x x = x<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">1</span> <span class="mi">1</span><span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>foo <span class="mi">1</span> <span class="mi">2</span><span class="p">;</span>
foo <span class="mi">1</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Non-linear patterns are particularly useful for computer algebra where you
will frequently encounter rules such as the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>x*y+x*z = x*(y+z)<span class="p">;</span>
<span class="gp">&gt; </span>a*(<span class="mi">3</span>*<span class="mi">4</span>)+a*<span class="mi">5</span><span class="p">;</span>
a*<span class="mi">17</span>
</pre></div>
</div>
<p>The notion of &#8220;sameness&#8221; employed here is that of syntactical identity, which
means that the matched subterms must be identical in structure and content.
The prelude provides syntactic equality as a function <a class="reference internal" href="purelib.html#same" title="same"><tt class="xref pure pure-func docutils literal"><span class="pre">same</span></tt></a> and a
comparison predicate &#8216;<a class="reference internal" href="purelib.html#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>&#8216;. Thus the above definition of <tt class="docutils literal"><span class="pre">foo</span></tt>
is roughly equivalent to the following:</p>
<div class="highlight-pure"><div class="highlight"><pre>foo x y = x <span class="kr">if</span> same x y<span class="p">;</span>
</pre></div>
</div>
<p>It is important to note the differences between syntactic equality embodied by
<a class="reference internal" href="purelib.html#same" title="same"><tt class="xref pure pure-func docutils literal"><span class="pre">same</span></tt></a> and &#8216;<a class="reference internal" href="purelib.html#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>&#8216;, and the &#8220;semantic&#8221; equality operator
&#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216;. The former are always defined on all terms, whereas
&#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; is only available on data where it has been defined
explicitly, either in the prelude or by the programmer. Also note that
&#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; may assert that two terms are equal even if they are
syntactically different. Consider, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mi">0</span>==<span class="mf">0.0</span><span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span><span class="mi">0</span>===<span class="mf">0.0</span><span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>This distinction is actually quite useful. It gives the programmer the
flexibility to define &#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; in any way that he sees fit, which is
consistent with the way the other comparison operators like &#8216;<a class="reference internal" href="purelib.html#&lt;" title="&lt;"><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;</span></tt></a>&#8216;
and &#8216;<a class="reference internal" href="purelib.html#&gt;" title="&gt;"><tt class="xref pure pure-func docutils literal"><span class="pre">&gt;</span></tt></a>&#8216; are handled in Pure.</p>
<p>Patterns may also contain the following special elements which are not
permitted in right-hand side expressions:</p>
<ul class="simple">
<li>A Haskell-style <strong class="dfn">&#8220;as&#8221; pattern</strong> of the form <em>variable</em> <tt class="docutils literal"><span class="pre">&#64;</span></tt> <em>pattern</em>
binds the given variable to the expression matched by the subpattern
<em>pattern</em> (in addition to the variables bound by <em>pattern</em> itself). This
is convenient if the value matched by the subpattern is to be used on the
right-hand side of an equation.</li>
<li>A left-hand side variable (including the anonymous variable) may be followed
by a <strong class="dfn">type tag</strong> of the form <tt class="docutils literal"><span class="pre">::</span></tt> <em>name</em>, where <em>name</em> is either one of the
built-in type symbols <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">bigint</span></tt>, <tt class="docutils literal"><span class="pre">double</span></tt>, <tt class="docutils literal"><span class="pre">string</span></tt>,
<tt class="docutils literal"><span class="pre">matrix</span></tt>, <tt class="docutils literal"><span class="pre">pointer</span></tt>, or an identifier denoting a user-defined data
type. The variable can then match only values of the designated type. Thus,
for instance, &#8216;<tt class="docutils literal"><span class="pre">x::int</span></tt>&#8216; only matches machine integers. See the <a class="reference internal" href="#type-tags">Type
Tags</a> section below for details.</li>
</ul>
<p>To these ends, the expression syntax is augmented with the following grammar
rule (but note that this form of expression is in fact only allowed on the
left-hand side of a rule):</p>
<pre>
<strong id="id3">prim_expr</strong> ::=  <a class="reference internal" href="#grammar-token-qualified_identifier"><tt class="xref docutils literal"><span class="pre">qualified_identifier</span></tt></a>
               (&quot;::&quot; <a class="reference internal" href="#grammar-token-qualified_identifier"><tt class="xref docutils literal"><span class="pre">qualified_identifier</span></tt></a> | &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-prim_expr"><tt class="xref docutils literal"><span class="pre">prim_expr</span></tt></a>)
</pre>
<p>As shown, both &#8220;as&#8221; patterns and type tags are primary expressions, and the
subpattern of an &#8220;as&#8221; pattern is a primary expression, too. Thus, if a
compound expression is to be used as the subpattern, it <em>must</em> be
parenthesized. For instance, the following function duplicates the head
element of a list:</p>
<div class="highlight-pure"><div class="highlight"><pre>foo xs<span class="p">@</span>(x:_) = x:xs<span class="p">;</span>
</pre></div>
</div>
<p>Note that if you accidentally forget the parentheses around the subpattern
<tt class="docutils literal"><span class="pre">x:_</span></tt>, you still get a syntactically correct definition:</p>
<div class="highlight-pure"><div class="highlight"><pre>foo xs<span class="p">@</span>x:_ = x:xs<span class="p">;</span>
</pre></div>
</div>
<p>But this gets parsed as <tt class="docutils literal"><span class="pre">(foo</span> <span class="pre">xs&#64;x):_</span> <span class="pre">=</span> <span class="pre">x:xs</span></tt>, which is most certainly <em>not</em>
what you want. It is thus a good idea to just always enclose the subpattern
with parentheses in order to prevent such glitches.</p>
<p>Another potential pitfall is that the notation <tt class="docutils literal"><span class="pre">foo::bar</span></tt> is also used to
denote &#8220;qualified symbols&#8221; in Pure, cf. <a class="reference internal" href="#namespaces">Namespaces</a>. Usually this will be
resolved correctly, but if <tt class="docutils literal"><span class="pre">foo</span></tt> happens to also be a valid namespace then
most likely you&#8217;ll get an error message about an undeclared symbol. You can
always work around this by adding spaces around the &#8216;<tt class="docutils literal"><span class="pre">::</span></tt>&#8216; symbol, as in
<tt class="docutils literal"><span class="pre">foo</span> <span class="pre">::</span> <span class="pre">bar</span></tt>. Spaces are never permitted in qualified symbols, so this makes
it clear that the construct denotes a type tag.</p>
</div>
<div class="section" id="type-tags">
<span id="id4"></span><h3><a class="toc-backref" href="#id38">Type Tags</a><a class="headerlink" href="#type-tags" title="Permalink to this headline">¶</a></h3>
<p>Like Lisp, Pure is essentially a typeless language and doesn&#8217;t really have a
built-in notion of &#8220;data types&#8221;; all data belongs to the same universe of
terms. However, for convenience it is possible to describe data domains by
means of (unary) type <em>predicates</em> which may denote arbitrary sets of
terms. The names of these type predicates can then be used as <strong class="dfn">type tags</strong> on
variables, so that they can only be matched by values of the given type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is important to note here that Pure&#8217;s notion of types has nothing
to do with static typing. Type tags are only used at runtime to restrict
the kind of data that can be matched by a rule, and maybe by the compiler
to generate better code. But they will never cause the compiler to spit out
&#8220;type errors&#8221;. This wouldn&#8217;t make any sense in Pure anyway, as failure to
match any of the rules given in the definition of a function simply means
that a function application is in normal form.</p>
</div>
<p>Some basic types are built into the language. The corresponding tags enable
you to match the built-in types of terms for which there is no way to spell
out all &#8220;constructors&#8221;, as there are infinitely many (or none, as in the case
of <tt class="docutils literal"><span class="pre">matrix</span></tt> and <tt class="docutils literal"><span class="pre">pointer</span></tt> which are constructed and inspected using
special primitives, but are otherwise &#8220;opaque&#8221; at the Pure level).
Specifically, the following data types are built-in (in fact, the pattern
matcher has special knowledge about these so that they can be matched very
efficiently):</p>
<dl class="type">
<dt id="int/type">
<em class="property">type </em><tt class="descname">int</tt><a class="headerlink" href="#int/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of machine integers.</p>
</dd></dl>

<dl class="type">
<dt id="bigint/type">
<em class="property">type </em><tt class="descname">bigint</tt><a class="headerlink" href="#bigint/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of arbitrary precision integers (GMP bigints).</p>
</dd></dl>

<dl class="type">
<dt id="double/type">
<em class="property">type </em><tt class="descname">double</tt><a class="headerlink" href="#double/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of double precision floating point numbers.</p>
</dd></dl>

<dl class="type">
<dt id="string/type">
<em class="property">type </em><tt class="descname">string</tt><a class="headerlink" href="#string/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of character strings.</p>
</dd></dl>

<dl class="type">
<dt id="matrix/type">
<em class="property">type </em><tt class="descname">matrix</tt><a class="headerlink" href="#matrix/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of all numeric and symbolic matrix values.</p>
</dd></dl>

<dl class="type">
<dt id="pointer/type">
<em class="property">type </em><tt class="descname">pointer</tt><a class="headerlink" href="#pointer/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of C pointer values.</p>
</dd></dl>

<p>To define your own data types, you employ a special kind of rule syntax, which
is explained in <a class="reference internal" href="#type-rules">Type Rules</a> below. For instance, we might represent points
in the plane using a constructor symbol <tt class="docutils literal"><span class="pre">Point</span></tt> which gets applied to pairs
of coordinates. We can then define the <tt class="docutils literal"><span class="pre">point</span></tt> data type as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> point (Point x<span class="p">::</span>number y<span class="p">::</span>number)<span class="p">;</span>
</pre></div>
</div>
<p>This introduces the type symbol <tt class="docutils literal"><span class="pre">point</span></tt> and specifies that this type
consists of terms of the form <tt class="docutils literal"><span class="pre">Point</span> <span class="pre">x</span> <span class="pre">y</span></tt> where <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> may be any
kinds of numbers (the <tt class="xref pure pure-type docutils literal"><span class="pre">number</span></tt> type is defined in the prelude). We can
now equip this data type with an operation <tt class="docutils literal"><span class="pre">point</span></tt> to construct a point from
its coordinates, and two operations <tt class="docutils literal"><span class="pre">xcoord</span></tt> and <tt class="docutils literal"><span class="pre">ycoord</span></tt> to retrieve the
coordinates:</p>
<div class="highlight-pure"><div class="highlight"><pre>point x<span class="p">::</span>number y<span class="p">::</span>number = Point (x,y)<span class="p">;</span>
xcoord (Point (x,y)) = x<span class="p">;</span>
ycoord (Point (x,y)) = y<span class="p">;</span>
</pre></div>
</div>
<p>Next we might define a function <tt class="docutils literal"><span class="pre">translate</span></tt> which shifts the coordinates of
a point by a given amount in the x and y directions as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre>translate (x<span class="p">::</span>number,y<span class="p">::</span>number) p<span class="p">::</span>point = point (xcoord p+x) (ycoord p+y)<span class="p">;</span>
</pre></div>
</div>
<p>Note the use of <tt class="docutils literal"><span class="pre">point</span></tt> as a type tag on the <tt class="docutils literal"><span class="pre">p</span></tt> variable. By these means,
we can ensure that the argument is actually an instance of the point data
type. The <tt class="docutils literal"><span class="pre">translate</span></tt> function can be invoked as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> p<span class="p">::</span>point = point <span class="mi">3</span> <span class="mi">3</span><span class="p">;</span>
<span class="gp">&gt; </span>p<span class="p">;</span> translate (<span class="mi">1</span>,<span class="mi">2</span>) p<span class="p">;</span>
Point (<span class="mi">3</span>,<span class="mi">3</span>)
Point (<span class="mi">4</span>,<span class="mi">5</span>)
</pre></div>
</div>
<p>The important point here is that <tt class="docutils literal"><span class="pre">translate</span></tt> can be defined without knowing
or assuming <em>anything</em> about the internal representation of the <tt class="docutils literal"><span class="pre">point</span></tt> data
type. In fact, the <tt class="docutils literal"><span class="pre">Point</span></tt> constructor might well be hidden by making it a
private member of some namespace (cf. <a class="reference internal" href="#namespaces">Namespaces</a>), so that all accesses to
the data structure would have to be done through the provided operations. Such
a data type is also known as an <strong class="dfn">abstract data type</strong> (ADT). The kind of
&#8220;information hiding&#8221; provided by abstract data types is very important in the
design of larger software systems. In particular, it makes it possible to
revise the internal representation or even provide alternative implementations
of a data type, and have auxiliary functions (like our <tt class="docutils literal"><span class="pre">translate</span></tt> function)
still work on the modified data structure.</p>
<p>Pure&#8217;s standard library provides a few predefined data types, some of them
concrete (like the derived number types), some of them abstract (like the
container data types), and some which are just aliases for frequently used
type predicates (such as the matrix subtypes). These are all described in the
<a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a>.</p>
<p>More examples and a detailed explanation of Pure&#8217;s type tag concept can be
found in the <a class="reference internal" href="#type-rules">Type Rules</a> section below.</p>
</div>
<div class="section" id="general-rules">
<h3><a class="toc-backref" href="#id39">General Rules</a><a class="headerlink" href="#general-rules" title="Permalink to this headline">¶</a></h3>
<p>The most general type of rule, used in function definitions and
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions, consists of a left-hand side pattern, a
right-hand side expression and an optional guard. The left-hand side of a rule
can be omitted if it is the same as for the previous rule. This provides a
convenient means to write out a collection of equations for the same left-hand
side which discriminates over different conditions:</p>
<div class="highlight-pure"><div class="highlight"><pre>lhs       = rhs <span class="kr">if</span> guard<span class="p">;</span>
          = rhs <span class="kr">if</span> guard<span class="p">;</span>
          ...
          = rhs <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre>fact n  = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
        = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>Pure also allows a collection of rules with different left-hand sides but the
same right-hand side(s) to be abbreviated as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre>lhs       |
          ...
lhs       = rhs<span class="p">;</span>
</pre></div>
</div>
<p>This is useful if you need different specializations of the same rule which
use different type tags on the left-hand side variables. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre>fact n<span class="p">::</span><span class="kt">int</span>    |
fact n<span class="p">::</span><span class="kt">double</span> |
fact n         = n*fact(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
               = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>In fact, the left-hand sides don&#8217;t have to be related at all, so that you can
also write something like:</p>
<div class="highlight-pure"><div class="highlight"><pre>foo x | bar y = x*y<span class="p">;</span>
</pre></div>
</div>
<p>However, this construct is most useful when using an &#8220;as&#8221; pattern to bind a
common variable to a parameter value after checking that it matches one of
several possible argument patterns (which is slightly more efficient than
using an equivalent type-checking guard). E.g., the following definition binds
the <tt class="docutils literal"><span class="pre">xs</span></tt> variable to the parameter of <tt class="docutils literal"><span class="pre">foo</span></tt>, if it is either the empty
list or a list starting with an integer:</p>
<div class="highlight-pure"><div class="highlight"><pre>foo xs<span class="p">@</span>[] | foo xs<span class="p">@</span>(_<span class="p">::</span><span class="kt">int</span>:_) = ... xs ...<span class="p">;</span>
</pre></div>
</div>
<p>The same construct also works in <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions, which is
convenient if different cases should be mapped to the same value, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">case</span> ans <span class="kr">of</span> <span class="s">&quot;y&quot;</span> | <span class="s">&quot;Y&quot;</span> = <span class="mi">1</span><span class="p">;</span> _ = <span class="mi">0</span><span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Sometimes it is useful if local definitions (<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and
<a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>) can be shared by the right-hand side and the guard of a
rule. This can be done by placing the local definitions behind the guard, as
follows (we only show the case of a single <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause here, but of
course there may be any number of <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> clauses
behind the guard):</p>
<div class="highlight-pure"><div class="highlight"><pre>lhs = rhs <span class="kr">if</span> guard <span class="kr">when</span> defns <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that this is different from the following, which indicates that the
definitions only apply to the guard but not the right-hand side of the rule:</p>
<div class="highlight-pure"><div class="highlight"><pre>lhs = rhs <span class="kr">if</span> (guard <span class="kr">when</span> defns <span class="kr">end</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Conversely, definitions placed <em>before</em> the guard only apply to the right-hand
side but not the guard (no parentheses are required in this case):</p>
<div class="highlight-pure"><div class="highlight"><pre>lhs = rhs <span class="kr">when</span> defns <span class="kr">end</span> <span class="kr">if</span> guard<span class="p">;</span>
</pre></div>
</div>
<p>An example showing the use of a local variable binding spanning both the
right-hand side and the guard of a rule is the following quadratic equation
solver, which returns the (real) solutions of the equation <tt class="docutils literal"><span class="pre">x^2+p*x+q</span> <span class="pre">=</span> <span class="pre">0</span></tt>
if the discriminant <tt class="docutils literal"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">p^2/4-q</span></tt> is nonnegative:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span>solve p q = -p/<span class="mi">2</span>+sqrt d,-p/<span class="mi">2</span>-sqrt d <span class="kr">if</span> d&gt;=<span class="mi">0</span> <span class="kr">when</span> d = p^<span class="mi">2</span>/<span class="mi">4</span>-q <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>solve <span class="mi">4</span> <span class="mi">2</span><span class="p">;</span> solve <span class="mi">2</span> <span class="mi">4</span><span class="p">;</span>
-<span class="mf">0.585786437626905</span>,-<span class="mf">3.41421356237309</span>
solve <span class="mi">2</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Note that the above definition leaves the case of a negative discriminant
undefined.</p>
</div>
<div class="section" id="type-rules">
<span id="type"></span><h3><a class="toc-backref" href="#id40">Type Rules</a><a class="headerlink" href="#type-rules" title="Permalink to this headline">¶</a></h3>
<p>The definition of a type (cf. <a class="reference internal" href="#type-tags">Type Tags</a> above) consists of one or more type
rules which basically have the same format as the <a class="reference internal" href="#general-rules">general rules</a>, but with
the keyword <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> in front of each rule. Also, each left-hand side
must have either zero or one argument patterns, and multiple right-hand sides
aren&#8217;t permitted (multiple left-hand sides work the same as in the general
rule format, though).</p>
<p>The identifier in the head of the left-hand side of a type rule is the name of
the type which can then be used as a type tag in other equations. This is just
a normal, possibly qualified identifier subject to the same namespace
mechanisms as other symbols; see <a class="reference internal" href="#namespaces">Namespaces</a> for details. However, as the type
symbol only gets used as a type tag, it can never collide with function and
variable symbols and hence the same symbol can be used both as a type and a
function or variable name.</p>
<p>A collection of type rules specifies a predicate, i.e. a unary, truth-valued
function which denotes a set of terms. The type consists precisely of those
terms for which the type predicate yields <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-func docutils literal"><span class="pre">true</span></tt></a>. For instance, the
following type defines the type <tt class="docutils literal"><span class="pre">triple</span></tt> as the set of all tuples with
exactly three elements:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> triple (x,y,z) = ~tuplep z<span class="p">;</span>
</pre></div>
</div>
<p>Note that the type check consists of two parts here: The left-hand side
pattern <tt class="docutils literal"><span class="pre">(x,y,z)</span></tt> restricts the set to all tuples with at least three
elements. The right-hand side <tt class="docutils literal"><span class="pre">~tuplep</span> <span class="pre">z</span></tt> then verifies that the last
component <tt class="docutils literal"><span class="pre">z</span></tt> is not a tuple itself, and thus the entire tuple consists of
exactly three elements.</p>
<p>Another important point here is that the definition of the <tt class="docutils literal"><span class="pre">triple</span></tt>
predicate is <em>partial</em>, as the given rule only applies to tuples with at least
three elements. A value will only match the <tt class="docutils literal"><span class="pre">triple</span></tt> type tag if the
predicate explicitly returns <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-func docutils literal"><span class="pre">true</span></tt></a>; otherwise the match will fail, no
matter what the result is (and even if the predicates just fails, i.e.,
returns an unevaluated normal form). Thus there is no need to make the
predicate work on all terms (and in fact there are good reasons to <em>not</em> do
so, see below).</p>
<p>In general, you should try to make your type definitions as specific as
possible. This makes it possible to extend the predicate later, just like Pure
allows you to extend the definition of a function to new types of arguments.
For instance, if you later decide that lists with three elements should be
considered as triples, too, then you may add the following type rule:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> triple [x,y,z] = true<span class="p">;</span>
</pre></div>
</div>
<p>This makes it possible to define a type in a piecemeal fashion. Each
subsequent rule enlarges the term set of the type.</p>
<p>Conversely, consider a definition like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> pair x = tuplep x &amp;&amp; #x==<span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>In this case the type rule applies to all values <tt class="docutils literal"><span class="pre">x</span></tt> and thus the type
definition is complete; there is no way to extend it later.</p>
<p>Whether to prefer the former or latter kind of definition depends on the
situation. If you want to keep a type extensible, so that you can later make
existing definitions of operations on the type work with new data
representations, then you should use the former approach, otherwise the
latter.</p>
<p>As an example for an extensible type definition, consider the following type
<tt class="docutils literal"><span class="pre">nat</span></tt> which denotes the type of positive (machine) integers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> nat x<span class="p">::</span><span class="kt">int</span> = x&gt;<span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This definition is complete for the case of machine integers, but allows the
type to be extended for other base types, and we&#8217;ll do that in a moment. But
first let&#8217;s define the factorial on <tt class="docutils literal"><span class="pre">nat</span></tt> values as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre>fact n<span class="p">::</span>nat = <span class="kr">if</span> n==<span class="mi">1</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n * fact (n-<span class="mi">1</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Because of the type tag on the left-hand side, this function works on positive
machine integers, but nothing else:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>map fact (<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[fact <span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
<span class="gp">&gt; </span>fact <span class="mi">10L</span><span class="p">;</span>
fact <span class="mi">10L</span>
</pre></div>
</div>
<p>But if we later decide that positive bigints should be consider as members of
<tt class="docutils literal"><span class="pre">nat</span></tt> as well, we can simply add another rule for the <tt class="docutils literal"><span class="pre">nat</span></tt> type:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> nat x<span class="p">::</span><span class="kt">bigint</span> = x&gt;<span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Et voila, our <tt class="docutils literal"><span class="pre">fact</span></tt> routine now magically works with bigints, too:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>map fact (<span class="mi">0L</span>..<span class="mi">10L</span>)<span class="p">;</span>
[fact <span class="mi">0L</span>,<span class="mi">1</span>,<span class="mi">2L</span>,<span class="mi">6L</span>,<span class="mi">24L</span>,<span class="mi">120L</span>,<span class="mi">720L</span>,<span class="mi">5040L</span>,<span class="mi">40320L</span>,<span class="mi">362880L</span>,<span class="mi">3628800L</span>]
</pre></div>
</div>
<p>Note that we did all this without ever touching our original definition of
<tt class="docutils literal"><span class="pre">fact</span></tt>. This works because the <tt class="docutils literal"><span class="pre">bigint</span></tt> data type already provides all
the operations which we expect to use with the <tt class="docutils literal"><span class="pre">nat</span></tt> type. Pulling off this
trick with other, more exotic kinds of data requires more preparation, since
we&#8217;ll first have to provide the required operations (in this case, at least
comparisons with and subtraction of 1, as well as multiplication). For
instance, and just for the fun of it, let&#8217;s implement our own variation of the
<tt class="docutils literal"><span class="pre">nat</span></tt> type using Peano arithmetic:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> nat (s x) = true<span class="p">;</span>

<span class="c1">// addition</span>
x + <span class="mi">0</span>   = x<span class="p">;</span>
x + <span class="mi">1</span>   = s x<span class="p">;</span>
x + s y = s (x+y)<span class="p">;</span>

<span class="c1">// multiplication</span>
x * <span class="mi">0</span>   = <span class="mi">0</span><span class="p">;</span>
x * <span class="mi">1</span>   = x<span class="p">;</span>
x * s y = x + x*y<span class="p">;</span>

<span class="c1">// subtract 1</span>
s x - <span class="mi">1</span> = x<span class="p">;</span>

<span class="c1">// comparison with 0 and 1</span>
s x == <span class="mi">0</span> = false<span class="p">;</span>
s x == <span class="mi">1</span> = x == <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This implements just the bare bones, but that should be enough to make
<tt class="docutils literal"><span class="pre">fact</span></tt> work. Let&#8217;s give it a try:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact (s (s (s <span class="mi">0</span>)))<span class="p">;</span>
s (s (s (s (s (s <span class="mi">0</span>)))))
</pre></div>
</div>
<p>So, counting the <tt class="docutils literal"><span class="pre">s</span></tt>&#8216;s, the factorial of 3 is 6. Works! It goes without
saying, though, that this implementation of <tt class="docutils literal"><span class="pre">nat</span></tt> is rather inefficient;
you&#8217;ll get mountains of <tt class="docutils literal"><span class="pre">s</span></tt>&#8216;s for larger values of <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
<p>As you can see, a type definition may in general consist of many type rules
which may be scattered out over different parts of a program. This works
exactly in the same way as with ordinary functions, which can also be defined
in a piecemeal fashion in Pure.</p>
<p>There&#8217;s an additional convenience provided for type rules, namely that the
right-hand side may be omitted if it&#8217;s just <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-func docutils literal"><span class="pre">true</span></tt></a>. For instance, the
rule</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> nat (s x) = true<span class="p">;</span>
</pre></div>
</div>
<p>from above can also be written simply as:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> nat (s x)<span class="p">;</span>
</pre></div>
</div>
<p>This kind of notation is particularly convenient for &#8220;algebraic types&#8221; which
are usually given by a collection of constructors with different arities. For
instance, a binary tree data type might be defined as follows (here we employ
the <tt class="docutils literal"><span class="pre">|</span></tt> symbol to separate the different left-hand sides so that we can give
all the constructor patterns in one go):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> bintree (tip value) | bintree (bin left right)<span class="p">;</span>
</pre></div>
</div>
<p>Moreover, a type rule can also take the form of a function definition without
arguments.  In this case, the corresponding right-hand side may either be
another type symbol, or any kind of closure denoting a (curried) type
predicate. In this case the defined type is simply an <strong class="dfn">alias</strong> for the type
denoted on the right-hand side. This is often done, e.g., for numeric types,
to document that they actually stand for special kinds of quantities:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> speed = <span class="kt">double</span><span class="p">;</span>
<span class="kr">type</span> size = <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the definition of a type alias is always complete; there&#8217;s no way to
extend the corresponding type later. However, it&#8217;s also possible to just
specify the type name, without giving the right-hand side:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> thing<span class="p">;</span>
</pre></div>
</div>
<p>This doesn&#8217;t have any effect other than just declaring the type symbol, so
that it can be used as a type tag in subsequent definitions. You then still
have to give a proper definition of the type later (either as an explicit
predicate or an alias).</p>
<p>Type aliases can also be used to quickly turn an existing predicate into a
&#8220;convenience&#8221; type which can be used as a tag on the left-hand side of
equations. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> closure = closurep<span class="p">;</span>
</pre></div>
</div>
<p>(The standard library also defines a number of these, e.g., for the different
matrix types <tt class="docutils literal"><span class="pre">imatrix</span></tt>, <tt class="docutils literal"><span class="pre">dmatrix</span></tt> etc.)</p>
<p>Conversely, you can turn any type tag into an ordinary predicate which can be
used on the right-hand side of other definitions. To these ends, the prelude
provides the <a class="reference internal" href="purelib.html#typep" title="typep"><tt class="xref pure pure-func docutils literal"><span class="pre">typep</span></tt></a> predicate which takes a type symbol and the value
to be checked as arguments. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">type</span> odd x<span class="p">::</span><span class="kt">int</span> = x mod <span class="mi">2</span><span class="p">;</span>
<span class="kr">type</span> even x<span class="p">::</span><span class="kt">int</span> = ~odd x<span class="p">;</span>

odd x = typep odd x<span class="p">;</span>
even x = typep even x<span class="p">;</span>
</pre></div>
</div>
<p>With those definitions you get:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>map odd (<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>]
<span class="gp">&gt; </span>map even (<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>]
</pre></div>
</div>
<p>(There&#8217;s one caveat here. As the type symbol passed to <a class="reference internal" href="purelib.html#typep" title="typep"><tt class="xref pure pure-func docutils literal"><span class="pre">typep</span></tt></a> gets
evaluated in normal code you have to be careful if the symbol is also defined
as a parameterless function or a variable; in such a case you&#8217;ll have to quote
the symbol, as described in section <a class="reference internal" href="#the-quote">The Quote</a>.)</p>
<p>Finally, note that Pure places no a priori restrictions on the rules defining
a data type (other than that they must either define a unary predicate or an
alias for an existing data type). Thus any type of relation between two data
types is possible; they might be unrelated (disjoint) term sets, one may be a
subset of another, or they might be related in some other way (some terms may
be members of both types, while others aren&#8217;t). Thus the relationships between
types and their adherence to certain &#8220;interfaces&#8221; are the responsibility of
the programmer; as far as Pure is concerned, types are just subsets of the
universe of terms.</p>
<p>Also note that since the right-hand side of a type definition may in general
be any predicate, it is the responsibility of the programmer that the
definition of a type is actually computable. In fact, you should strive for
the best possible efficiency in type predicates. A type definition which has
worse than O(1) complexity may well be a serious performance hog depending on
the way in which it is used.</p>
</div>
<div class="section" id="simple-rules">
<h3><a class="toc-backref" href="#id41">Simple Rules</a><a class="headerlink" href="#simple-rules" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>, <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> and <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> use
a simplified kind of rule syntax which just consists of a left-hand and a
right-hand side separated by the equals sign. In this case the meaning of the
rule is to bind the variables in the left-hand side of the rule to the
corresponding subterms of the value of the right-hand side. This is also
called a <strong class="dfn">pattern binding</strong>.</p>
<p>Guards or multiple left-hand or right-hand sides are not permitted in these
rules. However, it is possible to omit the left-hand side if it is just the
anonymous variable &#8216;<tt class="docutils literal"><span class="pre">_</span></tt>&#8216; by itself, indicating that you don&#8217;t care about the
result. The right-hand side is still evaluated, if only for its side-effects,
which is handy, e.g., for adding debugging statements to your code. For
instance, here is a variation of the quadratic equation solver which also
prints the discriminant after it has been computed:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> math, system<span class="p">;</span>
<span class="gp">&gt; </span>solve p q = -p/<span class="mi">2</span>+sqrt d,-p/<span class="mi">2</span>-sqrt d <span class="kr">if</span> d&gt;=<span class="mi">0</span>
<span class="gp">&gt; </span><span class="kr">when</span> d = p^<span class="mi">2</span>/<span class="mi">4</span>-q<span class="p">;</span> printf <span class="s">&quot;The discriminant is: %g</span><span class="se">\n</span><span class="s">&quot;</span> d<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>solve <span class="mi">4</span> <span class="mi">2</span><span class="p">;</span>
The discriminant is: <span class="mi">2</span>
-<span class="mf">0.585786437626905</span>,-<span class="mf">3.41421356237309</span>
<span class="gp">&gt; </span>solve <span class="mi">2</span> <span class="mi">4</span><span class="p">;</span>
The discriminant is: -<span class="mi">3</span>
solve <span class="mi">2</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Note that simple rules of the same form <tt class="docutils literal"><span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs</span></tt> are also used in macro
definitions (<a class="reference internal" href="#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a>), to be discussed in the <a class="reference internal" href="#macros">Macros</a> section. In
this case, however, the rule denotes a real rewriting rule, not a pattern
binding, hence the left-hand side is mandatory in these rules.</p>
</div>
</div>
<div class="section" id="examples">
<h2><a class="toc-backref" href="#id42">Examples</a><a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Here are a few examples of simple Pure programs.</p>
<p>The factorial:</p>
<div class="highlight-pure"><div class="highlight"><pre>fact n = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
       = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
<span class="kr">let</span> facts = map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span> facts<span class="p">;</span>
</pre></div>
</div>
<p>The Fibonacci numbers:</p>
<div class="highlight-pure"><div class="highlight"><pre>fib n = a <span class="kr">when</span> a,b = fibs n <span class="kr">end</span>
          <span class="kr">with</span> fibs n = <span class="mi">0</span>,<span class="mi">1</span> <span class="kr">if</span> n&lt;=<span class="mi">0</span><span class="p">;</span>
                      = <span class="kr">case</span> fibs (n-<span class="mi">1</span>) <span class="kr">of</span>
                          a,b = b,a+b<span class="p">;</span>
                        <span class="kr">end</span><span class="p">;</span>
          <span class="kr">end</span><span class="p">;</span>
<span class="kr">let</span> fibs = map fib (<span class="mi">1</span>..<span class="mi">30</span>)<span class="p">;</span> fibs<span class="p">;</span>
</pre></div>
</div>
<p>It is worth noting here that Pure performs tail call optimization so that
tail-recursive definitions like the following will be executed in constant
stack space (see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a>
section for more details on this):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="c1">// tail-recursive factorial using an &quot;accumulating parameter&quot;</span>
fact n = loop <span class="mi">1</span> n <span class="kr">with</span>
  loop p n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> loop (p*n) (n-<span class="mi">1</span>) <span class="kr">else</span> p<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Here is an example showing how constants are defined and used. Constant
definitions take pretty much the same form as variable definitions with
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> (see above), but work more like the definition of a
parameterless function whose value is precomputed at compile time:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> atan(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">const</span> pi = <span class="mi">4</span>*atan <span class="mf">1.0</span><span class="p">;</span>
<span class="gp">&gt; </span>pi<span class="p">;</span>
<span class="mf">3.14159265358979</span>
<span class="gp">&gt; </span>foo x = <span class="mi">2</span>*pi*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = <span class="mf">6.28318530717959</span>*x<span class="p">;</span>
</pre></div>
</div>
<p>Note that the compiler normally computes constant subexpressions at compile
time, such as <tt class="docutils literal"><span class="pre">2*pi</span></tt> in the <tt class="docutils literal"><span class="pre">foo</span></tt> function. This works with all simple
scalars (machine ints and doubles), see <a class="reference internal" href="#constant-definitions">Constant Definitions</a> for details.</p>
<div class="section" id="list-comprehensions">
<h3><a class="toc-backref" href="#id43">List Comprehensions</a><a class="headerlink" href="#list-comprehensions" title="Permalink to this headline">¶</a></h3>
<p>List comprehensions are Pure&#8217;s main workhorse for generating and processing
all kinds of list values. Here&#8217;s a well-known example, a variation of
Erathosthenes&#8217; classical prime sieve:</p>
<div class="highlight-pure"><div class="highlight"><pre>primes n        = sieve (<span class="mi">2</span>..n) <span class="kr">with</span>
  sieve []      = []<span class="p">;</span>
  sieve (p:qs)  = p : sieve [q | q = qs<span class="p">;</span> q mod p]<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>(This definition is actually rather inefficient, there are much better albeit
more complicated implementations of this sieve.)</p>
<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>primes <span class="mi">100</span><span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">11</span>,<span class="mi">13</span>,<span class="mi">17</span>,<span class="mi">19</span>,<span class="mi">23</span>,<span class="mi">29</span>,<span class="mi">31</span>,<span class="mi">37</span>,<span class="mi">41</span>,<span class="mi">43</span>,<span class="mi">47</span>,<span class="mi">53</span>,<span class="mi">59</span>,<span class="mi">61</span>,<span class="mi">67</span>,<span class="mi">71</span>,<span class="mi">73</span>,<span class="mi">79</span>,<span class="mi">83</span>,<span class="mi">89</span>,<span class="mi">97</span>]
</pre></div>
</div>
<p>If you dare, you can actually have a look at the catmap-lambda-if-then-else
expression the comprehension expanded to:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show primes
primes n = sieve (<span class="mi">2</span>..n) <span class="kr">with</span> sieve [] = []<span class="p">;</span> sieve (p:qs) = p:sieve
(catmap (\q -&gt; <span class="kr">if</span> q mod p <span class="kr">then</span> [q] <span class="kr">else</span> []) qs) <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>List comprehensions are also a useful device to organize backtracking
searches. For instance, here&#8217;s an algorithm for the n queens problem, which
returns the list of all placements of n queens on an n x n board (encoded as
lists of n pairs (i,j) with i = 1..n), so that no two queens hold each other
in check:</p>
<div class="highlight-pure"><div class="highlight"><pre>queens n       = search n <span class="mi">1</span> [] <span class="kr">with</span>
  search n i p = [reverse p] <span class="kr">if</span> i&gt;n<span class="p">;</span>
               = cat [search n (i+<span class="mi">1</span>) ((i,j):p) | j = <span class="mi">1</span>..n<span class="p">;</span> safe (i,j) p]<span class="p">;</span>
  safe (i,j) p = ~any (check (i,j)) p<span class="p">;</span>
  check (i1,j1) (i2,j2)
               = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>(Again, this algorithm is rather inefficient, see the examples included in the
Pure distribution for a much better algorithm by Libor Spacek.)</p>
</div>
<div class="section" id="lazy-evaluation-and-streams">
<span id="id5"></span><h3><a class="toc-backref" href="#id44">Lazy Evaluation and Streams</a><a class="headerlink" href="#lazy-evaluation-and-streams" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, lists can also be evaluated in a &#8220;lazy&#8221; fashion, by just
turning the tail of a list into a future. This special kind of list is also
called a <strong class="dfn">stream</strong>. Streams enable you to work with infinite lists (or finite
lists which are so huge that you would never want to keep them in memory in
their entirety). E.g., here&#8217;s one way to define the infinite stream of all
Fibonacci numbers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> fibs = fibs <span class="mi">0L</span> <span class="mi">1L</span> <span class="kr">with</span> fibs a b = a : fibs b (a+b) &amp; <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>fibs<span class="p">;</span>
<span class="mi">0L</span>:<span class="kt">#&lt;thunk 0xb5d54320&gt;</span>
</pre></div>
</div>
<p>Note the <a class="reference internal" href="#&amp;" title="&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;</span></tt></a> on the tail of the list in the definition of the local
<tt class="docutils literal"><span class="pre">fibs</span></tt> function. This turns the result of <tt class="docutils literal"><span class="pre">fibs</span></tt> into a stream, which is
required to prevent the function from recursing into samadhi. Also note that
we work with bigints in this example because the Fibonacci numbers grow quite
rapidly, so with machine integers the values would soon start wrapping around
to negative integers.</p>
<p>Streams like these can be worked with in pretty much the same way as with
lists. Of course, care must be taken not to invoke &#8220;eager&#8221; operations such as
<a class="reference internal" href="purelib.html##" title="#"><tt class="xref pure pure-func docutils literal"><span class="pre">#</span></tt></a> (which computes the size of a list) on infinite streams, to prevent
infinite recursion. However, many list operations work with infinite streams
just fine, and return the appropriate stream results. E.g., the <a class="reference internal" href="purelib.html#take" title="take"><tt class="xref pure pure-func docutils literal"><span class="pre">take</span></tt></a>
function (which retrieves a given number of elements from the front of a list)
works with streams just as well as with &#8220;eager&#8221; lists:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>take <span class="mi">10</span> fibs<span class="p">;</span>
<span class="mi">0L</span>:<span class="kt">#&lt;thunk 0xb5d54350&gt;</span>
</pre></div>
</div>
<p>Hmm, not much progress there, but that&#8217;s just how streams work (or rather they
don&#8217;t, they&#8217;re lazy bums indeed!). Nevertheless, the stream computed with
<a class="reference internal" href="purelib.html#take" title="take"><tt class="xref pure pure-func docutils literal"><span class="pre">take</span></tt></a> is in fact finite and we can readily convert it to an ordinary
list, forcing its evaluation:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>list (take <span class="mi">10</span> fibs)<span class="p">;</span>
[<span class="mi">0L</span>,<span class="mi">1L</span>,<span class="mi">1L</span>,<span class="mi">2L</span>,<span class="mi">3L</span>,<span class="mi">5L</span>,<span class="mi">8L</span>,<span class="mi">13L</span>,<span class="mi">21L</span>,<span class="mi">34L</span>]
</pre></div>
</div>
<p>An easier way to achieve this is to cut a &#8220;slice&#8221; from the stream:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fibs!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">0L</span>,<span class="mi">1L</span>,<span class="mi">1L</span>,<span class="mi">2L</span>,<span class="mi">3L</span>,<span class="mi">5L</span>,<span class="mi">8L</span>,<span class="mi">13L</span>,<span class="mi">21L</span>,<span class="mi">34L</span>,<span class="mi">55L</span>]
</pre></div>
</div>
<p>Also note that since we bound the stream to a variable, the already computed
prefix of the stream has been memoized, so that this portion of the stream is
now readily available in case we need to have another look at it later. By
these means, possibly costly reevaluations are avoided, trading memory for
execution speed:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fibs<span class="p">;</span>
<span class="mi">0L</span>:<span class="mi">1L</span>:<span class="mi">1L</span>:<span class="mi">2L</span>:<span class="mi">3L</span>:<span class="mi">5L</span>:<span class="mi">8L</span>:<span class="mi">13L</span>:<span class="mi">21L</span>:<span class="mi">34L</span>:<span class="mi">55L</span>:<span class="kt">#&lt;thunk 0xb5d54590&gt;</span>
</pre></div>
</div>
<p>Let&#8217;s take a look at some of the other convenience operations for generating
stream values. The prelude defines infinite arithmetic sequences, using
<tt class="docutils literal"><span class="pre">inf</span></tt> or <tt class="docutils literal"><span class="pre">-inf</span></tt> to denote an upper (or lower) infinite bound for the
sequence, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> u = <span class="mi">1</span>..inf<span class="p">;</span> <span class="kr">let</span> v = -<span class="mf">1.0</span>:-<span class="mf">1.2</span>..-inf<span class="p">;</span>
<span class="gp">&gt; </span>u!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span> v!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>,<span class="mi">11</span>]
[-<span class="mf">1.0</span>,-<span class="mf">1.2</span>,-<span class="mf">1.4</span>,-<span class="mf">1.6</span>,-<span class="mf">1.8</span>,-<span class="mf">2.0</span>,-<span class="mf">2.2</span>,-<span class="mf">2.4</span>,-<span class="mf">2.6</span>,-<span class="mf">2.8</span>,-<span class="mf">3.0</span>]
</pre></div>
</div>
<p>Other useful stream generator functions are <a class="reference internal" href="purelib.html#iterate" title="iterate"><tt class="xref pure pure-func docutils literal"><span class="pre">iterate</span></tt></a>, which keeps
applying the same function over and over again, <a class="reference internal" href="purelib.html#repeat" title="repeat"><tt class="xref pure pure-func docutils literal"><span class="pre">repeat</span></tt></a>, which just
repeats its argument forever, and <a class="reference internal" href="purelib.html#cycle" title="cycle"><tt class="xref pure pure-func docutils literal"><span class="pre">cycle</span></tt></a>, which cycles through the
elements of the given list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>iterate (*<span class="mi">2</span>) <span class="mi">1</span>!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">8</span>,<span class="mi">16</span>,<span class="mi">32</span>,<span class="mi">64</span>,<span class="mi">128</span>,<span class="mi">256</span>,<span class="mi">512</span>,<span class="mi">1024</span>]
<span class="gp">&gt; </span>repeat <span class="mi">1</span>!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>]
<span class="gp">&gt; </span>cycle [<span class="mi">0</span>,<span class="mi">1</span>]!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>]
</pre></div>
</div>
<p>Moreover, list comprehensions can draw values from streams and return the
appropriate stream result:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> rats = [m,n-m | n=<span class="mi">2</span>..inf<span class="p">;</span> m=<span class="mi">1</span>..n-<span class="mi">1</span><span class="p">;</span> gcd m (n-m) == <span class="mi">1</span>]<span class="p">;</span> rats<span class="p">;</span>
(<span class="mi">1</span>,<span class="mi">1</span>):<span class="kt">#&lt;thunk 0xb5d54950&gt;</span>
<span class="gp">&gt; </span>rats!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">2</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">3</span>),(<span class="mi">3</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">4</span>),(<span class="mi">2</span>,<span class="mi">3</span>),(<span class="mi">3</span>,<span class="mi">2</span>),(<span class="mi">4</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">5</span>),(<span class="mi">5</span>,<span class="mi">1</span>)]
</pre></div>
</div>
<p>Finally, let&#8217;s rewrite our prime sieve so that it generates the infinite
stream of <em>all</em> prime numbers:</p>
<div class="highlight-pure"><div class="highlight"><pre>all_primes      = sieve (<span class="mi">2</span>..inf) <span class="kr">with</span>
  sieve (p:qs)  = p : sieve [q | q = qs<span class="p">;</span> q mod p] &amp;<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that we can omit the empty list case of <tt class="docutils literal"><span class="pre">sieve</span></tt> here, since the sieve
now never becomes empty. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> P = all_primes<span class="p">;</span>
<span class="gp">&gt; </span>P!!(<span class="mi">0</span>..<span class="mi">20</span>)<span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">11</span>,<span class="mi">13</span>,<span class="mi">17</span>,<span class="mi">19</span>,<span class="mi">23</span>,<span class="mi">29</span>,<span class="mi">31</span>,<span class="mi">37</span>,<span class="mi">41</span>,<span class="mi">43</span>,<span class="mi">47</span>,<span class="mi">53</span>,<span class="mi">59</span>,<span class="mi">61</span>,<span class="mi">67</span>,<span class="mi">71</span>,<span class="mi">73</span>]
<span class="gp">&gt; </span>P!<span class="mi">299</span><span class="p">;</span>
<span class="mi">1987</span>
</pre></div>
</div>
<p>You can also just print the entire stream. This will run forever, so hit
<tt class="kbd docutils literal"><span class="pre">Ctrl-c</span></tt> when you get bored:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>do (printf <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span>) all_primes<span class="p">;</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">5</span>
  ...
</pre></div>
</div>
<p>(Make sure that you really use the <tt class="docutils literal"><span class="pre">all_primes</span></tt> function instead of the
<tt class="docutils literal"><span class="pre">P</span></tt> variable to print the stream. Otherwise, because of memoization the
stream stored in <tt class="docutils literal"><span class="pre">P</span></tt> will grow with the number of elements printed until
memory is exhausted. Calling <a class="reference internal" href="purelib.html#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a> on a fresh instance of the stream of
primes allows <a class="reference internal" href="purelib.html#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a> to get rid of each &#8220;cons&#8221; cell after having printed
the corresponding stream element.)</p>
</div>
<div class="section" id="matrix-computations">
<span id="id6"></span><h3><a class="toc-backref" href="#id45">Matrix Computations</a><a class="headerlink" href="#matrix-computations" title="Permalink to this headline">¶</a></h3>
<p>Pure offers a number of basic matrix operations, such as matrix construction,
indexing, slicing, as well as getting the size and dimensions of a matrix
(these are briefly described in the <a class="reference internal" href="#standard-library">Standard Library</a> section). However, it
does <em>not</em> supply built-in support for matrix arithmetic and other linear
algebra algorithms. The idea is that these can and should be provided through
separate libraries (please check the Pure website for the pure-gsl module
which is an ongoing project to provide a full GSL interface for the Pure
language).</p>
<p>But Pure&#8217;s facilities for matrix and list processing also make it easy to roll
your own, if desired. First, the prelude provides matrix versions of the
common list operations like <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>, <a class="reference internal" href="purelib.html#zip" title="zip"><tt class="xref pure pure-func docutils literal"><span class="pre">zip</span></tt></a> etc.,
which provide a way to implement common matrix operations. E.g., multiplying a
matrix <tt class="docutils literal"><span class="pre">x</span></tt> with a scalar <tt class="docutils literal"><span class="pre">a</span></tt> amounts to mapping the function <tt class="docutils literal"><span class="pre">(a*)</span></tt> to
x, which can be done as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>a * x<span class="p">::</span><span class="kt">matrix</span> = map (a*) x <span class="kr">if</span> ~matrixp a<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">2</span>*{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
{<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">6</span><span class="p">;</span><span class="mi">8</span>,<span class="mi">10</span>,<span class="mi">12</span>}
</pre></div>
</div>
<p>Likewise, matrix addition and other element-wise operations can be realized
using <a class="reference internal" href="purelib.html#zipwith" title="zipwith"><tt class="xref pure pure-func docutils literal"><span class="pre">zipwith</span></tt></a>, which combines corresponding elements of two matrices
using a given binary function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>x<span class="p">::</span><span class="kt">matrix</span> + y<span class="p">::</span><span class="kt">matrix</span> = zipwith (+) x y<span class="p">;</span>
<span class="gp">&gt; </span>{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}+{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">1</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span>
{<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">4</span><span class="p">;</span><span class="mi">7</span>,<span class="mi">7</span>,<span class="mi">9</span>}
</pre></div>
</div>
<p>Second, matrix comprehensions make it easy to express a variety of algorithms
which would typically be implemented using <tt class="docutils literal"><span class="pre">for</span></tt> loops in conventional
programming languages. To illustrate the use of matrix comprehensions, here is
how we can define an operation to create a square identity matrix of a given
dimension:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>eye n = {i==j | i = <span class="mi">1</span>..n<span class="p">;</span> j = <span class="mi">1</span>..n}<span class="p">;</span>
<span class="gp">&gt; </span>eye <span class="mi">3</span><span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">0</span><span class="p">;</span><span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span><span class="p">;</span><span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">1</span>}
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">i==j</span></tt> term is just a Pure idiom for the Kronecker
symbol. Another point worth mentioning here is that the generator clauses of
matrix comprehensions alternate between row and column generation
automatically, if values are drawn from lists as in the example above. (More
precisely, the last generator, which varies most quickly, yields a row, the
next-to-last one a column of these row vectors, and so on.) This makes matrix
comprehensions resemble customary mathematical notation very closely.</p>
<p>Of course, matrix comprehensions can also draw values from other matrices
instead of lists. In this case the block layout of the component matrices is
preserved. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>{x,y|x={<span class="mi">1</span>,<span class="mi">2</span>}<span class="p">;</span>y={a,b<span class="p">;</span>c,d}}<span class="p">;</span>
{(<span class="mi">1</span>,a),(<span class="mi">1</span>,b),(<span class="mi">2</span>,a),(<span class="mi">2</span>,b)<span class="p">;</span>(<span class="mi">1</span>,c),(<span class="mi">1</span>,d),(<span class="mi">2</span>,c),(<span class="mi">2</span>,d)}
</pre></div>
</div>
<p>Note that a matrix comprehension involving filters may fail because the
filtered result isn&#8217;t a rectangular matrix any more. E.g.,
<tt class="docutils literal"><span class="pre">{2*x|x={1,2,3,-4};x&gt;0}</span></tt> works, as does <tt class="docutils literal"><span class="pre">{2*x|x={-1,2;3,-4};x&gt;0}</span></tt>, but
<tt class="docutils literal"><span class="pre">{2*x|x={1,2;3,-4};x&gt;0}</span></tt> doesn&#8217;t because the rows of the result matrix have
different lengths.</p>
<p>As a slightly more comprehensive example (no pun intended!), here is a
definition of matrix multiplication in Pure. The building block here is the
&#8220;dot&#8221; product of two vectors which can be defined as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>sum = foldl (+) <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>dot x<span class="p">::</span><span class="kt">matrix</span> y<span class="p">::</span><span class="kt">matrix</span> = sum $ zipwith (*) (rowvector x) (rowvector y)<span class="p">;</span>
<span class="gp">&gt; </span>dot {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>} {<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>}<span class="p">;</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>The general matrix product now boils down to a simple matrix comprehension
which just computes the dot product of all rows of <tt class="docutils literal"><span class="pre">x</span></tt> with all columns of
<tt class="docutils literal"><span class="pre">y</span></tt> (the <a class="reference internal" href="purelib.html#rows" title="rows"><tt class="xref pure pure-func docutils literal"><span class="pre">rows</span></tt></a> and <a class="reference internal" href="purelib.html#cols" title="cols"><tt class="xref pure pure-func docutils literal"><span class="pre">cols</span></tt></a> functions are prelude operations
found in matrices.pure):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>x<span class="p">::</span><span class="kt">matrix</span> * y<span class="p">::</span><span class="kt">matrix</span> = {dot u v | u = rows x<span class="p">;</span> v = cols y}<span class="p">;</span>
<span class="gp">&gt; </span>{<span class="mi">0</span>,<span class="mi">1</span><span class="p">;</span><span class="mi">1</span>,<span class="mi">0</span><span class="p">;</span><span class="mi">1</span>,<span class="mi">1</span>}*{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
{<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span><span class="p">;</span><span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>}
</pre></div>
</div>
<p>(For the sake of simplicity, this doesn&#8217;t do much error checking. In
production code you&#8217;d check at least the conformance of matrix dimensions, of
course.)</p>
<p>Well, that was easy. So let&#8217;s take a look at a more challenging example,
Gaussian elimination, which can be used to solve systems of linear
equations. The algorithm brings a matrix into &#8220;row echelon&#8221; form, a
generalization of triangular matrices. The resulting system can then be solved
quite easily using back substitution.</p>
<p>Here is a Pure implementation of the algorithm. Note that the real meat is in
the pivoting and elimination step (<tt class="docutils literal"><span class="pre">step</span></tt> function) which is iterated over
all columns of the input matrix. In each step, <tt class="docutils literal"><span class="pre">x</span></tt> is the current matrix,
<tt class="docutils literal"><span class="pre">i</span></tt> the current row index, <tt class="docutils literal"><span class="pre">j</span></tt> the current column index, and <tt class="docutils literal"><span class="pre">p</span></tt> keeps
track of the current permutation of the row indices performed during
pivoting. The algorithm returns the updated matrix <tt class="docutils literal"><span class="pre">x</span></tt>, row index <tt class="docutils literal"><span class="pre">i</span></tt> and
row permutation <tt class="docutils literal"><span class="pre">p</span></tt>.</p>
<div class="highlight-pure"><div class="highlight"><pre>gauss_elimination x<span class="p">::</span><span class="kt">matrix</span> = p,x
<span class="kr">when</span> n,m = dim x<span class="p">;</span> p,_,x = foldl step (<span class="mi">0</span>..n-<span class="mi">1</span>,<span class="mi">0</span>,x) (<span class="mi">0</span>..m-<span class="mi">1</span>) <span class="kr">end</span><span class="p">;</span>

<span class="c1">// One pivoting and elimination step in column j of the matrix:</span>
step (p,i,x) j
= <span class="kr">if</span> max_x==<span class="mi">0</span> <span class="kr">then</span> p,i,x
  <span class="kr">else</span>
    <span class="c1">// updated row permutation and index:</span>
    transp i max_i p, i+<span class="mi">1</span>,
    {<span class="c1">// the top rows of the matrix remain unchanged:</span>
     x!!(<span class="mi">0</span>..i-<span class="mi">1</span>,<span class="mi">0</span>..m-<span class="mi">1</span>)<span class="p">;</span>
     <span class="c1">// the pivot row, divided by the pivot element:</span>
     {x!(i,l)/x!(i,j)                 | l=<span class="mi">0</span>..m-<span class="mi">1</span>}<span class="p">;</span>
     <span class="c1">// subtract suitable multiples of the pivot row:</span>
     {x!(k,l)-x!(k,j)*x!(i,l)/x!(i,j) | k=i+<span class="mi">1</span>..n-<span class="mi">1</span><span class="p">;</span> l=<span class="mi">0</span>..m-<span class="mi">1</span>}}
<span class="kr">when</span>
  n,m = dim x<span class="p">;</span> max_i, max_x = pivot i (col x j)<span class="p">;</span>
  x = <span class="kr">if</span> max_x&gt;<span class="mi">0</span> <span class="kr">then</span> swap x i max_i <span class="kr">else</span> x<span class="p">;</span>
<span class="kr">end</span> <span class="kr">with</span>
  pivot i x       = foldl max (<span class="mi">0</span>,<span class="mi">0</span>) [j,abs (x!j)|j=i..#x-<span class="mi">1</span>]<span class="p">;</span>
  max (i,x) (j,y) = <span class="kr">if</span> x&lt;y <span class="kr">then</span> j,y <span class="kr">else</span> i,x<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Please refer to any good textbook on numerical mathematics for a closer
description of the algorithm. But here is a brief rundown of what happens in
each elimination step: First we find the pivot element in column <tt class="docutils literal"><span class="pre">j</span></tt> of the
matrix. (We&#8217;re doing partial pivoting here, i.e., we only look for the element
with the largest absolute value in column <tt class="docutils literal"><span class="pre">j</span></tt>, starting at row <tt class="docutils literal"><span class="pre">i</span></tt>. That&#8217;s
usually good enough to achieve numerical stability.) If the pivot is zero then
we&#8217;re done (the rest of the pivot column is already zeroed out). Otherwise, we
bring it into the pivot position (swapping row <tt class="docutils literal"><span class="pre">i</span></tt> and the pivot row),
divide the pivot row by the pivot, and subtract suitable multiples of the
pivot row to eliminate the elements of the pivot column in all subsequent
rows. Finally we update <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> accordingly and return the result.</p>
<p>In order to complete the implementation, we still need the following little
helper functions to swap two rows of a matrix (this is used in the pivoting
step) and to apply a transposition to a permutation (represented as a list):</p>
<div class="highlight-pure"><div class="highlight"><pre>swap x i j = x!!(transp i j (<span class="mi">0</span>..n-<span class="mi">1</span>),<span class="mi">0</span>..m-<span class="mi">1</span>) <span class="kr">when</span> n,m = dim x <span class="kr">end</span><span class="p">;</span>
transp i j p = [p!tr k | k=<span class="mi">0</span>..#p-<span class="mi">1</span>]
<span class="kr">with</span> tr k = <span class="kr">if</span> k==i <span class="kr">then</span> j <span class="kr">else</span> <span class="kr">if</span> k==j <span class="kr">then</span> i <span class="kr">else</span> k <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, let us define a convenient print representation of double matrices a
la <a class="reference internal" href="#octave">Octave</a> (the meaning of the <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> function is explained in <a class="reference internal" href="#the-show-function">The
__show__ Function</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> system<span class="p">;</span>
__show__ x<span class="p">::</span><span class="kt">matrix</span>
= strcat [printd j (x!(i,j))|i=<span class="mi">0</span>..n-<span class="mi">1</span><span class="p">;</span> j=<span class="mi">0</span>..m-<span class="mi">1</span>] + <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="kr">with</span> printd <span class="mi">0</span> = sprintf <span class="s">&quot;</span><span class="se">\n</span><span class="s">%10.5f&quot;</span><span class="p">;</span> printd _ = sprintf <span class="s">&quot;%10.5f&quot;</span> <span class="kr">end</span>
<span class="kr">when</span> n,m = dim x <span class="kr">end</span> <span class="kr">if</span> dmatrixp x<span class="p">;</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> x = <span class="kt">dmatrix</span> {<span class="mi">2</span>,<span class="mi">1</span>,-<span class="mi">1</span>,<span class="mi">8</span><span class="p">;</span> -<span class="mi">3</span>,-<span class="mi">1</span>,<span class="mi">2</span>,-<span class="mi">11</span><span class="p">;</span> -<span class="mi">2</span>,<span class="mi">1</span>,<span class="mi">2</span>,-<span class="mi">3</span>}<span class="p">;</span>
<span class="gp">&gt; </span>x<span class="p">;</span> gauss_elimination x<span class="p">;</span>
   <span class="mf">2.00000</span>   <span class="mf">1.00000</span>  -<span class="mf">1.00000</span>   <span class="mf">8.00000</span>
  -<span class="mf">3.00000</span>  -<span class="mf">1.00000</span>   <span class="mf">2.00000</span> -<span class="mf">11.00000</span>
  -<span class="mf">2.00000</span>   <span class="mf">1.00000</span>   <span class="mf">2.00000</span>  -<span class="mf">3.00000</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">0</span>],
   <span class="mf">1.00000</span>   <span class="mf">0.33333</span>  -<span class="mf">0.66667</span>   <span class="mf">3.66667</span>
   <span class="mf">0.00000</span>   <span class="mf">1.00000</span>   <span class="mf">0.40000</span>   <span class="mf">2.60000</span>
   <span class="mf">0.00000</span>   <span class="mf">0.00000</span>   <span class="mf">1.00000</span>  -<span class="mf">1.00000</span>
</pre></div>
</div>
</div>
<div class="section" id="symbolic-matrices">
<h3><a class="toc-backref" href="#id46">Symbolic Matrices</a><a class="headerlink" href="#symbolic-matrices" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, matrices may contain not just numbers but any kind of
Pure value, in which case they become <em>symbolic</em> matrices. Symbolic matrices
are a convenient data structure for storing arbitrary collections of values
which provides fast random access to its members. In particular, symbolic
matrices can also be nested, and thus arrays of arbitrary dimension can be
realized as nested symbolic vectors. However, you have to be careful when
constructing such values, as the <tt class="docutils literal"><span class="pre">{...}</span></tt> construct normally combines
submatrices to larger matrices. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>}
</pre></div>
</div>
<p>One way to inhibit this &#8220;splicing&#8221; of the submatrices in a larger matrix is to
use the &#8220;quote&#8221; operator (cf. <a class="reference internal" href="#the-quote">The Quote</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>&#39;{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}<span class="p">;</span>
{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}
</pre></div>
</div>
<p>(Note that this result is really different from <tt class="docutils literal"><span class="pre">{1,2;3,4}</span></tt>. The latter is a
2x2 integer matrix, while the former is a symbolic vector a.k.a. 1x2 matrix
whose elements happen to be two integer vectors.)</p>
<p>Unfortunately, the quote operator in fact inhibits evaluation of <em>all</em>
embedded subterms which may be undesirable if the matrix expression contains
arithmetic (as in <tt class="docutils literal"><span class="pre">'{{1+1,2*3}}</span></tt>), so this method works best for constant
matrices. A more general way to create a symbolic vector of matrices is
provided by the <a class="reference internal" href="purelib.html#vector" title="vector"><tt class="xref pure pure-func docutils literal"><span class="pre">vector</span></tt></a> function from the prelude, which is applied to
a list of the vector elements as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>vector [{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}]<span class="p">;</span>
{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}
</pre></div>
</div>
<p>Calls to the <a class="reference internal" href="purelib.html#vector" title="vector"><tt class="xref pure pure-func docutils literal"><span class="pre">vector</span></tt></a> function can be nested to an arbitrary depth to
obtain higher-dimensional &#8220;arrays&#8221;:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>vector [vector [{<span class="mi">1</span>,<span class="mi">2</span>}],vector [{<span class="mi">3</span>,<span class="mi">4</span>}]]<span class="p">;</span>
{{{<span class="mi">1</span>,<span class="mi">2</span>}},{{<span class="mi">3</span>,<span class="mi">4</span>}}}
</pre></div>
</div>
<p>This obviously becomes a bit unwieldy for higher dimensions, but in Pure you
can easily define yourself some more convenient notation if you like. For
instance, the following macro may be used to define a pair of &#8220;non-splicing&#8221;
vector brackets:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">outfix</span> {: :}<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">def</span> {: xs<span class="p">@</span>(_,_) :} = vector (list xs)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">def</span> {: x :} = vector [x]<span class="p">;</span>
<span class="gp">&gt; </span>{:{:{<span class="mi">1</span>,<span class="mi">2</span>}:},{:{<span class="mi">3</span>,<span class="mi">4</span>}:}:}<span class="p">;</span>
{{{<span class="mi">1</span>,<span class="mi">2</span>}},{{<span class="mi">3</span>,<span class="mi">4</span>}}}
</pre></div>
</div>
<p>(Both macros and <a class="reference internal" href="#outfix"><tt class="xref std std-keyword docutils literal"><span class="pre">outfix</span></tt></a> symbol declarations are described later in
the appropriate sections, see <a class="reference internal" href="#macros">Macros</a> and <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a>.)</p>
</div>
<div class="section" id="record-data">
<span id="id7"></span><h3><a class="toc-backref" href="#id47">Record Data</a><a class="headerlink" href="#record-data" title="Permalink to this headline">¶</a></h3>
<p>Symbolic matrices also provide a means to represent simple record-like data,
by encoding records as symbolic vectors consisting of &#8220;hash pairs&#8221; of the form
<tt class="docutils literal"><span class="pre">key</span> <span class="pre">=&gt;</span> <span class="pre">value</span></tt>. This kind of data structure is very convenient to represent
aggregates with lots of different components. Since the components of records
can be accessed by indexing with key values, you don&#8217;t have to remember which
components are stored in which order, just knowing the keys of the required
members is enough. In contrast, tuples, lists and other kinds of constructor
terms quickly become unwieldy for such purposes.</p>
<p>The keys used for indexing the record data must be either symbols or strings,
while the corresponding values may be arbitrary Pure values. The prelude
provides some operations on these special kinds of matrices, which let you
retrieve vector elements by indexing and perform non-destructive updates, see
the <a class="reference internal" href="purelib.html#record-functions"><em>Record Functions</em></a> section in the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details. Here
are a few examples which illustrate how to create records and work with them:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> r = {x=&gt;<span class="mi">5</span>, y=&gt;<span class="mi">12</span>}<span class="p">;</span>
<span class="gp">&gt; </span>recordp r, member r x<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">1</span>
<span class="gp">&gt; </span>r!y<span class="p">;</span> r!![y,x]<span class="p">;</span>
<span class="mi">12</span>
{<span class="mi">12</span>,<span class="mi">5</span>}
<span class="gp">&gt; </span>insert r (x=&gt;<span class="mi">99</span>)<span class="p">;</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">12</span>}
<span class="gp">&gt; </span>insert ans (z=&gt;<span class="mi">77</span>)<span class="p">;</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">12</span>,z=&gt;<span class="mi">77</span>}
<span class="gp">&gt; </span>delete ans z<span class="p">;</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">12</span>}
</pre></div>
</div>
<p>Note the use of the &#8220;hash rocket&#8221; <a class="reference internal" href="purelib.html#=&gt;" title="=&gt;"><tt class="xref pure pure-cons docutils literal"><span class="pre">=&gt;</span></tt></a> which denotes the <tt class="docutils literal"><span class="pre">key=&gt;value</span></tt>
associations in a record. The hash rocket is a constructor declared as an
infix operator in the prelude, see the <a class="reference internal" href="purelib.html#prelude"><em>Prelude</em></a> section in the
<a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a>. There&#8217;s one caveat here, however. Since neither &#8216;<tt class="docutils literal"><span class="pre">=&gt;</span></tt>&#8216; nor
&#8216;<tt class="docutils literal"><span class="pre">!</span></tt>&#8216; treat their key operand in a special way, you&#8217;ll have to take care
that the key symbols do not evaluate to something else, as might be the case
if they are bound to a global or local variable or parameterless function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> u = <span class="mi">99</span><span class="p">;</span>
<span class="gp">&gt; </span>{u=&gt;u}<span class="p">;</span>
{<span class="mi">99</span>=&gt;<span class="mi">99</span>}
</pre></div>
</div>
<p>In the case of global variables and function symbols, you might also protect
the symbol with a quote (see <a class="reference internal" href="#the-quote">The Quote</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>{&#39;u=&gt;u}<span class="p">;</span>
{u=&gt;<span class="mi">99</span>}
</pre></div>
</div>
<p>However, even the quote doesn&#8217;t save you from local variable substitution:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>{&#39;u=&gt;u} <span class="kr">when</span> u = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
{<span class="mi">99</span>=&gt;<span class="mi">99</span>}
</pre></div>
</div>
<p>In such cases you&#8217;ll either have to rename the local variable, or use the
prelude function <a class="reference internal" href="purelib.html#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> to quote the symbol:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>{&#39;u=&gt;v} <span class="kr">when</span> v = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
{u=&gt;<span class="mi">99</span>}
<span class="gp">&gt; </span>{val <span class="s">&quot;u&quot;</span>=&gt;u} <span class="kr">when</span> u = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
{u=&gt;<span class="mi">99</span>}
</pre></div>
</div>
<p>It&#8217;s also possible to directly use strings as keys instead, which may actually
be more convenient in some cases:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> r = {<span class="s">&quot;x&quot;</span>=&gt;<span class="mi">5</span>, <span class="s">&quot;y&quot;</span>=&gt;<span class="mi">12</span>}<span class="p">;</span>
<span class="gp">&gt; </span>keys r<span class="p">;</span> vals r<span class="p">;</span>
{<span class="s">&quot;x&quot;</span>,<span class="s">&quot;y&quot;</span>}
{<span class="mi">5</span>,<span class="mi">12</span>}
<span class="gp">&gt; </span>update r <span class="s">&quot;y&quot;</span> (r!<span class="s">&quot;y&quot;</span>+<span class="mi">1</span>)<span class="p">;</span>
{<span class="s">&quot;x&quot;</span>=&gt;<span class="mi">5</span>,<span class="s">&quot;y&quot;</span>=&gt;<span class="mi">13</span>}
</pre></div>
</div>
<p>You can also mix strings and symbols as keys in the same record (but note that
strings and symbols are always distinct, so <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">&quot;y&quot;</span></tt> are really two
different keys here):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>insert r (y=&gt;<span class="mi">99</span>)<span class="p">;</span>
{<span class="s">&quot;x&quot;</span>=&gt;<span class="mi">5</span>,<span class="s">&quot;y&quot;</span>=&gt;<span class="mi">12</span>,y=&gt;<span class="mi">99</span>}
</pre></div>
</div>
<p>As records are in fact just special kinds of matrices, the standard matrix
operations can be used on record values as well. For instance, the matrix
constructor provides an alternative way to quickly augment a record with a
collection of new <tt class="docutils literal"><span class="pre">key=&gt;value</span></tt> associations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> r = {x=&gt;<span class="mi">5</span>, y=&gt;<span class="mi">12</span>}<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> r = {r, x=&gt;<span class="mi">7</span>, z=&gt;<span class="mi">3</span>}<span class="p">;</span> r<span class="p">;</span>
{x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>,x=&gt;<span class="mi">7</span>,z=&gt;<span class="mi">3</span>}
<span class="gp">&gt; </span>r!x, r!z<span class="p">;</span>
<span class="mi">7</span>,<span class="mi">3</span>
<span class="gp">&gt; </span>delete r x<span class="p">;</span>
{x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>,z=&gt;<span class="mi">3</span>}
<span class="gp">&gt; </span>ans!x<span class="p">;</span>
<span class="mi">5</span>
</pre></div>
</div>
<p>As the example shows, this may produce duplicate keys, but these are handled
gracefully; indexing and updates will always work with the <em>last</em> association
for a given key in the record. If necessary, you can remove duplicate entries
from a record as follows; this will only keep the last association for each
key:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>record r<span class="p">;</span>
{x=&gt;<span class="mi">7</span>,y=&gt;<span class="mi">12</span>,z=&gt;<span class="mi">3</span>}
</pre></div>
</div>
<p>In fact, the <a class="reference internal" href="purelib.html#record" title="record"><tt class="xref pure pure-func docutils literal"><span class="pre">record</span></tt></a> operation not only removes duplicates, but also
orders the record entries by keys. This produces a kind of normalized
representation which is useful if you want to compare or combine two record
values irrespective of the ordering of the fields. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>record {x=&gt;<span class="mi">5</span>, y=&gt;<span class="mi">12</span>} === record {y=&gt;<span class="mi">12</span>, x=&gt;<span class="mi">5</span>}<span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="purelib.html#record" title="record"><tt class="xref pure pure-func docutils literal"><span class="pre">record</span></tt></a> function can also be used to construct a normalized record
directly from a list or tuple of hash pairs:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>record [x=&gt;<span class="mi">5</span>, x=&gt;<span class="mi">7</span>, y=&gt;<span class="mi">12</span>]<span class="p">;</span>
{x=&gt;<span class="mi">7</span>,y=&gt;<span class="mi">12</span>}
</pre></div>
</div>
<p>Other matrix operations such as <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>, etc., and matrix
comprehensions can be applied to records just as easily. This enables you to
perform bulk updates of record data in a straightforward way. For instance,
here&#8217;s how you can define a function <tt class="docutils literal"><span class="pre">maprec</span></tt> which applies a function to
all values stored in a record:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>maprec f = map (\(u=&gt;v) -&gt; u=&gt;f v)<span class="p">;</span>
<span class="gp">&gt; </span>maprec (*<span class="mi">2</span>) {x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>}<span class="p">;</span>
{x=&gt;<span class="mi">10</span>,y=&gt;<span class="mi">24</span>}
</pre></div>
</div>
<p>Another example: The following <tt class="docutils literal"><span class="pre">ziprec</span></tt> function collects pairs of values
stored under common keys in two records (we also normalize the result here so
that duplicate keys are always removed):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>ziprec x y = record {u=&gt;(x!u,y!u) | u = keys x<span class="p">;</span> member y u}<span class="p">;</span>
<span class="gp">&gt; </span>ziprec {a=&gt;<span class="mi">3</span>,x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>} {x=&gt;<span class="mi">10</span>,y=&gt;<span class="mi">24</span>,z=&gt;<span class="mi">7</span>}<span class="p">;</span>
{x=&gt;(<span class="mi">5</span>,<span class="mi">10</span>),y=&gt;(<span class="mi">12</span>,<span class="mi">24</span>)}
</pre></div>
</div>
<p>Thus the full power of generic matrix operations is available for records,
which turns them into a very versatile data structure, much more powerful than
records in conventional programming languages which are usually limited to
constructing records and accessing or modifying their components. Note that
since the values stored in records can be arbitrary Pure values, you can also
have mutable records by making use of Pure&#8217;s expression references (see
<a class="reference internal" href="purelib.html#expression-references"><em>Expression References</em></a> in the library manual). And of course records can
be nested, too:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> r = {a =&gt; {b=&gt;<span class="mi">1</span>,c=&gt;<span class="mi">2</span>}, b =&gt; <span class="mi">2</span>}<span class="p">;</span>
<span class="gp">&gt; </span>r!a, r!b, r!a!b<span class="p">;</span>
{b=&gt;<span class="mi">1</span>,c=&gt;<span class="mi">2</span>},<span class="mi">2</span>,<span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="the-quote">
<h3><a class="toc-backref" href="#id48">The Quote</a><a class="headerlink" href="#the-quote" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned in <a class="reference internal" href="#special-forms">Special Forms</a>, the <a class="reference internal" href="#quote" title="quote"><tt class="xref pure pure-func docutils literal"><span class="pre">quote</span></tt></a> operation quotes
an expression, so that it can be passed around and manipulated freely until
its value is needed, in which case you can pass it to the <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>
function to obtain its value. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> x = &#39;(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>)<span class="p">;</span> x<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>
<span class="gp">&gt; </span>eval x<span class="p">;</span>
<span class="mf">4180.0</span>
</pre></div>
</div>
<p>The quote also inhibits evaluation inside matrix values, including the
&#8220;splicing&#8221; of embedded submatrices:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>&#39;{<span class="mi">1</span>,<span class="mi">2</span>+<span class="mi">3</span>,<span class="mi">2</span>*<span class="mi">3</span>}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>+<span class="mi">3</span>,<span class="mi">2</span>*<span class="mi">3</span>}
<span class="gp">&gt; </span>&#39;{<span class="mi">1</span>,{<span class="mi">2</span>,<span class="mi">3</span>},<span class="mi">4</span>}<span class="p">;</span>
{<span class="mi">1</span>,{<span class="mi">2</span>,<span class="mi">3</span>},<span class="mi">4</span>}
</pre></div>
</div>
<p>Lisp programmers will be well familiar with this operation which enables some
powerful metaprogramming techniques. However, there are some notable
differences to Lisp&#8217;s quote. First, <a class="reference internal" href="#quote" title="quote"><tt class="xref pure pure-func docutils literal"><span class="pre">quote</span></tt></a> only inhibits the evaluation
of global variables, <em>local</em> variables are substituted as usual:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>(\x -&gt; &#39;(<span class="mi">2</span>*x+<span class="mi">1</span>)) <span class="mi">99</span><span class="p">;</span>
<span class="mi">2</span>*<span class="mi">99</span>+<span class="mi">1</span>
<span class="gp">&gt; </span>foo x = &#39;(<span class="mi">2</span>*x+<span class="mi">1</span>)<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span> foo $ &#39;(<span class="mi">7</span>/y)<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">99</span>+<span class="mi">1</span>
<span class="mi">2</span>*(<span class="mi">7</span>/y)+<span class="mi">1</span>
<span class="gp">&gt; </span>&#39;(x+<span class="mi">1</span>) <span class="kr">when</span> x = &#39;(<span class="mi">2</span>*<span class="mi">3</span>) <span class="kr">end</span><span class="p">;</span>
<span class="mi">2</span>*<span class="mi">3</span>+<span class="mi">1</span>
<span class="gp">&gt; </span>&#39;(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^n) <span class="kr">when</span> n = <span class="mi">12</span> <span class="kr">end</span><span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>
</pre></div>
</div>
<p>This may come as a surprise (or even annoyance) to real Lisp weenies, but it
does have its advantages. In particular, it makes it easy to fill in the
variable parts in a quoted &#8220;template&#8221; expression, without any need for an
arguably complex tool like Lisp&#8217;s &#8220;quasiquote&#8221;. (It is quite easy to define
quasiquote in Pure if you want it, however. See the <a class="reference internal" href="#recursive-macros">Recursive Macros</a>
section for a simplified version; a full implementation can be found in the
Pure library sources.)</p>
<p>As already mentioned, if you do need to quote a symbol which is already being
used as a local variable in the current context, you can do this by supplying
the symbol as a string to the prelude function <a class="reference internal" href="purelib.html#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>val <span class="s">&quot;x&quot;</span>+x <span class="kr">when</span> x = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
x+<span class="mi">99</span>
</pre></div>
</div>
<p>Second, it is in fact possible to perform arbitrary computations right in the
middle of a quoted expression. This is because <a class="reference internal" href="#quote" title="quote"><tt class="xref pure pure-func docutils literal"><span class="pre">quote</span></tt></a> only ever quotes
<a class="reference internal" href="#simple-expressions">simple expressions</a>, embedded <a class="reference internal" href="#special-expressions">special expressions</a> (conditionals, lambda
and the <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> constructs) are
evaluated as usual. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>&#39;(x+<span class="mi">1</span> <span class="kr">when</span> x = &#39;(<span class="mi">2</span>*<span class="mi">3</span>) <span class="kr">end</span>)<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">3</span>+<span class="mi">1</span>
<span class="gp">&gt; </span>&#39;(<span class="mi">2</span>*<span class="mi">42</span>+(<span class="mi">2</span>^n <span class="kr">when</span> n = <span class="mi">2</span>*<span class="mi">6</span> <span class="kr">end</span>))<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mf">4096.0</span>
</pre></div>
</div>
<p>The downside of this is that there is no way to quote special expressions.
Macro expansion <em>is</em> inhibited in quoted expressions, however, so it is
possible to work around this limitation by defining a custom special form (see
<a class="reference internal" href="#macros">Macros</a>) to be used as a symbolic representation for, say, a lambda
expression, which reduces to a real lambda when evaluated. To these ends, the
<a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> function can be invoked with a string argument as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">def</span> lambda x y = eval $ <span class="s">&quot;</span><span class="se">\\</span><span class="s"> &quot;</span>+str (&#39;x)+<span class="s">&quot; -&gt; &quot;</span>+str (&#39;y)<span class="p">;</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> l = &#39;lambda x (x+<span class="mi">1</span>)<span class="p">;</span> l<span class="p">;</span>
lambda x (x+<span class="mi">1</span>)
<span class="gp">&gt; </span><span class="kr">let</span> f = eval l<span class="p">;</span> f<span class="p">;</span> f <span class="mi">9</span><span class="p">;</span>
<span class="kt">#&lt;closure 0x7fdc3ca45be8&gt;</span>
<span class="mi">10</span>
</pre></div>
</div>
<p>Other special constructs, such as <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and
<a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> can be handled in a similar fashion.</p>
<p>Another useful feature of Lisp&#8217;s quasiquote is the capability to splice
arguments into a function application. It is possible to achieve pretty much
the same in Pure with the following variation of the <a class="reference internal" href="purelib.html#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> operator which
&#8220;curries&#8221; its second (tuple) operand:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">infixr</span> <span class="mi">0</span> $<span class="p">@</span> <span class="p">;</span>
f $<span class="p">@</span> ()     = f<span class="p">;</span>
f $<span class="p">@</span> (x,xs) = f x $<span class="p">@</span> xs<span class="p">;</span>
f $<span class="p">@</span> x      = f x<span class="p">;</span>
</pre></div>
</div>
<p>Now you can write, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>&#39;(foo <span class="mi">1</span> <span class="mi">2</span>) $<span class="p">@</span> &#39;(<span class="mi">2</span>/<span class="mi">3</span>,<span class="mi">3</span>/<span class="mi">4</span>)<span class="p">;</span>
foo <span class="mi">1</span> <span class="mi">2</span> (<span class="mi">2</span>/<span class="mi">3</span>) (<span class="mi">3</span>/<span class="mi">4</span>)
</pre></div>
</div>
</div>
</div>
<div class="section" id="declarations">
<h2><a class="toc-backref" href="#id49">Declarations</a><a class="headerlink" href="#declarations" title="Permalink to this headline">¶</a></h2>
<p>Pure is a very terse language by design. Usually you don&#8217;t declare much stuff,
you just define it and be done with it. However, there are a few constructs
which let you declare symbols with special attributes and manage programs
consisting of several source modules:</p>
<ul class="simple">
<li>symbol declarations determine &#8220;scope&#8221; and &#8220;fixity&#8221; of a symbol;</li>
<li><a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations specify external C functions (described in
the <a class="reference internal" href="#c-interface">C Interface</a> section);</li>
<li><a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clauses let you include other scripts in a Pure script;</li>
<li><a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declarations let you avoid name clashes and thereby
make it easier to manage large programs consisting of many separate modules.</li>
</ul>
<p>These are toplevel elements (cf. <a class="reference internal" href="#toplevel">Toplevel</a>):</p>
<pre>
<strong id="id8">item</strong> ::=  <a class="reference internal" href="#grammar-token-symbol_decl"><tt class="xref docutils literal"><span class="pre">symbol_decl</span></tt></a> | <a class="reference internal" href="#grammar-token-extern_decl"><tt class="xref docutils literal"><span class="pre">extern_decl</span></tt></a> | <a class="reference internal" href="#grammar-token-using_decl"><tt class="xref docutils literal"><span class="pre">using_decl</span></tt></a> | <a class="reference internal" href="#grammar-token-namespace_decl"><tt class="xref docutils literal"><span class="pre">namespace_decl</span></tt></a>
</pre>
<p>The syntax of each of these is described in the following subsections, except
<a class="reference internal" href="#grammar-token-extern_decl"><tt class="xref std std-token docutils literal"><span class="pre">extern_decl</span></tt></a> which can be found in the <a class="reference internal" href="#c-interface">C Interface</a> section.</p>
<div class="section" id="symbol-declarations">
<span id="nonfix"></span><span id="outfix"></span><span id="postfix"></span><span id="prefix"></span><span id="infixr"></span><span id="infixl"></span><span id="infix"></span><span id="private"></span><span id="public"></span><h3><a class="toc-backref" href="#id50">Symbol Declarations</a><a class="headerlink" href="#symbol-declarations" title="Permalink to this headline">¶</a></h3>
<pre>
<strong id="grammar-token-symbol_decl">symbol_decl</strong> ::=  <a class="reference internal" href="#grammar-token-scope"><tt class="xref docutils literal"><span class="pre">scope</span></tt></a> <a class="reference internal" href="#grammar-token-symbol"><tt class="xref docutils literal"><span class="pre">symbol</span></tt></a>+ &quot;;&quot;
                 | [<a class="reference internal" href="#grammar-token-scope"><tt class="xref docutils literal"><span class="pre">scope</span></tt></a>] <a class="reference internal" href="#grammar-token-fixity"><tt class="xref docutils literal"><span class="pre">fixity</span></tt></a> <a class="reference internal" href="#grammar-token-symbol"><tt class="xref docutils literal"><span class="pre">symbol</span></tt></a>+ &quot;;&quot;
<strong id="grammar-token-scope">scope      </strong> ::=  &quot;public&quot; | &quot;private&quot;
<strong id="grammar-token-fixity">fixity     </strong> ::=  &quot;nonfix&quot; | &quot;outfix&quot;
                 | (&quot;infix&quot;|&quot;infixl&quot;|&quot;infixr&quot;|&quot;prefix&quot;|&quot;postfix&quot;) <a class="reference internal" href="#grammar-token-precedence"><tt class="xref docutils literal"><span class="pre">precedence</span></tt></a>
<strong id="grammar-token-precedence">precedence </strong> ::=  <a class="reference internal" href="#grammar-token-integer"><tt class="xref docutils literal"><span class="pre">integer</span></tt></a> | &quot;(&quot; <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> &quot;)&quot;
</pre>
<p>Scope declarations take the following form:</p>
<dl class="describe">
<dt>
<tt class="descname">public symbol ...;</tt></dt>
<dt>
<tt class="descname">private symbol ...;</tt></dt>
<dd></dd></dl>

<p>This declares the listed symbols as public or private, respectively. Each
symbol must either be an identifier or a sequence of punctuation
characters. The latter kind of symbols <em>must</em> always be declared before use,
whereas ordinary identifiers can be used without a prior declaration in which
case they are declared implicitly and default to public scope, meaning that
they are visible everywhere in a program. An explicit public declaration of
ordinary identifiers is thus rarely needed (unless you want to declare symbols
as members of a specific namespace, see <a class="reference internal" href="#namespaces">Namespaces</a> below). Symbols can also
be declared private, meaning that the symbol is visible only in the namespace
it belongs to. This is explained in more detail under <a class="reference internal" href="#private-symbols">Private Symbols</a> in
the <a class="reference internal" href="#namespaces">Namespaces</a> section below.</p>
<p>Note that to declare several symbols in a single declaration, you can list
them all with whitespace in between. The same syntax applies to the other
types of symbol declarations discussed below. (Commas are <em>not</em> allowed as
delimiters here, as they may occur as legal symbol constituents in the list of
symbols.) The <a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a> and <a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> keywords can also be
used as a prefix in any of the special symbol declarations discussed below, to
specify the scope of the declared symbols (if the scope prefix is omitted, it
defaults to <a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a>).</p>
<p>The following &#8220;fixity&#8221; declarations are available for introducing special
operator and constant symbols. This changes the way that these symbols are
parsed and thus provides you with a limited means to extend the Pure language
at the lexical and syntactical level.</p>
<dl class="describe">
<dt>
<tt class="descname">infix level symbol ...;</tt></dt>
<dt>
<tt class="descname">infixl level symbol ...;</tt></dt>
<dt>
<tt class="descname">infixr level symbol ...;</tt></dt>
<dt>
<tt class="descname">prefix level symbol ...;</tt></dt>
<dt>
<tt class="descname">postfix level symbol ...;</tt></dt>
<dd></dd></dl>

<p>Pure provides you with a theoretically unlimited number of different
precedence levels for user-defined infix, prefix and postfix operators.
Precedence levels are numbered starting at 0; larger numbers indicate higher
precedence. (For practical reasons, the current implementation does require
that precedence numbers can be encoded as 24 bit unsigned machine integers,
giving you a range from 0 to 16777215, but this should be large enough to
incur no real limitations on applications. Also, the operator declarations in
the prelude have been set up to leave enough &#8220;space&#8221; between the &#8220;standard&#8221;
levels so that you can easily sneak in new operator symbols at low, high or
intermediate precedences.)</p>
<p>On each precedence level, you can declare (in order of increasing precedence)
<a class="reference internal" href="#infix"><tt class="xref std std-keyword docutils literal"><span class="pre">infix</span></tt></a> (binary non-associative), <a class="reference internal" href="#infixl"><tt class="xref std std-keyword docutils literal"><span class="pre">infixl</span></tt></a> (binary
left-associative), <a class="reference internal" href="#infixr"><tt class="xref std std-keyword docutils literal"><span class="pre">infixr</span></tt></a> (binary right-associative),
<a class="reference internal" href="#prefix"><tt class="xref std std-keyword docutils literal"><span class="pre">prefix</span></tt></a> (unary prefix) and <a class="reference internal" href="#postfix"><tt class="xref std std-keyword docutils literal"><span class="pre">postfix</span></tt></a> (unary postfix)
operators. For instance, here is a typical excerpt from the prelude (the full
table can be found in the <a class="reference internal" href="purelib.html#prelude"><em>Prelude</em></a> section of the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">infix</span>  <span class="mi">1800</span> &lt; &gt; &lt;= &gt;= == ~= <span class="p">;</span>
<span class="kr">infixl</span> <span class="mi">2200</span> + - <span class="p">;</span>
<span class="kr">infixl</span> <span class="mi">2300</span> * / div mod <span class="p">;</span>
<span class="kr">infixr</span> <span class="mi">2500</span> ^ <span class="p">;</span>
<span class="kr">prefix</span> <span class="mi">2600</span> # <span class="p">;</span>
</pre></div>
</div>
<p>Instead of denoting the precedence by an explicit integer value, you can also
specify an existing operator symbol enclosed in parentheses. Thus the
following declaration gives the <tt class="docutils literal"><span class="pre">++</span></tt> operator the same precedence as <tt class="docutils literal"><span class="pre">+</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">infixl</span> (+) ++ <span class="p">;</span>
</pre></div>
</div>
<p>The given symbol may be of a different fixity than the declaration, but it
must have a proper precedence level (i.e., it must be an infix, prefix or
postfix symbol). E.g., the following declaration gives <tt class="docutils literal"><span class="pre">^^</span></tt> the same
precedence level as the infix <tt class="docutils literal"><span class="pre">^</span></tt> symbol, but turns it into a postfix
operator:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">postfix</span> (^) ^^ <span class="p">;</span>
</pre></div>
</div>
<p>Pure also provides unary outfix operators, which work like in Wm Leler&#8217;s
constraint programming language <a class="reference internal" href="#bertrand">Bertrand</a>. These can be declared as follows:</p>
<dl class="describe">
<dt>
<tt class="descname">outfix left right ...;</tt></dt>
<dd></dd></dl>

<p>Outfix operators let you define your own bracket structures. The operators
must be given as pairs of matching left and right symbols (which must be
distinct). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">outfix</span> |: :| BEGIN END<span class="p">;</span>
</pre></div>
</div>
<p>After this declaration you can write bracketed expressions like <tt class="docutils literal"><span class="pre">|:x:|</span></tt> or
<tt class="docutils literal"><span class="pre">BEGIN</span> <span class="pre">foo,</span> <span class="pre">bar</span> <span class="pre">END</span></tt>. These are always at the highest precedence level
(i.e., syntactically they work like parenthesized expressions). Just like
other operators, you can turn outfix symbols into ordinary functions by
enclosing them in parentheses, but you have to specify the symbols in matching
pairs, such as <tt class="docutils literal"><span class="pre">(BEGIN</span> <span class="pre">END)</span></tt>.</p>
<p>Pure also has a notation for &#8220;nullary&#8221; operators, i.e., &#8220;operators without
operands&#8221;, which are used to denote special constants. These are introduced
using a <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> declaration:</p>
<dl class="describe">
<dt>
<tt class="descname">nonfix symbol ...;</tt></dt>
<dd></dd></dl>

<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">nonfix</span> red green blue<span class="p">;</span>
</pre></div>
</div>
<p>Syntactically, these work just like ordinary identifiers, so they may stand
whereever an identifier is allowed (no parentheses are required to &#8220;escape&#8221;
them). The difference to ordinary identifiers is that nonfix symbols are
always interpreted as literals, even if they occur in a variable position on
the left-hand side of a rule. So, with the above declaration, you can write
something like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo x = <span class="kr">case</span> x <span class="kr">of</span> red = green<span class="p">;</span> green = blue<span class="p">;</span> blue = red <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>map foo [red,green,blue]<span class="p">;</span>
[green,blue,red]
</pre></div>
</div>
<p>Thus nonfix symbols are pretty much like nullary constructor symbols in
languages like Haskell. Non-fixity is just a syntactic attribute,
however. Pure doesn&#8217;t enforce that such values are really &#8220;constant&#8221;, so you
can still write a &#8220;constructor equation&#8221; like the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>red = blue<span class="p">;</span>
<span class="gp">&gt; </span>map foo [red,green,blue]<span class="p">;</span>
[blue,blue,blue]
</pre></div>
</div>
<p>Examples for all types of symbol declarations can be found in the
<a class="reference internal" href="purelib.html#prelude"><em>prelude</em></a> which declares a bunch of standard (arithmetic,
relational, logical) operator symbols as well as the list and pair
constructors &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; and &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216;, and a few nonfix symbols (mostly for
denoting different kinds of exceptions).</p>
<p>One final thing worth noting here is that unary minus plays a special role in
the syntax. Like in Haskell and following mathematical tradition, unary minus
is the only prefix operator symbol which is also used as an infix operator,
and is always on the same precedence level as binary minus, whose precedence
may be chosen freely in the prelude. (The minus operator is the only symbol
which gets that special treatment; all other operators must have distinct
lexical representations.) Thus, with the standard prelude, <tt class="docutils literal"><span class="pre">-x+y</span></tt> will be
parsed as <tt class="docutils literal"><span class="pre">(-x)+y</span></tt>, whereas <tt class="docutils literal"><span class="pre">-x*y</span></tt> is the same as <tt class="docutils literal"><span class="pre">-(x*y)</span></tt>. Also note
that the notation <tt class="docutils literal"><span class="pre">(-)</span></tt> always denotes the binary minus operator; the unary
minus operation can be denoted using the built-in <tt class="docutils literal"><span class="pre">neg</span></tt> function.</p>
</div>
<div class="section" id="modules-and-imports">
<span id="using"></span><h3><a class="toc-backref" href="#id51">Modules and Imports</a><a class="headerlink" href="#modules-and-imports" title="Permalink to this headline">¶</a></h3>
<pre>
<strong id="grammar-token-using_decl">using_decl</strong> ::=  &quot;using&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>)* &quot;;&quot;
<strong id="grammar-token-name">name      </strong> ::=  <a class="reference internal" href="#grammar-token-qualified_identifier"><tt class="xref docutils literal"><span class="pre">qualified_identifier</span></tt></a> | <a class="reference internal" href="#grammar-token-string"><tt class="xref docutils literal"><span class="pre">string</span></tt></a>
</pre>
<p>While Pure doesn&#8217;t offer separate compilation, the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a>
declaration provides a simple but effective way to assemble a Pure program
from several source modules. It takes the following form (note that in
contrast to symbol declarations, the comma is used as a delimiter symbol
here):</p>
<dl class="describe">
<dt>
<tt class="descname">using name, ...;</tt></dt>
<dd></dd></dl>

<p>This causes each given script to be included in the Pure program at the given
point (if it wasn&#8217;t already included before), which makes available all the
definitions of the included script in your program. Note that each included
script is loaded only <em>once</em>, when the first <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause for the
script is encountered. Nested imports are allowed, i.e., an imported module
may itself import other modules, etc. A Pure program then basically is the
concatenation of all the source modules given as command line arguments, with
other modules listed in <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clauses inserted at the corresponding
source locations.</p>
<p>(The <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause also has an alternative form which allows dynamic
libraries and LLVM bitcode modules to be loaded, this will be discussed in the
<a class="reference internal" href="#c-interface">C Interface</a> section.)</p>
<p>For instance, the following declaration causes the math.pure script from the
standard library to be included in your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> math<span class="p">;</span>
</pre></div>
</div>
<p>You can also import multiple scripts in one go:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> array, dict, set<span class="p">;</span>
</pre></div>
</div>
<p>Moreover, Pure provides a notation for qualified module names which can be
used to denote scripts located in specific package directories, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> examples<span class="p">::</span>libor<span class="p">::</span>bits<span class="p">;</span>
</pre></div>
</div>
<p>In fact this is equivalent to the following <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause which
spells out the real filename of the script between double quotes (the
<tt class="docutils literal"><span class="pre">.pure</span></tt> suffix can also be omitted in which case it is added
automatically):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="s">&quot;examples/libor/bits.pure&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Both notations can be used interchangeably; the former is usually more
convenient, but the latter allows you to denote scripts whose names aren&#8217;t
valid Pure identifiers.</p>
<p>Script identifiers are translated to the corresponding filenames by replacing
the &#8216;<tt class="docutils literal"><span class="pre">::</span></tt>&#8216; symbol with the pathname separator &#8216;<tt class="docutils literal"><span class="pre">/</span></tt>&#8216; and tacking on the
&#8216;<tt class="docutils literal"><span class="pre">.pure</span></tt>&#8216; suffix. The following table illustrates this with a few examples.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Script identifier</th>
<th class="head">Filename</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">math</span></tt></td>
<td><tt class="docutils literal"><span class="pre">&quot;math.pure&quot;</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">examples::libor::bits</span></tt></td>
<td><tt class="docutils literal"><span class="pre">&quot;examples/libor/bits.pure&quot;</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">::pure::examples::hello</span></tt></td>
<td><tt class="docutils literal"><span class="pre">&quot;/pure/examples/hello.pure&quot;</span></tt></td>
</tr>
</tbody>
</table>
<p>Note the last example, which shows how an absolute pathname can be denoted
using a qualifier starting with &#8216;<tt class="docutils literal"><span class="pre">::</span></tt>&#8216;.</p>
<p>Unless an absolute pathname is given, the interpreter performs a search to
locate the script. The search algorithm considers the following directories in
the given order:</p>
<ul class="simple">
<li>the directory of the current script, which is the directory of the script
containing the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause, or the current working directory if
the clause was read from standard input (as is the case, e.g., in an
interactive session);</li>
<li>the directories named in <a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a> options on the command line (in the
given order);</li>
<li>the colon-separated list of directories in the <span class="target" id="index-7"></span><a class="reference internal" href="#envvar-PURE_INCLUDE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_INCLUDE</span></tt></a>
environment variable (in the given order);</li>
<li>finally the directory named by the <span class="target" id="index-8"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a> environment variable.</li>
</ul>
<p>Note that the current working directory is not searched by default (unless the
<a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause is read from standard input), but of course you can
force this by adding the option <a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a>. to the command line, or by
including &#8216;.&#8217; in the <span class="target" id="index-9"></span><a class="reference internal" href="#envvar-PURE_INCLUDE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_INCLUDE</span></tt></a> variable.</p>
<p>The directory of the current script (the first item above) can be skipped by
specifying the script to be loaded as a filename in double quotes, prefixed
with the special <tt class="docutils literal"><span class="pre">sys:</span></tt> tag. The search then starts with the &#8220;system&#8221;
directories (<a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a>, <span class="target" id="index-10"></span><a class="reference internal" href="#envvar-PURE_INCLUDE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_INCLUDE</span></tt></a> and <span class="target" id="index-11"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a>)
instead. This is useful, e.g., if you want to provide your own custom version
of a standard library script which in turn imports that library script. For
instance, a custom version of math.pure might employ the following
<a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause to load the math.pure script from the Pure library:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="s">&quot;sys:math&quot;</span><span class="p">;</span>
<span class="c1">// custom definitions go here</span>
log2 x = ln x/ln <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>The interpreter compares script names (to determine whether two scripts are
actually the same) by using the <em>canonicalized</em> full pathname of the script,
following symbolic links to the destination file (albeit only one level). Thus
different scripts with the same basename, such as foo/utils.pure and
bar/utils.pure can both be included in the same program (unless they link to
the same file).</p>
<p>More precisely, canonicalizing a pathname involves the following steps:</p>
<ul class="simple">
<li>relative pathnames are expanded to absolute ones, using the search rules
discussed above;</li>
<li>the directory part of the pathname is normalized to the form returned by the
<tt class="docutils literal"><span class="pre">getcwd</span></tt> system call;</li>
<li>the &#8221;.pure&#8221; suffix is added if needed;</li>
<li>if the resulting script name is actually a symbolic link, the interpreter
follows that link to its destination, albeit only one level. (This is only
done on Unix-like systems.)</li>
</ul>
<p>The directory of the canonicalized pathname is also used when searching other
scripts included in a script. This makes it possible to have an executable
script with a shebang line in its own directory, which is then executed via a
symbolic link placed on the system <span class="target" id="index-12"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt>. In this case the script
search performed in <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clauses will use the real script
directory and thus other required scripts can be located there. This is the
recommended practice for installing standalone Pure applications in source
form which are to be run directly from the shell.</p>
</div>
<div class="section" id="namespaces">
<span id="namespace"></span><h3><a class="toc-backref" href="#id52">Namespaces</a><a class="headerlink" href="#namespaces" title="Permalink to this headline">¶</a></h3>
<pre>
<strong id="grammar-token-namespace_decl">namespace_decl</strong> ::=  &quot;namespace&quot; [<a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>] &quot;;&quot;
                    | &quot;namespace&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a> &quot;with&quot; <a class="reference internal" href="#grammar-token-item"><tt class="xref docutils literal"><span class="pre">item</span></tt></a>+ &quot;end&quot; &quot;;&quot;
                    | &quot;using&quot; &quot;namespace&quot; [<a class="reference internal" href="#grammar-token-name_spec"><tt class="xref docutils literal"><span class="pre">name_spec</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-name_spec"><tt class="xref docutils literal"><span class="pre">name_spec</span></tt></a>)*] &quot;;&quot;
<strong id="grammar-token-name_spec">name_spec     </strong> ::=  <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a> [&quot;(&quot; <a class="reference internal" href="#grammar-token-symbol"><tt class="xref docutils literal"><span class="pre">symbol</span></tt></a>+ &quot;)&quot;]
</pre>
<p>To facilitate modular development, Pure also provides namespaces as a means to
avoid name clashes between symbols, and to keep the global namespace tidy and
clean. Namespaces serve as containers holding groups of related identifiers
and other symbols. Inside each namespace, symbols must be unique, but the same
symbol may be used to denote different objects (variables, functions, etc.) in
different namespaces. (Pure&#8217;s namespace system was heavily inspired by C++ and
works in a very similar fashion. So if you know C++ you should feel right at
home and skimming this section to pick up Pure&#8217;s syntax of the namespace
constructs should be enough to start using it.)</p>
<p>The global namespace is always available. By default, new symbols are created
in this namespace, which is also called the <strong class="dfn">default namespace</strong>. Additional
namespaces can be created with the <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration, which
also switches to the given namespace (makes it the <em>current</em> namespace), so
that new symbols are then created in that namespace rather than the default
one. The current namespace also applies to all kinds of symbol declarations,
including operator and constant symbol declarations, as well as
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations (the latter are described in the <a class="reference internal" href="#c-interface">C Interface</a>
section).</p>
<p>The basic form of the <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration has the following
syntax (there&#8217;s also a &#8220;scoped&#8221; form of the <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration
which will be discussed in <a class="reference internal" href="#scoped-namespaces">Scoped Namespaces</a> at the end of this section):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> name<span class="p">;</span>
<span class="c1">// declarations and definitions in namespace &#39;name&#39;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>The second form switches back to the default namespace. For instance, in order
to define two symbols with the same print name <tt class="docutils literal"><span class="pre">foo</span></tt> in two different
namespaces <tt class="docutils literal"><span class="pre">foo</span></tt> and <tt class="docutils literal"><span class="pre">bar</span></tt>, you can write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> foo<span class="p">;</span>
foo x = x+<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span> bar<span class="p">;</span>
foo x = x-<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>We can now refer to the symbols we just defined using <strong class="dfn">qualified symbols</strong> of
the form <tt class="docutils literal"><span class="pre">namespace::symbol</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span>bar<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">98</span>
</pre></div>
</div>
<p>This avoids any potential name clashes, since the qualified identifier
notation always makes it clear which namespace the given identifier belongs
to.</p>
<p>A namespace can be &#8220;reopened&#8221; at any time to add new symbols and definitions
to it. This allows namespaces to be created that span several source
modules. You can also create several different namespaces in the same module.</p>
<p>Similar to the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> declaration, a <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a>
declaration accepts either identifiers or double-quoted strings as namespace
names. E.g., the following two declarations are equivalent:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> foo<span class="p">;</span>
<span class="kr">namespace</span> <span class="s">&quot;foo&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>The latter form also allows more descriptive labels which aren&#8217;t identifiers,
e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> <span class="s">&quot;Private stuff, keep out!&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the namespace prefix in a qualified identifier must be a legal
identifier, so it isn&#8217;t possible to access symbols in namespaces with such
descriptive labels in a direct fashion. The only way to get at the symbols in
this case is to use a <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> or <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a>
declaration (for the latter see <a class="reference internal" href="#using-namespaces">Using Namespaces</a> below).</p>
<div class="section" id="using-namespaces">
<span id="using-namespace"></span><h4><a class="toc-backref" href="#id53">Using Namespaces</a><a class="headerlink" href="#using-namespaces" title="Permalink to this headline">¶</a></h4>
<p>Since it is rather inconvenient if you always have to write identifiers in
their qualified form outside of their &#8220;home&#8221; namespace, Pure allows you to
specify a list of <em>search</em> namespaces which are used to look up symbols not in
the default or the current namespace. This is done with the <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span>
<span class="pre">namespace</span></tt></a> declaration, which takes the following form:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="kr">namespace</span> name1, name2, ...<span class="p">;</span>
<span class="c1">// ...</span>
<span class="kr">using</span> <span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>(As with <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declarations, the second form without any
namespace arguments gets you back to the default empty list of search
namespaces.)</p>
<p>For instance, consider this example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> foo<span class="p">;</span>
foo x = x+<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span> bar<span class="p">;</span>
foo x = x-<span class="mi">1</span><span class="p">;</span>
bar x = x+<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>The symbols in these namespaces can be accessed unqualified as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> foo<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> bar<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">98</span>
<span class="gp">&gt; </span>bar <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
</pre></div>
</div>
<p>This method is often to be preferred over opening a namespace with the
<a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration, since <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> only gives
you &#8220;read access&#8221; to the imported symbols, so you can&#8217;t accidentally mess up
the definitions of the namespace you&#8217;re using. Another advantage is that the
<a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declaration also lets you search multiple
namespaces at once:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="kr">namespace</span> foo, bar<span class="p">;</span>
</pre></div>
</div>
<p>Be warned, however, that this brings up the very same issue of name clashes
again:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> foo, bar<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 15: </span>symbol &#39;foo&#39; is ambiguous here
</pre></div>
</div>
<p>In such a case you&#8217;ll have to resort to using namespace qualifiers again, in
order to resolve the name clash:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
</pre></div>
</div>
<p>To avoid this kind of mishap, you can also selectively import just a few
symbols from a namespace instead. This can be done with a declaration of the
following form:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="kr">namespace</span> name1 ( sym1 sym2 ... ), name2 ... <span class="p">;</span>
</pre></div>
</div>
<p>As indicated, the symbols to be imported can optionally be placed as a
whitespace-delimited list inside parentheses, following the corresponding
namespace name. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> foo, bar (bar)<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span>bar <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span>bar<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">98</span>
</pre></div>
</div>
<p>Note that now we have no clash on the <tt class="docutils literal"><span class="pre">foo</span></tt> symbol any more, because we
restricted the import from the <tt class="docutils literal"><span class="pre">bar</span></tt> namespace to the <tt class="docutils literal"><span class="pre">bar</span></tt> symbol, so
that <tt class="docutils literal"><span class="pre">bar::foo</span></tt> has to be denoted with a qualified symbol now.</p>
</div>
<div class="section" id="symbol-lookup-and-creation">
<h4><a class="toc-backref" href="#id54">Symbol Lookup and Creation</a><a class="headerlink" href="#symbol-lookup-and-creation" title="Permalink to this headline">¶</a></h4>
<p>Pure&#8217;s rules for looking up and creating symbols are fairly straightforward
and akin to those in other languages featuring namespaces. However, there are
some intricacies involved, because the rewriting rule format of definitions
allows &#8220;referential&#8221; use of symbols not only in the &#8220;body&#8221; (right-hand side)
of a definition, but also in the left-hand side patterns. We discuss this in
detail below.</p>
<p>The compiler searches for symbols first in the current namespace (if any),
then in the currently active search namespaces (if any), and finally in the
default (i.e., the global) namespace, in that order. This automatic lookup can
be bypassed by using an <em>absolute</em> namespace qualifier of the form
<tt class="docutils literal"><span class="pre">::foo::bar</span></tt>. In particular, <tt class="docutils literal"><span class="pre">::bar</span></tt> always denotes the symbol <tt class="docutils literal"><span class="pre">bar</span></tt> in
the default namespace, while <tt class="docutils literal"><span class="pre">::foo::bar</span></tt> denotes the symbol <tt class="docutils literal"><span class="pre">bar</span></tt> in the
<tt class="docutils literal"><span class="pre">foo</span></tt> namespace. (Normally, the latter kind of notation is only needed if
you have to deal with nested namespaces, see <a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a>
below.)</p>
<p>If no existing symbol is found, a new symbol is created automatically, by
implicitly declaring a public symbol with default attributes. New
<em>unqualified</em> symbols are always created in the current namespace, while new
<em>qualified</em> symbols are created in the namespace given by the namespace prefix
of the symbol. However, note that in the latter case the compiler always
checks that the given namespace prefix matches the current namespace:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> foo<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">namespace</span><span class="p">;</span>
<span class="gp">&gt; </span>foo<span class="p">::</span>bar x = <span class="mi">1</span>/x<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 3: </span>undeclared symbol &#39;foo::bar&#39;
</pre></div>
</div>
<p>Thus it&#8217;s only possible to introduce a new symbol in a given namespace if that
namespace is the current one. These error messages are somewhat annoying, but
they provide at least some protection against typos and other silly mistakes
and prevent you from accidentally clobbering the contents of other
namespaces. To make these errors go away it&#8217;s enough to just declare the
symbols in their proper namespaces.</p>
<p>New symbols are also created if a global unqualified (and yet undeclared)
symbol is being &#8220;defined&#8221; in a rewriting rule or
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>/<a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> definition, even if a symbol with the same
print name from another namespace is already visible in the current scope. To
distinguish &#8220;defining&#8221; from &#8220;referring&#8221; uses of a global symbol, Pure uses the
following (purely syntactic) notions:</p>
<ul class="simple">
<li>A <strong class="dfn">defining occurrence</strong> of a global <em>function</em>, <em>macro</em> or <em>type symbol</em> is
any occurrence of the symbol as the <em>head symbol</em> on the left-hand side of a
rewriting rule.</li>
<li>A <strong class="dfn">defining occurrence</strong> of a global <em>variable</em> or <em>constant symbol</em> is any
occurrence of the symbol in a <em>variable position</em> (as given by the &#8220;head =
function&#8221; rule, cf. <a class="reference internal" href="#variables-in-equations">Variables in Equations</a>) on the left-hand side of a
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> or <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> definition.</li>
<li>All other occurrences of global symbols on the left-hand side, as well as
<em>all</em> symbol occurrences on the right-hand side of a definition are
<strong class="dfn">referring occurrences</strong>.</li>
</ul>
<p>The following example illustrates these notions:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> foo<span class="p">;</span>
bar (bar x) = bar x<span class="p">;</span>
<span class="kr">let</span> x,y = <span class="mi">1</span>,<span class="mi">2</span><span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, the first occurrence of <tt class="docutils literal"><span class="pre">bar</span></tt> on the left-hand side <tt class="docutils literal"><span class="pre">bar</span> <span class="pre">(bar</span> <span class="pre">x)</span></tt> of
the first rule is a <em>defining</em> occurrence, as are the occurrences of <tt class="docutils literal"><span class="pre">x</span></tt> and
<tt class="docutils literal"><span class="pre">y</span></tt> on the left-hand side of the <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> definition. Hence these
symbols are created as new symbols in the namespace <tt class="docutils literal"><span class="pre">foo</span></tt>. On the other
hand, the other occurrences of <tt class="docutils literal"><span class="pre">bar</span></tt> in the first rule, as well as the &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216; symbol on the left-hand side of the <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> definition are
<em>referring</em> occurrences. In the former case, <tt class="docutils literal"><span class="pre">bar</span></tt> refers to the <tt class="docutils literal"><span class="pre">bar</span></tt>
symbol defined by the rule, while in the latter case the &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216; operator
is actually declared in the prelude and thus imported from the global
namespace.</p>
<p>As an additional safety measure against missing or mistyped symbols, the
interpreter provides the option <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> (see <a class="reference internal" href="#invoking-pure">Invoking Pure</a>) to check
your scripts for non-defining uses of undeclared unqualified function
symbols. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre>$ pure -w
<span class="gp">&gt; </span>puts <span class="s">&quot;bla&quot;</span><span class="p">;</span> <span class="c1">// missing import of system module</span>
<span class="gr">&lt;stdin&gt;, line 1: </span>warning: implicit declaration of &#39;puts&#39;
puts <span class="s">&quot;bla&quot;</span>
</pre></div>
</div>
<p>For legitimate uses (such as forward uses of a symbol which is defined later),
you can make these warnings go away by declaring the symbol before using it.</p>
<p>Note that special operator (and nonfix) symbols <em>always</em> require an explicit
declaration. This works as already discussed in the <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a>
section, except that you first switch to the appropriate namespace before
declaring the symbols. For instance, here is how you can create a new <tt class="docutils literal"><span class="pre">+</span></tt>
operation which multiplies its operands rather than adding them:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">infixl</span> <span class="mi">2200</span> +<span class="p">;</span>
<span class="gp">&gt; </span>x+y = x*y<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">5</span>+<span class="mi">7</span><span class="p">;</span>
<span class="mi">35</span>
</pre></div>
</div>
<p>Note that the new <tt class="docutils literal"><span class="pre">+</span></tt> operation really belongs to the namespace we
created. The <tt class="docutils literal"><span class="pre">+</span></tt> operation in the default namespace works as before, and in
fact you can use qualified symbols to pick the version that you need:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">5</span>+<span class="mi">7</span><span class="p">;</span>
<span class="mi">12</span>
<span class="gp">&gt; </span><span class="mi">5</span> <span class="p">::</span>+ <span class="mi">7</span><span class="p">;</span>
<span class="mi">12</span>
<span class="gp">&gt; </span><span class="mi">5</span> my<span class="p">::</span>+ <span class="mi">7</span><span class="p">;</span>
<span class="mi">35</span>
</pre></div>
</div>
<p>Here&#8217;s what you get if you happen to forget the declaration of the <tt class="docutils literal"><span class="pre">+</span></tt>
operator:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span>x+y = x*y<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 2: </span>infixl symbol &#39;+&#39; was not declared in this namespace
</pre></div>
</div>
<p>Thus the compiler will never create a new instance of an operator symbol on
the fly, an explicit declaration is always needed in such cases.</p>
<p>Note that if you <em>really</em> wanted to redefine the global <tt class="docutils literal"><span class="pre">+</span></tt> operator, you
can do this even while the <tt class="docutils literal"><span class="pre">my</span></tt> namespace is current. You just have to use a
qualified identifier in this case, as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span>x <span class="p">::</span>+ y = x*y<span class="p">;</span>
<span class="gp">&gt; </span>a+b<span class="p">;</span>
a*b
</pre></div>
</div>
<p>This should rarely be necessary (in the above example you might just as well
enter this rule while in the global namespace), but it can be useful in some
circumstances.  Specifically, you might want to &#8220;overload&#8221; a global function
or operator with a definition that makes use of private symbols of a namespace
(which are only visible inside that namespace; see <a class="reference internal" href="#private-symbols">Private Symbols</a>
below). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">private</span> bar<span class="p">;</span>
<span class="gp">&gt; </span>bar x y = x*y<span class="p">;</span>
<span class="gp">&gt; </span>x <span class="p">::</span>+ y = bar x y<span class="p">;</span>
<span class="gp">&gt; </span>a+b<span class="p">;</span>
a*b
</pre></div>
</div>
<p>(The above is a rather contrived example, since the very same functionality
can be accomplished much easier, but there are some situations where this
approach is necessary.)</p>
</div>
<div class="section" id="private-symbols">
<h4><a class="toc-backref" href="#id55">Private Symbols</a><a class="headerlink" href="#private-symbols" title="Permalink to this headline">¶</a></h4>
<p>Pure also allows you to have private symbols, as a means to hide away internal
operations which shouldn&#8217;t be accessed directly outside the namespace in which
they are declared. The scope of a private symbol is confined to its namespace,
i.e., the symbol is only visible when its &#8220;home&#8221; namespace is current. Symbols
are declared private by using the <a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> keyword in the symbol
declaration:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> secret<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">private</span> baz<span class="p">;</span>
<span class="gp">&gt; </span><span class="c1">// &#39;baz&#39; is a private symbol in namespace &#39;secret&#39; here</span>
<span class="gp">&gt; </span>baz x = <span class="mi">2</span>*x<span class="p">;</span>
<span class="gp">&gt; </span><span class="c1">// you can use &#39;baz&#39; just like any other symbol here</span>
<span class="gp">&gt; </span>baz <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
<span class="gp">&gt; </span><span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that, at this point, <tt class="docutils literal"><span class="pre">secret::baz</span></tt> is now invisible, even if you have
<tt class="docutils literal"><span class="pre">secret</span></tt> in the search namespace list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> secret<span class="p">;</span>
<span class="gp">&gt; </span><span class="c1">// this actually creates a &#39;baz&#39; symbol in the default namespace:</span>
<span class="gp">&gt; </span>baz <span class="mi">99</span><span class="p">;</span>
baz <span class="mi">99</span>
<span class="gp">&gt; </span>secret<span class="p">::</span>baz <span class="mi">99</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 27: </span>symbol &#39;secret::baz&#39; is private here
</pre></div>
</div>
<p>The only way to bring the symbol back into scope is to make the <tt class="docutils literal"><span class="pre">secret</span></tt>
namespace current again:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> secret<span class="p">;</span>
<span class="gp">&gt; </span>baz <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
<span class="gp">&gt; </span>secret<span class="p">::</span>baz <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
</pre></div>
</div>
</div>
<div class="section" id="hierarchical-namespaces">
<h4><a class="toc-backref" href="#id56">Hierarchical Namespaces</a><a class="headerlink" href="#hierarchical-namespaces" title="Permalink to this headline">¶</a></h4>
<p>Namespace identifiers can themselves be qualified identifiers in Pure, which
enables you to introduce a hierarchy of namespaces. This is useful, e.g., to
group related namespaces together under a common &#8220;umbrella&#8221; namespace:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> my<span class="p">;</span>
<span class="kr">namespace</span> my<span class="p">::</span>old<span class="p">;</span>
foo x = x+<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span> my<span class="p">::</span>new<span class="p">;</span>
foo x = x-<span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the namespace <tt class="docutils literal"><span class="pre">my</span></tt>, which serves as the parent namespace, must be
created before the <tt class="docutils literal"><span class="pre">my::old</span></tt> and <tt class="docutils literal"><span class="pre">my::new</span></tt> namespaces, even if it does not
contain any symbols of its own. After these declarations, the <tt class="docutils literal"><span class="pre">my::old</span></tt> and
<tt class="docutils literal"><span class="pre">my::new</span></tt> namespaces are part of the <tt class="docutils literal"><span class="pre">my</span></tt> namespace and will be considered
in name lookup accordingly, so that you can write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span>old<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span>new<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">98</span>
</pre></div>
</div>
<p>This works pretty much like a hierarchy of directories and files, where the
namespaces play the role of the directories (with the default namespace as the
root directory), the symbols in each namespace correspond to the files in a
directory, and the <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declaration functions similar to
the shell&#8217;s <span class="target" id="index-13"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt> variable.</p>
<p>Sometimes it is necessary to tell the compiler to use a symbol in a specific
namespace, bypassing the usual symbol lookup mechanism. For instance, suppose
that we introduce another <em>global</em> <tt class="docutils literal"><span class="pre">old</span></tt> namespace and define yet another
version of <tt class="docutils literal"><span class="pre">foo</span></tt> in that namespace:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> old<span class="p">;</span>
foo x = <span class="mi">2</span>*x<span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>Now, if we want to access that function, with <tt class="docutils literal"><span class="pre">my</span></tt> still active as the
search namespace, we cannot simply refer to the new function as <tt class="docutils literal"><span class="pre">old::foo</span></tt>,
since this name will resolve to <tt class="docutils literal"><span class="pre">my::old::foo</span></tt> instead. As a remedy, the
compiler accepts an <strong class="dfn">absolute</strong> qualified identifier of the form
<tt class="docutils literal"><span class="pre">::old::foo</span></tt>. This bypasses name lookup and thus always yields exactly the
symbol in the given namespace (if it exists; as mentioned previously, the
compiler will complain about an undeclared symbol otherwise):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>old<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span><span class="p">::</span>old<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
</pre></div>
</div>
<p>Also note that, as a special case of the absolute qualifier notation,
<tt class="docutils literal"><span class="pre">::foo</span></tt> always denotes the symbol <tt class="docutils literal"><span class="pre">foo</span></tt> in the default namespace.</p>
</div>
<div class="section" id="scoped-namespaces">
<h4><a class="toc-backref" href="#id57">Scoped Namespaces</a><a class="headerlink" href="#scoped-namespaces" title="Permalink to this headline">¶</a></h4>
<p>Pure also provides an alternative scoped <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> construct which
makes nested namespace definitions more convenient. This construct takes the
following form:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> name <span class="kr">with</span> ... <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>The part between <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#end"><tt class="xref std std-keyword docutils literal"><span class="pre">end</span></tt></a> may contain arbitrary
declarations and definitions, using the same syntax as the toplevel. These are
processed in the context of the given namespace, as if you had written:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> name<span class="p">;</span>
...
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>However, the scoped namespace construct always returns you to the namespace
which was active before, and thus these declarations may be nested:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> foo <span class="kr">with</span>
  <span class="c1">// declarations and definitions in namespace foo</span>
  <span class="kr">namespace</span> bar <span class="kr">with</span>
    <span class="c1">// declarations and definitions in namespace bar</span>
  <span class="kr">end</span><span class="p">;</span>
  <span class="c1">// more declarations and definitions in namespace foo</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that this kind of nesting does not necessarily imply a namespace
hierarchy as discussed in <a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a>. However, you can achieve
this by using the appropriate qualified namespace names:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> foo <span class="kr">with</span>
  <span class="c1">// ...</span>
  <span class="kr">namespace</span> foo<span class="p">::</span>bar <span class="kr">with</span>
    <span class="c1">// ...</span>
  <span class="kr">end</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Another special feature of the scoped namespace construct is that
<a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declarations are always local to the current
namespace scope (and other nested namespace scopes inside it). Thus the
previous setting is restored at the end of each scope:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="kr">namespace</span> foo<span class="p">;</span>
<span class="kr">namespace</span> foo <span class="kr">with</span>
  <span class="c1">// still using namespace foo here</span>
  <span class="kr">using</span> <span class="kr">namespace</span> bar<span class="p">;</span>
  <span class="c1">// now using namespace bar</span>
  <span class="kr">namespace</span> bar <span class="kr">with</span>
    <span class="c1">// still using namespace bar here</span>
    <span class="kr">using</span> <span class="kr">namespace</span> foo<span class="p">;</span>
    <span class="c1">// now using namespace foo</span>
  <span class="kr">end</span><span class="p">;</span>
  <span class="c1">// back to using namespace bar</span>
<span class="kr">end</span><span class="p">;</span>
<span class="c1">// back to using namespace foo at toplevel</span>
</pre></div>
</div>
<p>Finally, here&#8217;s a more concrete example which shows how scoped namespaces
might be used to declare two namespaces and populate them with various
functions and operators:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> foo <span class="kr">with</span>
  <span class="kr">infixr</span> (<span class="p">::</span>^) ^<span class="p">;</span>
  foo x = x+<span class="mi">1</span><span class="p">;</span>
  bar x = x-<span class="mi">1</span><span class="p">;</span>
  x^y = <span class="mi">2</span>*x+y<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

<span class="kr">namespace</span> bar <span class="kr">with</span>
  <span class="kr">outfix</span> &lt;: :&gt;<span class="p">;</span>
  foo x = x+<span class="mi">2</span><span class="p">;</span>
  bar x = x-<span class="mi">2</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

<span class="kr">using</span> <span class="kr">namespace</span> foo(^ foo), bar(bar &lt;: :&gt;)<span class="p">;</span>

<span class="c1">// namespace foo</span>
foo x<span class="p">;</span>
x^y<span class="p">;</span>

<span class="c1">// namespace bar</span>
bar x<span class="p">;</span>
&lt;: x,y :&gt;<span class="p">;</span>
</pre></div>
</div>
<p>Pure&#8217;s namespaces can thus be used pretty much like &#8220;modules&#8221; or &#8220;packages&#8221; in
languages like Ada or Modula-2. They provide a structured way to describe
program components offering collections of related data and operations, which
can be brought into scope in a controlled way by making judicious use of
<a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declarations. They also provide an abstraction
barrier, since internal operations and data structures can be hidden away
employing private symbols.</p>
<p>Please note that these facilities are not Pure&#8217;s main focus and thus they are
somewhat limited compared to programming languages specifically designed for
big projects and large teams of developers. Nevertheless they should be useful
if your programs grow beyond a small collection of simple source modules, and
enable you to manage most Pure projects with ease.</p>
</div>
</div>
</div>
<div class="section" id="macros">
<h2><a class="toc-backref" href="#id58">Macros</a><a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h2>
<p>Macros are a special type of functions to be executed as a kind of
&#8220;preprocessing stage&#8221; at compile time. In Pure these are typically used to
define custom special forms and to perform inlining of function calls and
other simple kinds of source-level optimizations.</p>
<p>Whereas the macro facilities of most programming languages simply provide a
kind of textual substitution mechanism, Pure macros operate on symbolic
expressions and are implemented by the same kind of rewriting rules that are
also used to define ordinary functions in Pure. In contrast to these, macro
rules start out with the keyword <a class="reference internal" href="#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a>, and only simple kinds of
rules without any guards or multiple left-hand and right-hand sides are
permitted.</p>
<p>Syntactically, a macro definition looks just like a variable or constant
definition, using <a class="reference internal" href="#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a> in lieu of <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> or
<a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>, but they are processed in a different way. Macros are
substituted into the right-hand sides of function, constant and variable
definitions. All macro substitution happens before constant substitutions and
the actual compilation step. Macros can be defined in terms of other macros
(also recursively), and are evaluated using call by value (i.e., macro calls
in macro arguments are expanded before the macro gets applied to its
parameters).</p>
<p>Pure macros also have their limitations. Specifically, the left-hand side of a
macro rule must be a simple expression, just like in ordinary function
definitions. This restricts the kinds of expressions which can be rewritten by
a macro. But Pure macros are certainly powerful enough for most common
preprocessing purposes, while still being robust and easy to use.</p>
<div class="section" id="optimization-rules">
<span id="id9"></span><h3><a class="toc-backref" href="#id59">Optimization Rules</a><a class="headerlink" href="#optimization-rules" title="Permalink to this headline">¶</a></h3>
<p>Here is a simple example, showing a rule which expands saturated calls of the
<a class="reference internal" href="purelib.html#succ" title="succ"><tt class="xref pure pure-func docutils literal"><span class="pre">succ</span></tt></a> function (defined in the prelude) at compile time:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">def</span> succ x = x+<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>foo x<span class="p">::</span><span class="kt">int</span> = succ (succ x)<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x<span class="p">::</span><span class="kt">int</span> = x+<span class="mi">1</span>+<span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Rules like these can be useful to help the compiler generate better code. Note
that a macro may have the same name as an ordinary Pure function, which is
essential if you want to optimize calls to an existing function, as in the
previous example. (Just like ordinary functions, the number of parameters in
each rule for a given macro must be the same, but a macro may have a different
number of arguments than the corresponding function.)</p>
<p>A somewhat more practical example is the following rule from the prelude,
which eliminates saturated instances of the right-associative function
application operator:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">def</span> f $ x = f x<span class="p">;</span>
</pre></div>
</div>
<p>Like in Haskell, this low-priority operator is handy to write cascading
function calls. With the above macro rule, these will be &#8220;inlined&#8221; as ordinary
function applications automatically. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo x = bar $ bar $ <span class="mi">2</span>*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = bar (bar (<span class="mi">2</span>*x))<span class="p">;</span>
</pre></div>
</div>
<p>Here are two slightly more tricky rules from the prelude, which optimize the
case of &#8220;throwaway&#8221; list comprehensions. This is useful if a list
comprehension is evaluated solely for its side effects:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">def</span> <span class="kt">void</span> (catmap f x) = do f x<span class="p">;</span>
<span class="kr">def</span> <span class="kt">void</span> (listmap f x) = do f x<span class="p">;</span>
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="purelib.html#void" title="void"><tt class="xref pure pure-func docutils literal"><span class="pre">void</span></tt></a> function simply throws away its argument and
returns <a class="reference internal" href="purelib.html#()" title="()"><tt class="xref pure pure-cons docutils literal"><span class="pre">()</span></tt></a> instead. The <a class="reference internal" href="purelib.html#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a> function applies a function to
every member of a list (like <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>), but throws away all intermediate
results and just returns <a class="reference internal" href="purelib.html#()" title="()"><tt class="xref pure pure-cons docutils literal"><span class="pre">()</span></tt></a>, which is much more efficient if you don&#8217;t
need those results anyway. These are both defined in the prelude.</p>
<p>Before we delve into this example, a few remarks are in order about the way
list comprehensions are implemented in Pure. As already mentioned, list
comprehensions are just syntactic sugar; the compiler immediately transforms
them to an equivalent expression involving only lambdas and a few other list
operations. Note that list comprehensions are essentially equivalent to piles
of nested lambdas, filters and maps, but for various reasons they are actually
implemented using two special helper operations, <a class="reference internal" href="purelib.html#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a> and
<a class="reference internal" href="purelib.html#listmap" title="listmap"><tt class="xref pure pure-func docutils literal"><span class="pre">listmap</span></tt></a>.</p>
<p>The <a class="reference internal" href="purelib.html#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a> operation combines <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a> and <a class="reference internal" href="purelib.html#cat" title="cat"><tt class="xref pure pure-func docutils literal"><span class="pre">cat</span></tt></a>; this is
needed, in particular, to accumulate the results of nested generators, such as
<tt class="docutils literal"><span class="pre">[i,j</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1..n;</span> <span class="pre">j</span> <span class="pre">=</span> <span class="pre">1..m]</span></tt>. The same operation is also used to implement
filter clauses, you can see this below in the examples. However, for
efficiency simple generators like <tt class="docutils literal"><span class="pre">[2*i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1..n]</span></tt> are translated to a
<a class="reference internal" href="purelib.html#listmap" title="listmap"><tt class="xref pure pure-func docutils literal"><span class="pre">listmap</span></tt></a> instead (which is basically just <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, but works with
different aggregate types, so that list comprehensions can draw values from
aggregates other than lists, such as matrices).</p>
<p>Now let&#8217;s see how the rules above transform a list comprehension if we
&#8220;voidify&#8221; it:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>f = [printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>) | x=<span class="mi">1</span>..<span class="mi">5</span><span class="p">;</span> x mod <span class="mi">2</span>]<span class="p">;</span>
<span class="gp">&gt; </span>g = <span class="kt">void</span> [printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>) | x=<span class="mi">1</span>..<span class="mi">5</span><span class="p">;</span> x mod <span class="mi">2</span>]<span class="p">;</span>
<span class="gp">&gt; </span>show f g
f = catmap (\x -&gt; <span class="kr">if</span> x mod <span class="mi">2</span> <span class="kr">then</span> [printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>)] <span class="kr">else</span> []) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
g = do (\x -&gt; <span class="kr">if</span> x mod <span class="mi">2</span> <span class="kr">then</span> [printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>)] <span class="kr">else</span> []) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Ok, so the <a class="reference internal" href="purelib.html#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a> got replaced with a <a class="reference internal" href="purelib.html#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a> which is just what we
need to make this code go essentially as fast as a <tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt> loop in
conventional programming languages (up to constant factors, of course). Here&#8217;s
how it looks like when we run the <tt class="docutils literal"><span class="pre">g</span></tt> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>g<span class="p">;</span>
<span class="mi">3</span>
<span class="mi">9</span>
<span class="mi">33</span>
()
</pre></div>
</div>
<p>It&#8217;s not all roses, however, since the above macro rules will only get rid of
the outermost <a class="reference internal" href="purelib.html#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a> if the list comprehension binds multiple
variables:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>u = <span class="kt">void</span> [puts $ str (x,y) | x=<span class="mi">1</span>..<span class="mi">2</span><span class="p">;</span> y=<span class="mi">1</span>..<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span>show u
u = do (\x -&gt; listmap (\y -&gt; puts (str (x,y))) (<span class="mi">1</span>..<span class="mi">3</span>)) (<span class="mi">1</span>..<span class="mi">2</span>)<span class="p">;</span>
</pre></div>
</div>
<p>If you&#8217;re bothered by this, you&#8217;ll have to apply <a class="reference internal" href="purelib.html#void" title="void"><tt class="xref pure pure-func docutils literal"><span class="pre">void</span></tt></a> recursively,
creating a nested list comprehension which expands to a nested <a class="reference internal" href="purelib.html#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>v = <span class="kt">void</span> [<span class="kt">void</span> [puts $ str (x,y) | y=<span class="mi">1</span>..<span class="mi">3</span>] | x=<span class="mi">1</span>..<span class="mi">2</span>]<span class="p">;</span>
<span class="gp">&gt; </span>show v
v = do (\x -&gt; do (\y -&gt; puts (str (x,y))) (<span class="mi">1</span>..<span class="mi">3</span>)) (<span class="mi">1</span>..<span class="mi">2</span>)<span class="p">;</span>
</pre></div>
</div>
<p>(It would be nice to have this handled automatically, but the left-hand side
of a macro definition must be a simple expression, and thus it&#8217;s not possible
to write a macro which descends recursively into the lambda argument of
<a class="reference internal" href="purelib.html#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a>.)</p>
</div>
<div class="section" id="recursive-macros">
<h3><a class="toc-backref" href="#id60">Recursive Macros</a><a class="headerlink" href="#recursive-macros" title="Permalink to this headline">¶</a></h3>
<p>Macros can also be recursive, in which case they usually consist of multiple
rules and make use of pattern-matching like ordinary function definitions. As
a simple example, let&#8217;s implement a Pure version of Lisp&#8217;s quasiquote which
allows you to create a quoted expression from a &#8220;template&#8221; while substituting
variable parts of the template. (For the sake of brevity, our definition is
somewhat simplified and does not cover some corner cases. See the Pure
distribution for a full version of this example.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">def</span> quasiquote (unquote x)      = x<span class="p">;</span>
<span class="kr">def</span> quasiquote (f<span class="p">@</span>_ (splice x)) = foldl ($) (quasiquote f) x<span class="p">;</span>
<span class="kr">def</span> quasiquote (f<span class="p">@</span>_ x)          = quasiquote f (quasiquote x)<span class="p">;</span>
<span class="kr">def</span> quasiquote x                = quote x<span class="p">;</span>
</pre></div>
</div>
<p>(Note the <tt class="docutils literal"><span class="pre">f&#64;_</span></tt>, which is an anonymous &#8220;as&#8221; pattern forcing the compiler to
recognize <tt class="docutils literal"><span class="pre">f</span></tt> as a function variable, rather than a literal function
symbol. See <a class="reference internal" href="#head-function">Head = Function</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section for an
explanation of this trick.)</p>
<p>The first rule above takes care of &#8220;unquoting&#8221; embedded subterms. The second
rule &#8220;splices&#8221; an argument list into an enclosing function application. The
third rule recurses into subterms of a function application, and the fourth
and last rule takes care of quoting the &#8220;atomic&#8221; subterms. Note that
<tt class="docutils literal"><span class="pre">unquote</span></tt> and <tt class="docutils literal"><span class="pre">splice</span></tt> themselves are just passive constructor symbols,
the real work is done by <tt class="docutils literal"><span class="pre">quasiquote</span></tt>, using <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a> at runtime to
actually perform the splicing. (Putting off the splicing until runtime makes
it possible to splice argument lists computed at runtime.)</p>
<p>If we want, we can also add some syntactic sugar for Lisp weenies. (Note that
we cannot have &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216; for unquoting, so we use &#8216;<tt class="docutils literal"><span class="pre">,$</span></tt>&#8216; instead.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">prefix</span> <span class="mi">9</span> ` ,$ ,<span class="p">@</span> <span class="p">;</span>
<span class="kr">def</span> `x = quasiquote x<span class="p">;</span> <span class="kr">def</span> ,$x = unquote x<span class="p">;</span> <span class="kr">def</span> ,<span class="p">@</span>x = splice x<span class="p">;</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>`(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>)<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>
<span class="gp">&gt; </span>`(<span class="mi">2</span>*<span class="mi">42</span>+,$(<span class="mi">2</span>^<span class="mi">12</span>))<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mf">4096.0</span>
<span class="gp">&gt; </span>`foo <span class="mi">1</span> <span class="mi">2</span> (,<span class="p">@</span>&#39;[<span class="mi">2</span>/<span class="mi">3</span>,<span class="mi">3</span>/<span class="mi">4</span>]) (<span class="mi">5</span>/<span class="mi">6</span>)<span class="p">;</span>
foo <span class="mi">1</span> <span class="mi">2</span> (<span class="mi">2</span>/<span class="mi">3</span>) (<span class="mi">3</span>/<span class="mi">4</span>) (<span class="mi">5</span>/<span class="mi">6</span>)
<span class="gp">&gt; </span>`foo <span class="mi">1</span> <span class="mi">2</span> (,<span class="p">@</span>&#39;args) (<span class="mi">5</span>/<span class="mi">6</span>) <span class="kr">when</span> args = &#39;[<span class="mi">2</span>/<span class="mi">3</span>,<span class="mi">3</span>/<span class="mi">4</span>] <span class="kr">end</span><span class="p">;</span>
foo <span class="mi">1</span> <span class="mi">2</span> (<span class="mi">2</span>/<span class="mi">3</span>) (<span class="mi">3</span>/<span class="mi">4</span>) (<span class="mi">5</span>/<span class="mi">6</span>)
</pre></div>
</div>
<p>We mention in passing here that, technically, Pure macros are just as powerful
as (unconditional) term rewriting systems and thus they are
Turing-complete. This implies that a badly written macro may well send the
Pure compiler into an infinite recursion, which results in a stack overflow at
compile time. See <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a>
section for information on how to deal with these by setting the
<span class="target" id="index-14"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a> environment variable.</p>
</div>
<div class="section" id="user-defined-special-forms">
<h3><a class="toc-backref" href="#id61">User-Defined Special Forms</a><a class="headerlink" href="#user-defined-special-forms" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">quasiquote</span></tt> macro in the preceding subsection also provides an example
of how you can use macros to define your own special forms. This works because
the actual evaluation of macro arguments is put off until runtime, and thus we
can safely pass them to built-in special forms and other constructs which
defer their evaluation at <em>runtime</em>. In fact, the right-hand side of a macro
rule may be an arbitrary Pure expression involving conditional expressions,
lambdas, binding clauses, etc. These are never evaluated during macro
substitution, they just become part of the macro expansion (after substituting
the macro parameters).</p>
<p>Here is another useful example of a user-defined special form, the macro
<tt class="docutils literal"><span class="pre">timex</span></tt> which employs the system function <tt class="docutils literal"><span class="pre">clock</span></tt> to report the cpu time
in seconds needed to evaluate a given expression, along with the computed
result:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">def</span> timex x = (clock-t0)/CLOCKS_PER_SEC,y <span class="kr">when</span> t0 = clock<span class="p">;</span> y = x <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>sum = foldl (+) <span class="mi">0L</span><span class="p">;</span>
<span class="gp">&gt; </span>timex $ sum (<span class="mi">1L</span>..<span class="mi">100000L</span>)<span class="p">;</span>
<span class="mf">0.43</span>,<span class="mi">5000050000L</span>
</pre></div>
</div>
<p>Note that the above definition of <tt class="docutils literal"><span class="pre">timex</span></tt> wouldn&#8217;t work as an ordinary
function definition, since by virtue of Pure&#8217;s basic eager evaluation strategy
the <tt class="docutils literal"><span class="pre">x</span></tt> parameter would have been evaluated already before it is passed to
<tt class="docutils literal"><span class="pre">timex</span></tt>, making <tt class="docutils literal"><span class="pre">timex</span></tt> always return a zero time value. Try it!</p>
<p>Here&#8217;s yet another example, which is handy if you need to trace function
calls. (Note that the interpreter also has its own built-in debugging
facility, see <a class="reference internal" href="#debugging">Debugging</a>. However, the following macro allows you to trace
functions using your own custom output format, and may thus be useful in
situations where the built-in debugger is not appropriate.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> system<span class="p">;</span>
<span class="kr">def</span> trace f x y = printf <span class="s">&quot;** exit %s: %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span> (str f,str x,str y) $$ y
<span class="kr">when</span> y = printf <span class="s">&quot;** call %s: %s</span><span class="se">\n</span><span class="s">: &quot;</span> (str f,str x) $$ gets $$ y <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This macro is invoked with the function to be traced, the arguments (or
whatever you want to be printed as additional debugging information) and the
actual function call as parameters. (This is a rather simplistic version,
which just prints a prompt on function entry and the final reduction after the
call. You can easily make this as elaborate as you like. E.g., you might want
to keep track of recursive levels and profiling information, add various
interactive commands to selectively enable and disable tracing during the
evaluation, etc.)</p>
<p>We can still make this a bit more convenient by introducing the following
ordinary function definition:</p>
<div class="highlight-pure"><div class="highlight"><pre>trace f x = trace f x (f x)<span class="p">;</span>
</pre></div>
</div>
<p>This lets us patch up a call to trace a given function, as shown below,
without having to change the definition of the function at all. This trick
only works with global functions; for local functions you&#8217;ll have to add an
explicit call of the <tt class="docutils literal"><span class="pre">trace</span></tt> macro to the local definition yourself. Also
note that the definition above only works with functions taking a single
parameter; see the trace.pure example in the distribution for the full version
which can deal with any number of arguments.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="c1">// Uncomment this line to trace calls to the &#39;fact&#39; function.</span>
<span class="kr">def</span> fact n = trace fact n<span class="p">;</span>
<span class="c1">// Sample function to be traced.</span>
fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact(n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Here&#8217;s a trace of the <tt class="docutils literal"><span class="pre">fact</span></tt> function obtained in this fashion (hit carriage
return after each &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; prompt to proceed with the computation):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact <span class="mi">2</span><span class="p">;</span>
** call fact: <span class="mi">2</span>
:
** call fact: <span class="mi">1</span>
:
** call fact: <span class="mi">0</span>
:
** exit fact: <span class="mi">0</span> -&gt; <span class="mi">1</span>
** exit fact: <span class="mi">1</span> -&gt; <span class="mi">1</span>
** exit fact: <span class="mi">2</span> -&gt; <span class="mi">2</span>
<span class="mi">2</span>
</pre></div>
</div>
<p>Note that by just removing the macro definition for <tt class="docutils literal"><span class="pre">fact</span></tt> above, you can
make the function run untraced as usual again. This scheme is quite flexible,
the only real drawback is that you have to explicitly add some code for each
function you want to trace.</p>
</div>
<div class="section" id="macro-hygiene">
<h3><a class="toc-backref" href="#id62">Macro Hygiene</a><a class="headerlink" href="#macro-hygiene" title="Permalink to this headline">¶</a></h3>
<p>Pure macros are lexically scoped, i.e., the binding of symbols in the
right-hand-side of a macro definition is determined statically by the text of
the definition, and macro parameter substitution also takes into account
binding constructs, such as <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clauses, in
the right-hand side of the definition. Macro facilities with these pleasant
properties are also known as <strong class="dfn">hygienic macros</strong>. They are not susceptible to
so-called &#8220;name capture,&#8221; which makes macros in less sophisticated languages
bug-ridden and hard to use.</p>
<p>Macro hygiene is a somewhat esoteric topic for most programmers, so let us
take a brief look at what it&#8217;s all about. The problem avoided by hygienic
macros is that of <em>name capture</em>. There are actually two kinds of name capture
which may occur in unhygienic macro systems:</p>
<ul class="simple">
<li>A free symbol in the macro <em>body</em> inadvertently becomes bound to the value
of a local symbol in the context in which the macro is called.</li>
<li>A free symbol in the macro <em>call</em> inadvertently becomes bound to the value
of a local symbol in the macro body.</li>
</ul>
<p>Pure&#8217;s hygienic macros avoid both pitfalls. Here is an example for the first
form of name capture:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">def</span> G x = x+y<span class="p">;</span>
<span class="gp">&gt; </span>G <span class="mi">10</span> <span class="kr">when</span> y = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
<span class="mi">10</span>+y
</pre></div>
</div>
<p>Note that the expansion of the <tt class="docutils literal"><span class="pre">G</span></tt> macro correctly uses the global instance
of <tt class="docutils literal"><span class="pre">y</span></tt>, even though <tt class="docutils literal"><span class="pre">y</span></tt> is locally defined in the context of the macro
call. (In some languages this form of name capture is sometimes used
deliberately in order to make the macro use the binding of the symbol which is
active at the point of the macro call. This never works in Pure, hence in such
cases you will have to explicitly pass such symbols to the macro.)</p>
<p>In contrast, the second form of name capture is usually not intended, and is
therefore more dangerous. Consider the following example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">def</span> F x = x+y <span class="kr">when</span> y = x+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>F y<span class="p">;</span>
y+(y+<span class="mi">1</span>)
</pre></div>
</div>
<p>Pure again gives the correct result here. You&#8217;d have to be worried if you got
<tt class="docutils literal"><span class="pre">(y+1)+(y+1)</span></tt> instead, which would result from the literal expansion <tt class="docutils literal"><span class="pre">y+y</span>
<span class="pre">when</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y+1</span> <span class="pre">end</span></tt>, where the (free) variable <tt class="docutils literal"><span class="pre">y</span></tt> passed to <tt class="docutils literal"><span class="pre">F</span></tt> gets
captured by the local binding of <tt class="docutils literal"><span class="pre">y</span></tt>. In fact, that&#8217;s exactly what you get
with C macros:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define F(x) { int y = x+1; return x+y; }</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">F(y)</span></tt> expands to <tt class="docutils literal"><span class="pre">{</span> <span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y+1;</span> <span class="pre">return</span> <span class="pre">y+y;</span> <span class="pre">}</span></tt> which is usually
<em>not</em> what you want.</p>
</div>
</div>
<div class="section" id="exception-handling">
<span id="id10"></span><h2><a class="toc-backref" href="#id63">Exception Handling</a><a class="headerlink" href="#exception-handling" title="Permalink to this headline">¶</a></h2>
<p>Pure also offers a useful exception handling facility. To raise an exception,
you just invoke the built-in function <a class="reference internal" href="purelib.html#throw" title="throw"><tt class="xref pure pure-func docutils literal"><span class="pre">throw</span></tt></a> with the value to be
thrown as the argument. Exceptions are caught with the built-in special form
<a class="reference internal" href="#catch" title="catch"><tt class="xref pure pure-func docutils literal"><span class="pre">catch</span></tt></a> which is invoked as follows:</p>
<dl class="function">
<dt id="catch">
<tt class="descname">catch</tt> handler x<a class="headerlink" href="#catch" title="Permalink to this definition">¶</a></dt>
<dd><p>Catch an exception. The first argument denotes the exception handler (a
function to be applied to the exception value). The second (call-by-name)
argument is the expression to be evaluated.</p>
</dd></dl>

<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="nb">catch</span> error (<span class="nb">throw</span> hello_world)<span class="p">;</span>
error hello_world
</pre></div>
</div>
<p>Exceptions are also generated by the runtime system if the program runs out of
stack space, when a guard does not evaluate to a truth value, and when the
subject term fails to match the pattern in a pattern-matching lambda
abstraction, or a <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> or <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>
construct. These types of exceptions are reported using the symbols
<a class="reference internal" href="purelib.html#stack_fault" title="stack_fault"><tt class="xref pure pure-cons docutils literal"><span class="pre">stack_fault</span></tt></a>, <a class="reference internal" href="purelib.html#failed_cond" title="failed_cond"><tt class="xref pure pure-cons docutils literal"><span class="pre">failed_cond</span></tt></a> and <a class="reference internal" href="purelib.html#failed_match" title="failed_match"><tt class="xref pure pure-cons docutils literal"><span class="pre">failed_match</span></tt></a>,
respectively, which are declared as constant symbols in the standard
prelude. You can use <a class="reference internal" href="#catch" title="catch"><tt class="xref pure pure-func docutils literal"><span class="pre">catch</span></tt></a> to handle these kinds of exceptions just
like any other. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact(n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="nb">catch</span> error (fact foo)<span class="p">;</span>
error failed_cond
<span class="gp">&gt; </span><span class="nb">catch</span> error (fact <span class="mi">100000</span>)<span class="p">;</span>
error stack_fault
</pre></div>
</div>
<p>(You&#8217;ll only get the latter kind of exception if the interpreter does stack
checks, see the discussion of the <span class="target" id="index-15"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a> environment variable in
<a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>.)</p>
<p>Note that unhandled exceptions are reported by the interpreter with a
corresponding error message:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact foo<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 2: </span>unhandled exception &#39;failed_cond&#39; while evaluating &#39;fact foo&#39;
</pre></div>
</div>
<p>Exceptions also provide a way to handle asynchronous signals. Pure&#8217;s system
module provides symbolic constants for common POSIX signals and also defines
the operation <a class="reference internal" href="purelib.html#trap" title="trap"><tt class="xref pure pure-func docutils literal"><span class="pre">trap</span></tt></a> which lets you rebind any signal to a signal
exception. For instance, the following lets you handle the <tt class="docutils literal"><span class="pre">SIGQUIT</span></tt>
signal:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>trap SIG_TRAP SIGQUIT<span class="p">;</span>
</pre></div>
</div>
<p>You can also use <a class="reference internal" href="purelib.html#trap" title="trap"><tt class="xref pure pure-func docutils literal"><span class="pre">trap</span></tt></a> to just ignore a signal or revert to the
system&#8217;s default handler (which might take different actions depending on the
type of signal, see signal(7) for details):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>trap SIG_IGN SIGQUIT<span class="p">;</span> <span class="c1">// signal is ignored</span>
<span class="gp">&gt; </span>trap SIG_DFL SIGQUIT<span class="p">;</span> <span class="c1">// reinstalls the default signal handler</span>
</pre></div>
</div>
<p>Note that when the interpreter runs interactively, for convenience most
standard termination signals (<tt class="docutils literal"><span class="pre">SIGINT</span></tt>, <tt class="docutils literal"><span class="pre">SIGTERM</span></tt>, etc.) are already set
up to produce corresponding Pure exceptions of the form <tt class="docutils literal"><span class="pre">signal</span> <span class="pre">SIG</span></tt> where
<tt class="docutils literal"><span class="pre">SIG</span></tt> is the signal number. If a script is to be run non-interactively then
you&#8217;ll have to do this yourself (otherwise most signals will terminate the
program).</p>
<p>Last but not least, exceptions can also be used to implement non-local value
returns. For instance, here&#8217;s a variation of our n queens algorithm which only
returns the first solution. Note the use of <a class="reference internal" href="purelib.html#throw" title="throw"><tt class="xref pure pure-func docutils literal"><span class="pre">throw</span></tt></a> in the recursive
search routine to bail out with a solution as soon as we found one. The value
thrown there is caught in the main routine. Also note the use of <a class="reference internal" href="purelib.html#void" title="void"><tt class="xref pure pure-func docutils literal"><span class="pre">void</span></tt></a>
in the second equation of <tt class="docutils literal"><span class="pre">search</span></tt>. This effectively turns the list
comprehension into a simple loop which suppresses the normal list result and
just returns <tt class="docutils literal"><span class="pre">()</span></tt> instead. Thus, if no value gets thrown then the function
regularly returns with <tt class="docutils literal"><span class="pre">()</span></tt> to indicate that there is no solution.</p>
<div class="highlight-pure"><div class="highlight"><pre>queens n       = <span class="nb">catch</span> reverse (search n <span class="mi">1</span> []) <span class="kr">with</span>
  search n i p = <span class="nb">throw</span> p <span class="kr">if</span> i&gt;n<span class="p">;</span>
               = <span class="kt">void</span> [search n (i+<span class="mi">1</span>) ((i,j):p) | j = <span class="mi">1</span>..n<span class="p">;</span> safe (i,j) p]<span class="p">;</span>
  safe (i,j) p = ~any (check (i,j)) p<span class="p">;</span>
  check (i1,j1) (i2,j2)
               = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>E.g., let&#8217;s compute a solution for a standard 8x8 board:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>queens <span class="mi">8</span><span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">1</span>),(<span class="mi">2</span>,<span class="mi">5</span>),(<span class="mi">3</span>,<span class="mi">8</span>),(<span class="mi">4</span>,<span class="mi">6</span>),(<span class="mi">5</span>,<span class="mi">3</span>),(<span class="mi">6</span>,<span class="mi">7</span>),(<span class="mi">7</span>,<span class="mi">2</span>),(<span class="mi">8</span>,<span class="mi">4</span>)]
</pre></div>
</div>
</div>
<div class="section" id="c-interface">
<h2><a class="toc-backref" href="#id64">C Interface</a><a class="headerlink" href="#c-interface" title="Permalink to this headline">¶</a></h2>
<p>Pure makes it very easy to call C functions (as well as functions in a number
of other languages supported by the GNU compiler collection). To call an
existing C function, you just need an <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration of the
function, as described below. By these means, all functions in the standard C
library and the Pure runtime are readily available to Pure scripts. Functions
can also be loaded from dynamic libraries and LLVM bitcode files at
runtime. In the latter case, you don&#8217;t even need to write any
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations, the interpreter will do that for you. As of
Pure 0.45, you can also add inline C/C++ and Fortran code to your Pure scripts
and have the Pure interpreter compile them on the fly, provided that you have
the corresponding compilers from the LLVM project installed.</p>
<p>In some cases you will still have to rely on big and complicated third-party
and system libraries which aren&#8217;t readily available in bitcode form. It goes
without saying that writing all the <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations for such
libraries can be a daunting task. Fortunately, there is a utility to help with
this, by extracting the <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations automatically from C
headers. Please see <a class="reference internal" href="#external-c-functions">External C Functions</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a>
section for details.</p>
<div class="section" id="extern-declarations">
<span id="extern"></span><h3><a class="toc-backref" href="#id65">Extern Declarations</a><a class="headerlink" href="#extern-declarations" title="Permalink to this headline">¶</a></h3>
<p>To access an existing C function in Pure, you need an <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declaration of the function, which is a simplified kind of C prototype. The
syntax of these declarations is described by the following grammar rules:</p>
<pre>
<strong id="grammar-token-extern_decl">extern_decl</strong> ::=  [<a class="reference internal" href="#grammar-token-scope"><tt class="xref docutils literal"><span class="pre">scope</span></tt></a>] &quot;extern&quot; <a class="reference internal" href="#grammar-token-prototype"><tt class="xref docutils literal"><span class="pre">prototype</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-prototype"><tt class="xref docutils literal"><span class="pre">prototype</span></tt></a>) &quot;;&quot;
<strong id="grammar-token-prototype">prototype  </strong> ::=  <a class="reference internal" href="#grammar-token-c_type"><tt class="xref docutils literal"><span class="pre">c_type</span></tt></a> <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-parameters"><tt class="xref docutils literal"><span class="pre">parameters</span></tt></a> | &quot;...&quot;] &quot;)&quot; [&quot;=&quot; <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>]
<strong id="grammar-token-parameters">parameters </strong> ::=  <a class="reference internal" href="#grammar-token-parameter"><tt class="xref docutils literal"><span class="pre">parameter</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-parameter"><tt class="xref docutils literal"><span class="pre">parameter</span></tt></a>)* [&quot;,&quot; &quot;...&quot;]
<strong id="grammar-token-parameter">parameter  </strong> ::=  <a class="reference internal" href="#grammar-token-c_type"><tt class="xref docutils literal"><span class="pre">c_type</span></tt></a> [<a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>]
<strong id="grammar-token-c_type">c_type     </strong> ::=  <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> &quot;*&quot;*
</pre>
<p>Extern functions can be called in Pure just like any other. For instance, the
following commands, entered interactively in the interpreter, let you use the
<tt class="docutils literal"><span class="pre">sin</span></tt> function from the C library (of course you could just as well put the
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration into a script):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mf">0.3</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
</pre></div>
</div>
<p>An <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration can also be prefixed with a
<a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a>/<a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> scope specifier:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">private</span> <span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Multiple prototypes can be given in one <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration,
separating them with commas:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>), <span class="kt">double</span> cos(<span class="kt">double</span>), <span class="kt">double</span> tan(<span class="kt">double</span>)<span class="p">;</span>
</pre></div>
</div>
<p>For clarity, the parameter types can also be annotated with parameter names
(these only serve informational purposes and are for the human reader; they
are effectively treated as comments by the compiler):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span> x)<span class="p">;</span>
</pre></div>
</div>
<p>Pointer types are indicated by following the name of the element type with one
or more asterisks, as in C. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">char</span>* strchr(<span class="kt">char</span> *s, <span class="kt">int</span> c)<span class="p">;</span>
<span class="gp">&gt; </span>strchr <span class="s">&quot;foo bar&quot;</span> (ord <span class="s">&quot;b&quot;</span>)<span class="p">;</span>
<span class="s">&quot;bar&quot;</span>
</pre></div>
</div>
<p>As you can see in the previous example, some pointer types get special
treatment, allowing you to pass certain kinds of Pure data (such as Pure
strings as <tt class="docutils literal"><span class="pre">char*</span></tt> in this example). This is discussed in more detail in <a class="reference internal" href="#c-types">C
Types</a> below.</p>
<p>The interpreter makes sure that the parameters in a call match; if not, then
by default the call is treated as a normal form expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mf">0.3</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
<span class="gp">&gt; </span>sin <span class="mi">0</span><span class="p">;</span>
sin <span class="mi">0</span>
</pre></div>
</div>
<p>This gives you the opportunity to augment the external function with your own
Pure equations. To make this work, you have to make sure that the
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration of the function comes first. For instance, we
might want to extend the <tt class="docutils literal"><span class="pre">sin</span></tt> function with a rule to handle integers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>sin x<span class="p">::</span><span class="kt">int</span> = sin (<span class="kt">double</span> x)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mi">0</span><span class="p">;</span>
<span class="mf">0.0</span>
</pre></div>
</div>
<p>Sometimes it is preferable to replace a C function with a wrapper function
written in Pure. In such a case you can specify an <strong class="dfn">alias</strong> under which the
original C function is known to the Pure program, so that you can still call
the C function from the wrapper. An alias is introduced by terminating the
extern declaration with a clause of the form <tt class="docutils literal"><span class="pre">=</span> <span class="pre">alias</span></tt>. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>) = c_sin<span class="p">;</span>
<span class="gp">&gt; </span>sin x<span class="p">::</span><span class="kt">double</span> = c_sin x<span class="p">;</span>
<span class="gp">&gt; </span>sin x<span class="p">::</span><span class="kt">int</span> = c_sin (<span class="kt">double</span> x)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mf">0.3</span><span class="p">;</span> sin <span class="mi">0</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
<span class="mf">0.0</span>
</pre></div>
</div>
<p>Aliases are just one way to declare a <strong class="dfn">synonym</strong> of an external function. As
an alternative, you can also declare the C function in a special namespace
(cf. <a class="reference internal" href="#namespaces">Namespaces</a> in the <a class="reference internal" href="#declarations">Declarations</a> section):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> c<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span>c<span class="p">::</span>sin <span class="mf">0.3</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
</pre></div>
</div>
<p>Note that the namespace qualification only affects the Pure side; the
underlying C function is still called under the unqualified name as usual. The
way in which such qualified externs are accessed is the same as for ordinary
qualified symbols. In particular, the <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declaration
applies as usual, and you can declare such symbols as <a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> if
needed. It is also possible to combine a namespace qualifier with an alias:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> c<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>) = mysin<span class="p">;</span>
<span class="gp">&gt; </span>c<span class="p">::</span>mysin <span class="mf">0.3</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
</pre></div>
</div>
<p>In either case, different synonyms of the same external function can be
declared in slightly different ways, which makes it possible to adjust the
interpretation of pointer values on the Pure side. This is particularly useful
for string arguments which, as described below, may be passed both as
<tt class="docutils literal"><span class="pre">char*</span></tt> (which implies copying and conversion to or from the system
encoding) and as <tt class="docutils literal"><span class="pre">void*</span></tt> (which simply passes through the character
pointers). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">char</span> *strchr(<span class="kt">char</span> *s, <span class="kt">int</span> c) = foo<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">void</span> *strchr(<span class="kt">void</span> *s, <span class="kt">int</span> c) = bar<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="s">&quot;foo bar&quot;</span> <span class="mi">98</span><span class="p">;</span> bar <span class="s">&quot;foo bar&quot;</span> <span class="mi">98</span><span class="p">;</span>
<span class="s">&quot;bar&quot;</span>
<span class="kt">#&lt;pointer 0x12c2f24&gt;</span>
</pre></div>
</div>
<p>Also note that, as far as Pure is concerned, different synonyms of an external
function are really different functions. In particular, they can each have
their own set of augmenting Pure equations. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>) = mysin<span class="p">;</span>
<span class="gp">&gt; </span>sin === sin<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>sin === mysin<span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span>sin <span class="mf">1.0</span><span class="p">;</span> mysin <span class="mf">1.0</span><span class="p">;</span>
<span class="mf">0.841470984807897</span>
<span class="mf">0.841470984807897</span>
<span class="gp">&gt; </span>sin x<span class="p">::</span><span class="kt">int</span> = sin (<span class="kt">double</span> x)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mi">1</span><span class="p">;</span> mysin <span class="mi">1</span><span class="p">;</span>
<span class="mf">0.841470984807897</span>
mysin <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="variadic-c-functions">
<h3><a class="toc-backref" href="#id66">Variadic C Functions</a><a class="headerlink" href="#variadic-c-functions" title="Permalink to this headline">¶</a></h3>
<p>Variadic C functions are declared as usual by terminating the parameter list
with an ellipsis (<tt class="docutils literal"><span class="pre">...</span></tt>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> printf(<span class="kt">char</span>*, ...)<span class="p">;</span>
<span class="gp">&gt; </span>printf <span class="s">&quot;Hello, world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
Hello, world
<span class="mi">13</span>
</pre></div>
</div>
<p>Note that the variadic prototype is mandatory here, since the compiler needs
to know about the optional arguments so that it can generate the proper code
to call the function. However, in Pure a function always has a fixed arity,
so, as far as Pure is concerned, the function is still treated as if it had no
extra arguments. Thus the above declaration only allows you to call <tt class="docutils literal"><span class="pre">printf</span></tt>
with a single argument.</p>
<p>To make it possible to pass optional arguments to a variadic function, you
must explicitly give the (non-variadic) prototypes with which the function is
to be called. To these ends, the additional prototypes are declared as
synonyms of the original variadic function. This works because the compiler
only checks the non-variadic parameters for conformance. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> printf(<span class="kt">char</span>*, <span class="kt">char</span>*) = printf_s<span class="p">;</span>
<span class="gp">&gt; </span>printf_s <span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="s">&quot;world&quot;</span><span class="p">;</span>
Hello, world
<span class="mi">13</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> printf(<span class="kt">char</span>*, <span class="kt">int</span>) = printf_d<span class="p">;</span>
<span class="gp">&gt; </span>printf_d <span class="s">&quot;Hello, %d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="mi">99</span><span class="p">;</span>
Hello, <span class="mi">99</span>
<span class="mi">10</span>
</pre></div>
</div>
</div>
<div class="section" id="c-types">
<span id="id11"></span><h3><a class="toc-backref" href="#id67">C Types</a><a class="headerlink" href="#c-types" title="Permalink to this headline">¶</a></h3>
<p>As indicated in the previous section, the data types in <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declarations are either C type names or pointer types derived from these. The
special <tt class="docutils literal"><span class="pre">expr*</span></tt> pointer type is simply passed through; this provides a means
to deal with Pure data in C functions in a direct fashion. For all other C
types, Pure values are &#8220;marshalled&#8221; (converted) from Pure to C when passed as
arguments to C functions, and the result returned by the C function is then
converted back from C to Pure. All of this is handled by the runtime system in
a transparent way, of course.</p>
<p>Note that, to keep things simple, Pure does <em>not</em> provide any notations for C
structs or function types, although it is possible to represent pointers to
such objects using <tt class="docutils literal"><span class="pre">void*</span></tt> or some other appropriate pointer types. In
practice, this simplified system should cover most kinds of calls that need to
be done when interfacing to C libraries, but there are ways to work around
these limitations if you need to access C structs or call back from C to Pure,
see <a class="reference internal" href="#external-c-functions">External C Functions</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section for details.</p>
<div class="section" id="basic-c-types">
<h4><a class="toc-backref" href="#id68">Basic C Types</a><a class="headerlink" href="#basic-c-types" title="Permalink to this headline">¶</a></h4>
<p>Pure supports the usual range of basic C types: <tt class="docutils literal"><span class="pre">void</span></tt>, <tt class="docutils literal"><span class="pre">bool</span></tt>, <tt class="docutils literal"><span class="pre">char</span></tt>,
<tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">long</span></tt>, <tt class="docutils literal"><span class="pre">float</span></tt>, <tt class="docutils literal"><span class="pre">double</span></tt>, and converts between
these and the corresponding Pure data types (machine ints, bigints and double
values) in a straightforward way.</p>
<p>The <tt class="docutils literal"><span class="pre">void</span></tt> type is only allowed in function results. It is converted to the
empty tuple <tt class="docutils literal"><span class="pre">()</span></tt>.</p>
<p>Both <tt class="docutils literal"><span class="pre">float</span></tt> and <tt class="docutils literal"><span class="pre">double</span></tt> are supported as floating point types. Single
precision <tt class="docutils literal"><span class="pre">float</span></tt> arguments and return values are converted from/to Pure&#8217;s
double precision floating point numbers.</p>
<p>A variety of C integer types (<tt class="docutils literal"><span class="pre">bool</span></tt>, <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>,
<tt class="docutils literal"><span class="pre">long</span></tt>) are provided which are converted from/to the available Pure integer
types in a straightforward way. In addition, the synonyms <tt class="docutils literal"><span class="pre">int8</span></tt>, <tt class="docutils literal"><span class="pre">int16</span></tt>
and <tt class="docutils literal"><span class="pre">int32</span></tt> are provided for <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt> and <tt class="docutils literal"><span class="pre">int</span></tt>, respectively,
and <tt class="docutils literal"><span class="pre">int64</span></tt> denotes 64 bit integers (a.k.a. ISO C99 <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt>). Note
that <tt class="docutils literal"><span class="pre">long</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">int32</span></tt> on 32 bit systems, whereas it is the
same as <tt class="docutils literal"><span class="pre">int64</span></tt> on most 64 bit systems. To make it easier to interface to
various system routines, there&#8217;s also a special <tt class="docutils literal"><span class="pre">size_t</span></tt> integer type which
usually is 4 bytes on 32 bit and 8 bytes on 64 bit systems.</p>
<p>All integer parameters take both Pure ints and bigints as actual arguments;
truncation or sign extension is performed as needed, so that the C interface
behaves as if the argument was &#8220;cast&#8221; to the C target type. Returned integers
use the smallest Pure type capable of holding the result, i.e., int for the C
<tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt> and <tt class="docutils literal"><span class="pre">int</span></tt> types, bigint for <tt class="docutils literal"><span class="pre">int64</span></tt>.</p>
<p>Pure considers all integers as signed quantities, but it is possible to pass
unsigned integers as well (if necessary, you can use a bigint to pass positive
values which are too big to fit into a machine int). Also note that when an
unsigned integer is returned by a C routine, which is too big to fit into the
corresponding signed integer type, it will &#8220;wrap around&#8221; and become
negative. In this case, depending on the target type, you can use the
<a class="reference internal" href="purelib.html#ubyte" title="ubyte"><tt class="xref pure pure-func docutils literal"><span class="pre">ubyte</span></tt></a>, <a class="reference internal" href="purelib.html#ushort" title="ushort"><tt class="xref pure pure-func docutils literal"><span class="pre">ushort</span></tt></a>, <a class="reference internal" href="purelib.html#uint" title="uint"><tt class="xref pure pure-func docutils literal"><span class="pre">uint</span></tt></a>, <a class="reference internal" href="purelib.html#ulong" title="ulong"><tt class="xref pure pure-func docutils literal"><span class="pre">ulong</span></tt></a> and <a class="reference internal" href="purelib.html#uint64" title="uint64"><tt class="xref pure pure-func docutils literal"><span class="pre">uint64</span></tt></a>
functions provided by the prelude to convert the result back to an unsigned
quantity.</p>
</div>
<div class="section" id="pointer-types">
<h4><a class="toc-backref" href="#id69">Pointer Types</a><a class="headerlink" href="#pointer-types" title="Permalink to this headline">¶</a></h4>
<p>The use of pointer types is also fairly straightforward, but Pure has some
special rules for the conversion of certain pointer types which make it easy
to pass aggregate Pure data to and from C routines, while also following the
most common idioms for pointer usage in C. The following types of pointers are
recognized both as arguments and return values of C functions.</p>
<p>Bidirectional pointer conversions:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">char*</span></tt> is used for string arguments and return values which are converted
from Pure&#8217;s internal utf-8 based string representation to the system
encoding and vice versa. (Thus a C routine can never modify the raw Pure
string data in-place; if this is required then you&#8217;ll have to pass the
string argument as a <tt class="docutils literal"><span class="pre">void*</span></tt>, see below.)</li>
<li><tt class="docutils literal"><span class="pre">void*</span></tt> is for any generic pointer value, which is simply passed through
unchanged. When used as an argument, you can also pass Pure strings,
matrices and bigints. In this case the raw underlying data pointer
(<tt class="docutils literal"><span class="pre">char*</span></tt> in the case of strings, <tt class="docutils literal"><span class="pre">int*</span></tt>, <tt class="docutils literal"><span class="pre">double*</span></tt> or <tt class="docutils literal"><span class="pre">expr*</span></tt> in the
case of numeric and symbolic matrices, and the GMP type <tt class="docutils literal"><span class="pre">mpz_t</span></tt> in the
case of bigints) is passed, which allows the data to be modified in place
(with care). In particular, passing bigints as <tt class="docutils literal"><span class="pre">void*</span></tt> makes it possible
to call most GMP integer routines directly from Pure.</li>
<li><tt class="docutils literal"><span class="pre">dmatrix*</span></tt>, <tt class="docutils literal"><span class="pre">cmatrix*</span></tt> and <tt class="docutils literal"><span class="pre">imatrix*</span></tt> allow you to pass numeric Pure
matrices of the appropriate types (double, complex, int). Here a pointer to
the underlying GSL matrix structure is passed (not just the data itself).
This makes it possible to transfer GSL matrices between Pure and GSL
routines in a direct fashion without any overhead. (For convenience, there
are also some other pointer conversions for marshalling matrix arguments to
numeric C vectors, which are described in <a class="reference internal" href="#pointers-and-matrices">Pointers and Matrices</a> below.)</li>
<li><tt class="docutils literal"><span class="pre">expr*</span></tt> is for any kind of Pure value. A pointer to the expression node is
passed to or from the C function. This type is to be used for C routines
which are prepared to deal with pristine Pure data, using the corresponding
functions provided by the runtime. You can find many examples of this in the
standard library.</li>
</ul>
<p>All other pointer types are simply taken at face value, allowing you to pass
Pure pointer values as is, without any conversions. This also includes
pointers to arbitrary named types which don&#8217;t have a predefined meaning in
Pure, such as <tt class="docutils literal"><span class="pre">FILE*</span></tt>. As of Pure 0.45, the interpreter keeps track of the
actual names of all pointer types and checks (at runtime) that the types match
in an external call, so that you can&#8217;t accidentally get a core dump by
passing, say, a <tt class="docutils literal"><span class="pre">FILE*</span></tt> for a <tt class="docutils literal"><span class="pre">char*</span></tt>. (The call will then simply fail and
yield a normal form, which gives you the opportunity to hook into the function
with your own Pure definitions which may supply any desired data conversions.)
Typing information about pointer values is also available to Pure scripts by
means of corresponding library functions, please see the <a class="reference internal" href="purelib.html#tagged-pointers"><em>Tagged Pointers</em></a> section in the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.</p>
</div>
<div class="section" id="pointers-and-matrices">
<h4><a class="toc-backref" href="#id70">Pointers and Matrices</a><a class="headerlink" href="#pointers-and-matrices" title="Permalink to this headline">¶</a></h4>
<p>The following additional pointer conversions are provided to deal with Pure
matrix values in arguments of C functions, i.e., on the input side. These
enable you to pass Pure matrices for certain kinds of C vectors. Note that in
any case, you can also simply pass a suitable plain pointer value instead.
Also, these types aren&#8217;t special in return values, where they will simply
yield a pointer value (with the exception of <tt class="docutils literal"><span class="pre">char*</span></tt> which gets special
treatment as explained in the previous subsection). Thus you will have to
decode such results manually if needed. The standard library provides various
routines to do this, please see the <a class="reference internal" href="purelib.html#string-functions"><em>String Functions</em></a> and <a class="reference internal" href="purelib.html#matrix-functions"><em>Matrix Functions</em></a> sections in the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.</p>
<p>Numeric pointer conversions (input only):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">char*</span></tt>, <tt class="docutils literal"><span class="pre">short*</span></tt>, <tt class="docutils literal"><span class="pre">int*</span></tt>, <tt class="docutils literal"><span class="pre">int64*</span></tt>, <tt class="docutils literal"><span class="pre">float*</span></tt>, <tt class="docutils literal"><span class="pre">double*</span></tt> can be
used to pass numeric matrices as C vectors. This kind of conversion passes
just the matrix data (not the GSL matrix structure, as the <tt class="docutils literal"><span class="pre">dmatrix*</span></tt> et
al conversions do) and does conversions between integer or floating point
data of different sizes on the fly. You can either pass an int matrix as a
<tt class="docutils literal"><span class="pre">char*</span></tt>, <tt class="docutils literal"><span class="pre">short*</span></tt> <tt class="docutils literal"><span class="pre">int*</span></tt> or <tt class="docutils literal"><span class="pre">int64*</span></tt> argument, or a double or
complex matrix as a <tt class="docutils literal"><span class="pre">float*</span></tt> or <tt class="docutils literal"><span class="pre">double*</span></tt> argument (complex values are
then represented as two separate double numbers, first the real, then the
imaginary part, for each matrix element).</li>
<li><tt class="docutils literal"><span class="pre">char**</span></tt>, <tt class="docutils literal"><span class="pre">short**</span></tt>, <tt class="docutils literal"><span class="pre">int**</span></tt>, <tt class="docutils literal"><span class="pre">int64**</span></tt>, <tt class="docutils literal"><span class="pre">float**</span></tt>, <tt class="docutils literal"><span class="pre">double**</span></tt>
provide yet another way to pass numeric matrix arguments. This works
analogously to the numeric vector conversions above, but here a temporary C
vector of pointers is passed to the C function, whose elements point to the
rows of the matrix.</li>
</ul>
<p>Argv-style conversions (input only):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">char**</span></tt> and <tt class="docutils literal"><span class="pre">void**</span></tt> can be used to pass <tt class="docutils literal"><span class="pre">argv</span></tt>-style vectors as
arguments to C functions. In this case, the Pure argument must be a symbolic
vector of strings or generic pointer values. <tt class="docutils literal"><span class="pre">char**</span></tt> converts the string
elements to the system encoding, whereas <tt class="docutils literal"><span class="pre">void**</span></tt> passes through character
string data and other pointers unchanged (and allows in-place modification
of the data). A temporary C vector of these elements is passed to the C
function, which is always <a class="reference internal" href="purelib.html#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>-terminated and can thus be used for
almost any purpose which requires such <tt class="docutils literal"><span class="pre">argv</span></tt>-style vectors.</li>
</ul>
<p>Note that in the numeric pointer conversions, the matrix data is passed &#8220;per
reference&#8221; to C routines, i.e., the C function may modify the data &#8220;in
place&#8221;. This is true even for target data types such as <tt class="docutils literal"><span class="pre">short*</span></tt> or
<tt class="docutils literal"><span class="pre">float**</span></tt> which involve automatic conversions and hence need temporary
storage. In this case the data from the temporary storage is written back to
the original matrix when the function returns, to maintain the illusion of
in-place modification. Temporary storage is also needed when the GSL matrix
has the data in non-contiguous storage. You may want to avoid this if
performance is critical, by always using &#8220;packed&#8221; matrices (see <a class="reference internal" href="purelib.html#pack" title="pack"><tt class="xref pure pure-func docutils literal"><span class="pre">pack</span></tt></a>
in <a class="reference internal" href="purelib.html#matrix-functions"><em>Matrix Functions</em></a>) of the appropriate types.</p>
</div>
<div class="section" id="pointer-examples">
<h4><a class="toc-backref" href="#id71">Pointer Examples</a><a class="headerlink" href="#pointer-examples" title="Permalink to this headline">¶</a></h4>
<p>Let&#8217;s finally have a look at some instructive examples to explain some of the
trickier pointer types.</p>
<p>First, the matrix pointer types <tt class="docutils literal"><span class="pre">dmatrix*</span></tt>, <tt class="docutils literal"><span class="pre">cmatrix*</span></tt> and <tt class="docutils literal"><span class="pre">imatrix*</span></tt>
can be used to pass double, complex double and int matrices to GSL functions
taking pointers to the corresponding GSL types (<tt class="docutils literal"><span class="pre">gsl_matrix</span></tt>,
<tt class="docutils literal"><span class="pre">gsl_matrix_complex</span></tt> and <tt class="docutils literal"><span class="pre">gsl_matrix_int</span></tt>) as arguments or returning them
as results. (Note that there is no special marshalling of Pure&#8217;s symbolic
matrix type, as these aren&#8217;t supported by GSL anyway.) Also note that matrices
are always passed by reference. Thus, if you need to pass a matrix as an
output parameter of a GSL matrix routine, you should either create a zero
matrix or a copy of an existing matrix to hold the result. The prelude
provides various operations for that purpose (in particular, see the
<a class="reference internal" href="purelib.html#dmatrix" title="dmatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">dmatrix</span></tt></a>, <a class="reference internal" href="purelib.html#cmatrix" title="cmatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">cmatrix</span></tt></a>, <a class="reference internal" href="purelib.html#imatrix" title="imatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">imatrix</span></tt></a> and <a class="reference internal" href="purelib.html#pack" title="pack"><tt class="xref pure pure-func docutils literal"><span class="pre">pack</span></tt></a> functions
in matrices.pure). For instance, here is how you can quickly wrap up GSL&#8217;s
double matrix addition function in a way that preserves value semantics:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> <span class="s">&quot;lib:gsl&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> gsl_matrix_add(<span class="kt">dmatrix</span>*, <span class="kt">dmatrix</span>*)<span class="p">;</span>
<span class="gp">&gt; </span>x<span class="p">::</span><span class="kt">matrix</span> + y<span class="p">::</span><span class="kt">matrix</span> = gsl_matrix_add x y $$ x <span class="kr">when</span> x = pack x <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = <span class="kt">dmatrix</span> {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span> <span class="kr">let</span> y = <span class="kt">dmatrix</span> {<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">2</span>}<span class="p">;</span> x<span class="p">;</span> y<span class="p">;</span> x+y<span class="p">;</span>
{<span class="mf">1.0</span>,<span class="mf">2.0</span>,<span class="mf">3.0</span>}
{<span class="mf">2.0</span>,<span class="mf">3.0</span>,<span class="mf">2.0</span>}
{<span class="mf">3.0</span>,<span class="mf">5.0</span>,<span class="mf">5.0</span>}
</pre></div>
</div>
<p>Most GSL matrix routines can be wrapped in this fashion quite easily. A
ready-made GSL interface providing access to all of GSL&#8217;s numeric functions is
in the works; please check the Pure website for details.</p>
<p>For convenience, it is also possible to pass any kind of numeric matrix for a
<tt class="docutils literal"><span class="pre">char*</span></tt>, <tt class="docutils literal"><span class="pre">short*</span></tt>, <tt class="docutils literal"><span class="pre">int*</span></tt>, <tt class="docutils literal"><span class="pre">int64*</span></tt>, <tt class="docutils literal"><span class="pre">float*</span></tt> or <tt class="docutils literal"><span class="pre">double*</span></tt>
parameter. This requires that the pointer and the matrix type match up;
conversions between <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int64</span></tt> and <tt class="docutils literal"><span class="pre">int</span></tt> data and,
likewise, between <tt class="docutils literal"><span class="pre">float</span></tt> and <tt class="docutils literal"><span class="pre">double</span></tt> are handled automatically,
however. For instance, here is how you can call the <tt class="docutils literal"><span class="pre">puts</span></tt> routine from the
C library with an int matrix encoding the string <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></tt> as byte
values (ASCII codes):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> puts(<span class="kt">char</span>*)<span class="p">;</span>
<span class="gp">&gt; </span>puts {<span class="mi">72</span>,<span class="mi">101</span>,<span class="mi">108</span>,<span class="mi">108</span>,<span class="mi">111</span>,<span class="mi">44</span>,<span class="mi">32</span>,<span class="mi">119</span>,<span class="mi">111</span>,<span class="mi">114</span>,<span class="mi">108</span>,<span class="mi">100</span>,<span class="mi">33</span>,<span class="mi">0</span>}<span class="p">;</span>
Hello, world!
<span class="mi">14</span>
</pre></div>
</div>
<p>Pure 0.45 and later also support <tt class="docutils literal"><span class="pre">char**</span></tt>, <tt class="docutils literal"><span class="pre">short**</span></tt>, <tt class="docutils literal"><span class="pre">int**</span></tt>,
<tt class="docutils literal"><span class="pre">int64**</span></tt>, <tt class="docutils literal"><span class="pre">float**</span></tt> and <tt class="docutils literal"><span class="pre">double**</span></tt> parameters which encode a matrix as
a vector of row pointers instead. This kind of matrix representation is often
found in audio and video processing software (where the rows of the matrix
might denote different audio channels, display lines or video frames), but
it&#8217;s also fairly convenient to do any kind of matrix processing in C. For
instance, here&#8217;s how to do matrix multiplication (the naive algorithm):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">matmult</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">double</span> <span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="o">**</span><span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="o">**</span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see, this multiplies a <tt class="docutils literal"><span class="pre">n</span></tt> times <tt class="docutils literal"><span class="pre">l</span></tt> matrix <tt class="docutils literal"><span class="pre">x</span></tt> with a <tt class="docutils literal"><span class="pre">l</span></tt>
times <tt class="docutils literal"><span class="pre">m</span></tt> matrix <tt class="docutils literal"><span class="pre">y</span></tt> and puts the result into the <tt class="docutils literal"><span class="pre">n</span></tt> times <tt class="docutils literal"><span class="pre">m</span></tt> matrix
<tt class="docutils literal"><span class="pre">z</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">void</span> matmult(<span class="kt">int</span>, <span class="kt">int</span>, <span class="kt">int</span>, <span class="kt">double</span>**, <span class="kt">double</span>**, <span class="kt">double</span>**)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = {<span class="mf">0.11</span>,<span class="mf">0.12</span>,<span class="mf">0.13</span><span class="p">;</span><span class="mf">0.21</span>,<span class="mf">0.22</span>,<span class="mf">0.23</span>}<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> y = {<span class="mf">1011.0</span>,<span class="mf">1012.0</span><span class="p">;</span><span class="mf">1021.0</span>,<span class="mf">1022.0</span><span class="p">;</span><span class="mf">1031.0</span>,<span class="mf">1032.0</span>}<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> z = <span class="kt">dmatrix</span> (<span class="mi">2</span>,<span class="mi">2</span>)<span class="p">;</span>
<span class="gp">&gt; </span>matmult <span class="mi">2</span> <span class="mi">3</span> <span class="mi">2</span> x y z $$ z<span class="p">;</span>
{<span class="mf">367.76</span>,<span class="mf">368.12</span><span class="p">;</span><span class="mf">674.06</span>,<span class="mf">674.72</span>}
</pre></div>
</div>
<p>Also new in Pure 0.45 is the support for passing <tt class="docutils literal"><span class="pre">argv</span></tt>-style vectors as
arguments. For instance, here is how you can use <tt class="docutils literal"><span class="pre">fork</span></tt> and <tt class="docutils literal"><span class="pre">execvp</span></tt> to
implement a poor man&#8217;s version of the C <tt class="docutils literal"><span class="pre">system</span></tt> function. (This is
UNIX-specific and doesn&#8217;t do much error-checking, but you get the idea.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">extern</span> <span class="kt">int</span> fork()<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">int</span> execvp(<span class="kt">char</span> *path, <span class="kt">char</span> **argv)<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">int</span> waitpid(<span class="kt">int</span> pid, <span class="kt">int</span> *status, <span class="kt">int</span> options)<span class="p">;</span>

system cmd<span class="p">::</span><span class="kt">string</span> = <span class="kr">case</span> fork <span class="kr">of</span>
  <span class="c1">// child: execute the program, bail out if error</span>
  <span class="mi">0</span> = execvp <span class="s">&quot;/bin/sh&quot;</span> {<span class="s">&quot;/bin/sh&quot;</span>,<span class="s">&quot;-c&quot;</span>,cmd} $$ exit <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// parent: wait for the child and return its exit code</span>
  pid = waitpid pid status <span class="mi">0</span> $$ status!<span class="mi">0</span> &gt;&gt; <span class="mi">8</span>
        <span class="kr">when</span> status = {<span class="mi">0</span>} <span class="kr">end</span> <span class="kr">if</span> pid&gt;=<span class="mi">0</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

system <span class="s">&quot;echo Hello, world!&quot;</span><span class="p">;</span>
system <span class="s">&quot;ls -l *.pure&quot;</span><span class="p">;</span>
system <span class="s">&quot;exit 1&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="importing-dynamic-libraries">
<h3><a class="toc-backref" href="#id72">Importing Dynamic Libraries</a><a class="headerlink" href="#importing-dynamic-libraries" title="Permalink to this headline">¶</a></h3>
<p>By default, external C functions are resolved by the LLVM runtime, which first
looks for the symbol in the C library and Pure&#8217;s runtime library (or the
interpreter executable, if the interpreter was linked statically). Thus all C
library and Pure runtime functions are readily available in Pure programs.
Other functions can be provided by adding them to the runtime, or by linking
them into the runtime or the interpreter executable. Better yet, you can just
&#8220;dlopen&#8221; shared libraries at runtime with a special form of the
<a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="s">&quot;lib:libname[.ext]&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance, if you want to call the functions from library libxyz directly
from Pure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="s">&quot;lib:libxyz&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>After this declaration the functions from the given library will be ready to
be imported into your Pure program by means of corresponding <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declarations.</p>
<p>Shared libraries opened with using clauses are searched for in the same way as
source scripts (see section <a class="reference internal" href="#modules-and-imports">Modules and Imports</a> above), using the
<a class="reference internal" href="#cmdoption-pure-L"><em class="xref std std-option">-L</em></a> option and the <span class="target" id="index-16"></span><a class="reference internal" href="#envvar-PURE_LIBRARY"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_LIBRARY</span></tt></a> environment variable in
place of <a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a> and <span class="target" id="index-17"></span><a class="reference internal" href="#envvar-PURE_INCLUDE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_INCLUDE</span></tt></a>. If the library isn&#8217;t found
by these means, the interpreter will also consider other platform-specific
locations searched by the dynamic linker, such as the system library
directories and <span class="target" id="index-18"></span><tt class="xref std std-envvar docutils literal"><span class="pre">LD_LIBRARY_PATH</span></tt> on Linux. The necessary filename
suffix (e.g., .so on Linux or .dll on Windows) will be supplied automatically
when needed. Of course you can also specify a full pathname for the library if
you prefer that. If a library file cannot be found, or if an <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declaration names a function symbol which cannot be resolved, an appropriate
error message is printed.</p>
</div>
<div class="section" id="importing-llvm-bitcode">
<h3><a class="toc-backref" href="#id73">Importing LLVM Bitcode</a><a class="headerlink" href="#importing-llvm-bitcode" title="Permalink to this headline">¶</a></h3>
<p>As of Pure 0.44, the interpreter also provides a direct way to import LLVM
bitcode modules in Pure scripts. The main advantage of this method over the
&#8220;plain&#8221; C interface explained above is that the bitcode loader knows all the
call interfaces and generates the necessary <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations
automatically. This is more than just a convenience, as it also eliminates at
least some of the mistakes in <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations that may arise
when importing functions manually from dynamic libraries.</p>
<p>LLVM bitcode is loaded in a Pure script using the following special format of
the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="s">&quot;bc:modname[.bc]&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>(Here the <tt class="docutils literal"><span class="pre">bc</span></tt> tag indicates a bitcode file, and the default <tt class="docutils literal"><span class="pre">.bc</span></tt> bitcode
filename extension is supplied automatically. Also, the bitcode file is
searched for on the usual library search path.)</p>
<p>That&#8217;s it, no explicit <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations are required on the Pure
side. The Pure interpreter automatically creates <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declarations (in the current namespace) for all the external functions defined
in the LLVM bitcode module, and generates the corresponding wrappers to make
the functions callable from Pure. (This also works when batch-compiling a Pure
script. In this case, the bitcode file actually gets linked into the output
code, so the loaded bitcode module only needs to be present at compile time.)</p>
<p>By default the imported symbols will be public. You can also specify the
desired scope of the symbols explicitly, by placing the <a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a> or
<a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> keyword before the module name. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> <span class="kr">private</span> <span class="s">&quot;bc:modname&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>You can also import the same bitcode module several times, possibly in
different namespaces. This will not actually reload the module, but it will
create synonyms for the external functions in different namespaces:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">namespace</span> foo<span class="p">;</span>
<span class="kr">using</span> <span class="s">&quot;bc:modname&quot;</span><span class="p">;</span>
<span class="kr">namespace</span> bar<span class="p">;</span>
<span class="kr">using</span> <span class="kr">private</span> <span class="s">&quot;bc:modname&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>You can load any number of bitcode modules along with shared libraries in a
Pure script, in any order. The JIT will try to satisfy external references in
modules and libraries from other loaded libraries and bitcode modules. This is
deferred until the code is actually JIT-compiled, so that you can make sure
beforehand that all required libraries and bitcode modules have been loaded.
If the JIT fails to resolve a function, the interpreter will print its name
and also raise an exception at runtime when the function is being called from
other C code. (You can then run your script in the debugger to locate the
external visible in Pure from which the unresolved function is called.)</p>
<p>Let&#8217;s take a look at a concrete example to see how this actually
works. Consider the following C code which defines a little function to
compute the greatest common divisor of two (machine) integers:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">mygcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">mygcd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">%</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let&#8217;s say that this code is in the file <tt class="docutils literal"><span class="pre">mygcd.c</span></tt>, then you&#8217;d compile it to
a bitcode module using llvm-gcc as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre>llvm-gcc -emit-llvm -c mygcd.c -o mygcd.bc
</pre></div>
</div>
<p>Or, if you prefer to use <a class="reference internal" href="#clang">clang</a>, the new LLVM-based C/C++ compiler:</p>
<div class="highlight-pure"><div class="highlight"><pre>clang -emit-llvm -c mygcd.c -o mygcd.bc
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">-emit-llvm</span> <span class="pre">-c</span></tt> options instruct llvm-gcc or clang to build an
LLVM bitcode module. Of course, you can also add optimizations and other
options to the compile command as desired.</p>
<p>You can now load the resulting bitcode module and run the <tt class="docutils literal"><span class="pre">mygcd</span></tt> function
in the Pure interpreter simply as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> <span class="s">&quot;bc:mygcd&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>mygcd <span class="mi">75</span> <span class="mi">105</span><span class="p">;</span>
<span class="mi">15</span>
</pre></div>
</div>
<p>To actually see the generated <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration of the imported
function, you can use the interactive <tt class="docutils literal"><span class="pre">show</span></tt> command:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show mygcd
<span class="kr">extern</span> <span class="kt">int</span> mygcd(<span class="kt">int</span>, <span class="kt">int</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Some more examples showing how to use the bitcode interface can be found in
the Pure sources. In particular, the interface also works with Fortran (using
llvm-gfortran), and there is special support for interfacing to Grame&#8217;s
functional DSP programming language <a class="reference internal" href="#faust">Faust</a> (the latter uses a special variant
of the bitcode loader, which is selected with the <tt class="docutils literal"><span class="pre">dsp</span></tt> tag in the
<a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause). Please refer to the corresponding examples in the
distribution for further details.</p>
<p>Please note that at this time the LLVM bitcode interface is still somewhat
experimental, and there are some known limitations:</p>
<ul class="simple">
<li>LLVM doesn&#8217;t distinguish between <tt class="docutils literal"><span class="pre">char*</span></tt> and <tt class="docutils literal"><span class="pre">void*</span></tt> in bitcode, so all
<tt class="docutils literal"><span class="pre">void*</span></tt> parameters and return values in C code will be promoted to
<tt class="docutils literal"><span class="pre">char*</span></tt> on the Pure side. Also, pointers to types which neither have a
predefined meaning in Pure nor a proper type name in the bitcode file, will
become a generic pointer type (<tt class="docutils literal"><span class="pre">void*</span></tt>, <tt class="docutils literal"><span class="pre">void**</span></tt>, etc.) in Pure. If this
is a problem then you can just redeclare the corresponding functions under a
synonym <em>after</em> loading the bitcode module, giving the proper argument and
result types (see <a class="reference internal" href="#extern-declarations">Extern Declarations</a> above).</li>
<li>The bitcode interface is limited to the same range of C types as Pure&#8217;s
plain C interface. In practice, this should cover most C code, but it&#8217;s
certainly possible that you run into unsupported types for arguments and
return values. The compiler will then print a warning; the affected
functions will still be linked in, but they will not be callable from Pure.
Also note that calling conventions for passing C structs <em>by value</em> depend
on the host ABI, so you should have a look at the resulting
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration (using <tt class="docutils literal"><span class="pre">show</span></tt>) to determine how the function
is actually to be called from Pure.</li>
</ul>
</div>
<div class="section" id="inline-code">
<h3><a class="toc-backref" href="#id74">Inline Code</a><a class="headerlink" href="#inline-code" title="Permalink to this headline">¶</a></h3>
<p>Instead of manually compiling source files to bitcode modules, you can also
just place the source code into a Pure script, enclosing it in <tt class="docutils literal"><span class="pre">%&lt;</span> <span class="pre">...</span> <span class="pre">%&gt;</span></tt>.
(Optionally, the opening brace may also be preceded with a <a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a>
or <a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> scope specifier, which is used in the same way as the
scope specifier following the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> keyword when importing bitcode
files.)</p>
<p>For instance, here is a little script showing inline code for the <tt class="docutils literal"><span class="pre">mygcd</span></tt>
function from the previous subsection:</p>
<div class="highlight-pure"><div class="highlight"><pre>%&lt;
int mygcd(int x, int y)
{
  if (y == 0)
    return x;
  else
    return mygcd(y, x%y);
}
%&gt;

mygcd <span class="mi">75</span> <span class="mi">105</span><span class="p">;</span>
</pre></div>
</div>
<p>The interpreter automatically compiles the inlined code to LLVM bitcode which
is then loaded as usual. (Of course, this will only work if you have the
corresponding LLVM compilers installed.) This method has the advantage that
you don&#8217;t have to write a Makefile and you can create self-contained Pure
scripts which include all required external functions. The downside is that
the inline code sections will have to be recompiled every time you run the
script with the interpreter which may considerably increase startup times. If
this is a problem then it&#8217;s usually better to import a separate bitcode module
instead (see <a class="reference internal" href="#importing-llvm-bitcode">Importing LLVM Bitcode</a>), or at least batch-compile your script
to an executable (see <a class="reference internal" href="#batch-compilation">Batch Compilation</a>).</p>
<p>Currently, C, C++, Fortran and Faust are supported as foreign source
languages, with llvm-gcc, llvm-g++, llvm-gfortran and faust2 as the
corresponding compilers. Alternatively, the LLVM clang and clang++ compilers
can be used for C/C++ compilation (this will actually be default if the Pure
interpreter itself was compiled with clang). Examples for all of these can be
found in the Pure sources.</p>
<p>C is the default language. The desired source language can be selected by
placing an appropriate tag into the inline code section, immediately after the
opening brace. (The tag is removed before the code is submitted to
compilation.) For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre>%&lt; -*- Fortran90 -*-
function fact(n) result(p)
  integer n, p
  p = 1
  do i = 1, n
     p = p*i
  end do
end function fact
%&gt;

fact n<span class="p">::</span><span class="kt">int</span> = fact_ {n}<span class="p">;</span>
map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
</pre></div>
</div>
<p>As indicated, the language tag takes the form <tt class="docutils literal"><span class="pre">-*-</span> <span class="pre">lang</span> <span class="pre">-*-</span></tt> where <tt class="docutils literal"><span class="pre">lang</span></tt>
can currently be any of <tt class="docutils literal"><span class="pre">c</span></tt>, <tt class="docutils literal"><span class="pre">c++</span></tt>, <tt class="docutils literal"><span class="pre">fortran</span></tt> and <tt class="docutils literal"><span class="pre">dsp</span></tt> (the latter
indicates the Faust language). Case is insignificant here, so you can also
write <tt class="docutils literal"><span class="pre">C</span></tt>, <tt class="docutils literal"><span class="pre">C++</span></tt>, <tt class="docutils literal"><span class="pre">Fortran</span></tt>, <tt class="docutils literal"><span class="pre">DSP</span></tt> etc. For the <tt class="docutils literal"><span class="pre">fortran</span></tt> tag, you
may also have to specify the appropriate language standard, such as
<tt class="docutils literal"><span class="pre">fortran90</span></tt> which is used in the example above. The language tag can also be
followed by a module name, using the format <tt class="docutils literal"><span class="pre">-*-</span> <span class="pre">lang:name</span> <span class="pre">-*-</span></tt>. This is
optional for all languages except Faust (where the module name specifies the
namespace for the interface routines of the Faust module). So, e.g., a Faust
DSP named <tt class="docutils literal"><span class="pre">test</span></tt> would be specified with a <tt class="docutils literal"><span class="pre">dsp:test</span></tt> tag. Case is
<em>significant</em> in the module name.</p>
<p>The Pure interpreter has some built-in knowledge on how to invoke the LLVM
compilers to produce a working bitcode file ready to be loaded by the
interpreter, so the examples above should work out of the box if you have the
required compilers installed on your <span class="target" id="index-19"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt>. However, there are also
some environment variables you can set for customization purposes.
Specifically, <span class="target" id="index-20"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_CC</span></tt> is the command to invoke the C compiler. This
variable lets you specify the exact name of the executable along with any
debugging and optimization options that you may want to add. Likewise,
<span class="target" id="index-21"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_CXX</span></tt>, <span class="target" id="index-22"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_FC</span></tt> and <span class="target" id="index-23"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_FAUST</span></tt> are used for
the C++, Fortran and Faust compilers, respectively.</p>
<p>For instance, if you prefer to use clang as your C compiler, and you&#8217;d like to
invoke it with the <tt class="docutils literal"><span class="pre">-O3</span></tt> optimization option, you would set
<span class="target" id="index-24"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_CC</span></tt> to <tt class="docutils literal"><span class="pre">&quot;clang</span> <span class="pre">-O3&quot;</span></tt>. (To verify the settings you made, you
can have the interpreter echo the compilation commands which are actually
executed, by running Pure with the <tt class="docutils literal"><span class="pre">-v0100</span></tt> option, see <a class="reference internal" href="#verbosity-and-debugging-options">Verbosity and
Debugging Options</a>.)</p>
</div>
</div>
<div class="section" id="standard-library">
<h2><a class="toc-backref" href="#id75">Standard Library</a><a class="headerlink" href="#standard-library" title="Permalink to this headline">¶</a></h2>
<p>Pure comes with a collection of Pure library modules, which includes the
standard prelude (loaded automatically at startup time) and some other modules
which can be loaded explicitly with a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause. The prelude
offers the necessary functions to work with the built-in types (including
arithmetic and logical operations) and to do most kind of list processing you
can find in ML- and Haskell-like languages. It also provides a collection of
basic string and matrix operations. Please refer to the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for
details on the provided operations. Here is a very brief summary of some of
the prelude operations which, besides the usual arithmetic and logical
operators, are probably used most frequently:</p>
<dl class="describe">
<dt>
<tt class="descname">x+y</tt></dt>
<dd><p>The arithmetic <tt class="docutils literal"><span class="pre">+</span></tt> operation is also used to denote list and string
concatenation in Pure.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x:y</tt></dt>
<dd><p>This is the list-consing operation. <tt class="docutils literal"><span class="pre">x</span></tt> becomes the head of the list,
<tt class="docutils literal"><span class="pre">y</span></tt> its tail. As &#8216;<a class="reference internal" href="purelib.html#:" title=":"><tt class="xref pure pure-cons docutils literal"><span class="pre">:</span></tt></a>&#8216; is a constructor symbol, you can use it
in patterns on the left hand side of rewriting rules.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x..y</tt></dt>
<dd><p>Constructs arithmetic sequences. <tt class="docutils literal"><span class="pre">x:y..z</span></tt> can be used to denote
sequences with arbitrary stepsize <tt class="docutils literal"><span class="pre">y-x</span></tt>. Infinite sequences can be
constructed using an infinite bound (i.e., <tt class="docutils literal"><span class="pre">inf</span></tt> or <tt class="docutils literal"><span class="pre">-inf</span></tt>). E.g.,
<tt class="docutils literal"><span class="pre">1:3..inf</span></tt> denotes the stream of all odd integers starting at 1.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x,y</tt></dt>
<dd><p>This is the pair constructor, used to create tuples of arbitrary sizes.
Tuples provide an alternative way to represent aggregate values in Pure.
In contrast to lists, tuples are always &#8220;flat&#8221;, so that <tt class="docutils literal"><span class="pre">(x,y),z</span></tt> and
<tt class="docutils literal"><span class="pre">x,(y,z)</span></tt> denote the same triple <tt class="docutils literal"><span class="pre">x,y,z</span></tt>. (This is explained in more
detail in the <a class="reference internal" href="#primary-expressions">Primary Expressions</a> section.)</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">#x</tt></dt>
<dd><p>The size (number of elements) of the list, tuple, matrix or string
<tt class="docutils literal"><span class="pre">x</span></tt>. In addition, <tt class="docutils literal"><span class="pre">dim</span> <span class="pre">x</span></tt> yields the dimensions (number of rows and
columns) of a matrix.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x!y</tt></dt>
<dd><p>This is Pure&#8217;s indexing operation, which applies to lists, tuples,
matrices and strings. Note that all indices in Pure are zero-based, thus
<tt class="docutils literal"><span class="pre">x!0</span></tt> and <tt class="docutils literal"><span class="pre">x!(#x-1)</span></tt> are the first and last element of <tt class="docutils literal"><span class="pre">x</span></tt>. In the
case of matrices, the subscript may also be a pair of row and column
indices, such as <tt class="docutils literal"><span class="pre">x!(1,2)</span></tt>.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x!!ys</tt></dt>
<dd><p>This is the &#8220;slicing&#8221; operation, which returns the list, tuple, matrix or
string of all <tt class="docutils literal"><span class="pre">x!y</span></tt> while <tt class="docutils literal"><span class="pre">y</span></tt> runs through the (list or matrix)
<tt class="docutils literal"><span class="pre">ys</span></tt>. Thus, e.g., <tt class="docutils literal"><span class="pre">x!!(i..j)</span></tt> returns all the elements between <tt class="docutils literal"><span class="pre">i</span></tt>
and <tt class="docutils literal"><span class="pre">j</span></tt> (inclusive). Indices which fall outside the valid index range
are quietly discarded. The index range <tt class="docutils literal"><span class="pre">ys</span></tt> may contain any number of
indices (also duplicates), in any order. Thus <tt class="docutils literal"><span class="pre">x!![0|i=1..n]</span></tt> returns the
first element of <tt class="docutils literal"><span class="pre">x</span></tt> <tt class="docutils literal"><span class="pre">n</span></tt> times, and, if <tt class="docutils literal"><span class="pre">ys</span></tt> is a permutation of the
range <tt class="docutils literal"><span class="pre">0..#x-1</span></tt>, then <tt class="docutils literal"><span class="pre">x!!ys</span></tt> yields the corresponding permutation of
the elements of <tt class="docutils literal"><span class="pre">x</span></tt>. In the case of matrices the index range may also
contain two-dimensional subscripts, or the index range itself may be
specified as a pair of row/column index lists such as <tt class="docutils literal"><span class="pre">x!!(i..j,k..l)</span></tt>.</p>
</dd></dl>

<p>The prelude also offers support operations for the implementation of list and
matrix comprehensions, as well as the customary list operations like
<a class="reference internal" href="purelib.html#head" title="head"><tt class="xref pure pure-func docutils literal"><span class="pre">head</span></tt></a>, <a class="reference internal" href="purelib.html#tail" title="tail"><tt class="xref pure pure-func docutils literal"><span class="pre">tail</span></tt></a>, <a class="reference internal" href="purelib.html#drop" title="drop"><tt class="xref pure pure-func docutils literal"><span class="pre">drop</span></tt></a>, <a class="reference internal" href="purelib.html#take" title="take"><tt class="xref pure pure-func docutils literal"><span class="pre">take</span></tt></a>, <a class="reference internal" href="purelib.html#filter" title="filter"><tt class="xref pure pure-func docutils literal"><span class="pre">filter</span></tt></a>,
<a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>, <a class="reference internal" href="purelib.html#foldr" title="foldr"><tt class="xref pure pure-func docutils literal"><span class="pre">foldr</span></tt></a>, <a class="reference internal" href="purelib.html#scanl" title="scanl"><tt class="xref pure pure-func docutils literal"><span class="pre">scanl</span></tt></a>, <a class="reference internal" href="purelib.html#scanr" title="scanr"><tt class="xref pure pure-func docutils literal"><span class="pre">scanr</span></tt></a>,
<a class="reference internal" href="purelib.html#zip" title="zip"><tt class="xref pure pure-func docutils literal"><span class="pre">zip</span></tt></a>, <a class="reference internal" href="purelib.html#unzip" title="unzip"><tt class="xref pure pure-func docutils literal"><span class="pre">unzip</span></tt></a>, etc., which make list programming so much fun in
modern FPLs. In Pure, these also work on strings as well as matrices,
although, for reasons of efficiency, these data structures are internally
represented as arrays.</p>
<p>Besides the prelude, Pure&#8217;s standard library also comprises a growing number
of additional library modules which we can only mention in passing here. In
particular, the <a class="reference internal" href="purelib.html#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module provides additional mathematical functions
as well as Pure&#8217;s complex and rational number data types. Common container
data structures like sets and dictionaries are implemented in the <a class="reference internal" href="purelib.html#module-set"><tt class="xref pure pure-mod docutils literal"><span class="pre">set</span></tt></a>
and <a class="reference internal" href="purelib.html#module-dict"><tt class="xref pure pure-mod docutils literal"><span class="pre">dict</span></tt></a> modules, among others. Moreover, the system interface can be
found in the <a class="reference internal" href="purelib.html#module-system"><tt class="xref pure pure-mod docutils literal"><span class="pre">system</span></tt></a> module. In particular, this module also provides
operations to do basic C-style I/O, including <a class="reference internal" href="purelib.html#printf" title="printf"><tt class="xref pure pure-func docutils literal"><span class="pre">printf</span></tt></a> and <a class="reference internal" href="purelib.html#scanf" title="scanf"><tt class="xref pure pure-func docutils literal"><span class="pre">scanf</span></tt></a>.</p>
</div>
<div class="section" id="interactive-usage">
<h2><a class="toc-backref" href="#id76">Interactive Usage</a><a class="headerlink" href="#interactive-usage" title="Permalink to this headline">¶</a></h2>
<p>In interactive mode, the interpreter reads definitions and expressions and
processes them as usual. You can use the <a class="reference internal" href="#cmdoption-pure-i"><em class="xref std std-option">-i</em></a> option to force
interactive mode when invoking the interpreter with some script files.
Additional scripts can be loaded interactively using either a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a>
declaration or the interactive <tt class="docutils literal"><span class="pre">run</span></tt> command (see the description of the
<tt class="docutils literal"><span class="pre">run</span></tt> command below for the differences between these). Or you can just
start typing away, entering your own definitions and expressions to be
evaluated.</p>
<p>The input language is just the same as for source scripts, and hence
individual definitions and expressions must be terminated with a semicolon
before they are processed. For instance, here is a simple interaction which
defines the factorial and then uses that definition in some evaluations. Input
lines begin with &#8216;&gt; &#8216;, which is the interpreter&#8217;s default command prompt:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact <span class="mi">1</span> = <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = fact <span class="mi">10</span><span class="p">;</span> x<span class="p">;</span>
<span class="mi">3628800</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>As indicated, in interactive mode the normal forms of toplevel expressions are
printed after each expression is entered. We also call this the
<strong class="dfn">read-eval-print loop</strong>. Normal form expressions are usually printed in the
same form as you&#8217;d enter them. However, there are a few special kinds of
objects like anonymous closures, thunks (&#8220;lazy&#8221; values to be evaluated when
needed) and pointers which don&#8217;t have a textual representation in the Pure
syntax and will be printed in the format <tt class="docutils literal"><span class="pre">#&lt;</span></tt>object description<tt class="docutils literal"><span class="pre">&gt;</span></tt> by
default. It is also possible to override the print representation of any kind
of expression by means of the <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> function, see <a class="reference internal" href="#the-show-function">The __show__
Function</a> for details.</p>
<div class="section" id="online-help">
<h3><a class="toc-backref" href="#id77">Online Help</a><a class="headerlink" href="#online-help" title="Permalink to this headline">¶</a></h3>
<p>Online help is available in the interpreter with the interactive <tt class="docutils literal"><span class="pre">help</span></tt>
command, see <a class="reference internal" href="#interactive-commands">Interactive Commands</a> below. You need to have a html browser
installed for that. By default, the <tt class="docutils literal"><span class="pre">help</span></tt> command uses <strong class="program">w3m</strong>, but
you can change this by setting either the <span class="target" id="index-25"></span><a class="reference internal" href="#envvar-PURE_HELP"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_HELP</span></tt></a> or the
<span class="target" id="index-26"></span><a class="reference internal" href="#envvar-BROWSER"><tt class="xref std std-envvar docutils literal"><span class="pre">BROWSER</span></tt></a> environment variable accordingly.</p>
<p>As of Pure 0.46, the interpreter provides a much improved <tt class="docutils literal"><span class="pre">help</span></tt> command
which gives you access to all the available documentation in html format,
which includes this manual, the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a>, as well as all manuals of the
addon modules available from the Pure website.</p>
<p>When invoked without arguments, the <tt class="docutils literal"><span class="pre">help</span></tt> command displays an overview of
the available documentation, from which you can follow the links to the
provided manuals:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>help
</pre></div>
</div>
<p>(If the interpreter gives you an error message when you do this then you
haven&#8217;t installed the documentation yet. The complete set of manuals is
provided as a separate package at the Pure website, please see the Pure
installation instructions for details.)</p>
<p>The <tt class="docutils literal"><span class="pre">help</span></tt> command also accepts a parameter which lets you specify a search
term which is looked up in the global index, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>help foldl
</pre></div>
</div>
<p>Besides Pure functions, macros, variables and constants described in the
manual you can also look up program options and environment variables, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>help -x
<span class="gp">&gt; </span>help pure-gen -x
<span class="gp">&gt; </span>help PURE_STACK
</pre></div>
</div>
<p>(Note that you can specify the program name to disambiguate between options
for different utilities, such as the <tt class="docutils literal"><span class="pre">-x</span></tt> option which is accepted both by
the Pure interpreter and the <tt class="docutils literal"><span class="pre">pure-gen</span></tt> program.)</p>
<p>If the search term doesn&#8217;t appear in the index, it is assumed to be a topic (a
link target, usually a section title) in the Pure manual. Note that the
<a class="reference external" href="http://docutils.sourceforge.net/">docutils</a> tools used to generate the html source of the Pure documentation
mangle the section titles so that they are in lowercase and blanks are
replaced with hyphens. So to look up the present section in this manual you&#8217;d
have to type:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>help online-help
</pre></div>
</div>
<p>The help files are in html format and located in the docs subdirectory of the
Pure library directory (i.e., /usr/local/lib/pure/docs by default). You can
look up topics in any of the help files with a command like the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>help pure-gsl#matrices
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">pure-gsl</span></tt> is the basename of the help file (library path and .html
suffix are supplied automatically), and <tt class="docutils literal"><span class="pre">matrices</span></tt> is a link target in that
document. To just read the pure-gsl.html file without specifying a target,
type the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>help pure-gsl#
</pre></div>
</div>
<p>(Note that just <tt class="docutils literal"><span class="pre">help</span> <span class="pre">pure-gsl</span></tt> won&#8217;t work, since it would look for a search
term in the index or a topic in the Pure manual.)</p>
<p>Last but not least, you can also point the help browser to any html document
(either a local file or some website) denoted by a proper URL, provided that
your browser program can handle these. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>help file:mydoc.html#foo
<span class="gp">&gt; </span>help http://pure-lang.googlecode.com
</pre></div>
</div>
</div>
<div class="section" id="interactive-commands">
<h3><a class="toc-backref" href="#id78">Interactive Commands</a><a class="headerlink" href="#interactive-commands" title="Permalink to this headline">¶</a></h3>
<p>When running interactively, the interpreter accepts a number of special
commands useful for interactive purposes. Here is a quick rundown of the
currently supported operations:</p>
<span class="target" id="index-27"></span><dl class="describe">
<dt>
<tt class="descname">! command</tt></dt>
<dd><p>Shell escape.</p>
</dd></dl>

<span class="target" id="index-28"></span><dl class="describe">
<dt>
<tt class="descname">break [symbol ...]</tt></dt>
<dd><p>Sets breakpoints on the given function or operator symbols. All symbols
must be specified in fully qualified form, see the remarks below. If
invoked without arguments, prints all currently defined breakpoints. This
requires that the interpreter was invoked with the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option to
enable debugging support. See <a class="reference internal" href="#debugging">Debugging</a> below for details.</p>
</dd></dl>

<span class="target" id="index-29"></span><dl class="describe">
<dt>
<tt class="descname">bt</tt></dt>
<dd><p>Prints a full backtrace of the call sequence of the most recent evaluation,
if that evaluation ended with an unhandled exception. This requires that
the interpreter was invoked with the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option to enable
debugging support. See <a class="reference internal" href="#debugging">Debugging</a> below for details.</p>
</dd></dl>

<span class="target" id="index-30"></span><dl class="describe">
<dt>
<tt class="descname">cd dir</tt></dt>
<dd><p>Change the current working dir.</p>
</dd></dl>

<span class="target" id="index-31"></span><dl class="describe">
<dt>
<tt class="descname">clear [option ...] [symbol ...]</tt></dt>
<dd><p>Purge the definitions of the given symbols (functions, macros, constants or
global variables). All symbols must be specified in fully qualified form,
see the remarks below. If invoked as <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">ans</span></tt>, clears the <a class="reference internal" href="purelib.html#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a>
value (see <a class="reference internal" href="#last-result">Last Result</a> below). When invoked without any arguments,
<tt class="docutils literal"><span class="pre">clear</span></tt> purges all definitions at the current interactive &#8220;level&#8221; (after
confirmation) and returns you to the previous level, if any. (It might be a
good idea to first check your current definitions with <tt class="docutils literal"><span class="pre">show</span></tt> or back
them up with <tt class="docutils literal"><span class="pre">dump</span></tt> before you do that.)  The desired level can be
specified with the <tt class="docutils literal"><span class="pre">-t</span></tt> option. See the description of the <tt class="docutils literal"><span class="pre">save</span></tt>
command and <a class="reference internal" href="#definition-levels">Definition Levels</a> below for further details. A description
of the common options accepted by the <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt>
commands can be found in <a class="reference internal" href="#specifying-symbol-selections">Specifying Symbol Selections</a> below.</p>
</dd></dl>

<span class="target" id="index-32"></span><dl class="describe">
<dt>
<tt class="descname">del [-b|-t] [symbol ...]</tt></dt>
<dd><p>Deletes breakpoints and tracepoints on the given function or operator
symbols. If the <tt class="docutils literal"><span class="pre">-b</span></tt> option is specified then only breakpoints are
deleted; similarly, <tt class="docutils literal"><span class="pre">del</span> <span class="pre">-t</span></tt> only deletes tracepoints. Otherwise both
breakpoints and tracepoints are deleted. All symbols must be specified in
fully qualified form, see the remarks below. If invoked without non-option
arguments, <tt class="docutils literal"><span class="pre">del</span></tt> clears <em>all</em> currently defined breakpoints and/or
tracepoints (after confirmation). See <a class="reference internal" href="#debugging">Debugging</a> below for details.</p>
</dd></dl>

<span class="target" id="index-33"></span><dl class="describe">
<dt>
<tt class="descname">dump [-n filename] [option ...] [symbol ...]</tt></dt>
<dd><p>Dump a snapshot of the current function, macro, constant and variable
definitions in Pure syntax to a text file. All symbols must be specified in
fully qualified form, see the remarks below. This works similar to the
<tt class="docutils literal"><span class="pre">show</span></tt> command (see below), but writes the definitions to a file. The
default output file is .pure in the current directory, which is then
reloaded automatically the next time the interpreter starts up in
interactive mode in the same directory. This provides a quick-and-dirty way
to save an interactive session and have it restored later, but note that
this isn&#8217;t perfect. In particular, declarations of <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
symbols won&#8217;t be saved unless they&#8217;re specified explicitly, and some
objects like closures, thunks and pointers don&#8217;t have a textual
representation from which they could be reconstructed. To handle these,
you&#8217;ll probably have to prepare a corresponding .purerc file yourself, see
<a class="reference internal" href="#interactive-startup">Interactive Startup</a> below.</p>
<p>A different filename can be specified with the <tt class="docutils literal"><span class="pre">-n</span></tt> option, which expects
the name of the script to be written in the next argument, e.g: <tt class="docutils literal"><span class="pre">dump</span> <span class="pre">-n</span>
<span class="pre">myscript.pure</span></tt>. You can then edit that file and use it as a starting point
for an ordinary script or a .purerc file, or you can just run the file with
the <tt class="docutils literal"><span class="pre">run</span></tt> command (see below) to restore the definitions in a subsequent
interpreter session.</p>
</dd></dl>

<span class="target" id="index-34"></span><dl class="describe">
<dt>
<tt class="descname">help [topic]</tt></dt>
<dd><p>Display online documentation. If a topic is given, it is looked up in the
index. Alternatively, you can also specify a link target in any of the
installed help files, or any other html document denoted by a proper URL.
Please see <a class="reference internal" href="#online-help">Online Help</a> above for details.</p>
</dd></dl>

<span class="target" id="index-35"></span><dl class="describe">
<dt>
<tt class="descname">ls [args]</tt></dt>
<dd><p>List files (shell <strong class="command">ls</strong> command).</p>
</dd></dl>

<span class="target" id="index-36"></span><dl class="describe">
<dt>
<tt class="descname">mem</tt></dt>
<dd><p>Print current memory usage. This reports the number of expression cells
currently in use by the program, along with the size of the freelist (the
number of allocated but currently unused expression cells). Note that the
actual size of the expression storage may be somewhat larger than this,
since the runtime always allocates expression memory in bigger chunks.
Also, this figure does not reflect other heap-allocated memory in use by
the program, such as strings or malloc&#8217;ed pointers.</p>
</dd></dl>

<span class="target" id="index-37"></span><dl class="describe">
<dt>
<tt class="descname">override</tt></dt>
<dd><p>Enter &#8220;override&#8221; mode. This allows you to add equations &#8220;above&#8221; existing
definitions in the source script, possibly overriding existing
equations. See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for details.</p>
</dd></dl>

<span class="target" id="index-38"></span><dl class="describe">
<dt>
<tt class="descname">pwd</tt></dt>
<dd><p>Print the current working dir (shell <strong class="command">pwd</strong> command).</p>
</dd></dl>

<span class="target" id="index-39"></span><dl class="describe">
<dt>
<tt class="descname">quit</tt></dt>
<dd><p>Exits the interpreter.</p>
</dd></dl>

<span class="target" id="index-40"></span><dl class="describe">
<dt>
<tt class="descname">run [-g|script]</tt></dt>
<dd><p>When invoked without arguments or with the <tt class="docutils literal"><span class="pre">-g</span></tt> option, <tt class="docutils literal"><span class="pre">run</span></tt> does a
&#8220;cold&#8221; restart of the interpreter, with the scripts and options given on
the interpreter&#8217;s original command line. If just <tt class="docutils literal"><span class="pre">-g</span></tt> is specified as the
argument, the interpreter is run with debugging enabled.  Otherwise the
interpreter is invoked without debugging support. (This overrides the
corresponding option from the interpreter&#8217;s command line.)  This command
provides a quick way to rerun the interpreter after changes in some of the
loaded script files, or if you want to enable or disable debugging on the
fly (which requires a restart of the interpreter). You&#8217;ll also loose any
definitions that you entered interactively in the interpreter, so you may
want to back them up with <tt class="docutils literal"><span class="pre">dump</span></tt> beforehand.</p>
<p>When invoked with a script name as argument, <tt class="docutils literal"><span class="pre">run</span></tt> loads the given script
file and adds its definitions to the current environment. This works more
or less like a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause, but only searches for the script in
the current directory and places the definitions in the script at the
current temporary level, so that <tt class="docutils literal"><span class="pre">clear</span></tt> can be used to remove them
again. Also note that namespace and pragma settings of scripts loaded with
<tt class="docutils literal"><span class="pre">run</span></tt> stick around after loading the script. This allows you to quickly
set up your environment by just running a script containing the necessary
namespace declarations and compiler directives. (Alternatively, you can
also use the interpreter&#8217;s startup files for that purpose, see <a class="reference internal" href="#interactive-startup">Interactive
Startup</a> below.)</p>
</dd></dl>

<span class="target" id="index-41"></span><dl class="describe">
<dt>
<tt class="descname">save</tt></dt>
<dd><p>Begin a new level of temporary definitions. A subsequent <tt class="docutils literal"><span class="pre">clear</span></tt> command
(see above) will purge the definitions made since the most recent <tt class="docutils literal"><span class="pre">save</span></tt>
command. See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for details.</p>
</dd></dl>

<span class="target" id="index-42"></span><dl class="describe">
<dt>
<tt class="descname">show [option ...] [symbol ...]</tt></dt>
<dd><p>Show the definitions of symbols in various formats. See <a class="reference internal" href="#the-show-command">The show Command</a>
below for details. All symbols must be specified in fully qualified form,
see the remarks below. A description of the common options accepted by the
<tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands can be found in <a class="reference internal" href="#specifying-symbol-selections">Specifying
Symbol Selections</a> below.</p>
</dd></dl>

<span class="target" id="index-43"></span><dl class="describe">
<dt>
<tt class="descname">stats [-m] [on|off]</tt></dt>
<dd><p>Enables (default) or disables &#8220;stats&#8221; mode, in which some statistics are
printed after an expression has been evaluated. Invoking just <tt class="docutils literal"><span class="pre">stats</span></tt> or
<tt class="docutils literal"><span class="pre">stats</span> <span class="pre">on</span></tt> only prints the cpu time in seconds for each evaluation. If
the <tt class="docutils literal"><span class="pre">-m</span></tt> option is specified, memory usage is printed along with the cpu
time, which indicates the maximum amount of expression memory (in terms of
expression cells) used during the computation. Invoking <tt class="docutils literal"><span class="pre">stats</span> <span class="pre">off</span></tt>
disables stats mode, while <tt class="docutils literal"><span class="pre">stats</span> <span class="pre">-m</span> <span class="pre">off</span></tt> just disables the printing of
the memory usage statistics.</p>
</dd></dl>

<span class="target" id="index-44"></span><dl class="describe">
<dt>
<tt class="descname">trace [symbol ...]</tt></dt>
<dd><p>Sets tracepoints on the given function or operator symbols. This works like
the <tt class="docutils literal"><span class="pre">break</span></tt> command (see above) but only prints rule invocations and
reductions without actually interrupting the evaluation. See <a class="reference internal" href="#debugging">Debugging</a>
below for details.</p>
</dd></dl>

<span class="target" id="index-45"></span><dl class="describe">
<dt>
<tt class="descname">underride</tt></dt>
<dd><p>Exits &#8220;override&#8221; mode. This returns you to the normal mode of operation,
where new equations are added &#8220;below&#8221; previous rules of an existing
function. See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for details.</p>
</dd></dl>

<p>Note that these special commands are only recognized at the beginning of the
interactive command line (they are not reserved keywords of the Pure
language). Thus it&#8217;s possible to &#8220;escape&#8221; identifiers looking like commands by
entering a space at the beginning of the line.</p>
<p>Also note that symbols (identifiers, operators etc.) must always be specified
in fully qualified form. No form of namespace lookup is performed by these
commands, so they always work the same no matter what <tt class="docutils literal"><span class="pre">namespace</span></tt> and
<tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> declarations are currently in effect.</p>
</div>
<div class="section" id="last-result">
<h3><a class="toc-backref" href="#id79">Last Result</a><a class="headerlink" href="#last-result" title="Permalink to this headline">¶</a></h3>
<p>Another convenience for interactive usage is the <a class="reference internal" href="purelib.html#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a> function, which
retrieves the most recent result printed in interactive mode. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact n = <span class="kr">if</span> n&lt;=<span class="mi">1</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n*fact (n-<span class="mi">1</span>)<span class="p">;</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
<span class="gp">&gt; </span>scanl (+) <span class="mi">0</span> ans<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">9</span>,<span class="mi">33</span>,<span class="mi">153</span>,<span class="mi">873</span>,<span class="mi">5913</span>,<span class="mi">46233</span>,<span class="mi">409113</span>,<span class="mi">4037913</span>]
</pre></div>
</div>
<p>Note that <a class="reference internal" href="purelib.html#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a> is just an ordinary function, defined in the prelude,
not a special command. However, there is a special <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">ans</span></tt> command which
purges the <tt class="docutils literal"><span class="pre">ans</span></tt> value. This is useful, e.g., if you got a huge result which
you want to erase from memory before starting the next computation.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>clear ans
<span class="gp">&gt; </span>ans<span class="p">;</span>
ans
</pre></div>
</div>
</div>
<div class="section" id="specifying-symbol-selections">
<h3><a class="toc-backref" href="#id80">Specifying Symbol Selections</a><a class="headerlink" href="#specifying-symbol-selections" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands all accept the following options
for specifying a subset of symbols and definitions on which to operate. All
symbols must be specified in fully qualified form. Options may be combined,
thus, e.g., <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-mft</span></tt> is the same as <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-m</span> <span class="pre">-f</span> <span class="pre">-t</span></tt>. Some options
specify optional numeric parameters; these must follow immediately behind the
option character if present, as in <tt class="docutils literal"><span class="pre">-t0</span></tt>.</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-c</span></kbd></td>
<td>Selects defined constants.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-f</span></kbd></td>
<td>Selects defined functions.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-g</span></kbd></td>
<td>Indicates that the following symbols are actually shell glob patterns and
that all matching symbols should be selected.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-m</span></kbd></td>
<td>Select defined macros.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-p<var>flag</var></span></kbd></td>
<td>Select only private symbols if <em>flag</em> is nonzero (the default), otherwise
(<em>flag</em> is zero) select only public symbols. If this option is omitted
then both private and public symbols are selected.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-t<var>level</var></span></kbd></td>
<td>Select symbols and definitions at the given &#8220;level&#8221; of definitions and
above. This is described in more detail below. Briefly, the executing
program and all imported modules (including the prelude) are at level 0,
while &#8220;temporary&#8221; definitions made interactively in the interpreter are at
level 1 and above. Thus a level of 1 restricts the selection to all
temporary definitions, whereas 0 indicates all definitions (i.e.,
everything, including the prelude). If <em>level</em> is omitted, it defaults to
the current definitions level.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-v</span></kbd></td>
<td>Select defined variables.</td></tr>
</tbody>
</table>
<p>In addition, the <tt class="docutils literal"><span class="pre">-h</span></tt> option prints a short help message describing all
available options of the command at hand.</p>
<p>If none of the <tt class="docutils literal"><span class="pre">-c</span></tt>, <tt class="docutils literal"><span class="pre">-f</span></tt>, <tt class="docutils literal"><span class="pre">-m</span></tt> and <tt class="docutils literal"><span class="pre">-v</span></tt> options are specified, then
all kinds of symbols (constants, functions, macros and variables) are
selected, otherwise only the specified categories will be considered.</p>
<p>A reasonable default is used if the <tt class="docutils literal"><span class="pre">-t</span></tt> option is omitted. By default, if
no symbols are specified, only temporary definitions are considered, which
corresponds to <tt class="docutils literal"><span class="pre">-t1</span></tt>. Otherwise the command applies to all corresponding
definitions, no matter whether they belong to the executing program, the
prelude, or some temporary level, which has the same effect as <tt class="docutils literal"><span class="pre">-t0</span></tt>. This
default choice can be overridden by specifying the desired level explicitly.</p>
<p>As a special case, just <tt class="docutils literal"><span class="pre">clear</span></tt> (without any other options or symbol
arguments) always backs out to the previous definitions level (instead of
level #1). This is inconsistent with the rules set out above, but is
implemented this way for convenience and backward compatibility. Thus, if you
really want to delete all your temporary definitions, use <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">-t1</span></tt>
instead. When used in this way, the <tt class="docutils literal"><span class="pre">clear</span></tt> command will only remove
temporary definitions; if you need to remove definitions at level #0, you must
specify those symbols explicitly.</p>
<p>Note that <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">-g</span> <span class="pre">*</span></tt> will have pretty much the same disastrous
consequences as the Unix command <tt class="docutils literal"><span class="pre">rm</span> <span class="pre">-rf</span> <span class="pre">*</span></tt>, so don&#8217;t do that. Also note
that a macro or function symbol may well have defining equations at different
levels, in which case a command like <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">-tn</span> <span class="pre">foo</span></tt> might only affect some
part of <tt class="docutils literal"><span class="pre">foo</span></tt>&#8216;s definition. The <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands work
analogously (albeit less destructively). See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for
some examples.</p>
</div>
<div class="section" id="the-show-command">
<h3><a class="toc-backref" href="#id81">The show Command</a><a class="headerlink" href="#the-show-command" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">show</span></tt> command can be used to obtain information about defined symbols
in various formats. Besides the common selection options discussed above, this
command recognizes the following additional options for specifying the content
to be listed and the format to use.</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-a</span></kbd></td>
<td>Disassembles pattern matching automata. Works like the <tt class="docutils literal"><span class="pre">-v4</span></tt> option of
the interpreter.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-d</span></kbd></td>
<td>Disassembles LLVM IR, showing the generated LLVM assembler code of a
function. Works like the <tt class="docutils literal"><span class="pre">-v8</span></tt> option of the interpreter.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-e</span></kbd></td>
<td>Annotate printed definitions with lexical environment information (de
Bruijn indices, subterm paths). Works like the <tt class="docutils literal"><span class="pre">-v2</span></tt> option of the
interpreter.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-l</span></kbd></td>
<td>Long format, prints definitions along with the summary symbol
information. This implies <tt class="docutils literal"><span class="pre">-s</span></tt>.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-s</span></kbd></td>
<td>Summary format, print just summary information about listed symbols.</td></tr>
</tbody>
</table>
<p>Symbols are always listed in lexicographic order. Note that some of the
options (in particular, <tt class="docutils literal"><span class="pre">-a</span></tt> and <tt class="docutils literal"><span class="pre">-d</span></tt>) may produce excessive amounts of
information. By setting the <span class="target" id="index-46"></span><a class="reference internal" href="#envvar-PURE_MORE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_MORE</span></tt></a> environment variable, you can
specify a shell command to be used for paging, usually <strong class="command">more</strong> or
<strong class="command">less</strong>.</p>
<p>For instance, to list all temporary definitions made in an interactive
session, simply say:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show
</pre></div>
</div>
<p>You can also list a specific symbol, no matter whether it comes from the
interactive command line, the executing script or the prelude:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show foldl
foldl f a x<span class="p">::</span><span class="kt">matrix</span> = foldl f a (list x)<span class="p">;</span>
foldl f a s<span class="p">::</span><span class="kt">string</span> = foldl f a (chars s)<span class="p">;</span>
foldl f a [] = a<span class="p">;</span>
foldl f a (x:xs) = foldl f (f a x) xs<span class="p">;</span>
</pre></div>
</div>
<p>Wildcards can be used with the <tt class="docutils literal"><span class="pre">-g</span></tt> option, which is useful if you want to
print an entire family of related functions, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show -g foldl*
foldl f a x<span class="p">::</span><span class="kt">matrix</span> = foldl f a (list x)<span class="p">;</span>
foldl f a s<span class="p">::</span><span class="kt">string</span> = foldl f a (chars s)<span class="p">;</span>
foldl f a [] = a<span class="p">;</span>
foldl f a (x:xs) = foldl f (f a x) xs<span class="p">;</span>
foldl1 f x<span class="p">::</span><span class="kt">matrix</span> = foldl1 f (list x)<span class="p">;</span>
foldl1 f s<span class="p">::</span><span class="kt">string</span> = foldl1 f (chars s)<span class="p">;</span>
foldl1 f (x:xs) = foldl f x xs<span class="p">;</span>
</pre></div>
</div>
<p>Or you can just specify multiple symbols as follows (this also works with
multiple glob patterns when you add the <tt class="docutils literal"><span class="pre">-g</span></tt> option):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show min max
max x y = <span class="kr">if</span> x&gt;=y <span class="kr">then</span> x <span class="kr">else</span> y<span class="p">;</span>
min x y = <span class="kr">if</span> x&lt;=y <span class="kr">then</span> x <span class="kr">else</span> y<span class="p">;</span>
</pre></div>
</div>
<p>You can also select symbols by category. E.g., the following command shows
summary information about all the variable symbols along with their current
values (using the &#8220;long&#8221; format):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show -lvg *
argc       var  argc = <span class="mi">0</span><span class="p">;</span>
argv       var  argv = []<span class="p">;</span>
compiling  var  compiling = <span class="mi">0</span><span class="p">;</span>
sysinfo    var  sysinfo = <span class="s">&quot;x86_64-unknown-linux-gnu&quot;</span><span class="p">;</span>
version    var  version = <span class="s">&quot;0.47&quot;</span><span class="p">;</span>
<span class="mi">5</span> variables
</pre></div>
</div>
<p>Or you can list just private symbols of the namespace <tt class="docutils literal"><span class="pre">foo</span></tt>, as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show -pg foo::*
</pre></div>
</div>
<p>The following command will list each and every symbol that&#8217;s currently defined
(instead of <tt class="docutils literal"><span class="pre">-g</span> <span class="pre">*</span></tt> you can also use the <tt class="docutils literal"><span class="pre">-t0</span></tt> option):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show -g *
</pre></div>
</div>
<p>This usually produces a lot of output and is rarely needed, unless you&#8217;d like
to browse through an entire program including all library imports. (In that
case you might consider to use the <tt class="docutils literal"><span class="pre">dump</span></tt> command instead, which writes the
definitions to a file which can then be loaded into a text editor for easier
viewing. This may occasionally be useful for debugging purposes.)</p>
<p>Finally, there are two alternate forms of the <tt class="docutils literal"><span class="pre">show</span></tt> command: <tt class="docutils literal"><span class="pre">show</span>
<span class="pre">namespace</span></tt> which lists the current and search namespaces, and <tt class="docutils literal"><span class="pre">show</span>
<span class="pre">namespaces</span></tt> which lists all declared namespaces. These come in handy if you
have forgotten what namespaces are currently active and which other namespaces
are available in your program. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show namespace
<span class="gp">&gt; </span>show namespaces
<span class="kr">namespace</span> C<span class="p">;</span>
<span class="kr">namespace</span> <span class="kt">matrix</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> C<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span>show namespace
<span class="kr">namespace</span> my<span class="p">;</span>
<span class="kr">using</span> <span class="kr">namespace</span> C<span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="definition-levels">
<h3><a class="toc-backref" href="#id82">Definition Levels</a><a class="headerlink" href="#definition-levels" title="Permalink to this headline">¶</a></h3>
<p>To help with incremental development, the interpreter offers some commands to
manipulate the current set of definitions interactively. To these ends,
definitions are organized into different subsets called <strong class="dfn">levels</strong>. As already
mentioned, the prelude, as well as other source programs specified when
invoking the interpreter, are always at level 0, while the interactive
environment starts at level 1. Each <tt class="docutils literal"><span class="pre">save</span></tt> command introduces a new
temporary level, and each subsequent <tt class="docutils literal"><span class="pre">clear</span></tt> command (without any arguments)
&#8220;pops&#8221; the definitions on the current level and returns you to the previous
one (if any). This gives you a &#8220;stack&#8221; of temporary environments which enables
you to &#8220;plug and play&#8221; in a (more or less) safe fashion, without affecting the
rest of your program.</p>
<p>For all practical purposes, this stack is unlimited, so that you can create as
many levels as you like. However, this facility also has its limitations. The
interpreter doesn&#8217;t really keep a full history of everything you entered
interactively, it only records the level a variable, constant, and function or
macro rule belongs to so that the corresponding definitions can be removed
again when the level is popped. On the other hand, intermediate changes in
variable values are not recorded anywhere and cannot be undone. Moreover,
global declarations (which encompasses <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clauses,
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations and special symbol declarations) always apply
to all levels, so they can&#8217;t be undone either.</p>
<p>That said, the temporary levels can still be pretty useful when you&#8217;re playing
around with the interpreter. Here&#8217;s a little example which shows how to use
<tt class="docutils literal"><span class="pre">clear</span></tt> to quickly get rid of a definition that you entered interactively:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo (x:xs) = x+foo xs<span class="p">;</span>
<span class="gp">&gt; </span>foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>show
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">55</span>
<span class="gp">&gt; </span>clear
This will clear all temporary definitions at level #<span class="mi">1</span>.
Continue (y/n)? y
<span class="gp">&gt; </span>show
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
foo [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>]
</pre></div>
</div>
<p>We&#8217;ve seen already that normally, if you enter a sequence of equations, they
will be recorded in the order in which they were written. However, it is also
possible to override definitions in lower levels with the <tt class="docutils literal"><span class="pre">override</span></tt>
command:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo (x:xs) = x+foo xs<span class="p">;</span>
<span class="gp">&gt; </span>foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>show
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">55</span>
<span class="gp">&gt; </span>save
save: now at temporary definitions level #<span class="mi">2</span>
<span class="gp">&gt; </span>override
<span class="gp">&gt; </span>foo (x:xs) = x*foo xs<span class="p">;</span>
<span class="gp">&gt; </span>show
foo (x:xs) = x*foo xs<span class="p">;</span>
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
warning: rule never reduced: foo (x:xs) = x+foo xs<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>Note that the equation <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">x*foo</span> <span class="pre">xs</span></tt> was inserted before the
previous rule <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">x+foo</span> <span class="pre">xs</span></tt>, which is at level #1. (The latter
equation is now &#8220;shadowed&#8221; by the rule we just entered, hence the compiler
warns us that this rule can&#8217;t be reduced any more.)</p>
<p>Even in override mode, new definitions will be added after other definitions
at the <em>current</em> level. This allows us to just continue adding more
high-priority definitions overriding lower-priority ones:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo [] = <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>show
foo (x:xs) = x*foo xs<span class="p">;</span>
foo [] = <span class="mi">1</span><span class="p">;</span>
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
warning: rule never reduced: foo (x:xs) = x+foo xs<span class="p">;</span>
warning: rule never reduced: foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="mi">3628800</span>
</pre></div>
</div>
<p>Again, the new equation was inserted above the existing lower-priority rules,
but below our previous equation <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">x*foo</span> <span class="pre">xs</span></tt> entered at the same
level. As you can see, we have now effectively replaced our original
definition of <tt class="docutils literal"><span class="pre">foo</span></tt> with a version that calculates list products instead of
sums, but of course we can easily go back one level to restore the previous
definition:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>clear
This will clear all temporary definitions at level #<span class="mi">2</span>.
Continue (y/n)? y
clear: now at temporary definitions level #<span class="mi">1</span>
clear: override mode is on
<span class="gp">&gt; </span>show
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">55</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">clear</span></tt> reminded us that override mode is still enabled (<tt class="docutils literal"><span class="pre">save</span></tt>
will do the same if override mode is on while pushing a new definitions
level). To turn it off again, use the <tt class="docutils literal"><span class="pre">underride</span></tt> command. This will revert
to the normal behaviour of adding new equations below existing ones:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>underride
</pre></div>
</div>
<p>It&#8217;s also possible to use <tt class="docutils literal"><span class="pre">clear</span></tt> to back out multiple levels at once, if
you specify the target level to be cleared with the -t option. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>save
save: now at temporary definitions level #<span class="mi">2</span>
<span class="gp">&gt; </span><span class="kr">let</span> bar = <span class="mi">99</span><span class="p">;</span>
<span class="gp">&gt; </span>show
<span class="kr">let</span> bar = <span class="mi">99</span><span class="p">;</span>
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="c1">// this scraps all our scribblings!</span>
<span class="gp">&gt; </span>clear -t1
This will clear all temporary definitions at level #<span class="mi">1</span> and above.
Continue (y/n)? y
clear: now at temporary definitions level #<span class="mi">1</span>
<span class="gp">&gt; </span>show
<span class="gp">&gt;</span>
</pre></div>
</div>
<p>Finally, it is worth noting here that the facilities described above are also
available to Pure programs, as the <tt class="docutils literal"><span class="pre">save</span></tt> and <tt class="docutils literal"><span class="pre">clear</span></tt> commands can also be
executed under program control using the <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> primitive; see
<a class="reference internal" href="#reflection">Reflection</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section for details.</p>
</div>
<div class="section" id="debugging">
<h3><a class="toc-backref" href="#id83">Debugging</a><a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h3>
<p>The interpreter provides a simple but reasonably convenient symbolic debugging
facility when running interactively. To make this work, you have to specify
the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option when invoking the interpreter (<tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-g</span></tt>). If you&#8217;re
already at the interpreter&#8217;s command line, you can also use the <tt class="docutils literal"><span class="pre">run</span> <span class="pre">-g</span></tt>
command to enable the debugger. The <tt class="docutils literal"><span class="pre">-g</span></tt> option disables tail call
optimization (see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>) to make it easier to debug
programs. It also causes special debugging code to be generated which will
make your program run <em>much</em> slower. Therefore the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option should
only be used if you actually need the debugger.</p>
<p>One common use of the debugger is &#8220;post mortem&#8221; debugging after an evaluation
ended with an unhandled exception. In such a case, the <tt class="docutils literal"><span class="pre">bt</span></tt> command of the
interpreter prints a backtrace of the call sequence which caused the
exception. Note that this only works if debugging mode was enabled. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>[<span class="mi">1</span>,<span class="mi">2</span>]!<span class="mi">3</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 2: </span>unhandled exception &#39;out_of_bounds&#39; while evaluating &#39;[1,2]!3&#39;
<span class="gp">&gt; </span>bt
   [<span class="mi">1</span>] (!): (x:xs)!n<span class="p">::</span><span class="kt">int</span> = xs!(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
     n = <span class="mi">3</span><span class="p">;</span> x = <span class="mi">1</span><span class="p">;</span> xs = [<span class="mi">2</span>]
   [<span class="mi">2</span>] (!): (x:xs)!n<span class="p">::</span><span class="kt">int</span> = xs!(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
     n = <span class="mi">2</span><span class="p">;</span> x = <span class="mi">2</span><span class="p">;</span> xs = []
   [<span class="mi">3</span>] (!): []!n<span class="p">::</span><span class="kt">int</span> = <span class="nb">throw</span> out_of_bounds<span class="p">;</span>
     n = <span class="mi">1</span>
&gt;&gt; [<span class="mi">4</span>] <span class="nb">throw</span>: <span class="kr">extern</span> <span class="kt">void</span> pure_throw(<span class="kt">expr</span>*) = <span class="nb">throw</span><span class="p">;</span>
     x1 = out_of_bounds
</pre></div>
</div>
<p>The last call, which is also marked with the <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> symbol, is the call that
raised the exception. The format is similar to the <tt class="docutils literal"><span class="pre">p</span></tt> command of the
debugger, see below, but <tt class="docutils literal"><span class="pre">bt</span></tt> always prints a full backtrace. (As with the
<tt class="docutils literal"><span class="pre">show</span></tt> command of the interpreter, you can set the <span class="target" id="index-47"></span><a class="reference internal" href="#envvar-PURE_MORE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_MORE</span></tt></a>
environment variable to pipe the output through the corresponding command, or
use <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> to capture the output of <tt class="docutils literal"><span class="pre">bt</span></tt> in a string.)</p>
<p>The debugger can also be used interactively. To these ends, you can set
breakpoints on functions with the <tt class="docutils literal"><span class="pre">break</span></tt> command. The debugger then gets
invoked as soon as a rule for one of the given functions is
executed. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>break fact
<span class="gp">&gt; </span>fact <span class="mi">1</span><span class="p">;</span>
** [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
(Type &#39;h&#39; for help.)
:
** [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
:
++ [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
     --&gt; <span class="mi">1</span>
** [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
:
++ [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
     --&gt; <span class="mi">1</span>
++ [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
     --&gt; <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Lines beginning with <tt class="docutils literal"><span class="pre">**</span></tt> indicate that the evaluation was interrupted to
show the rule (or external) which is currently being considered, along with
the current depth of the call stack, the invoked function and the values of
parameters and other local variables in the current lexical environment. In
contrast, the prefix <tt class="docutils literal"><span class="pre">++</span></tt> denotes reductions which were actually performed
during the evaluation and the results that were returned by the function call
(printed as <tt class="docutils literal"><span class="pre">--&gt;</span> <span class="pre">return</span> <span class="pre">value</span></tt>).</p>
<p>Sometimes you might also see funny symbols like <tt class="docutils literal"><span class="pre">#&lt;closure&gt;</span></tt>, <tt class="docutils literal"><span class="pre">#&lt;case&gt;</span></tt> or
<tt class="docutils literal"><span class="pre">#&lt;when&gt;</span></tt> instead of the function name. These indicate lambdas and the
special variable-binding environments, which are all implemented as anonymous
closures in Pure. Also note that the debugger doesn&#8217;t know about the argument
names of external functions (which are optional in Pure and not recorded
anywhere), so it will display the generic names <tt class="docutils literal"><span class="pre">x1</span></tt>, <tt class="docutils literal"><span class="pre">x2</span></tt> etc. instead.</p>
<p>At the debugger prompt &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; you can enter various special debugger
commands, or just keep on hitting the carriage return key to walk through an
evaluation step by step, as we did in the example above. (Command line editing
works as usual at the debugger prompt, if it is enabled.) The usual commands
are provided to walk through an evaluation, print and navigate the call stack,
step over the current call, or continue the evaluation unattended until you
hit another breakpoint. If you know other source level debuggers like
<strong class="program">gdb</strong> then you should feel right at home. You can type <tt class="docutils literal"><span class="pre">h</span></tt> at the
debugger prompt to print the following list:</p>
<div class="highlight-none"><div class="highlight"><pre>: h
Debugger commands:
a       auto: step through the entire program, run unattended
c [f]   continue until next breakpoint, or given function f
h       help: print this list
n       next step: step over reduction
p [n]   print rule stack (n = number of frames)
r       run: finish evaluation without debugger
s       single step: step into reduction
t, b    move to the top or bottom of the rule stack
u, d    move up or down one level in the rule stack
x       exit the interpreter (after confirmation)
.       reprint current rule
! cmd   shell escape
? expr  evaluate expression
&lt;cr&gt;    single step (same as &#39;s&#39;)
&lt;eof&gt;   step through program, run unattended (same as &#39;a&#39;)
</pre></div>
</div>
<p>The command syntax is very simple. Besides the commands listed above you can
also enter comment lines (<tt class="docutils literal"><span class="pre">//</span> <span class="pre">comment</span> <span class="pre">text</span></tt>) which will just be
ignored. Extra arguments on commands which don&#8217;t expect any will generally be
ignored as well. The single letter commands all have to be separated from any
additional parameters with whitespace, whereas the &#8216;<tt class="docutils literal"><span class="pre">!</span></tt>&#8216;, &#8216;<tt class="docutils literal"><span class="pre">?</span></tt>&#8216; and
&#8216;<tt class="docutils literal"><span class="pre">.</span></tt>&#8216; commands count as word delimiters and can thus be followed immediately
by an argument. For convenience, the &#8216;<tt class="docutils literal"><span class="pre">?</span></tt>&#8216; command can also be omitted if
the expression to be evaluated doesn&#8217;t start with a single letter or one of
the special punctuation commands.</p>
<p>The debugger can be exited or suspended in the following ways:</p>
<ul class="simple">
<li>You can type <tt class="docutils literal"><span class="pre">c</span></tt> to continue the evaluation until the next breakpoint, or
<tt class="docutils literal"><span class="pre">c</span> <span class="pre">foo</span></tt> in order to proceed until the debugger hits an invokation of the
function <tt class="docutils literal"><span class="pre">foo</span></tt>.</li>
<li>You can type <tt class="docutils literal"><span class="pre">r</span></tt> to run the rest of the evaluation without the debugger.</li>
<li>The <tt class="docutils literal"><span class="pre">a</span></tt> (&#8220;auto&#8221;) command single-steps through the rest of the evaluation,
running unattended. This command can also be entered by just hitting the
end-of-file key (<tt class="kbd docutils literal"><span class="pre">Ctrl-d</span></tt> on Unix systems) at the debugger prompt.</li>
<li>You can also type <tt class="docutils literal"><span class="pre">x</span></tt> to exit from the debugger <em>and</em> the interpreter
immediately (after confirmation).</li>
</ul>
<p>At the debugger prompt, you can use the <tt class="docutils literal"><span class="pre">u</span></tt> (&#8220;up&#8221;), <tt class="docutils literal"><span class="pre">d</span></tt> (&#8220;down&#8221;), <tt class="docutils literal"><span class="pre">t</span></tt>
(&#8220;top&#8221;) and <tt class="docutils literal"><span class="pre">b</span></tt> (&#8220;bottom&#8221;) commands to move around on the current call
stack. The <tt class="docutils literal"><span class="pre">p</span></tt> command prints a range of the call stack centered around the
currently selected stack frame, which is indicated with the <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> tag,
whereas <tt class="docutils literal"><span class="pre">**</span></tt> denotes the current bottom of the stack (which is the rule to
be executed with the single step command). The <tt class="docutils literal"><span class="pre">p</span></tt> command can also be
followed by a numeric argument which indicates the number of stack frames to
be printed (this will then become the default for subsequent invocations of
<tt class="docutils literal"><span class="pre">p</span></tt>). The <tt class="docutils literal"><span class="pre">n</span></tt> command steps over the call selected with the stack
navigation commands. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact <span class="mi">3</span><span class="p">;</span>
** [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">3</span>
: c *
** [<span class="mi">4</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
: p
   [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">3</span>
   [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">2</span>
   [<span class="mi">3</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
** [<span class="mi">4</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
: u
&gt;&gt; [<span class="mi">3</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
: u
&gt;&gt; [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">2</span>
: p
   [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">3</span>
&gt;&gt; [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">2</span>
   [<span class="mi">3</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
** [<span class="mi">4</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
: n
++ [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">2</span>
     --&gt; <span class="mi">2</span>
** [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">3</span><span class="p">;</span> y = <span class="mi">2</span>
:
</pre></div>
</div>
<p>If you ever get lost, you can reprint the current rule with the &#8216;<tt class="docutils literal"><span class="pre">.</span></tt>&#8216;
command:</p>
<div class="highlight-pure"><div class="highlight"><pre>: .
** [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">3</span><span class="p">;</span> y = <span class="mi">2</span>
</pre></div>
</div>
<p>Another useful feature is the <tt class="docutils literal"><span class="pre">?</span></tt> command which lets you evaluate any Pure
expression, with the local variables of the current rule bound to their
corresponding values. Like the <tt class="docutils literal"><span class="pre">n</span></tt> command, <tt class="docutils literal"><span class="pre">?</span></tt> applies to the current
stack frame as selected with the stack navigation commands. The expression
must be entered on a single line, and the trailing semicolon is optional. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fact <span class="mi">3</span><span class="p">;</span>
** [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">3</span>
: c *
** [<span class="mi">4</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
: ?x+y
<span class="mi">2</span>
: u
&gt;&gt; [<span class="mi">3</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
: n&gt;<span class="mi">0</span>, fact n
<span class="mi">1</span>,<span class="mi">1</span>
</pre></div>
</div>
<p>A third use of the debugger is to trace function calls. For that the
interpreter provides the <tt class="docutils literal"><span class="pre">trace</span></tt> command which works similarly to <tt class="docutils literal"><span class="pre">break</span></tt>,
but sets so-called &#8220;tracepoints&#8221; which only print rule invocations and
reductions instead of actually interrupting the evaluation. For instance,
assuming the same example as above, let&#8217;s first remove the breakpoint on
<tt class="docutils literal"><span class="pre">fact</span></tt> (using the <tt class="docutils literal"><span class="pre">del</span></tt> command) and then set it as a tracepoint instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>del fact
<span class="gp">&gt; </span>trace fact
<span class="gp">&gt; </span>fact <span class="mi">1</span><span class="p">;</span>
** [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
** [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
++ [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
     --&gt; <span class="mi">1</span>
++ [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
     --&gt; <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">break</span></tt> and <tt class="docutils literal"><span class="pre">trace</span></tt> commands can also be used in concert if you want
to debug some functions while only tracing others.</p>
<p>The current sets of breakpoints and tracepoints can be changed with the
<tt class="docutils literal"><span class="pre">break</span></tt>, <tt class="docutils literal"><span class="pre">trace</span></tt> and <tt class="docutils literal"><span class="pre">del</span></tt> commands, as shown above, and just <tt class="docutils literal"><span class="pre">break</span></tt>
or <tt class="docutils literal"><span class="pre">trace</span></tt> without any arguments lists the currently defined breakpoints or
tracepoints, respectively. Please see <a class="reference internal" href="#interactive-commands">Interactive Commands</a> above for
details. Also note that these are really interpreter commands, so to enter
them you first have to exit the debugger (using the <tt class="docutils literal"><span class="pre">a</span></tt> or <tt class="docutils literal"><span class="pre">r</span></tt> command) if
an evaluation is currently in progress. (However, it&#8217;s possible to set a
temporary breakpoint in the debugger with the <tt class="docutils literal"><span class="pre">c</span></tt> command, see above.)</p>
</div>
<div class="section" id="interactive-startup">
<h3><a class="toc-backref" href="#id84">Interactive Startup</a><a class="headerlink" href="#interactive-startup" title="Permalink to this headline">¶</a></h3>
<p>In interactive mode, the interpreter also runs some additional scripts at
startup, after loading the prelude and the scripts specified on the command
line. This lets you tailor the interactive environment to your liking.</p>
<p>The interpreter first looks for a .purerc file in the user&#8217;s home directory
(as given by the <span class="target" id="index-48"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOME</span></tt> environment variable) and then for a .purerc
file in the current working directory. These are just ordinary Pure scripts
which may contain any additional definitions that you need. The .purerc file
in the home directory is for global definitions which should always be
available when running interactively, while the .purerc file in the current
directory can be used for project-specific definitions.</p>
<p>Finally, you can also have a .pure initialization file in the current
directory, which is usually created with the <tt class="docutils literal"><span class="pre">dump</span></tt> command (see
above). This file is loaded after the .purerc files if it is present.</p>
<p>The interpreter processes all these files in the same way as with the <tt class="docutils literal"><span class="pre">run</span></tt>
command (see above). When invoking the interpreter, you can specify the
<a class="reference internal" href="#cmdoption-pure--norc"><em class="xref std std-option">--norc</em></a> option on the command line if you wish to skip these
initializations.</p>
</div>
</div>
<div class="section" id="batch-compilation">
<h2><a class="toc-backref" href="#id85">Batch Compilation</a><a class="headerlink" href="#batch-compilation" title="Permalink to this headline">¶</a></h2>
<p>The interpreter&#8217;s <a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> option provides a means to turn Pure scripts
into standalone executables. This feature is still a bit experimental. In
particular, note that the compiled executable is essentially a <em>static
snapshot</em> of your program which is executed on the &#8220;bare metal&#8221;, without a
hosting interpreter. Only a minimal runtime system is provided. This
considerably reduces startup times, but also implies the following quirks and
limitations:</p>
<ul class="simple">
<li>All toplevel expressions and <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> bindings are evaluated <em>after</em>
all functions have been defined. This might cause inconsistent behaviour
with an interpreted run of the same program, which executes expressions and
variable definitions immediately, as the program is being processed. To
avoid these semantic differences, you&#8217;ll have to make sure that expressions
are evaluated <em>after</em> all functions used in the evaluation have been defined
completely.</li>
<li>Toplevel expressions won&#8217;t be of much use in a batch-compiled program,
unless, of course, they are evaluated for their side-effects. Usually your
program will have to include at least one of these to play the role of the
&#8220;main program&#8221; in your script. In most cases these expressions are best
placed after all the function and variable definitions, at the end of your
program.</li>
<li>The <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> function can only be used to evaluate plain toplevel
expressions.  You can define local functions and variables in
<a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clauses inside an expression, but you
can&#8217;t use <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> to define new global variables and functions. In
other words, anything which changes the executing program is &#8220;verboten&#8221;.
Moreover, the introspective capabilities provided by <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a>
(discussed under <a class="reference internal" href="#reflection">Reflection</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section) won&#8217;t work
either because the interactive commands are all disabled. If you need any of
these capabilities, you have to run your program with the interpreter.</li>
<li>Constant and macro definitions, being compile time features, aren&#8217;t
available in the compiled program. If you need to use these with
<a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> at run time, you have to provide them through variable and
function definitions instead. Also, the compiler usually strips unused
functions from the output code, so that only functions which are actually
called somewhere in the static program text are available to <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>.
(The <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a> option and the <a class="reference internal" href="#cmdoption-pure--required"><em class="xref std std-option">--required</em></a> pragma can be used to
avoid this, see <a class="reference internal" href="#code-size-and-unstripped-executables">Code Size and Unstripped Executables</a> below.)</li>
<li>Code which gets executed to compute constant values at compile time will
generally <em>not</em> be executed in the compiled executable, so your program
shouldn&#8217;t rely on side-effects of such computations (this would be bad
practice anyway). There is an exception to this rule, however, namely if a
constant value contains run time data such as pointers and local functions
which requires an initialization at run time, then the batch compiler will
generate code for that. (The same happens if the <a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> option
is used to force computation of constant values at run time, see <a class="reference internal" href="#code-size-and-unstripped-executables">Code Size
and Unstripped Executables</a>.)</li>
</ul>
<p>What all this boils down to is that anything which requires the compile time
or interactive facilities of the interpreter, is unavailable. These
restrictions only apply at run time, of course. At compile time the program
<em>is</em> being executed by the interpreter so you can use <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> and
<a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> in any desired way. See the description of the
<tt class="xref pure pure-var docutils literal"><span class="pre">compiling</span></tt> variable below for how to distinguish these cases in your
script.</p>
<p>For most kinds of scripts, the above restrictions aren&#8217;t really that much of
an obstacle, or can easily be worked around. For the few scripts which
actually need the full dynamic capabilities of Pure you&#8217;ll just have to run
the script with the interpreter. This isn&#8217;t a big deal either, only the
startup will be somewhat slower because the script is compiled on the
fly. Once the JIT has done its thing the &#8220;interpreted&#8221; script will run every
bit as fast as the &#8220;compiled&#8221; one, since in fact <em>both</em> are compiled (only at
different times) to exactly the same code!</p>
<p>Also note that during a batch compilation, the compiled program is actually
executed as usual, i.e., the script is also run <em>at compile time</em>. This might
first seem to be a big annoyance, but it actually opens the door for some
powerful programming techniques like <a class="reference external" href="http://en.wikipedia.org/wiki/Partial_evaluation">partial evaluation</a>. It is also a
necessity because of Pure&#8217;s highly dynamic nature. For instance, Pure allows
you to define constants by evaluating an arbitrary expression (see <a class="reference internal" href="#constant-definitions">Constant
Definitions</a> below), and using <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> a program can easily modify
itself in even more unforeseeable ways. Therefore pretty much anything in your
program can actually depend on previous computations performed while the
program is being executed.</p>
<div class="section" id="example">
<h3><a class="toc-backref" href="#id86">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>For the sake of a concrete example, consider the following little script:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> system<span class="p">;</span>

fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>

main n = do puts [<span class="s">&quot;Hello, world!&quot;</span>, str (map fact (<span class="mi">1</span>..n))]<span class="p">;</span>

<span class="kr">if</span> argc&lt;=<span class="mi">1</span> <span class="kr">then</span> () <span class="kr">else</span> main (sscanf (argv!<span class="mi">1</span>) <span class="s">&quot;%d&quot;</span>)<span class="p">;</span>
</pre></div>
</div>
<p>When invoked from the command line, with the number <tt class="docutils literal"><span class="pre">n</span></tt> as the first
parameter, this program will print the string <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></tt> and the list
of the first <tt class="docutils literal"><span class="pre">n</span></tt> factorials:</p>
<div class="highlight-pure"><div class="highlight"><pre>$ pure -x hello.pure <span class="mi">10</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Note the condition on <tt class="docutils literal"><span class="pre">argc</span></tt> in the last line of the script. This prevents
the program from producing an exception if no command line parameters are
specified, so that the program can also be run interactively:</p>
<div class="highlight-pure"><div class="highlight"><pre>$ pure -i -q hello.pure
<span class="gp">&gt; </span>main <span class="mi">10</span><span class="p">;</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
()
<span class="gp">&gt; </span>quit
</pre></div>
</div>
<p>To turn the script into an executable, we just invoke the Pure interpreter
with the <a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> option, using the <a class="reference internal" href="#cmdoption-pure-o"><em class="xref std std-option">-o</em></a> option to specify the
desired output file name:</p>
<div class="highlight-pure"><div class="highlight"><pre>$ pure -c hello.pure -o hello
$ ./hello <span class="mi">10</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Next suppose that we&#8217;d like to supply the value <tt class="docutils literal"><span class="pre">n</span></tt> at <em>compile</em> rather than
run time. To these ends we want to turn the value passed to the <tt class="docutils literal"><span class="pre">main</span></tt>
function into a compile time constant, which can be done as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">const</span> n = <span class="kr">if</span> argc&gt;<span class="mi">1</span> <span class="kr">then</span> sscanf (argv!<span class="mi">1</span>) <span class="s">&quot;%d&quot;</span> <span class="kr">else</span> <span class="mi">10</span><span class="p">;</span>
</pre></div>
</div>
<p>(Note that we provide <tt class="docutils literal"><span class="pre">10</span></tt> as a default if <tt class="docutils literal"><span class="pre">n</span></tt> isn&#8217;t specified on the
command line.)</p>
<p>Moreover, in such a case we usually want to skip the execution of the main
function at compile time. The Pure runtime provides a special system variable
<tt class="xref pure pure-var docutils literal"><span class="pre">compiling</span></tt> which holds a truth value indicating whether the program is
actually running under the auspices of the batch compiler, so that it can
adjust accordingly. In our example, the evaluation of <tt class="docutils literal"><span class="pre">main</span></tt> becomes:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">if</span> compiling <span class="kr">then</span> () <span class="kr">else</span> main n<span class="p">;</span>
</pre></div>
</div>
<p>Our program now looks as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> system<span class="p">;</span>

fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>

main n = do puts [<span class="s">&quot;Hello, world!&quot;</span>, str (map fact (<span class="mi">1</span>..n))]<span class="p">;</span>

<span class="kr">const</span> n = <span class="kr">if</span> argc&gt;<span class="mi">1</span> <span class="kr">then</span> sscanf (argv!<span class="mi">1</span>) <span class="s">&quot;%d&quot;</span> <span class="kr">else</span> <span class="mi">10</span><span class="p">;</span>
<span class="kr">if</span> compiling <span class="kr">then</span> () <span class="kr">else</span> main n<span class="p">;</span>
</pre></div>
</div>
<p>This script &#8220;specializes&#8221; <tt class="docutils literal"><span class="pre">n</span></tt> to the first (compile time) parameter when
being batch-compiled, and it still works as before when we run it through the
interpreter in both batch and interactive mode, too:</p>
<div class="highlight-pure"><div class="highlight"><pre>$ pure -i -q hello.pure
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
<span class="gp">&gt; </span>main <span class="mi">5</span><span class="p">;</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>]
()
<span class="gp">&gt; </span>quit

$ pure -x hello.pure <span class="mi">7</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>]

$ pure -o hello -c -x hello.pure <span class="mi">7</span>
$ ./hello
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>]
</pre></div>
</div>
<p>You&#8217;ll rarely need an elaborate setup like this, most of the time something
like our simple first example will do the trick. But, as you&#8217;ve seen, Pure can
easily do it.</p>
</div>
<div class="section" id="code-size-and-unstripped-executables">
<h3><a class="toc-backref" href="#id87">Code Size and Unstripped Executables</a><a class="headerlink" href="#code-size-and-unstripped-executables" title="Permalink to this headline">¶</a></h3>
<p>By default, the batch compiler strips unused functions from the output code,
to keep the code size small. You can disable this with the <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a>
option, in which case the output code includes <em>all</em> functions defined in the
compiled program or imported through a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause, even if they
don&#8217;t seem to be used anywhere. This considerably increases compilation times
and makes the compiled executable much larger. For instance, on a 64 bit Linux
systems with ELF binaries the executable of our hello.pure example is about
thrice as large:</p>
<div class="highlight-none"><div class="highlight"><pre>$ pure -o hello -c -x hello.pure 7 &amp;&amp; ls -l hello
-rwxr-xr-x 1 ag users 178484 2010-01-12 06:21 hello
$ pure -o hello -c -u -x hello.pure 7 &amp;&amp; ls -l hello
-rwxr-xr-x 1 ag users 541941 2010-01-12 06:21 hello
</pre></div>
</div>
<p>(Note that even the stripped executable is fairly large when compared to
compiled C code, as it still contains the symbol table of the entire program,
which is needed by the runtime environment.)</p>
<p>Stripped executables should be fine for most purposes, but you have to be
careful when using <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> in your compiled program. The compiler only
does a <em>static</em> analysis of which functions might be reached from the
initialization code (i.e., toplevel expressions and <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>
bindings). It does <em>not</em> take into account code run via the <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>
routine. Thus, functions used only in <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>ed code will be stripped
from the executable, as if they were never defined at all. If such a function
is then being called using <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> at runtime, it will evaluate to a
plain constructor symbol.</p>
<p>If this is a problem then you can either use the <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a> option to
produce an unstripped executable, or you can force functions to be included in
the stripped executable with the <a class="reference internal" href="#cmdoption-pure--required"><em class="xref std std-option">--required</em></a> pragma (cf. <a class="reference internal" href="#code-generation-options">Code
Generation Options</a>). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="cp">#! --required foo</span>
foo x = bar (x-<span class="mi">1</span>)<span class="p">;</span>
eval <span class="s">&quot;foo 99&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>There is another code generation option which may have a substantial effect on
code size, namely the <a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> option. Normally, constant values
defined in a <tt class="xref pure pure-func docutils literal"><span class="pre">const</span></tt> definition are precomputed at compile time and then
stored in the generated executable; this reduces startup times but may
increase the code size considerably if your program contains big constant
values such as lists. If you prefer smaller executables then you can use the
<a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> option to force the value of the constant to be recomputed
at run time (which effectively turns the constant into a kind of read-only
variable). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="cp">#! --noconst</span>
<span class="kr">const</span> xs = <span class="mi">1L</span>..<span class="mi">100000L</span><span class="p">;</span>
sum = foldl (+) <span class="mi">0</span><span class="p">;</span>

<span class="kr">using</span> system<span class="p">;</span>
puts $ str $ sum xs<span class="p">;</span>
</pre></div>
</div>
<p>On my 64 bit Linux system this produces a 187115 bytes executable. Without
<a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> the code becomes almost an order of magnitude larger in
this case (1788699 bytes). On the other hand, the smaller executable also
takes a little longer to run since it must first recompute the value of the
list constant at startup. So you have to consider the tradeoffs in a given
situation. Usually big executables aren&#8217;t much of a problem on modern
operating systems, but if your program contains a lot of big constants then
this may become an important consideration. However, if a constant value takes
a long time to compute then you&#8217;ll be better off with the default behaviour of
precomputing the value at compile time.</p>
</div>
<div class="section" id="other-output-code-formats">
<h3><a class="toc-backref" href="#id88">Other Output Code Formats</a><a class="headerlink" href="#other-output-code-formats" title="Permalink to this headline">¶</a></h3>
<p>Note that while the batch compiler generates native executables by default, it
can just as well create object files which can be linked into other C/C++
programs and libraries:</p>
<div class="highlight-none"><div class="highlight"><pre>$ pure -o hello.o -c -x hello.pure 7
</pre></div>
</div>
<p>The .o extension tells the compiler that you want an object file. When linking
the object module, you also need to supply an initialization routine which
calls the <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> function in hello.o to initialize the compiled
module. This routine is declared in C/C++ code as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">__pure_main__</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
</pre></div>
</div>
<p>As indicated, <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> is to be invoked with two parameters, the
argument count and <a class="reference internal" href="purelib.html#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>-terminated argument vector which become the
<tt class="docutils literal"><span class="pre">argc</span></tt> and the <tt class="docutils literal"><span class="pre">argv</span></tt> of the Pure program, respectively. (You can also
just pass 0 for both arguments if you don&#8217;t need to supply command line
parameters.) The purpose of <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> is to initialize a shell
instance of the Pure interpreter which provides the minimal runtime support
necessary to execute the Pure program, and to invoke all &#8220;initialization code&#8221;
(variable definitions and toplevel expressions) of the program itself.</p>
<p>A minimal C <tt class="docutils literal"><span class="pre">main</span></tt> function which does the job of initializing the Pure
module looks as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">void</span> <span class="n">__pure_main__</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__pure_main__</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you link the <tt class="docutils literal"><span class="pre">main</span></tt> routine with the Pure module, don&#8217;t forget to also
pull in the Pure runtime library. Assuming that the above C code is in
pure_main.c:</p>
<div class="highlight-pure"><div class="highlight"><pre>$ gcc -c pure_main.c -o pure_main.o
$ g++ -o hello hello.o pure_main.o -lpure
$ ./hello
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>]
</pre></div>
</div>
<p>(The C++ compiler is used as the linker here so that the standard C++ library
gets linked in, too. This is necessary because Pure&#8217;s runtime library is
actually written in C++.)</p>
<p>In fact, this is pretty much what <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> actually does for you when
creating an executable.</p>
<p>If your script loads dynamic libraries (<tt class="docutils literal"><span class="pre">using</span> <span class="pre">&quot;lib:...&quot;;</span></tt>) then you&#8217;ll also
have to link with those; <em>all</em> external references have to be resolved at
compile time. This is taken care of automatically when creating
executables. Otherwise it is a good idea to run <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> with the
<tt class="docutils literal"><span class="pre">-v0100</span></tt> verbosity option so that it prints the libraries to be linked (in
addition to the commands which are invoked in the compilation process):</p>
<div class="highlight-none"><div class="highlight"><pre>$ pure -v0100 -c hello.pure -o hello.o
opt -f -std-compile-opts hello.o.bc | llc -f -o hello.o.s
gcc -c hello.o.s -o hello.o
Link with: g++ hello.o -lpure
</pre></div>
</div>
<p>Well, we already knew that, so let&#8217;s consider a slightly more interesting
example from Pure&#8217;s ODBC module:</p>
<div class="highlight-none"><div class="highlight"><pre>$ pure -v0100 -c pure-odbc/examples/menagerie.pure -o menagerie.o
opt -f -std-compile-opts menagerie.o.bc | llc -f -o menagerie.o.s
gcc -c menagerie.o.s -o menagerie.o
Link with: g++ menagerie.o /usr/local/lib/pure/odbc.so -lpure
$ g++ -shared -o menagerie.so menagerie.o /usr/local/lib/pure/odbc.so -lpure
</pre></div>
</div>
<p>Note that the listed link options are necessary but might not be sufficient;
<tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> just makes a best guess based on the Pure source. On most systems
this will be good enough, but if it isn&#8217;t, you can just add options to the
linker command as needed to pull in additional required libraries.</p>
<p>As this last example shows, you can also create shared libraries from Pure
modules. However, on some systems (most notably x86_64), this requires that
you pass the <a class="reference internal" href="#cmdoption-pure-fPIC"><em class="xref std std-option">-fPIC</em></a> option when batch-compiling the module, so that
position-independent code is generated:</p>
<div class="highlight-pure"><div class="highlight"><pre>$ pure -c -fPIC pure-odbc/examples/menagerie.pure -o menagerie.o
</pre></div>
</div>
<p>Also note that even when building a shared module, you&#8217;ll have to supply an
initialization routine which calls <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> somewhere.</p>
<p>Last but not least, <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> can also generate just plain LLVM assembler
code:</p>
<div class="highlight-pure"><div class="highlight"><pre>pure -c hello.pure -o hello.ll
</pre></div>
</div>
<p>Note the .ll extension; this tells the compiler that you want an LLVM
assembler file. An LLVM bitcode file can be created just as easily:</p>
<div class="highlight-pure"><div class="highlight"><pre>pure -c hello.pure -o hello.bc
</pre></div>
</div>
<p>In these cases you&#8217;ll have to have to handle the rest of the compilation
yourself. This gives you the opportunity, e.g., to play with special
optimization and code generation options provided by the LLVM
toolchain. Please refer to the <a class="reference external" href="http://llvm.org/docs/">LLVM documentation</a> (in particular, the
description of the opt and llc programs) for details.</p>
</div>
<div class="section" id="calling-pure-functions-from-c">
<h3><a class="toc-backref" href="#id89">Calling Pure Functions From C</a><a class="headerlink" href="#calling-pure-functions-from-c" title="Permalink to this headline">¶</a></h3>
<p>Another point worth mentioning here is that you can&#8217;t just call Pure functions
in a batch-compiled module directly. That&#8217;s because in order to call a Pure
function, at least in the current implementation, you have to set up a Pure
stack frame for the function. However, there&#8217;s a convenience function called
<tt class="docutils literal"><span class="pre">pure_funcall</span></tt> in the runtime API to handle this. This function takes a
pointer to the Pure function, the argument count and the arguments themselves
(as <tt class="docutils literal"><span class="pre">pure_expr*</span></tt> objects) as parameters. For instance, here is a pure_main.c
module which can be linked against the hello.pure program from above, which
calls the <tt class="docutils literal"><span class="pre">fact</span></tt> function from the Pure program:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;pure/runtime.h&gt;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__pure_main__</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">pure_expr</span> <span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">pure_expr</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">__pure_main__</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pure_is_int</span><span class="p">(</span><span class="n">pure_funcall</span><span class="p">(</span><span class="n">fact</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pure_int</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">))</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fact %d = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And here&#8217;s how you can compile, link and run this program:</p>
<div class="highlight-pure"><div class="highlight"><pre>$ pure -o hello.o -c -x hello.pure <span class="mi">7</span>
$ gcc -o pure_main.o -c pure_main.c
$ g++ -o myhello hello.o pure_main.o -lpure
$ ./myhello
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>]
fact <span class="mi">10</span> = <span class="mi">3628800</span>
</pre></div>
</div>
<p>Note that the first two lines are output from the Pure program; the last line
is what gets printed by the <tt class="docutils literal"><span class="pre">main</span></tt> routine in pure_main.c.</p>
</div>
</div>
<div class="section" id="caveats-and-notes">
<h2><a class="toc-backref" href="#id90">Caveats and Notes</a><a class="headerlink" href="#caveats-and-notes" title="Permalink to this headline">¶</a></h2>
<p>This section is a grab bag of casual remarks, useful tips and tricks, and
information on common pitfalls, quirks and limitations of the current
implementation and how to deal with them.</p>
<div class="section" id="etymology">
<h3><a class="toc-backref" href="#id91">Etymology</a><a class="headerlink" href="#etymology" title="Permalink to this headline">¶</a></h3>
<p>People keep asking me what&#8217;s so &#8220;pure&#8221; about Pure. The long and apologetic
answer is that Pure tries to stay as close as possible to the spirit of term
rewriting without sacrificing practicality. It&#8217;s possible and in fact quite
easy to write purely functional programs in Pure, and you&#8217;re encouraged to do
so whenever this is possible or at least reasonable. On the other hand, Pure
doesn&#8217;t get in your way if you want to call external operations with side
effects; it does allow you to call any C function after all.</p>
<p>The short (and true) answer is that I simply liked the name, and there wasn&#8217;t
any programming language named &#8220;Pure&#8221; yet (quite a feat nowadays), so there&#8217;s
one now. If you insist on a (recursive) backronym, just take &#8220;PURE&#8221; to stand
for the &#8220;Pure Universal Rewriting Engine&#8221;.</p>
</div>
<div class="section" id="backward-compatibility">
<h3><a class="toc-backref" href="#id92">Backward Compatibility</a><a class="headerlink" href="#backward-compatibility" title="Permalink to this headline">¶</a></h3>
<p>Pure is based on the author&#8217;s earlier <a class="reference internal" href="#q">Q</a> language, but it offers many new and
powerful features and programs run much faster than their Q equivalents. The
language also went through a thorough facelift in order to modernize the
syntax and make it more similar to other modern-style functional languages, in
particular <a class="reference internal" href="#miranda">Miranda</a> and <a class="reference internal" href="#haskell">Haskell</a>. Thus porting Q scripts to Pure often
involves a substantial amount of manual work, but it can (and has) been done.</p>
<p>Since its modest beginnings in April 2008, Pure has gone through a lot of
major and minor revisions which raise various backward compatibility issues.
We document these in the following, in order to facilitate the porting of
older Pure scripts.</p>
<p>Pure 0.7 introduced built-in matrix structures, which called for some minor
changes in the syntax of comprehensions and arithmetic sequences.
Specifically, the template expression and generator/filter clauses of a
comprehension are now separated with <tt class="docutils literal"><span class="pre">|</span></tt> instead of <tt class="docutils literal"><span class="pre">;</span></tt>. Moreover,
arithmetic sequences with arbitrary stepsize are now written <tt class="docutils literal"><span class="pre">x:y..z</span></tt>
instead of <tt class="docutils literal"><span class="pre">x,y..z</span></tt>, and the &#8216;<tt class="docutils literal"><span class="pre">..</span></tt>&#8216; operator now has a higher precedence
than the &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216; operator. This makes writing matrix slices like
<tt class="docutils literal"><span class="pre">x!!(i..j,k..l)</span></tt> much more convenient.</p>
<p>In Pure 0.13 the naming of the logical and bitwise operations was changed, so
that these are now called <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt>, <tt class="docutils literal"><span class="pre">||</span></tt> and <tt class="docutils literal"><span class="pre">not</span></tt>/<tt class="docutils literal"><span class="pre">and</span></tt>/<tt class="docutils literal"><span class="pre">or</span></tt>,
respectively. (Previously, <tt class="docutils literal"><span class="pre">~</span></tt> was used for bitwise, <tt class="docutils literal"><span class="pre">not</span></tt> for logical
negation, which was rather inconsistent, albeit compatible with the naming of
the <tt class="docutils literal"><span class="pre">not</span></tt> operation in Haskell and ML.) Also, to stay in line with this
naming scheme, inequality was renamed to <tt class="docutils literal"><span class="pre">~=</span></tt> (previously <tt class="docutils literal"><span class="pre">!=</span></tt>).</p>
<p>Pure 0.14 introduced the namespaces feature. Consequently, the scope of
private symbols is now confined to a namespace rather than a source module;
scripts making use of private symbols need to be adapted accordingly. Also
note that syntax like <tt class="docutils literal"><span class="pre">foo::int</span></tt> may now also denote a qualified symbol
rather than a tagged variable, if <tt class="docutils literal"><span class="pre">foo</span></tt> has been declared as a
namespace. You can work around such ambiguities by renaming the variable, or
by placing spaces around the &#8216;<tt class="docutils literal"><span class="pre">::</span></tt>&#8216; delimiter (these aren&#8217;t permitted in a
qualified symbol, so the construct <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">::</span> <span class="pre">int</span></tt> is always interpreted as a
tagged variable, no matter whether <tt class="docutils literal"><span class="pre">foo</span></tt> is also a valid namespace).</p>
<p>Pure 0.26 extended the namespaces feature to add support for hierarchical
namespaces. This means that name lookup works in a slightly different fashion
now (see <a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a> for details), but old code which doesn&#8217;t
use the new feature should continue to work unchanged.</p>
<p>Pure 0.26 also changed the <tt class="xref std std-keyword docutils literal"><span class="pre">nullary</span></tt> keyword to <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>,
which is more consistent with the other kinds of fixity declarations.
Moreover, the parser was enhanced so that it can cope with a theoretically
unbounded number of precedence levels, and the system of standard operators in
the prelude was modified so that it becomes possible to sneak in new operator
symbols with ease; details can be found in the <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a> section.</p>
<p>Pure 0.41 added support for optimization of indirect tail calls, so that any
previous restrictions on the use of tail recursion in indirect function calls
and mutually recursive globals have been removed. Moreover, the logical
operators <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt> are now tail-recursive in their second operand and
can also be extended with user-defined equations, just like the other
builtins. Note that this implies that the values returned by <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt>
aren&#8217;t normalized to the values 0 and 1 any more (this isn&#8217;t possible with
tail call semantics). If you need this then you&#8217;ll have to make sure that
either the operands are already normalized, or you&#8217;ll have to normalize the
result yourself.</p>
<p>Also, as of Pure 0.41 the batch compiler produces stripped executables by
default. To create unstripped executables you now have to use the <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a>
option, see <a class="reference internal" href="#code-size-and-unstripped-executables">Code Size and Unstripped Executables</a> for details. The
<em class="xref std std-option">-s</em> option to produce stripped executables is still provided for
backward compatibility, but it won&#8217;t have any effect unless you use it to
override a previous <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a> option.</p>
<p>Pure 0.43 changed the rules for looking up symbols in user-defined namespaces.
Unqualified symbols are now created in the current (rather than the global)
namespace by default, see <a class="reference internal" href="#symbol-lookup-and-creation">Symbol Lookup and Creation</a> for details. The
<a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option can be used to get warnings about unqualified symbols
which are resolved to a different namespace than previously. It also provides
a means to check your scripts for implicit declarations which might indicate
missing or mistyped function symbols.</p>
<p>Pure 0.45 added support for checking arbitrary pointer types in the C
interface, so that you don&#8217;t have to worry about passing the wrong kinds of
pointers to system and library routines any more. Moreover, the interpretation
of numeric pointer arguments (<tt class="docutils literal"><span class="pre">int*</span></tt> etc.) was changed to bring them in line
with the other new numeric matrix conversions (<tt class="docutils literal"><span class="pre">int**</span></tt> etc.). In particular,
the matrix data can now be modified in-place and type checking is more strict
(<tt class="docutils literal"><span class="pre">int*</span></tt> requires an int matrix, etc.). Also, there&#8217;s now support for
<tt class="docutils literal"><span class="pre">argv</span></tt>-style vector arguments (<tt class="docutils literal"><span class="pre">char**</span></tt> and <tt class="docutils literal"><span class="pre">void**</span></tt>). Please see the <a class="reference internal" href="#c-types">C
Types</a> section for details.</p>
<p>Pure 0.47 added support for declaring variadic externs, so functions like
<tt class="docutils literal"><span class="pre">printf</span></tt> can now be called without much ado; see <a class="reference internal" href="#variadic-c-functions">Variadic C Functions</a> for
details. Also, the syntax used to denote <a class="reference internal" href="#inline-code">inline code</a> sections was changed
from <tt class="docutils literal"><span class="pre">%{...%}</span></tt> to <tt class="docutils literal"><span class="pre">%&lt;...%&gt;</span></tt>. This resolves an ambiguity in the syntax
(note that <tt class="docutils literal"><span class="pre">%{</span></tt> is legal Pure syntax; it could denote a <tt class="docutils literal"><span class="pre">%</span></tt> operator
followed by a matrix value), and also makes it easier to properly support this
construct in Emacs Pure mode.</p>
<p>Pure 0.47 also introduced a new, more flexible type tag feature, which defines
type tags as unary predicates, using normal rewriting rules just as with
ordinary functions. To these ends, a new keyword <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> was added.
Please see section <a class="reference internal" href="#type-rules">Type Rules</a> for details. (In contrast, the old-tyle type
tags were just a syntactic shortcut for &#8220;as&#8221; patterns involving unary
constructor symbols. For the time being, these are still supported, but
considered deprecated. The <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option can be used to get warnings
about these so that you can fix up your scripts accordingly.)</p>
</div>
<div class="section" id="error-recovery">
<h3><a class="toc-backref" href="#id93">Error Recovery</a><a class="headerlink" href="#error-recovery" title="Permalink to this headline">¶</a></h3>
<p>The parser uses a fairly simplistic panic mode error recovery which tries to
catch syntax errors at the toplevel only. This seems to work reasonably well,
but might catch some errors much too late. Unfortunately, Pure&#8217;s terseness
makes it rather difficult to design a better scheme. As a remedy, the parser
accepts an empty definition (just <tt class="docutils literal"><span class="pre">;</span></tt> by itself) at the toplevel only. Thus,
in interactive usage, if the parser seems to eat away your input without doing
anything, entering an extra semicolon or two should break the spell, putting
you back at the toplevel where you can start typing the definition again.</p>
</div>
<div class="section" id="the-show-function">
<h3><a class="toc-backref" href="#id94">The __show__ Function</a><a class="headerlink" href="#the-show-function" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="__show__">
<tt class="descname">__show__</tt> x<a class="headerlink" href="#__show__" title="Permalink to this definition">¶</a></dt>
<dd><p>This function provides a &#8220;hook&#8221; to override the print representations of
expressions at runtime, which works in a fashion similar to Haskell&#8217;s
<tt class="docutils literal"><span class="pre">show</span></tt> function.</p>
</dd></dl>

<p><a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> is just an ordinary Pure function expected to return a string
with the desired custom representation of a normal form value given as the
function&#8217;s single argument. The interpreter prints the strings returned by
<a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> just as they are. It will not check whether they conform to
Pure syntax and/or semantics, or modify them in any way. Also, the library
doesn&#8217;t define this function anywhere, so you are free to add any rules that
you want.</p>
<p>Custom print representations are most useful for interactive purposes, if
you&#8217;re not happy with the default print syntax of some kinds of objects. One
particularly useful application of <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> is to change the format of
numeric values. Here are some examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>__show__ x<span class="p">::</span><span class="kt">double</span> = sprintf <span class="s">&quot;%0.6f&quot;</span> x<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">1</span>/<span class="mi">7</span><span class="p">;</span>
<span class="mf">0.142857</span>
<span class="gp">&gt; </span>__show__ x<span class="p">::</span><span class="kt">int</span> = sprintf <span class="s">&quot;0x%0x&quot;</span> x<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">1786</span><span class="p">;</span>
<span class="mh">0x6fa</span>
<span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span>__show__ (x<span class="p">::</span><span class="kt">double</span> +: y<span class="p">::</span><span class="kt">double</span>) = sprintf <span class="s">&quot;%0.6f+%0.6fi&quot;</span> (x,y)<span class="p">;</span>
<span class="gp">&gt; </span>cis (-pi/<span class="mi">2</span>)<span class="p">;</span>
<span class="mf">0.000000</span>+-<span class="mi">1</span>.000000i
</pre></div>
</div>
<p>The prelude function <a class="reference internal" href="purelib.html#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a>, which returns the print representation of
any Pure expression, calls <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> as well:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>str (<span class="mi">1</span>/<span class="mi">7</span>)<span class="p">;</span>
<span class="s">&quot;0.142857&quot;</span>
</pre></div>
</div>
<p>Conversely, you can call the <a class="reference internal" href="purelib.html#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a> function from <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a>, but
in this case it always returns the default representation of an
expression. This prevents the expression printer from going recursive, and
allows you to define your custom representation in terms of the default
one. E.g., the following rule removes the <tt class="docutils literal"><span class="pre">L</span></tt> suffixes from bigint values:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>__show__ x<span class="p">::</span><span class="kt">bigint</span> = init (str x)<span class="p">;</span>
<span class="gp">&gt; </span>fact n = foldl (*) <span class="mi">1L</span> (<span class="mi">1</span>..n)<span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mi">30</span><span class="p">;</span>
<span class="mi">265252859812191058636308480000000</span>
</pre></div>
</div>
<p>Of course, your definition of <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> can also call <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a>
itself recursively to determine the custom representation of an object.</p>
<p>One case which needs special consideration are thunks (futures). The printer
will <em>never</em> use <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> for those, to prevent them from being forced
inadvertently. In fact, you <em>can</em> use <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> to define custom
representations for thunks, but only in the context of a rule for other kinds
of objects, such as lists. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">nonfix</span> ...<span class="p">;</span>
<span class="gp">&gt; </span>__show__ (x:xs) = str (x:...) <span class="kr">if</span> thunkp xs<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">1</span>:<span class="mi">2</span>:(<span class="mi">3</span>..inf)<span class="p">;</span>
<span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>:...
</pre></div>
</div>
<p>Another case which needs special consideration are numeric matrices. For
efficiency, the expression printer will always use the default representation
for these, unless you override the representation of the matrix as a
whole. E.g., the following rule for double matrices mimics Octave&#8217;s default
output format (for the sake of simplicity, this isn&#8217;t perfect, but you get the
idea):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>__show__ x<span class="p">::</span><span class="kt">matrix</span> =
<span class="gp">&gt; </span>  strcat [printd j (x!(i,j))|i=<span class="mi">0</span>..n-<span class="mi">1</span><span class="p">;</span> j=<span class="mi">0</span>..m-<span class="mi">1</span>] + <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="gp">&gt; </span><span class="kr">with</span> printd <span class="mi">0</span> = sprintf <span class="s">&quot;</span><span class="se">\n</span><span class="s">%10.5f&quot;</span><span class="p">;</span> printd _ = sprintf <span class="s">&quot;%10.5f&quot;</span> <span class="kr">end</span>
<span class="gp">&gt; </span><span class="kr">when</span> n,m = dim x <span class="kr">end</span> <span class="kr">if</span> dmatrixp x<span class="p">;</span>
<span class="gp">&gt; </span>{<span class="mf">1.0</span>,<span class="mi">1</span>/<span class="mi">2</span><span class="p">;</span><span class="mi">1</span>/<span class="mi">3</span>,<span class="mf">4.0</span>}<span class="p">;</span>
   <span class="mf">1.00000</span>   <span class="mf">0.50000</span>
   <span class="mf">0.33333</span>   <span class="mf">4.00000</span>
</pre></div>
</div>
<p>Finally, by just purging the definition of the <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> function you
can easily go back to the standard print syntax:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>clear __show__
<span class="gp">&gt; </span><span class="mi">1</span>/<span class="mi">7</span><span class="p">;</span> <span class="mi">1786</span><span class="p">;</span> cis (-pi/<span class="mi">2</span>)<span class="p">;</span>
<span class="mf">0.142857142857143</span>
<span class="mi">1786</span>
<span class="mf">6.12303176911189e-17</span>+:-<span class="mf">1.0</span>
</pre></div>
</div>
<p>Note that if you have a set of definitions for the <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> function
which should always be loaded at startup, you can put them into the
interpreter&#8217;s interactive startup files, see <a class="reference internal" href="#interactive-usage">Interactive Usage</a>.</p>
</div>
<div class="section" id="non-linear-patterns">
<h3><a class="toc-backref" href="#id95">Non-Linear Patterns</a><a class="headerlink" href="#non-linear-patterns" title="Permalink to this headline">¶</a></h3>
<p>As explained in section <a class="reference internal" href="#patterns">Patterns</a>, Pure allows multiple occurrences of the
same variable in a pattern (so-called non-linearities):</p>
<div class="highlight-pure"><div class="highlight"><pre>foo x x = x<span class="p">;</span>
</pre></div>
</div>
<p>This rule will only be matched if both occurrences of <tt class="docutils literal"><span class="pre">x</span></tt> are bound to the
same value. More precisely, the two instances of <tt class="docutils literal"><span class="pre">x</span></tt> will checked for
syntactic equality during pattern matching, using the <a class="reference internal" href="purelib.html#same" title="same"><tt class="xref pure pure-func docutils literal"><span class="pre">same</span></tt></a> primitive
provided by the prelude. This may need time proportional to the sizes of both
argument terms, and thus become quite costly for big terms. In fact,
<a class="reference internal" href="purelib.html#same" title="same"><tt class="xref pure pure-func docutils literal"><span class="pre">same</span></tt></a> might not even terminate at all if the compared terms are both
infinite lazy data structures, such as in <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(1..inf)</span> <span class="pre">(1..inf)</span></tt>. So you
have to be careful to avoid such uses.</p>
<p>When using non-linearities in conjunction with &#8220;as&#8221; patterns, you also have to
make sure that the &#8220;as&#8221; variable does not occur inside the corresponding
subpattern. Thus a definition like the following is illegal:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo xs<span class="p">@</span>(x:xs) = x<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 1: </span>error in pattern (recursive variable &#39;xs&#39;)
</pre></div>
</div>
<p>The explanation is that such a pattern couldn&#8217;t possibly be matched by a
finite list anyway. Indeed, the only match for <tt class="docutils literal"><span class="pre">xs&#64;(x:xs)</span></tt> would be an
infinite list of <tt class="docutils literal"><span class="pre">x</span></tt>&#8216;s, and there&#8217;s no way that this condition could be
verified in a finite amount of time. Therefore the interpreter reports a
&#8220;recursive variable&#8221; error in such situations.</p>
</div>
<div class="section" id="as-patterns">
<h3><a class="toc-backref" href="#id96">&#8220;As&#8221; Patterns</a><a class="headerlink" href="#as-patterns" title="Permalink to this headline">¶</a></h3>
<p>In the current implementation, &#8220;as&#8221; patterns cannot be placed on the &#8220;spine&#8221;
of a function definition. Thus rules like the following, which have the
pattern somewhere in the head of the left-hand side, will all provoke an error
message from the compiler:</p>
<div class="highlight-pure"><div class="highlight"><pre>a<span class="p">@</span>foo x y   = a,x,y<span class="p">;</span>
a<span class="p">@</span>(foo x) y = a,x,y<span class="p">;</span>
a<span class="p">@</span>(foo x y) = a,x,y<span class="p">;</span>
</pre></div>
</div>
<p>This is because the spine of a function application is not available when the
function is called at runtime. &#8220;As&#8221; patterns in pattern bindings
(<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>, <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>) are not
affected by this restriction since the entire value to be matched is available
at runtime. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">case</span> bar <span class="mi">99</span> <span class="kr">of</span> y<span class="p">@</span>(bar x) = y,x+<span class="mi">1</span><span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
bar <span class="mi">99</span>,<span class="mi">100</span>
</pre></div>
</div>
</div>
<div class="section" id="head-function">
<h3><a class="toc-backref" href="#id97">Head = Function</a><a class="headerlink" href="#head-function" title="Permalink to this headline">¶</a></h3>
<p>&#8220;As&#8221; patterns are also a useful device if you need to manipulate function
applications in a generic way. Note that the &#8220;head = function&#8221; rule means that
the head symbol <tt class="docutils literal"><span class="pre">f</span></tt> of an application <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span></tt> occurring on (or
inside) the left-hand side of an equation, variable binding, or
pattern-matching lambda expression, is always interpreted as a literal
function symbol (not a variable). This implies that you cannot match the
&#8220;function&#8221; component of an application against a variable, at least not
directly. An anonymous &#8220;as&#8221; pattern like <tt class="docutils literal"><span class="pre">f&#64;_</span></tt> does the trick, however,
since the anonymous variable is always recognized, even if it occurs as the
head symbol of a function application. Here&#8217;s a little example which
demonstrates how you can convert a function application to a list containing
the function and all arguments:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo x = a [] x <span class="kr">with</span> a xs (x<span class="p">@</span>_ y) = a (y:xs) x<span class="p">;</span> a xs x = x:xs <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (a b c d)<span class="p">;</span>
[a,b,c,d]
</pre></div>
</div>
<p>This may seem a little awkward, but as a matter of fact the &#8220;head = function&#8221;
rule is quite useful since it covers the common cases without forcing the
programmer to declare &#8220;constructor&#8221; symbols (except nonfix symbols). On the
other hand, generic rules operating on arbitrary function applications are not
all that common, so having to &#8220;escape&#8221; a variable using the anonymous &#8220;as&#8221;
pattern trick is a small price to pay for that convenience.</p>
<p>Sometimes you may also run into the complementary problem, i.e., to match a
function argument against a given function. Consider this code fragment:</p>
<div class="highlight-pure"><div class="highlight"><pre>foo x = x+<span class="mi">1</span><span class="p">;</span>
foop f = <span class="kr">case</span> f <span class="kr">of</span> foo = <span class="mi">1</span><span class="p">;</span> _ = <span class="mi">0</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>You might expect <tt class="docutils literal"><span class="pre">foop</span></tt> to return true for <tt class="docutils literal"><span class="pre">foo</span></tt>, and false on all other
values. Better think again, because in reality <tt class="docutils literal"><span class="pre">foop</span></tt> will always return
true! In fact, the Pure compiler will warn you about the second rule of the
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression not being used at all:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foop <span class="mi">99</span><span class="p">;</span>
warning: rule never reduced: _ = <span class="mi">0</span><span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>This happens because an identifier on the left-hand side of a rule, which is
neither the head symbol of a function application nor a <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>
symbol, is always considered to be a variable (cf. <a class="reference internal" href="#variables-in-equations">Variables in Equations</a>),
even if that symbol is defined as a global function elsewhere.  So <tt class="docutils literal"><span class="pre">foo</span></tt>
isn&#8217;t a literal name in the above <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression, it&#8217;s a variable!
(As a matter of fact, this is rather useful, since otherwise a rule like <tt class="docutils literal"><span class="pre">f</span> <span class="pre">g</span>
<span class="pre">=</span> <span class="pre">g+1</span></tt> would suddenly change meaning if you happen to add a definition like
<tt class="docutils literal"><span class="pre">g</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x-1</span></tt> somewhere else in your program, which certainly isn&#8217;t
desirable.)</p>
<p>A possible workaround is to &#8220;escape&#8221; the function symbol using an empty
namespace qualifier:</p>
<div class="highlight-pure"><div class="highlight"><pre>foop f = <span class="kr">case</span> f <span class="kr">of</span> <span class="p">::</span>foo = <span class="mi">1</span><span class="p">;</span> _ = <span class="mi">0</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This trick works in <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions and function definitions, but
fails in circumstances in which qualified variable symbols are permitted
(i.e., in variable and constant definitions). A better solution is to employ
the syntactic equality operator <tt class="docutils literal"><span class="pre">===</span></tt> defined in the prelude to match the
target value against the function symbol. This allows you to define the
<tt class="docutils literal"><span class="pre">foop</span></tt> predicate as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foop f = f===foo<span class="p">;</span>
<span class="gp">&gt; </span>foop foo, foop <span class="mi">99</span><span class="p">;</span>
<span class="mi">1</span>,<span class="mi">0</span>
</pre></div>
</div>
<p>Another way to deal with the situation would be to just declare <tt class="docutils literal"><span class="pre">foo</span></tt> as a
nonfix symbol. However, this makes the <tt class="docutils literal"><span class="pre">foo</span></tt> symbol &#8220;precious&#8221;, i.e., after
such a declaration it cannot be used as a local variable anymore. It&#8217;s usually
a good idea to avoid that kind of thing, at least for generic symbols, so the
above solution is preferred in this case.</p>
</div>
<div class="section" id="with-and-when">
<h3><a class="toc-backref" href="#id98">With and when</a><a class="headerlink" href="#with-and-when" title="Permalink to this headline">¶</a></h3>
<p>A common source of confusion is that Pure provides two different constructs to
bind local function and variable symbols, respectively. This distinction is
necessary because Pure does not segregate defined functions and constructors,
and thus there is no magic to figure out whether an equation like <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">x</span> <span class="pre">=</span>
<span class="pre">y</span></tt> by itself is meant as a definition of a function <tt class="docutils literal"><span class="pre">foo</span></tt> with formal
parameter <tt class="docutils literal"><span class="pre">x</span></tt> and return value <tt class="docutils literal"><span class="pre">y</span></tt>, or a pattern binding defining the
local variable <tt class="docutils literal"><span class="pre">x</span></tt> by matching the pattern <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">x</span></tt> against the value of
<tt class="docutils literal"><span class="pre">y</span></tt>. The <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> construct does the former, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> the
latter. (As a mnemonic, you may consider that <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> conveys a sense
of time, as the individual variable definitions in a <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause
are executed in order, while the function definitions in a <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>
clause are all done simultaneously.)</p>
<p>Another speciality is that <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clauses are
tacked on to the end of the expression they belong to. This mimics
mathematical language and makes it easy to read and understand a definition in
a &#8220;top-down&#8221; fashion.  This style differs considerably from other
block-structured programming languages, however, which often place local
definitions in front of the code they apply to. To grasp the operational
meaning of such nested definitions, it can be helpful to read the nested
scopes &#8220;in reverse&#8221; (from bottom to top). Some people also prefer to write
their programs that way. In contrast to Haskell and ML which have
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> expressions to support that kind of notation, Pure doesn&#8217;t
provide any special syntax for this. But note that you can always write
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clauses in the following style which places the &#8220;body&#8221; at the
bottom of the clause:</p>
<div class="highlight-pure"><div class="highlight"><pre>result <span class="kr">when</span>
  y = foo (x+<span class="mi">1</span>)<span class="p">;</span>
  z = bar y<span class="p">;</span>
  result = baz z<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This doesn&#8217;t incur any overhead, since the compiler will always eliminate the
trivial &#8220;tail binding&#8221; for the result value. E.g., the above will compile to
exactly the same code as:</p>
<div class="highlight-pure"><div class="highlight"><pre>baz z <span class="kr">when</span>
  y = foo (x+<span class="mi">1</span>)<span class="p">;</span>
  z = bar y<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="numeric-calculations">
<h3><a class="toc-backref" href="#id99">Numeric Calculations</a><a class="headerlink" href="#numeric-calculations" title="Permalink to this headline">¶</a></h3>
<p>If possible, you should decorate numeric variables on the left-hand sides of
function definitions with the appropriate type tags, like <tt class="docutils literal"><span class="pre">int</span></tt> or
<tt class="docutils literal"><span class="pre">double</span></tt>. This often helps the compiler to generate better code and makes
your programs run faster. The <tt class="docutils literal"><span class="pre">|</span></tt> syntax makes it easy to add the necessary
specializations of existing rules to your program. E.g., taking the
polymorphic implementation of the factorial as an example, you only have to
add a left-hand side with the appropriate type tag to make that definition go
as fast as possible for the special case of machine integers:</p>
<div class="highlight-pure"><div class="highlight"><pre>fact n<span class="p">::</span><span class="kt">int</span>    |
fact n         = n*fact(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
               = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>(This obviously becomes unwieldy if you have to deal with several numeric
arguments of different types, however, so in this case it is usually better to
just use a polymorphic rule.)</p>
<p>Also note that int (the machine integers), bigint (the GMP &#8220;big&#8221; integers) and
double (floating point numbers) are all different kinds of objects. While they
can be used in mixed operations (such as multiplying an int with a bigint
which produces a bigint, or a bigint with a double which produces a double),
the <tt class="docutils literal"><span class="pre">int</span></tt> tag will only ever match a machine int, <em>not</em> a bigint or a
double. Likewise, <tt class="docutils literal"><span class="pre">bigint</span></tt> only matches bigints (never int or double
values), and <tt class="docutils literal"><span class="pre">double</span></tt> only doubles. Thus, if you want to define a function
operating on different kinds of numbers, you&#8217;ll also have to provide equations
for all the types that you need (or a polymorphic rule which catches them
all). This also applies to equations matching against constant values of these
types. In particular, a small integer constant like <tt class="docutils literal"><span class="pre">0</span></tt> only matches machine
integers, not bigints; for the latter you&#8217;ll have to use the &#8220;big L&#8221; notation
<tt class="docutils literal"><span class="pre">0L</span></tt>. Similarly, the constant <tt class="docutils literal"><span class="pre">0.0</span></tt> only matches doubles, but not ints or
bigints.</p>
</div>
<div class="section" id="constant-definitions">
<h3><a class="toc-backref" href="#id100">Constant Definitions</a><a class="headerlink" href="#constant-definitions" title="Permalink to this headline">¶</a></h3>
<p>Constants differ from variables in that they cannot be redefined (that&#8217;s their
main purpose after all) so that their values, once defined, can be substituted
into other definitions which use them. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">const</span> c = <span class="mi">2</span><span class="p">;</span>
<span class="gp">&gt; </span>foo x = c*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = <span class="mi">2</span>*x<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
</pre></div>
</div>
<p>While a variable can be rebound to a new value at any time, you will get an
error message if you try to do this with a constant:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">const</span> c = <span class="mi">3</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 5: </span>symbol &#39;c&#39; is already defined as a constant
</pre></div>
</div>
<p>Note that in interactive mode you can work around this by purging the old
definition with the <tt class="docutils literal"><span class="pre">clear</span></tt> command. However, this won&#8217;t affect any earlier
uses of the symbol:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>clear c
<span class="gp">&gt; </span><span class="kr">const</span> c = <span class="mi">3</span><span class="p">;</span>
<span class="gp">&gt; </span>bar x = c*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo bar
bar x = <span class="mi">3</span>*x<span class="p">;</span>
foo x = <span class="mi">2</span>*x<span class="p">;</span>
</pre></div>
</div>
<p>(You&#8217;ll also have to purge any existing definition of a variable if you want
to redefine it as a constant, or vice versa, since Pure won&#8217;t let you redefine
an existing constant or variable as a different kind of symbol. The same also
holds if a symbol is currently defined as a function or a macro.)</p>
<p>Constants can also be used in patterns (i.e., on the left-hand side of a rule
in a definition or a <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression), but only if you also declare
the corresponding symbol as <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>. This is useful, e.g., if you&#8217;d
like to use constants such as <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a> and <a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> on the
left-hand side of a definition, just like other <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> symbols:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show false true
<span class="kr">const</span> false = <span class="mi">0</span><span class="p">;</span>
<span class="kr">const</span> true = <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">nonfix</span> false true<span class="p">;</span>
<span class="gp">&gt; </span>check false = <span class="s">&quot;no&quot;</span><span class="p">;</span> check true = <span class="s">&quot;yes&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>show check
check <span class="mi">0</span> = <span class="s">&quot;no&quot;</span><span class="p">;</span>
check <span class="mi">1</span> = <span class="s">&quot;yes&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>check (<span class="mi">5</span>&gt;<span class="mi">0</span>)<span class="p">;</span>
<span class="s">&quot;yes&quot;</span>
</pre></div>
</div>
<p>Note that without the <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> declaration, the above definition of
<tt class="docutils literal"><span class="pre">check</span></tt> wouldn&#8217;t work as intended, because the <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a> and
<a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> symbols on the left-hand side of the two equations would be
interpreted as local variables. Also note that the standard library never
declares any constant symbols as <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>, since once a symbol is
<a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> there&#8217;s no going back. Thus the library leaves this to the
programmer to decide.</p>
<p>As the value of a constant is known at compile time, the compiler can apply
various optimizations to uses of such values. In particular, the Pure compiler
inlines constant scalars (numbers, strings and pointers) by literally
substituting their values into the output code, and it also precomputes simple
constant expressions involving only (machine) integer and double
values. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> atan(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">const</span> pi = <span class="mi">4</span>*atan <span class="mf">1.0</span><span class="p">;</span>
<span class="gp">&gt; </span>show pi
<span class="kr">const</span> pi = <span class="mf">3.14159265358979</span><span class="p">;</span>
<span class="gp">&gt; </span>foo x = <span class="mi">2</span>*pi*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = <span class="mf">6.28318530717959</span>*x<span class="p">;</span>
</pre></div>
</div>
<p>In addition, the LLVM backend eliminates dead code automatically, so you can
employ a constant to configure your code for different environments, without
any runtime penalties:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">const</span> win = index sysinfo <span class="s">&quot;mingw32&quot;</span> &gt;= <span class="mi">0</span><span class="p">;</span>
check boy = bad boy <span class="kr">if</span> win<span class="p">;</span>
          = good boy <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>In this case the code for one of the branches of <tt class="docutils literal"><span class="pre">check</span></tt> will be completely
eliminated, depending on the outcome of the configuration check.</p>
<p>For efficiency, constant aggregates (lists, tuples, matrices and other kinds
of non-scalar terms) receive special treatment. Here, the constant is computed
once and stored in a read-only variable which then gets looked up at runtime,
just like an ordinary global variable. However, there&#8217;s an important
difference: If a script is batch-compiled (cf. <a class="reference internal" href="#batch-compilation">Batch Compilation</a>), the
constant value is normally computed <em>at compile time only</em>; when running the
compiled executable, the constant value is simply reconstructed, which is
often much more efficient than recomputing its value. For instance, you might
use this to precompute a large table whose computation may be costly or
involve functions with side effects:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">const</span> table = [foo x | x = <span class="mi">1</span>..<span class="mi">1000000</span>]<span class="p">;</span>
process table<span class="p">;</span>
</pre></div>
</div>
<p>Note that this only works with <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> values which are completely
determined at compile time. If a constant contains run time objects such as
pointers and (local) functions, this is impossible, and the batch compiler
will instead create code to recompute the value of the constant at run time.
For instance, consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> system<span class="p">;</span>
<span class="kr">const</span> p = malloc <span class="mi">100</span><span class="p">;</span>
foo p<span class="p">;</span>
</pre></div>
</div>
<p>Here, the value of the pointer <tt class="docutils literal"><span class="pre">p</span></tt> of course critically depends on its
computation (involving a side effect which sets aside a corresponding chunk of
memory). It would become unusable without actually executing the
initialization, so the compiler generates the appropriate run time
initialization code in this case. For all practical purposes, this turns the
constant into a read-only variable. (There&#8217;s also a code generation option to
force this behaviour even for &#8220;normal&#8221; constants for which it&#8217;s not strictly
necessary, in order to create smaller executables; see <a class="reference internal" href="#code-size-and-unstripped-executables">Code Size and
Unstripped Executables</a> for details.)</p>
</div>
<div class="section" id="external-c-functions">
<h3><a class="toc-backref" href="#id101">External C Functions</a><a class="headerlink" href="#external-c-functions" title="Permalink to this headline">¶</a></h3>
<p>The interpreter always takes your <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations of C routines
at face value. It will not go and read any C header files to determine whether
you actually declared the function correctly! So you have to be careful to
give the proper declarations, otherwise your program might well give a
segfault when calling the function. This problem can to some extent be
alleviated by using the bitcode interface, see <a class="reference internal" href="#importing-llvm-bitcode">Importing LLVM Bitcode</a> and
<a class="reference internal" href="#inline-code">Inline Code</a> in the <a class="reference internal" href="#c-interface">C Interface</a> section. However, you always have to be
careful when calling <a class="reference internal" href="#variadic-c-functions">variadic C functions</a>, as the compiler has no way of
checking which combinations of extra parameters a function like <tt class="docutils literal"><span class="pre">printf</span></tt> is
to be invoked with. (As a remedy, the standard library provides safe
implementations of <a class="reference internal" href="purelib.html#printf" title="printf"><tt class="xref pure pure-func docutils literal"><span class="pre">printf</span></tt></a> and other commonly used variadic functions
from the C library, see the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.)</p>
<p>Another limitation of the C interface is that it does not offer any special
support for C structs and C function parameters. However, an optional addon
module is available which interfaces to the <a class="reference external" href="http://sourceware.org/libffi/">libffi</a> library to provide that
kind of functionality, please see <a class="reference internal" href="pure-ffi.html"><em>pure-ffi</em></a> for details.</p>
<p>Last but not least, to make it easier to create Pure interfaces to large C
libraries, there&#8217;s a separate pure-gen program available at the Pure website.
This program takes a C header (.h) file and creates a corresponding Pure
module with definitions and <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations for the constants
and functions declared in the header. Please refer to <a class="reference internal" href="pure-gen.html"><em>pure-gen: Pure interface generator</em></a> for
details.</p>
</div>
<div class="section" id="calling-special-forms">
<h3><a class="toc-backref" href="#id102">Calling Special Forms</a><a class="headerlink" href="#calling-special-forms" title="Permalink to this headline">¶</a></h3>
<p>Special forms are recognized at compile time only. Thus the <a class="reference internal" href="#catch" title="catch"><tt class="xref pure pure-func docutils literal"><span class="pre">catch</span></tt></a>
function, as well as <a class="reference internal" href="#quote" title="quote"><tt class="xref pure pure-func docutils literal"><span class="pre">quote</span></tt></a> and the operators <a class="reference internal" href="#&amp;&amp;/special" title="&amp;&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;&amp;</span></tt></a>,
<a class="reference internal" href="#||/special" title="||"><tt class="xref pure pure-func docutils literal"><span class="pre">||</span></tt></a>, <a class="reference internal" href="#$$" title="$$"><tt class="xref pure pure-func docutils literal"><span class="pre">$$</span></tt></a> and <a class="reference internal" href="#&amp;" title="&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;</span></tt></a>, are only treated as special
forms in direct (saturated) calls. They can still be used if you pass them
around as function values or in partial applications, but in this case they
lose all their special call-by-name argument processing.</p>
</div>
<div class="section" id="laziness">
<h3><a class="toc-backref" href="#id103">Laziness</a><a class="headerlink" href="#laziness" title="Permalink to this headline">¶</a></h3>
<p>Pure does lazy evaluation in the same way as <a class="reference internal" href="#alice-ml">Alice ML</a>, providing an
explicit operation (<a class="reference internal" href="#&amp;" title="&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;</span></tt></a>) to defer evaluation and create a &#8220;future&#8221; which
is called by need. However, note that like any language with a basically eager
evaluation strategy, Pure cannot really support lazy evaluation in a fully
automatic way. That is, coding an operation so that it works with infinite
data structures usually requires additional thought, and sometimes special
code will be needed to recognize futures in the input and handle them
accordingly. This can be hard, but of course in the case of the prelude
operations this work has already been done for you, so as long as you stick to
these, you&#8217;ll never have to think about these issues. (It should be noted here
that lazy evaluation has its pitfalls even in fully lazy FPLs, such as hidden
memory leaks and other kinds of subtle inefficiencies or non-termination
issues resulting from definitions being too lazy or not lazy enough. You can
read about that in any good textbook on Haskell.)</p>
<p>The prelude goes to great lengths to implement all standard list operations in
a way that properly deals with streams (a.k.a. lazy lists). What this all
boils down to is that all list operations which can reasonably be expected to
operate in a lazy way on streams, will do so. (Exceptions are inherently eager
operations such as <a class="reference internal" href="purelib.html##" title="#"><tt class="xref pure pure-func docutils literal"><span class="pre">#</span></tt></a>, <a class="reference internal" href="purelib.html#reverse" title="reverse"><tt class="xref pure pure-func docutils literal"><span class="pre">reverse</span></tt></a> and <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>.) Only those
portions of an input stream will be traversed which are strictly required to
produce the result. For most purposes, this works just like in fully lazy FPLs
such as Haskell. However, there are some notable differences:</p>
<ul class="simple">
<li>Since Pure uses dynamic typing, some of the list functions may have to peek
ahead one element in input streams to check their arguments for validity,
meaning that these functions will be slightly more eager than their Haskell
counterparts.</li>
<li>Pure&#8217;s list functions never produce truly cyclic list structures such as the
ones you get, e.g., with Haskell&#8217;s <tt class="docutils literal"><span class="pre">cycle</span></tt> operation. (This is actually a
good thing, because the current implementation of the interpreter cannot
garbage-collect cyclic expression data.) Cyclic streams such as <tt class="docutils literal"><span class="pre">cycle</span>
<span class="pre">[1]</span></tt> or <tt class="docutils literal"><span class="pre">fix</span> <span class="pre">(1:)</span></tt> will of course work as expected, but, depending
on the algorithm, memory usage may increase linearly as they are traversed.</li>
<li>Pattern matching is always refutable (and therefore eager) in Pure. If you
need something like Haskell&#8217;s irrefutable matches, you&#8217;ll have to code them
explicitly using futures. See the definition of the <a class="reference internal" href="purelib.html#unzip" title="unzip"><tt class="xref pure pure-func docutils literal"><span class="pre">unzip</span></tt></a> function
in the prelude for an example showing how to do this.</li>
</ul>
<p>Here are some common pitfalls with lazy data structures in Pure that you
should be aware of:</p>
<ul>
<li><p class="first">Laziness and side effects don&#8217;t go well together, as most of the time you
can&#8217;t be sure when a given thunk will be executed. So as a general guideline
you should avoid side effects in thunked data structures. If you can&#8217;t avoid
them, then at least make sure that all accesses to the affected resources
are done through a single instance of the thunked data structure. E.g., the
following definition lets you create a stream of random numbers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> xs = [random | _ = <span class="mi">1</span>..inf]<span class="p">;</span>
</pre></div>
</div>
<p>This works as expected if only a single stream created with <a class="reference internal" href="purelib.html#random" title="random"><tt class="xref pure pure-func docutils literal"><span class="pre">random</span></tt></a>
exists in your program. However, as the <a class="reference internal" href="purelib.html#random" title="random"><tt class="xref pure pure-func docutils literal"><span class="pre">random</span></tt></a> function in the
<a class="reference internal" href="purelib.html#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module modifies an internal data structure to produce a
sequence of pseudorandom numbers, using two or more such streams in your
program will in fact modify the same underlying data structure and thus
produce two disjoint subsequences of the same underlying pseudorandom
sequence which might not be distributed uniformly any more.</p>
</li>
<li><p class="first">You should avoid keeping references to potentially big (or even infinite)
thunked data structures when traversing them (unless you specifically need
to memoize the entire data structure). In particular, if you assign such a
data structure to a local variable, the traversal of the data structure
should then be invoked as a tail call. If you fail to do this, it forces the
entire memoized part of the data structure to stay in main memory while it
is being traversed, leading to rather nasty memory leaks. Please see the
<tt class="docutils literal"><span class="pre">all_primes</span></tt> function in <a class="reference internal" href="#lazy-evaluation-and-streams">Lazy Evaluation and Streams</a> for an example.</p>
</li>
</ul>
</div>
<div class="section" id="reflection">
<h3><a class="toc-backref" href="#id104">Reflection</a><a class="headerlink" href="#reflection" title="Permalink to this headline">¶</a></h3>
<p>Pure versions since 0.12 offer some basic reflection capabilities via the
<a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> primitive. This function provides access to interactive
commands like <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">save</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt>, which enable you to inspect
and modify the running program. The only &#8220;canonical&#8221; way to represent an
entire Pure program in Pure itself is the program text, hence <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a>
only provides a textual interface at this time. But of course custom
higher-level representations can be built on top of that, similar to those
discussed in section <a class="reference internal" href="#the-quote">The Quote</a>.</p>
<p>Here&#8217;s an example showing what can be done using the <tt class="docutils literal"><span class="pre">show</span></tt> command and a
little bit of trivial text processing. The following <tt class="docutils literal"><span class="pre">sym_info</span></tt> function
retrieves information about a given collection of global symbols in a way
which can be processed in a Pure program. The <tt class="docutils literal"><span class="pre">cat</span></tt> argument can be any
combination of the letters &#8220;c&#8221;, &#8220;v&#8221;, &#8220;f&#8221; and &#8220;m&#8221; denoting the categories of
constants, variables, functions and macros, respectively. (You can also just
leave this empty if you don&#8217;t care about the type of symbol.) The <tt class="docutils literal"><span class="pre">pat</span></tt>
argument is a shell-like glob pattern for the name of symbols which should be
listed (just &#8220;*&#8221; matches all symbols). The result is a list of tuples <tt class="docutils literal"><span class="pre">(name,</span>
<span class="pre">value,</span> <span class="pre">cat,</span> <span class="pre">descr)</span></tt> with the name of the symbol and its value, as well as the
category and description of the symbol, as provided by <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-s</span></tt>.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> system<span class="p">;</span>
sym_info cat<span class="p">::</span><span class="kt">string</span> pat<span class="p">::</span><span class="kt">string</span>
= [name,eval (<span class="s">&quot;(&quot;</span>+name+<span class="s">&quot;)&quot;</span>),descr | name,descr = info]
<span class="kr">when</span>
  <span class="c1">// Get the info about matching symbols from the &#39;show&#39; command.</span>
  info = evalcmd $ sprintf <span class="s">&quot;show -sg%s %s&quot;</span> (cat,pat)<span class="p">;</span>
  <span class="c1">// Split into lines.</span>
  info = <span class="kr">if</span> null info <span class="kr">then</span> [<span class="s">&quot;&quot;</span>] <span class="kr">else</span> split <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> $ init info<span class="p">;</span>
  <span class="c1">// Get rid of the last line with the summary information.</span>
  info = init info<span class="p">;</span>
  <span class="c1">// Retrieve the information that we need.</span>
  info = [x | x<span class="p">@</span>(s,_) = map fields info<span class="p">;</span>
  <span class="c1">// Get rid of extra lines containing extern and fixity declarations.</span>
          s ~= <span class="s">&quot;extern&quot;</span> &amp;&amp; s ~= <span class="s">&quot;nonfix&quot;</span> &amp;&amp; s ~= <span class="s">&quot;outfix&quot;</span> &amp;&amp;
          s ~= <span class="s">&quot;prefix&quot;</span> &amp;&amp; s ~= <span class="s">&quot;postfix&quot;</span> &amp;&amp; ~fnmatch <span class="s">&quot;infix*&quot;</span> s <span class="mi">0</span>]<span class="p">;</span>
<span class="kr">end</span> <span class="kr">with</span>
  <span class="c1">// Regex call to split the summary information about one symbol, as</span>
  <span class="c1">// returned by &#39;show -s&#39;, into the name and description parts.</span>
  fields s<span class="p">::</span><span class="kt">string</span> = tuple $
          [info!<span class="mi">2</span> | info = tail $ regs $ reg_info $
           regex <span class="s">&quot;([^ ]+)[ ]+([a-z]*)[ ]*(.*)&quot;</span> REG_EXTENDED s <span class="mi">0</span>]<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>E.g., this call retrieves information about all defined macros:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>sym_info <span class="s">&quot;m&quot;</span> <span class="s">&quot;*&quot;</span><span class="p">;</span>
[(<span class="s">&quot;$&quot;</span>,($),<span class="s">&quot;mac&quot;</span>,<span class="s">&quot;2 args, 1 rules&quot;</span>),(<span class="s">&quot;.&quot;</span>,(.),<span class="s">&quot;mac&quot;</span>,<span class="s">&quot;3 args, 1 rules&quot;</span>),
(<span class="s">&quot;void&quot;</span>,<span class="kt">void</span>,<span class="s">&quot;mac&quot;</span>,<span class="s">&quot;1 args, 6 rules&quot;</span>)]
</pre></div>
</div>
</div>
<div class="section" id="hygienic-macros">
<h3><a class="toc-backref" href="#id105">Hygienic Macros</a><a class="headerlink" href="#hygienic-macros" title="Permalink to this headline">¶</a></h3>
<p>As mentioned in the <a class="reference internal" href="#macro-hygiene">Macro Hygiene</a> section, Pure macros are lexically scoped
and thus &#8220;hygienic&#8221;. So Pure macros are not suceptible to name capture, but
there is also one Pure-related caveat here. The expression printer currently
doesn&#8217;t check for different bindings of the same variable identifier when it
prints a (compile time) expression. For instance, consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">def</span> F x = x+y <span class="kr">when</span> y = x+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>foo y = F y<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo y = y+y <span class="kr">when</span> y = y+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This <em>looks</em> as if <tt class="docutils literal"><span class="pre">y</span></tt> got captured, but in fact it&#8217;s not, it&#8217;s just the
<tt class="docutils literal"><span class="pre">show</span></tt> command which displays the definition in an incorrect way. You can
add the <tt class="docutils literal"><span class="pre">-e</span></tt> option to <tt class="docutils literal"><span class="pre">show</span></tt> which prints the deBruijn indices of locally
bound symbols, then you see that the actual bindings are all right anyway
(note that the number before the colon is the actual deBruijn index, the
sequence of bits behind it is the subterm path):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>show -e foo
foo y<span class="cm">/*0:1*/</span> = y<span class="cm">/*1:1*/</span>+y<span class="cm">/*0:*/</span> <span class="kr">when</span> y<span class="cm">/*0:*/</span> = y<span class="cm">/*0:1*/</span>+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Alas, this means that if you use <tt class="docutils literal"><span class="pre">dump</span></tt> to write such a definition to a text
file and read it back with <tt class="docutils literal"><span class="pre">run</span></tt> later, then you&#8217;ll get the wrong
definition. This is an outright bug in the expression printer which will
hopefully be fixed some time. But for the time being you will have to correct
such glitches manually.</p>
</div>
<div class="section" id="stack-size-and-tail-recursion">
<h3><a class="toc-backref" href="#id106">Stack Size and Tail Recursion</a><a class="headerlink" href="#stack-size-and-tail-recursion" title="Permalink to this headline">¶</a></h3>
<p>Pure programs may need a considerable amount of stack space to handle
recursive function and macro calls, and the interpreter itself also takes its
toll. So you should configure your system accordingly (8 MB of stack space is
recommended for 32 bit systems, systems with 64 bit pointers probably need
more). If the <span class="target" id="index-49"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a> environment variable is defined, the
interpreter performs advisory stack checks on function entry and raises a Pure
exception if the current stack size exceeds the given limit. The value of
<span class="target" id="index-50"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a> should be the maximum stack size in kilobytes. Please
note that this is only an advisory limit which does not change the program&#8217;s
physical stack size.  Your operating system should supply you with a command
such as ulimit(1) to set the real process stack size. (The
<span class="target" id="index-51"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a> limit should be a little less than that, to account for
temporary stack usage by the interpreter itself.)</p>
<p>Like Scheme, Pure does proper tail calls (if LLVM provides that feature on the
platform at hand), so tail-recursive definitions should work fine in limited
stack space. For instance, the following little program will loop forever if
your platform supports the required optimizations:</p>
<div class="highlight-pure"><div class="highlight"><pre>loop = loop<span class="p">;</span>
loop<span class="p">;</span>
</pre></div>
</div>
<p>This also works if your definition involves function parameters, guards and
multiple equations, of course. Moreover, conditional expressions
(<a class="reference internal" href="#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a>-<a class="reference internal" href="#then"><tt class="xref std std-keyword docutils literal"><span class="pre">then</span></tt></a>-<a class="reference internal" href="#else"><tt class="xref std std-keyword docutils literal"><span class="pre">else</span></tt></a>) are tail-recursive in both
branches, and the logical operators <a class="reference internal" href="#&amp;&amp;/special" title="&amp;&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;&amp;</span></tt></a> and <a class="reference internal" href="#||/special" title="||"><tt class="xref pure pure-func docutils literal"><span class="pre">||</span></tt></a>,
as well as the sequence operator <a class="reference internal" href="#$$" title="$$"><tt class="xref pure pure-func docutils literal"><span class="pre">$$</span></tt></a>, are tail-recursive in their
second operand.</p>
<p>Also note that tail call optimization is <em>always</em> disabled if the debugger is
enabled (-g). This makes it much easier to debug programs, but means that you
may run into stack overflows when debugging a program that does deep tail
recursion.</p>
</div>
<div class="section" id="handling-of-asynchronous-signals">
<h3><a class="toc-backref" href="#id107">Handling of Asynchronous Signals</a><a class="headerlink" href="#handling-of-asynchronous-signals" title="Permalink to this headline">¶</a></h3>
<p>As described in section <a class="reference internal" href="#exception-handling">Exception Handling</a>, signals delivered to the
process can be caught and handled with Pure&#8217;s exception handling facilities.
This has its limitations, however. Since Pure code cannot be executed directly
from a C signal handler, checks for pending signals are only done on function
entry. This means that in certain situations (such as the execution of an
external C routine), delivery of a signal may be delayed by an arbitrary
amount of time. Moreover, if more than one signal arrives between two
successive signal checks, only the last one will be reported in the current
implementation.</p>
<p>When delivering a signal which has been remapped to a Pure exception, the
corresponding exception handler (if any) will be invoked as usual. Further
signals are blocked while the exception handler is being executed.</p>
<p>A fairly typical case is that you have to handle signals in a tail-recursive
function. This can be done with code like the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> system<span class="p">;</span>

<span class="c1">// Remap some common POSIX signals.</span>
do (trap SIG_TRAP) [SIGHUP, SIGINT, SIGTERM]<span class="p">;</span>

loop = <span class="nb">catch</span> handler process $$ loop
<span class="kr">with</span> handler (signal k) = printf <span class="s">&quot;Hey, I got signal %d.</span><span class="se">\n</span><span class="s">&quot;</span> k <span class="kr">end</span><span class="p">;</span>
process = sleep <span class="mi">1</span><span class="p">;</span> <span class="c1">// do something</span>
</pre></div>
</div>
<p>Running the above <tt class="docutils literal"><span class="pre">loop</span></tt> function enters an endless loop reporting all
signals delivered to the process. Note that to make this work, the
tail-recursive invocation of <tt class="docutils literal"><span class="pre">loop</span></tt> must immediately follow the
signal-handling code, so that signals don&#8217;t escape the exception handler.</p>
<p>Of course, in a real application you&#8217;d probably want the <tt class="docutils literal"><span class="pre">loop</span></tt> function to
carry around some data to be processed by the <tt class="docutils literal"><span class="pre">process</span></tt> routine, which then
returns an updated value for the next iteration. This can be implemented as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre>loop x = loop (<span class="nb">catch</span> handler (process x))
<span class="kr">with</span> handler (signal k) = printf <span class="s">&quot;Hey, I got signal %d.</span><span class="se">\n</span><span class="s">&quot;</span> k $$ <span class="mi">0</span> <span class="kr">end</span><span class="p">;</span>
process x = printf <span class="s">&quot;counting: %d</span><span class="se">\n</span><span class="s">&quot;</span> x $$ sleep <span class="mi">1</span> $$ x+<span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="author">
<h2><a class="toc-backref" href="#id108">Author</a><a class="headerlink" href="#author" title="Permalink to this headline">¶</a></h2>
<p>Albert Gräf &lt;<a class="reference external" href="mailto:Dr&#46;Graef&#37;&#52;&#48;t-online&#46;de">Dr<span>&#46;</span>Graef<span>&#64;</span>t-online<span>&#46;</span>de</a>&gt;, Dept. of Computer Music, Johannes
Gutenberg University of Mainz, Germany.</p>
<p>The author gratefully acknowledges the contributions by Scott E. Dillard,
Rooslan S. Khayrov, Eddie Rucker, Libor Spacek, Jiri Spitz and Sergei
Winitzki, as well as Toni Graffy, Michel Salim and Ryan Schmidt who maintain
the SUSE Linux, Fedora Core and OSX packages, respectively. Thanks are also
due to Vili Aapro, Alvaro Castro Castilla, John Cowan, Chris Double, Tim
Haynes, Roman Neuhauser, Wm Leler, John Lunney and Max Wolf.</p>
</div>
<div class="section" id="copying">
<h2><a class="toc-backref" href="#id109">Copying</a><a class="headerlink" href="#copying" title="Permalink to this headline">¶</a></h2>
<p>Pure comes with a fairly liberal license which lets you distribute your own
Pure programs and extensions under a license of your choice and permits
linking of commercial applications against the Pure runtime and the Pure
standard library without requiring special permission. Moreover, the Pure
interpreter (the <tt class="docutils literal"><span class="pre">pure</span></tt> main program), the Pure runtime library
(<tt class="docutils literal"><span class="pre">libpure</span></tt>) and the Pure standard library (the Pure scripts in the <tt class="docutils literal"><span class="pre">lib</span></tt>
folder distributed with the software) are distributed as free software, and
you are welcome to modify and redistribute them under the appropriate license
terms, as detailed below.</p>
<p>(The above explanations are not legal advice. Please read the full text of the
licenses and consult qualified professional counsel for an interpretation of
the license terms as they apply to you.)</p>
<p>The <em>Pure interpreter</em> is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.</p>
<p>The <em>Pure runtime library</em> and the <em>Pure standard library</em> are also free
software: you can redistribute them and/or modify them under the terms of the
GNU <em>Lesser</em> General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.</p>
<p>Pure is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.</p>
<p>Please see the <a class="reference external" href="http://www.gnu.org/copyleft/gpl.html">GNU General Public License</a> and the <a class="reference external" href="http://www.gnu.org/copyleft/lgpl.html">GNU Lesser General Public License</a> for the precise license terms. You can
also find the license conditions in the COPYING and COPYING.LESSER files
accompanying the software. Also, please see the source code for the copyright
and license notes pertaining to individual source files which are part of this
software.</p>
<p>Pure uses <a class="reference internal" href="#llvm">LLVM</a> as its compiler backend. LLVM is under Copyright (c) 2003-2010
by the University of Illinois at Urbana-Champaign, and is licensed under a
3-clause BSD-style license, please read COPYING.LLVM included in the
distribution for the exact licensing terms. You can also find the LLVM license
at the <a class="reference internal" href="#llvm">LLVM</a> website.</p>
</div>
<div class="section" id="references-and-links">
<h2><a class="toc-backref" href="#id110">References and Links</a><a class="headerlink" href="#references-and-links" title="Permalink to this headline">¶</a></h2>
<dl class="docutils" id="aardappel">
<dt>Aardappel</dt>
<dd>Wouter van Oortmerssen&#8217;s functional programming language based on term
rewriting, <a class="reference external" href="http://wouter.fov120.com/aardappel">http://wouter.fov120.com/aardappel</a>.</dd>
</dl>
<dl class="docutils" id="alice-ml">
<dt>Alice ML</dt>
<dd>A version of ML (see below) from which Pure borrows its model of lazy
evaluation, <a class="reference external" href="http://www.ps.uni-sb.de/alice">http://www.ps.uni-sb.de/alice</a>.</dd>
</dl>
<dl class="docutils" id="baader-and-nipkow">
<dt>Franz Baader and Tobias Nipkow</dt>
<dd><em>Term Rewriting and All That.</em> Cambridge University Press, Cambridge, 1998.</dd>
</dl>
<dl class="docutils" id="bertrand">
<dt>Bertrand</dt>
<dd>Wm Leler&#8217;s constraint programming language based on term rewriting,
<a class="reference external" href="http://groups.google.com/group/bertrand-constraint">http://groups.google.com/group/bertrand-constraint</a>. See Wm Leler:
<em>Constraint Programming Languages: Their Specification and Generation.</em>
Addison-Wesley, 1988.</dd>
</dl>
<dl class="docutils" id="clang">
<dt>Clang</dt>
<dd>The new C/C++/Objective C compiler designed specifically to work on top of
LLVM, <a class="reference external" href="http://clang.llvm.org">http://clang.llvm.org</a>. Clang provides a comparatively light-weight
alternative to llvm-gcc which is faster and has better and more friendly
diagnostics than gcc.</dd>
</dl>
<dl class="docutils" id="faust">
<dt>Faust</dt>
<dd>Grame&#8217;s functional DSP programming language, <a class="reference external" href="http://faust.grame.fr">http://faust.grame.fr</a>.</dd>
</dl>
<dl class="docutils" id="gmp">
<span id="gnu-multiprecision-library"></span><dt>GNU Multiprecision Library</dt>
<dd>Free library for arbitrary precision arithmetic, <a class="reference external" href="http://gmplib.org">http://gmplib.org</a>.</dd>
</dl>
<dl class="docutils" id="octave">
<span id="gnu-octave"></span><dt>GNU Octave</dt>
<dd>A popular high-level language for numeric applications and free MATLAB
replacement, <a class="reference external" href="http://www.gnu.org/software/octave">http://www.gnu.org/software/octave</a>.</dd>
</dl>
<dl class="docutils" id="gsl">
<span id="gnu-scientific-library"></span><dt>GNU Scientific Library</dt>
<dd>A free software library for numeric applications, can be used with Pure&#8217;s
numeric matrices, <a class="reference external" href="http://www.gnu.org/software/gsl">http://www.gnu.org/software/gsl</a>.</dd>
</dl>
<dl class="docutils" id="haskell">
<dt>Haskell</dt>
<dd>A popular non-strict FPL, <a class="reference external" href="http://www.haskell.org">http://www.haskell.org</a>.</dd>
</dl>
<dl class="docutils" id="llvm">
<dt>LLVM</dt>
<dd>The LLVM code generator framework, <a class="reference external" href="http://llvm.org">http://llvm.org</a>.</dd>
</dl>
<dl class="docutils" id="miranda">
<dt>Miranda</dt>
<dd>David Turner&#8217;s non-strict FPL, <a class="reference external" href="http://miranda.org.uk">http://miranda.org.uk</a>. Miranda was fairly
successful in its time and one of the forerunners of <a class="reference internal" href="#haskell">Haskell</a>.</dd>
</dl>
<dl class="docutils" id="ml">
<dt>ML</dt>
<dd>A popular strict FPL. See Robin Milner, Mads Tofte, Robert Harper,
D. MacQueen: <em>The Definition of Standard ML (Revised).</em> MIT Press, 1997.</dd>
</dl>
<dl class="docutils" id="michael-o-donnell">
<dt>Michael O&#8217;Donnell</dt>
<dd><em>Equational Logic as a Programming Language.</em> Series in the Foundations of
Computing. MIT Press, Cambridge, Mass., 1985.</dd>
</dl>
<dl class="docutils" id="q">
<dt>Q</dt>
<dd>Another term rewriting language by yours truly, <a class="reference external" href="http://q-lang.sf.net">http://q-lang.sf.net</a>.</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Pure Manual</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#further-reading">Further Reading</a></li>
<li><a class="reference internal" href="#typographical-conventions">Typographical Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#invoking-pure">Invoking Pure</a><ul>
<li><a class="reference internal" href="#options">Options</a></li>
<li><a class="reference internal" href="#overview-of-operation">Overview of Operation</a></li>
<li><a class="reference internal" href="#compiling-scripts">Compiling Scripts</a></li>
<li><a class="reference internal" href="#tagging-scripts">Tagging Scripts</a></li>
<li><a class="reference internal" href="#running-interactively">Running Interactively</a></li>
<li><a class="reference internal" href="#verbosity-and-debugging-options">Verbosity and Debugging Options</a></li>
<li><a class="reference internal" href="#code-generation-options">Code Generation Options</a></li>
<li><a class="reference internal" href="#startup-files">Startup Files</a></li>
<li><a class="reference internal" href="#environment">Environment</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pure-overview">Pure Overview</a><ul>
<li><a class="reference internal" href="#lexical-matters">Lexical Matters</a></li>
<li><a class="reference internal" href="#definitions-and-symbolic-evaluation">Definitions and Symbolic Evaluation</a></li>
<li><a class="reference internal" href="#variables-in-equations">Variables in Equations</a></li>
<li><a class="reference internal" href="#expression-syntax">Expression Syntax</a><ul>
<li><a class="reference internal" href="#primary-expressions">Primary Expressions</a></li>
<li><a class="reference internal" href="#simple-expressions">Simple Expressions</a></li>
<li><a class="reference internal" href="#special-expressions">Special Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-forms">Special Forms</a></li>
<li><a class="reference internal" href="#toplevel">Toplevel</a></li>
<li><a class="reference internal" href="#scoping-rules">Scoping Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rule-syntax">Rule Syntax</a><ul>
<li><a class="reference internal" href="#patterns">Patterns</a></li>
<li><a class="reference internal" href="#type-tags">Type Tags</a></li>
<li><a class="reference internal" href="#general-rules">General Rules</a></li>
<li><a class="reference internal" href="#type-rules">Type Rules</a></li>
<li><a class="reference internal" href="#simple-rules">Simple Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#list-comprehensions">List Comprehensions</a></li>
<li><a class="reference internal" href="#lazy-evaluation-and-streams">Lazy Evaluation and Streams</a></li>
<li><a class="reference internal" href="#matrix-computations">Matrix Computations</a></li>
<li><a class="reference internal" href="#symbolic-matrices">Symbolic Matrices</a></li>
<li><a class="reference internal" href="#record-data">Record Data</a></li>
<li><a class="reference internal" href="#the-quote">The Quote</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declarations">Declarations</a><ul>
<li><a class="reference internal" href="#symbol-declarations">Symbol Declarations</a></li>
<li><a class="reference internal" href="#modules-and-imports">Modules and Imports</a></li>
<li><a class="reference internal" href="#namespaces">Namespaces</a><ul>
<li><a class="reference internal" href="#using-namespaces">Using Namespaces</a></li>
<li><a class="reference internal" href="#symbol-lookup-and-creation">Symbol Lookup and Creation</a></li>
<li><a class="reference internal" href="#private-symbols">Private Symbols</a></li>
<li><a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a></li>
<li><a class="reference internal" href="#scoped-namespaces">Scoped Namespaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#macros">Macros</a><ul>
<li><a class="reference internal" href="#optimization-rules">Optimization Rules</a></li>
<li><a class="reference internal" href="#recursive-macros">Recursive Macros</a></li>
<li><a class="reference internal" href="#user-defined-special-forms">User-Defined Special Forms</a></li>
<li><a class="reference internal" href="#macro-hygiene">Macro Hygiene</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exception-handling">Exception Handling</a></li>
<li><a class="reference internal" href="#c-interface">C Interface</a><ul>
<li><a class="reference internal" href="#extern-declarations">Extern Declarations</a></li>
<li><a class="reference internal" href="#variadic-c-functions">Variadic C Functions</a></li>
<li><a class="reference internal" href="#c-types">C Types</a><ul>
<li><a class="reference internal" href="#basic-c-types">Basic C Types</a></li>
<li><a class="reference internal" href="#pointer-types">Pointer Types</a></li>
<li><a class="reference internal" href="#pointers-and-matrices">Pointers and Matrices</a></li>
<li><a class="reference internal" href="#pointer-examples">Pointer Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#importing-dynamic-libraries">Importing Dynamic Libraries</a></li>
<li><a class="reference internal" href="#importing-llvm-bitcode">Importing LLVM Bitcode</a></li>
<li><a class="reference internal" href="#inline-code">Inline Code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#standard-library">Standard Library</a></li>
<li><a class="reference internal" href="#interactive-usage">Interactive Usage</a><ul>
<li><a class="reference internal" href="#online-help">Online Help</a></li>
<li><a class="reference internal" href="#interactive-commands">Interactive Commands</a></li>
<li><a class="reference internal" href="#last-result">Last Result</a></li>
<li><a class="reference internal" href="#specifying-symbol-selections">Specifying Symbol Selections</a></li>
<li><a class="reference internal" href="#the-show-command">The show Command</a></li>
<li><a class="reference internal" href="#definition-levels">Definition Levels</a></li>
<li><a class="reference internal" href="#debugging">Debugging</a></li>
<li><a class="reference internal" href="#interactive-startup">Interactive Startup</a></li>
</ul>
</li>
<li><a class="reference internal" href="#batch-compilation">Batch Compilation</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#code-size-and-unstripped-executables">Code Size and Unstripped Executables</a></li>
<li><a class="reference internal" href="#other-output-code-formats">Other Output Code Formats</a></li>
<li><a class="reference internal" href="#calling-pure-functions-from-c">Calling Pure Functions From C</a></li>
</ul>
</li>
<li><a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a><ul>
<li><a class="reference internal" href="#etymology">Etymology</a></li>
<li><a class="reference internal" href="#backward-compatibility">Backward Compatibility</a></li>
<li><a class="reference internal" href="#error-recovery">Error Recovery</a></li>
<li><a class="reference internal" href="#the-show-function">The __show__ Function</a></li>
<li><a class="reference internal" href="#non-linear-patterns">Non-Linear Patterns</a></li>
<li><a class="reference internal" href="#as-patterns">&#8220;As&#8221; Patterns</a></li>
<li><a class="reference internal" href="#head-function">Head = Function</a></li>
<li><a class="reference internal" href="#with-and-when">With and when</a></li>
<li><a class="reference internal" href="#numeric-calculations">Numeric Calculations</a></li>
<li><a class="reference internal" href="#constant-definitions">Constant Definitions</a></li>
<li><a class="reference internal" href="#external-c-functions">External C Functions</a></li>
<li><a class="reference internal" href="#calling-special-forms">Calling Special Forms</a></li>
<li><a class="reference internal" href="#laziness">Laziness</a></li>
<li><a class="reference internal" href="#reflection">Reflection</a></li>
<li><a class="reference internal" href="#hygienic-macros">Hygienic Macros</a></li>
<li><a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a></li>
<li><a class="reference internal" href="#handling-of-asynchronous-signals">Handling of Asynchronous Signals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#author">Author</a></li>
<li><a class="reference internal" href="#copying">Copying</a></li>
<li><a class="reference internal" href="#references-and-links">References and Links</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="purepad.html"
                        title="previous chapter">Using PurePad</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="purelib.html"
                        title="next chapter">Pure Library Manual</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pure.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="pure-modindex.html" title="Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="purelib.html" title="Pure Library Manual"
             >next</a> |</li>
        <li class="right" >
          <a href="purepad.html" title="Using PurePad"
             >previous</a> |</li>
        <li><a href="index.html">Pure Language and Library Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009-2010, Albert Gräf et al.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1pre.
    </div>
  </body>
</html>