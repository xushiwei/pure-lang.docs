\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-reduce.info
@documentencoding UTF-8
@copying
Generated by Sphinx
@end copying
@settitle pure-reduce
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-reduce: (pure-reduce.info).    A REDUCE Interface for the Pure Programming Language
@end direntry

@c %**end of header

@titlepage
@title pure-reduce
@author Albert Gr√§f (Editor)
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-reduce
@end ifnottex

@c %**start of body
@geindex reduce module
Version 0.1, October 07, 2012

@display
Albert Graef <@email{Dr.Graef@@t-online.de}>@w{ }
Kurt Pagani <@email{kp@@scios.ch}>@w{ }
@end display
This is a module providing access to the @uref{http://www.reduce-algebra.com/,Reduce} computer algebra system from
Pure. It uses an "embedded" version of Reduce which can be provided in the
form of a shared library. The @pxref{0,,Installation} section below describes how to
build this library from the Reduce sources. More background information and a
discussion of the interface can be found in the @uref{http://groups.google.com/group/pure-lang/browse_thread/thread/c11e82ca2e9e8cbb,Embedding REDUCE} thread on
the Pure mailing list.

@anchor{1}@anchor{reduce}@anchor{2}@anchor{embedding-reduce}The interface can be found in the reduce.pure module. It actually consists of
two parts, a @pxref{3,,low-level interface} which consists of a number of C entry
points provided by the Reduce library, and a @pxref{4,,high-level interface} which
provides everything that the Pure programmer needs to use Reduce from Pure.
Some basic examples are in reduce_examp.pure. Please note that at present this
module is still experimental and under development. But the basic
functionality works, and you're welcome to discuss the new interface on the
mailing list and/or submit bug reports and patches.


@menu
* Installation::
* Low-Level Interface::
* High-Level Interface::
* Basic Examples::
* Index::
@end menu


@node Installation,Low-Level Interface,Top,Top
@anchor{installation}@anchor{5}@anchor{module-reduce}@anchor{6}@anchor{a-reduce-interface-for-the-pure-programming-language}@anchor{0}
@chapter Installation
Get the latest source from
@indicateurl{http://pure-lang.googlecode.com/files/pure-reduce-0.1.tar.gz}.

You'll need both the Reduce library (named reduce.so, reduce.dylib or
reduce.dll, depending on the system you have) and a Reduce image file
(reduce.img) to make this module work. A Makefile is included with this
package so that you can build these yourself from the Reduce sources. (In
principle, this only needs to be done once for the initial installation of
this module, but you may want to repeat this procedure every once in a while
to get the latest Reduce version.)

You can check out the latest Reduce version from its svn repository with the
following command:

@example
svn co https://reduce-algebra.svn.sourceforge.net/svnroot/reduce-algebra/trunk/ reduce-algebra
@end example

@noindent
This may take a while; Reduce is a @emph{big} package. Once it's finished, just
drop the resulting reduce-algebra directory into the pure-reduce source
directory. Run @code{make} and then (if needed) @code{make install} in the
pure-reduce directory (@emph{not} in the reduce-algebra directory!). You should
also run @code{make check} which runs a few tests in order to verify that the
interface works ok (this can be done without installing the package, but needs
the Reduce image and library).

In case the above procedure doesn't work for you, there are more detailed
instructions on how to compile the relevant parts of Reduce in the
pure_reduce.txt file included in the distribution. Also note that the
pure-reduce module requires neither a full Reduce installation nor a full
build of the Reduce package; just the Reduce library and image. Thus the
additional items discussed below are all completely optional.

For convenience, the Makefile also has a @code{make reduce} target which builds a
minimal Reduce executable. If you use that option, @code{make install} installs
this executable along with the library and image files, so that you can then
run Reduce directly from the command line by just typing @code{reduce}. Please
note that this is a rather minimalistic Reduce frontend; it's small, builds
with minimal fuss and doesn't need any support files other than the image
file, but doesn't have all the bells and whistles of the full Reduce version.

If you want to install the full Reduce version, the easiest way to go is to
download one of the binary packages available on @uref{http://sourceforge.net/projects/reduce-algebra/,SourceForge}. You can also
build Reduce yourself from the sources; please check the build instructions in
the reduce-algebra folder for details. (Basically, you'll need to run
@code{./configure --with-csl} or @code{./configure --with-psl} and then @code{make}
there. Be patient, this takes a while.)

@anchor{7}@anchor{sourceforge}
@node Low-Level Interface,High-Level Interface,Installation,Top
@anchor{low-level interface}@anchor{3}@anchor{low-level-interface}
@chapter Low-Level Interface
The low-level interface is a straight wrapper of the C entry points
provided by the Reduce library, also known as the "procedural" or @uref{http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup,PROC}
interface, for short. It uses an embedded version of Reduce which runs on a
free and open-source Lisp flavour known as @uref{http://lisp.codemist.co.uk/,CSL} (Codemist Standard
Lisp). The external C routines are all declared in the @code{reduce}
namespace. Normally you shouldn't have to call these functions directly,
since we provide a high-level, idiomatic Pure interface which makes calling
Reduce from Pure much more convenient, see below.

@anchor{8}@anchor{proc}@anchor{9}@anchor{csl}
@node High-Level Interface,Basic Examples,Low-Level Interface,Top
@anchor{high-level interface}@anchor{4}@anchor{high-level-interface}
@chapter High-Level Interface
The goal here is to make it easy to run Reduce from Pure; to these ends,
the most important features of the low-level PROC interface are wrapped in
a convenient way. Currently the following variables and functions are
provided:

@geindex REDUCE_PATH variable
@anchor{a}@anchor{reduce_path}
@deffn {variable} REDUCE_PATH

This variable holds a colon-delimited search path used to locate the
Reduce image file (see @pxref{b,,reduce start} below). By default this
includes the current directory and the Pure library directory.
@end deffn

@geindex reduce start function
@anchor{b}@anchor{reduce start}
@deffn {Function} reduce::start image::string args::smatrix

Initializes the Reduce system. This is done automatically when loading
this module, so normally you shouldn't have to call this manually,
unless the default image file wasn't found or you want to restart the
Reduce system with your own image file or your own set of options. When
calling this operation manually, you need to specify the name of the
Reduce image file and any desired extra arguments as a string vector.
Unless the filename contains a slash, @pxref{b,,reduce start} searches the
directories in @pxref{a,,REDUCE_PATH} for the image file. An exception is
raised if the image file isn't found.
@end deffn

@geindex reduce finish function
@anchor{c}@anchor{reduce finish}
@deffn {Function} reduce::finish

Finalizes the Reduce system. You can call this to release the resources
of the Reduce system. (@pxref{b,,reduce start} also invokes this
automatically if a Reduce instance is already running, so it isn't
necessary to call @pxref{c,,reduce finish} in this case.)
@end deffn

@geindex reduce verbosity function
@anchor{d}@anchor{reduce verbosity}
@deffn {Function} reduce::verbosity n

Sets the verbosity level; 0 means no messages at all (which is the
default when using this module), and the following values may be or'ed
together to pick what you need:

@quotation
1: messages whenever garbage collection happens

2: messages whenever a module of code is loaded

4: extra details in the garbage collector messages
@end quotation
@end deffn

@geindex reduce load function
@anchor{e}@anchor{reduce load}
@deffn {Function} reduce::load name::string

Loads Reduce packages. This works like Reduce's @code{load_package}
command; please check the Reduce documentation for details.
@end deffn

@geindex reduce switch function
@anchor{f}@anchor{reduce switch}
@deffn {Function} reduce::switch name:string val::int

Lets you change global Reduce options. This works like Reduce's @code{on}
and @code{off} declarations; please check the Reduce documentation for
details.
@end deffn

For convenience, the following operations are in the default namespace:

@geindex simplify function
@anchor{10}@anchor{simplify}
@deffn {Function} simplify x

This is the main entry point. It takes an algebraic expression in Pure
format and tries to simplify it using Reduce. The result is then
converted back to Pure format. Note that you need to quote @code{x} if you
want to prevent it from being evaluated on the Pure side.
@end deffn

@geindex lisp function
@anchor{11}@anchor{lisp}
@deffn {Function} lisp x

This can be used to execute arbitrary Lisp code, which is sometimes
necessary to perform special functions in the Reduce system. The result
is always a Pure list or an atomic value. Note that you need to quote
@code{x} if you want to prevent it from being evaluated on the Pure
side. This is to be used with care. At present, the PROC interface isn't
very forgiving if you try to execute invalid Lisp code; it will most
likely crash in such cases.
@end deffn

@geindex declare function
@anchor{12}@anchor{declare}
@deffn {Function} declare declsym [foo,bar,...]

Declare symbols and their properties; please see the Declarations
section in the Reduce manual for details. The second argument can also
be a singleton symbol. In the present implementation, @code{declsym} must
be one of:

@itemize *
@item
@code{operator} (declares an operator symbol);
@item
@code{antisymmetric}, @code{symmetric}, @code{even}, @code{odd}, @code{linear},
@code{noncom} and @code{nonzero} (declares properties of already declared
operator symbols);
@item
@code{depend}, @code{nodepend}, @code{factor}, @code{remfac}, @code{order},
@code{korder} (declares kernel dependencies and orders). These take both
symbols and "kernels" as arguments (the latter are simple prefix
expressions which denote irreducible subterms such as @code{cos x};
Reduce treats these more or less like variables in algebraic
simplifications).
@end itemize
@end deffn

@geindex precision function
@anchor{13}@anchor{precision}
@deffn {Function} precision prec::int

Sets the internal Reduce precision in decimal digits for floating point
calculations, and returns the previously set precision. This takes
effect when rounded mode is enabled (@code{reduce::switch "rounded" 1}).
Note that at present this only affects Reduce's internal precision,
floating point values are still returned as double precision numbers in
Pure land.
@end deffn

@geindex plotreset function
@anchor{14}@anchor{plotreset}
@deffn {Function} plotreset

This is identical to the @code{plotreset} command provided by Reduce's
@uref{http://www.gnuplot.info/,gnuplot} interface, and is sometimes needed to reset the plot subsystem.
@end deffn

@anchor{15}@anchor{gnuplot}At present, this module makes no attempt to capture terminal output such as
error messages produced by Reduce, so you should be prepared to read these
in the terminal in which Pure is running, or capture them yourself using
the output redirection facilities of the shell if needed.

In Pure land, Reduce and Lisp expressions are represented using Pure's
standard curried notation. Some special conversions are applied to
algebraic expressions to make arithmetic operations such as @code{+}, @code{*}
etc. work as expected. In addition, the @code{==}, @code{..} and @code{:=} infix
operators can be used to denote equations, ranges and assignments in
Reduce, respectively. (Note that you may have to quote these in some cases
so that they don't get evaluated on the Pure side.) Also, Reduce's
@code{arbconst n}, @code{arbint n} and @code{arbcomplex n} terms are mapped to Greek
symbols @code{Œ±n}, @code{Œ≤n} and @code{Œ∂n} on the Pure side. (All these automatic
conversions can also be turned off on the output side with the @code{#!
--disable mapped} compilation pragma; this may be useful for debugging
purposes.)


@node Basic Examples,Index,High-Level Interface,Top
@anchor{basic examples}@anchor{16}@anchor{basic-examples}
@chapter Basic Examples
Here is a simple example showing how to start up Reduce and do some
calculations:

@example
> using reduce;
Reduce (Free CSL version), 27-Sep-12 ...
> simplify $ df ((x+5)^3) x;
3*x^2+30*x+75
> simplify $ solve (x^2+7) x;
[x==sqrt 7*i,x==-sqrt 7*i]
@end example

@noindent
Note that the result returned by @pxref{10,,simplify} is always a quoted
expression. If the expression can be further reduced on the Pure side,
you'll have to use Pure's @code{eval} function to force its evaluation:

@example
> using math;
> eval ans;
[x==0.0+:2.64575131106459,x==0.0+:-2.64575131106459]
@end example

@noindent
You can also execute Lisp code in the CSL interpreter hosting the Reduce
system. This is sometimes necessary to access special functionality, but
should be done with care (at present invalid Lisp code can easily crash the
interpreter). For instance:

@example
> lisp ('list a b c d e);
[a,b,c,d,e]
> lisp ('cdr [a,b,[c,d],e]);
[b,[c,d],e]
@end example

@noindent
Free symbols are quoted automatically, and Pure lists are mapped to
corresponding Lisp lists. If the result is a Lisp list, it will be
converted back to a Pure list. Most simple kinds of Lisp calls should be
doable that way, but don't expect any miracles; the @pxref{11,,lisp} function
is provided to access special functionality in the "symbolic mode" of the
Reduce system, not to turn Pure into a full-featured Lisp frontend.

The following example illustrates how you can use the @pxref{11,,lisp} function
to declare an operator symbol and change or query its properties:

@example
> lisp ('operator [myop]);
[]
> lisp ('flag [myop] odd);
[]
> lisp ('prop myop);
[odd:t,simpfn:simpiden]
> simplify (myop (-x));
-myop x
@end example

@noindent
If you find it awkward to evaluate Lisp forms in Pure, you can also achieve
the same with the @pxref{12,,declare} function which covers most of the common
Reduce declarations that might be needed:

@example
> declare operator myop;
[]
> declare odd myop;
[]
> simplify (myop (-x));
-myop x
@end example

@noindent
This example shows how you can do a simple plot using Reduce's @uref{http://www.gnuplot.info/,gnuplot}
module:

@example
> simplify $ plot [sin x/x, x=='(-20..20), terminal=="wxt", title=="sinc"];
0
@end example

@noindent
Many more examples can be found in the reduce_examp.pure and tests.pure
scripts included in the distribution.


@node Index,,Basic Examples,Top
@anchor{index}
@unnumbered Index
@printindex ge

@c %**end of body
@bye
