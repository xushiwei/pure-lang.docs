\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-gsl.info
@documentencoding UTF-8
@copying
Generated by Sphinx
@end copying
@settitle pure-gsl
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-gsl: (pure-gsl.info).    pure-gsl - GNU Scientific Library Interface for Pure
@end direntry

@c %**end of header

@titlepage
@title pure-gsl
@author Albert Gr√§f (Editor)
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-gsl
@end ifnottex

@c %**start of body
@geindex gsl module
Version 0.11, March 22, 2012

@display
Albert Graef <@email{Dr.Graef@@t-online.de}>@w{ }
Eddie Rucker <@email{erucker@@bmc.edu}>@w{ }
@end display
License: GPL V3 or later, see the accompanying COPYING file

Building on Pure's GSL-compatible matrix support, this module aims to
provide a complete wrapper for the GNU Scientific Library which provides a
wide range of mathematical routines useful for scientific programming,
number crunching and signal processing applications.

This is still work in progress, only a small part of the interface is
finished right now. Here is a brief summary of the operations which are
implemented:

@itemize -
@item
Matrix-scalar and matrix-matrix arithmetic. This is fairly complete
and includes matrix multiplication, as well as element-wise
exponentiation (^) and integer operations (div, mod, bit shifts and
bitwise logical operations) which aren't actually in the GSL API.
@item
SVD (singular value decomposition), as well as the corresponding
solvers, pseudo inverses and left and right matrix division. This is
only available for real matrices right now, as GSL doesn't implement
complex SVD.
@item
Random distributions (p.d.f. and c.d.f.) and statistic functions.
@item
Polynomial evaluation and roots.
@item
Linear least-squares fitting. Multi-fitting is not available yet.
@end itemize

Installation instructions: Get the latest source from
@indicateurl{http://pure-lang.googlecode.com/files/pure-gsl-0.11.tar.gz}. Run
@code{make} to compile the module and @code{make install} (as root) to install it
in the Pure library directory.  This requires GNU make, and of course you
need to have Pure and GSL installed.  The @code{make install} step is only
necessary for system-wide installation.

@code{make} tries to guess your Pure installation directory and
platform-specific setup. If it gets this wrong, you can set some variables
manually. In particular, @code{make install prefix=/usr} sets the installation
prefix, and @code{make PIC=-fPIC} or some similar flag might be needed for
compilation on 64 bit systems. Please see the Makefile for details.

The current release requires GSL 1.11 or later and Pure 0.45 or later.
Older GSL versions might still work, but then some operations may be
missing. The latest and greatest GSL version is always available from
@indicateurl{http://www.gnu.org/software/gsl}.

After installation, you can import the entire GSL interface as follows:

@example
using gsl;
@end example

@noindent
For convenience, the different parts of the GSL interface are also
available as separate modules. E.g., if you only need the matrix
operations:

@example
using gsl::matrix;
@end example

@noindent
In either case, the global @code{gsl_version} variable reports the installed
GSL version:

@example
> show gsl_version
let gsl_version = "1.11";
@end example

@noindent
(This variable used to be defined by the Pure runtime but has been moved
into pure-gsl as of Pure 0.37.)

Most other operations are declared in separate namespaces which are in 1-1
correspondence with the module names. Thus, e.g., the @code{gsl_poly_eval}
routine is named @code{gsl::poly::eval} in Pure and can be found in the
@code{gsl::poly} module and namespace. The @code{using namespace} declaration can
be used to facilitate access to the operations in a given namespace, e.g.:

@example
> using gsl::poly;
> using namespace gsl::poly;
> eval @{1,2,3@} 2;
17
@end example

@noindent
See the @code{examples} folder in the sources for some examples.

If you'd like to contribute, please mail the authors or contact us at
@indicateurl{http://groups.google.com/group/pure-lang}.


@menu
* Polynomials::
* Special Functions::
* Matrices::
* Least-Squares Fitting::
* Statistics::
* Random Number Distributions::
* Sorting::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Polynomials

* Routines::
* Examples::

Special Functions

* Airy Functions::
* Examples: Examples<2>.
* Bessel Functions::
* Examples: Examples<3>.
* Clausen Functions::
* Examples: Examples<4>.
* Colomb Functions::
* Examples: Examples<5>.
* Coupling Coefficients::
* Examples: Examples<6>.
* Dawson Function::
* Examples: Examples<7>.
* Debye Functions::
* Examples: Examples<8>.
* Dilogarithm::
* Examples: Examples<9>.
* Examples: Examples<10>.

Matrices

* Matrix Creation::
* Matrix Operators and Functions::
* Singular Value Decomposition::

Least-Squares Fitting

* Routines: Routines<2>.
* Examples: Examples<11>.

Statistics

* Routines: Routines<3>.
* Examples: Examples<12>.

Random Number Distributions

* Routines: Routines<4>.
* Examples: Examples<13>.

Sorting

* Routines: Routines<5>.
* Examples: Examples<14>.
@end detailmenu
@end menu


@node Polynomials,Special Functions,Top,Top
@anchor{polynomials}@anchor{0}@anchor{module-gsl}@anchor{1}@anchor{pure-gsl-gnu-scientific-library-interface-for-pure}@anchor{2}@anchor{module-gsl poly}@anchor{3}
@chapter Polynomials

@geindex gsl poly module
This module provides Pure wrappers for the GSL polynomial routines. For
detail about the routines, see Chapter 6 of the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Polynomials.html}.

Polynomials are represented by vectors (one row matrices).


@menu
* Routines::
* Examples::
@end menu


@node Routines,Examples,,Polynomials
@anchor{routines}@anchor{4}
@section Routines

@geindex gsl poly eval function
@anchor{5}@anchor{gsl poly eval}
@deffn {Function} gsl::poly::eval c::matrix  x

implements @code{gsl_poly_eval}, @code{gsl_poly_complex_eval}, and
@code{gsl_complex_poly_eval} without the @code{len} parameter.

GSL does not supply an integer routine for evaluating polynomials
with @code{int} or  @code{bigint} coefficients. Therefore, an integer
routine has been provided in pure-gsl using the Chinese Remainder
Theorem.
@end deffn

@geindex gsl poly dd_init function
@anchor{6}@anchor{gsl poly dd_init}
@deffn {Function} gsl::poly::dd_init x::matrix  y::matrix

implements @code{gsl_poly_dd_init} without the @code{size} parameter.
@end deffn

@geindex gsl poly dd_eval function
@anchor{7}@anchor{gsl poly dd_eval}
@deffn {Function} gsl::poly::dd_eval dd::matrix  xa::matrix  x::double

implements @code{gsl_poly_dd_eval} without the @code{size} parameter.
@end deffn

@geindex gsl poly dd_taylor function
@anchor{8}@anchor{gsl poly dd_taylor}
@deffn {Function} gsl::poly::dd_taylor xp::double  dd::matrix  xa::matrix

implements @code{gsl_poly_dd_taylor} without the @code{size} and workspace
@code{w} arguments.
@end deffn

@geindex gsl poly solve_quadratic function
@anchor{9}@anchor{gsl poly solve_quadratic}
@deffn {Function} gsl::poly::solve_quadratic a  b  c

implements @code{gsl_poly_solve_quadratic}.  This function returns a list
of roots instead of passing them through the parameters @code{x0} and
@code{x1}.
@end deffn

@geindex gsl poly complex_solve_quadratic function
@anchor{a}@anchor{gsl poly complex_solve_quadratic}
@deffn {Function} gsl::poly::complex_solve_quadratic a  b  c

implements @code{gsl_poly_complex_solve_quadratic}. This function returns a
list of roots instead of passing trhough the parameters @code{z0} and
@code{z1}.
@end deffn

@geindex gsl poly solve_cubic function
@anchor{b}@anchor{gsl poly solve_cubic}
@deffn {Function} gsl::poly::solve_cubic a  b  c

implements @code{gsl_poly_solve_cubic}. This function returns a list of
roots instead of passing them through the parameters @code{x0}, @code{x1}, and
@code{x2}.
@end deffn

@geindex gsl poly complex_solve_cubic function
@anchor{c}@anchor{gsl poly complex_solve_cubic}
@deffn {Function} gsl::poly::complex_solve_cubic a  b  c

implements @code{gsl_poly_complex_colve_cubic}. This function returns a
list of roots instead of passing them through the parameters @code{z0},
@code{z1}, and @code{z2}.
@end deffn

@geindex gsl poly complex_solve function
@anchor{d}@anchor{gsl poly complex_solve}
@deffn {Function} gsl::poly::complex_solve c::matrix

implements @code{gsl_poly_complex_solve} omitting the parametrs @code{n} and
@code{w}. The GSL routines for creating and freeing the workspace are
handled automatically.
@end deffn


@node Examples,,Routines,Polynomials
@anchor{examples}@anchor{e}
@section Examples
Usage of each library routine is illustrated below.

@example
> using gsl::poly;
> using namespace gsl::poly;
> eval @{1,2,3@} 2;
17
> eval @{1.0,2.0,3.0@} (-2.0);
9.0
> eval @{1, 2, 2@} (1+:1);
3.0+:6.0
> eval @{1+:2, 2+:3, 2+:3@} (1+:1);
-6.0+:11.0
> let dd = dd_init @{1,2,3@} @{2,4,6@};
> dd;
@{2.0,2.0,0.0@}
> dd_eval dd @{1,2,3@} 2;
4.0
> dd_taylor 0.0 dd @{1,2,3@};
@{0.0,2.0,0.0@}
> solve_quadratic 2 4 1;
[-1.70710678118655,-0.292893218813452]
> solve_quadratic 1 4 4;
[-2.0,-2.0]
> solve_quadratic 0 2 1;
[-0.5]
> solve_quadratic 1 2 8;
[]
> complex_solve_quadratic 0 2 1;
[-0.5+:0.0]
> complex_solve_quadratic 2 2 3;
[-0.5+:-1.11803398874989,-0.5+:1.11803398874989]
> solve_cubic 3 3 1;
[-1.0,-1.0,-1.0]
> solve_cubic 3 2 1;
[-2.32471795724475]
> complex_solve_cubic 2 2 1;
[-1.0+:0.0,-0.5+:-0.866025403784439,-0.5+:0.866025403784439]
> complex_solve @{6,1,-7,-1,1@};
[1.0+:0.0,-1.0+:0.0,-2.0+:0.0,3.0+:0.0]
@end example

@noindent

@node Special Functions,Matrices,Polynomials,Top
@anchor{special functions}@anchor{f}@anchor{module-gsl sf}@anchor{10}@anchor{special-functions}
@chapter Special Functions

@geindex gsl sf module
This module is loaded via the command @code{using gsl::sf} and provides
Pure wrappers for the GSL Special Functions. For details, see Chapter 7
of the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Special-Functions.html}.

To load the library, use the Pure command @code{using gsl::sf}.
Modes for the functions must be one of:

@example
GSL_PREC_DOUBLE
GSL_PREC_SINGLE
GSL_PREC_APPROX
@end example

@noindent
Results for some of the functions are returned as a Pure list instead of
the @code{gsl_sf_result} or  @code{gsl_sf_result_e10} structures in C. In these
cases, the resulting list is one of the following forms.

@quotation

@itemize -
@item
@code{[val, err]} for the @code{gsl_sf_result} struct and
@item
@code{[val, err, e10]} for the @code{gsl_sf_result_e10} struct.
@end itemize
@end quotation


@menu
* Airy Functions::
* Examples: Examples<2>.
* Bessel Functions::
* Examples: Examples<3>.
* Clausen Functions::
* Examples: Examples<4>.
* Colomb Functions::
* Examples: Examples<5>.
* Coupling Coefficients::
* Examples: Examples<6>.
* Dawson Function::
* Examples: Examples<7>.
* Debye Functions::
* Examples: Examples<8>.
* Dilogarithm::
* Examples: Examples<9>.
* Examples: Examples<10>.
@end menu


@node Airy Functions,Examples<2>,,Special Functions
@anchor{airy functions}@anchor{11}@anchor{airy-functions}
@section Airy Functions

@geindex gsl sf airy_Ai function
@anchor{12}@anchor{gsl sf airy_ai}
@deffn {Function} gsl::sf::airy_Ai x

@deffnx {Function} gsl::sf::airy_Ai (x, mode::int)

implements @code{gsl_sf_airy_Ai}. The first form computes the function with
@code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Ai_e function
@anchor{13}@anchor{gsl sf airy_ai_e}
@deffn {Function} gsl::sf::airy_Ai_e x

@deffnx {Function} gsl::sf::airy_Ai_e (x, mode::int)

implements @code{gsl_sf_airy_Ai_e}. The first form computes the function
with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Ai_scaled function
@anchor{14}@anchor{gsl sf airy_ai_scaled}
@deffn {Function} gsl::sf::airy_Ai_scaled x

@deffnx {Function} gsl::sf::airy_Ai_scaled (x, mode::int)

implements @code{gsl_sf_airy_Ai_scaled}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Ai_scaled_e function
@anchor{15}@anchor{gsl sf airy_ai_scaled_e}
@deffn {Function} gsl::sf::airy_Ai_scaled_e x

@deffnx {Function} gsl::sf::airy_Ai_scaled_e (x, mode::int)

implements @code{gsl_sf_airy_Ai_scaled_e}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Bi function
@anchor{16}@anchor{gsl sf airy_bi}
@deffn {Function} gsl::sf::airy_Bi x

@deffnx {Function} gsl::sf::airy_Bi (x, mode::int)

implements @code{gsl_sf_airy_Bi}. The first form computes the function with
@code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Bi_e function
@anchor{17}@anchor{gsl sf airy_bi_e}
@deffn {Function} gsl::sf::airy_Bi_e x

@deffnx {Function} gsl::sf::airy_Bi_e (x, mode::int)

implements @code{gsl_sf_airy_Bi_e}. The first form computes the function
with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Bi_scaled function
@anchor{18}@anchor{gsl sf airy_bi_scaled}
@deffn {Function} gsl::sf::airy_Bi_scaled x

@deffnx {Function} gsl::sf::airy_Bi_scaled (x, mode::int)

implements @code{gsl_sf_airy_Bi_scaled}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Bi_scaled_e function
@anchor{19}@anchor{gsl sf airy_bi_scaled_e}
@deffn {Function} gsl::sf::airy_Bi_scaled_e x

@deffnx {Function} gsl::sf::airy_Bi_scaled_e (x, mode::int)

implements @code{gsl_sf_airy_Bi_scaled_e}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Ai_deriv function
@anchor{1a}@anchor{gsl sf airy_ai_deriv}
@deffn {Function} gsl::sf::airy_Ai_deriv x

@deffnx {Function} gsl::sf::airy_Ai_deriv (x, mode::int)

implements @code{gsl_sf_airy_Ai_deriv}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Ai_deriv_e function
@anchor{1b}@anchor{gsl sf airy_ai_deriv_e}
@deffn {Function} gsl::sf::airy_Ai_deriv_e x

@deffnx {Function} gsl::sf::airy_Ai_deriv_e (x, mode::int)

implements @code{gsl_sf_airy_Ai_deriv_e}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Ai_deriv_scaled function
@anchor{1c}@anchor{gsl sf airy_ai_deriv_scaled}
@deffn {Function} gsl::sf::airy_Ai_deriv_scaled x

@deffnx {Function} gsl::sf::airy_Ai_deriv_scaled (x, mode::int)

implements @code{gsl_sf_airy_Ai_deriv_scaled}. The first form computes
the function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Ai_deriv_scaled_e function
@anchor{1d}@anchor{gsl sf airy_ai_deriv_scaled_e}
@deffn {Function} gsl::sf::airy_Ai_deriv_scaled_e x

@deffnx {Function} gsl::sf::airy_Ai_deriv_scaled_e (x, mode::int)

implements @code{gsl_sf_airy_Ai_deriv_scaled_e}. The first form computes
the function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Bi_deriv function
@anchor{1e}@anchor{gsl sf airy_bi_deriv}
@deffn {Function} gsl::sf::airy_Bi_deriv x

@deffnx {Function} gsl::sf::airy_Bi_deriv (x, mode::int)

implements @code{gsl_sf_airy_Bi_deriv}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Bi_deriv_e function
@anchor{1f}@anchor{gsl sf airy_bi_deriv_e}
@deffn {Function} gsl::sf::airy_Bi_deriv_e x

@deffnx {Function} gsl::sf::airy_Bi_deriv_e (x, mode::int)

implements @code{gsl_sf_airy_Bi_deriv_e}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Bi_deriv_scaled function
@anchor{20}@anchor{gsl sf airy_bi_deriv_scaled}
@deffn {Function} gsl::sf::airy_Bi_deriv_scaled x

@deffnx {Function} gsl::sf::airy_Bi_deriv_scaled (x, mode::int)

implements @code{gsl_sf_airy_Bi_deriv_scaled}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_Bi_deriv_scaled_e function
@anchor{21}@anchor{gsl sf airy_bi_deriv_scaled_e}
@deffn {Function} gsl::sf::airy_Bi_deriv_scaled_e x

@deffnx {Function} gsl::sf::airy_Bi_deriv_scaled_e (x, mode::int)

implements @code{gsl_sf_airy_Bi_deriv_scaled_e}. The first form computes
the function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl sf airy_zero_Ai function
@anchor{22}@anchor{gsl sf airy_zero_ai}
@deffn {Function} gsl::sf::airy_zero_Ai s

implements @code{gsl_sf_airy_zero_Ai}.
@end deffn

@geindex gsl sf airy_zero_Ai_e function
@anchor{23}@anchor{gsl sf airy_zero_ai_e}
@deffn {Function} gsl::sf::airy_zero_Ai_e s

implements @code{gsl_sf_airy_zero_Ai_e}.
@end deffn

@geindex gsl sf airy_zero_Bi function
@anchor{24}@anchor{gsl sf airy_zero_bi}
@deffn {Function} gsl::sf::airy_zero_Bi s

implements @code{gsl_sf_airy_zero_Bi}.
@end deffn

@geindex gsl sf airy_zero_Bi_e function
@anchor{25}@anchor{gsl sf airy_zero_bi_e}
@deffn {Function} gsl::sf::airy_zero_Bi_e s

implements @code{gsl_sf_airy_zero_Bi_e}.
@end deffn

@geindex gsl sf airy_zero_Ai_deriv function
@anchor{26}@anchor{gsl sf airy_zero_ai_deriv}
@deffn {Function} gsl::sf::airy_zero_Ai_deriv s

implements @code{gsl_sf_airy_zero_Ai_deriv}.
@end deffn

@geindex gsl sf airy_zero_Ai_deriv_e function
@anchor{27}@anchor{gsl sf airy_zero_ai_deriv_e}
@deffn {Function} gsl::sf::airy_zero_Ai_deriv_e s

implements @code{gsl_sf_airy_zero_Ai_deriv_e}.
@end deffn

@geindex gsl sf airy_zero_Bi_deriv function
@anchor{28}@anchor{gsl sf airy_zero_bi_deriv}
@deffn {Function} gsl::sf::airy_zero_Bi_deriv s

implements @code{gsl_sf_airy_zero_Bi_deriv}.
@end deffn

@geindex gsl sf airy_zero_Bi_deriv_e function
@anchor{29}@anchor{gsl sf airy_zero_bi_deriv_e}
@deffn {Function} gsl::sf::airy_zero_Bi_deriv_e s

implements @code{gsl_sf_airy_zero_Bi_deriv_e}.
@end deffn


@node Examples<2>,Bessel Functions,Airy Functions,Special Functions
@anchor{examples<2>}@anchor{2a}@anchor{id1}
@section Examples
The following illustrate the Airy functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> airy_Ai (-1.2); // defaults to GSL_PREC_DOUBLE
0.52619437480212
> airy_Ai_scaled (-1.2);
0.52619437480212
> airy_Ai (-1.2,GSL_PREC_APPROX);
0.526194374771687
> airy_Ai_scaled (-1.2, GSL_PREC_SINGLE);
0.526194374771687
> airy_Ai_e (-1.2);
[0.52619437480212,1.88330586480371e-15]
> airy_Ai_e (-1.2,GSL_PREC_APPROX);
[0.526194374771687,1.01942940819652e-08]
> airy_Ai_scaled_e (-1.2);
[0.52619437480212,1.88330586480371e-15]
> airy_Ai_scaled_e (-1.2,GSL_PREC_APPROX);
[0.526194374771687,1.01942940819652e-08]
> airy_Bi (-1.2);
-0.015821370184632
> airy_Bi_scaled (-1.2);
-0.015821370184632
> airy_Bi (-1.2,GSL_PREC_APPROX);
-0.0158213701898015
> airy_Bi_scaled (-1.2, GSL_PREC_SINGLE);
-0.0158213701898015
> airy_Bi_e (-1.2);
[-0.015821370184632,1.31448899295896e-16]
> airy_Bi_e (-1.2,GSL_PREC_APPROX);
[-0.0158213701898015,4.10638404843775e-10]
> airy_Bi_scaled_e (-1.2);
[-0.015821370184632,1.31448899295896e-16]
> airy_Bi_scaled_e (-1.2,GSL_PREC_APPROX);
[-0.0158213701898015,4.10638404843775e-10]
> airy_Ai_deriv (-1.2); // defaults to GSL_PREC_DOUBLE
0.107031569272281
> airy_Ai_deriv_scaled (-1.2);
0.107031569272281
> airy_Ai_deriv (-1.2,GSL_PREC_APPROX);
0.107031569264504
> airy_Ai_deriv_scaled (-1.2, GSL_PREC_SINGLE);
0.107031569264504
> airy_Ai_deriv_e (-1.2);
[0.107031569272281,3.02919983680384e-16]
> airy_Ai_deriv_e (-1.2,GSL_PREC_APPROX);
[0.107031569264504,9.25921017197604e-11]
> airy_Ai_deriv_scaled_e (-1.2);
[0.107031569272281,3.02919983680384e-16]
> airy_Ai_deriv_scaled_e (-1.2,GSL_PREC_APPROX);
[0.107031569264504,9.25921017197604e-11]
> airy_Bi_deriv (-1.2);
0.601710157437464
> airy_Bi_deriv_scaled (-1.2);
0.601710157437464
> airy_Bi_deriv (-1.2,GSL_PREC_APPROX);
0.601710157441937
> airy_Bi_deriv_scaled (-1.2, GSL_PREC_SINGLE);
0.601710157441937
> airy_Bi_deriv_e (-1.2);
[0.601710157437464,1.7029557943563e-15]
> airy_Bi_deriv_e (-1.2,GSL_PREC_APPROX);
[0.601710157441937,5.20534347823991e-10]
> airy_Bi_deriv_scaled_e (-1.2);
[0.601710157437464,1.7029557943563e-15]
> airy_Bi_deriv_scaled_e (-1.2,GSL_PREC_APPROX);
[0.601710157441937,5.20534347823991e-10]
> airy_zero_Ai 2;
-4.08794944413097
> airy_zero_Ai_e 3;
[-5.52055982809555,1.22581052599448e-15]
> airy_zero_Bi 2;
-3.27109330283635
> airy_zero_Bi_e 3;
[-4.83073784166202,1.07263927554824e-15]
> airy_zero_Ai_deriv 2;
-3.24819758217984
> airy_zero_Ai_deriv_e 3;
[-4.82009921117874,1.07027702504564e-15]
> airy_zero_Bi_deriv 2;
-4.07315508907183
> airy_zero_Bi_deriv_e 3;
[-5.5123957296636,1.22399773198358e-15]
@end example

@noindent

@node Bessel Functions,Examples<3>,Examples<2>,Special Functions
@anchor{bessel functions}@anchor{2b}@anchor{bessel-functions}
@section Bessel Functions

@geindex gsl sf bessel_J0 function
@anchor{2c}@anchor{gsl sf bessel_j0}
@deffn {Function} gsl::sf::bessel_J0 x

implements @code{gsl_sf_bessel_J0}.
@end deffn

@geindex gsl sf bessel_J0_e function
@anchor{2d}@anchor{gsl sf bessel_j0_e}
@deffn {Function} gsl::sf::bessel_J0_e x

implements @code{gsl_sf_besselJ0_e}.
@end deffn

@geindex gsl sf bessel_J1 function
@anchor{2e}@anchor{gsl sf bessel_j1}
@deffn {Function} gsl::sf::bessel_J1 x

implements @code{gsl_sf_bessel_J1}.
@end deffn

@geindex gsl sf bessel_J1_e function
@anchor{2f}@anchor{gsl sf bessel_j1_e}
@deffn {Function} gsl::sf::bessel_J1_e x

implements @code{gsl_sf_bessel_J1_e}.
@end deffn

@geindex gsl sf bessel_Jn function
@anchor{30}@anchor{gsl sf bessel_jn}
@deffn {Function} gsl::sf::bessel_Jn n  x

implements @code{gsl_sf_bessel_Jn}.
@end deffn

@geindex gsl sf bessel_Jn_e function
@anchor{31}@anchor{gsl sf bessel_jn_e}
@deffn {Function} gsl::sf::bessel_Jn_e n  x

implements @code{gsl_sf_bessel_Jn_e}.
@end deffn

@geindex gsl sf bessel_Jn_array function
@anchor{32}@anchor{gsl sf bessel_jn_array}
@deffn {Function} gsl::sf::bessel_Jn_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_Jn_array}.
@end deffn

@geindex gsl sf bessel_Y0 function
@anchor{33}@anchor{gsl sf bessel_y0}
@deffn {Function} gsl::sf::bessel_Y0 x

implements @code{gsl_sf_bessel_Y0}.
@end deffn

@geindex gsl sf bessel_Y0_e function
@anchor{34}@anchor{gsl sf bessel_y0_e}
@deffn {Function} gsl::sf::bessel_Y0_e x

implements @code{gsl_sf_bessel_Y0_e}.
@end deffn

@geindex gsl sf bessel_Y1 function
@anchor{35}@anchor{gsl sf bessel_y1}
@deffn {Function} gsl::sf::bessel_Y1 x

implements @code{gsl_sf_bessel_Y1}.
@end deffn

@geindex gsl sf bessel_Y1_e function
@anchor{36}@anchor{gsl sf bessel_y1_e}
@deffn {Function} gsl::sf::bessel_Y1_e x

implements @code{gsl_sf_bessel_Y1_e}.
@end deffn

@geindex gsl sf bessel_Yn function
@anchor{37}@anchor{gsl sf bessel_yn}
@deffn {Function} gsl::sf::bessel_Yn x

implements @code{gsl_sf_bessel_Yn}.
@end deffn

@geindex gsl sf bessel_Yn_e function
@anchor{38}@anchor{gsl sf bessel_yn_e}
@deffn {Function} gsl::sf::bessel_Yn_e x

implements @code{gsl_sf_bessel_Yn_e}.
@end deffn

@geindex gsl sf bessel_Yn_array function
@anchor{39}@anchor{gsl sf bessel_yn_array}
@deffn {Function} gsl::sf::bessel_Yn_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_Yn_array}.
@end deffn

@geindex gsl sf bessel_I0 function
@anchor{3a}@anchor{gsl sf bessel_i0}
@deffn {Function} gsl::sf::bessel_I0 x

implements @code{gsl_sf_bessel_I0}.
@end deffn

@geindex gsl sf bessel_I0_e function
@anchor{3b}@anchor{gsl sf bessel_i0_e}
@deffn {Function} gsl::sf::bessel_I0_e x

implements @code{gsl_sf_bessel_I0_e}.
@end deffn

@geindex gsl sf bessel_I1 function
@anchor{3c}@anchor{gsl sf bessel_i1}
@deffn {Function} gsl::sf::bessel_I1 x

implements @code{gsl_sf_bessel_I1}.
@end deffn

@geindex gsl sf bessel_I1_e function
@anchor{3d}@anchor{gsl sf bessel_i1_e}
@deffn {Function} gsl::sf::bessel_I1_e x

implements @code{gsl_sf_bessel_I1_e}.
@end deffn

@geindex gsl sf bessel_In function
@anchor{3e}@anchor{gsl sf bessel_in}
@deffn {Function} gsl::sf::bessel_In n::int  x

implements @code{gsl_sf_bessel_In}.
@end deffn

@geindex gsl sf bessel_In_e function
@anchor{3f}@anchor{gsl sf bessel_in_e}
@deffn {Function} gsl::sf::bessel_In_e n::int  x

implements @code{gsl_sf_bessel_In_e}
@end deffn

@geindex gsl sf bessel_In_array function
@anchor{40}@anchor{gsl sf bessel_in_array}
@deffn {Function} gsl::sf::bessel_In_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_In_array}.
@end deffn

@geindex gsl sf bessel_I0_scaled function
@anchor{41}@anchor{gsl sf bessel_i0_scaled}
@deffn {Function} gsl::sf::bessel_I0_scaled x

implements @code{gsl_sf_bessel_I0_scaled}.
@end deffn

@geindex gsl sf bessel_I0_scaled_e function
@anchor{42}@anchor{gsl sf bessel_i0_scaled_e}
@deffn {Function} gsl::sf::bessel_I0_scaled_e x

implements @code{gsl_sf_bessel_I0_scaled_e}.
@end deffn

@geindex gsl sf bessel_I1_scaled function
@anchor{43}@anchor{gsl sf bessel_i1_scaled}
@deffn {Function} gsl::sf::bessel_I1_scaled x

implements @code{gsl_sf_bessel_I1_scaled}.
@end deffn

@geindex gsl sf bessel_I1_scaled_e function
@anchor{44}@anchor{gsl sf bessel_i1_scaled_e}
@deffn {Function} gsl::sf::bessel_I1_scaled_e x

implements @code{gsl_sf_bessel_I1_scaled_e}.
@end deffn

@geindex gsl sf bessel_In_scaled function
@anchor{45}@anchor{gsl sf bessel_in_scaled}
@deffn {Function} gsl::sf::bessel_In_scaled n::int  x

implements @code{gsl_sf_bessel_In_scaled}.
@end deffn

@geindex gsl sf bessel_In_scaled_e function
@anchor{46}@anchor{gsl sf bessel_in_scaled_e}
@deffn {Function} gsl::sf::bessel_In_scaled_e n::int  x

implements @code{gsl_sf_bessel_In_scaled_e}.
@end deffn

@geindex gsl sf bessel_In_scaled_array function
@anchor{47}@anchor{gsl sf bessel_in_scaled_array}
@deffn {Function} gsl::sf::bessel_In_scaled_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_In_array}.
@end deffn

@geindex gsl sf bessel_K0 function
@anchor{48}@anchor{gsl sf bessel_k0}
@deffn {Function} gsl::sf::bessel_K0 x

implements @code{gsl_sf_bessel_K0}.
@end deffn

@geindex gsl sf bessel_K0_e function
@anchor{49}@anchor{gsl sf bessel_k0_e}
@deffn {Function} gsl::sf::bessel_K0_e x

implements @code{gsl_sf_bessel_K0_e}.
@end deffn

@geindex gsl sf bessel_K1 function
@anchor{4a}@anchor{gsl sf bessel_k1}
@deffn {Function} gsl::sf::bessel_K1 x

implements @code{gsl_sf_bessel_K1}.
@end deffn

@geindex gsl sf bessel_K1_e function
@anchor{4b}@anchor{gsl sf bessel_k1_e}
@deffn {Function} gsl::sf::bessel_K1_e x

implements @code{gsl_sf_bessel_K1_e}.
@end deffn

@geindex gsl sf bessel_Kn function
@anchor{4c}@anchor{gsl sf bessel_kn}
@deffn {Function} gsl::sf::bessel_Kn n::int  x

implements @code{gsl_sf_bessel_Kn}.
@end deffn

@geindex gsl sf bessel_Kn_e function
@anchor{4d}@anchor{gsl sf bessel_kn_e}
@deffn {Function} gsl::sf::bessel_Kn_e n::int  x

implements @code{gsl_sf_bessel_Kn_e}
@end deffn

@geindex gsl sf bessel_Kn_array function
@anchor{4e}@anchor{gsl sf bessel_kn_array}
@deffn {Function} gsl::sf::bessel_Kn_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_Kn_array}.
@end deffn

@geindex gsl sf bessel_K0_scaled function
@anchor{4f}@anchor{gsl sf bessel_k0_scaled}
@deffn {Function} gsl::sf::bessel_K0_scaled x

implements @code{gsl_sf_bessel_K0_scaled}.
@end deffn

@geindex gsl sf bessel_K0_scaled_e function
@anchor{50}@anchor{gsl sf bessel_k0_scaled_e}
@deffn {Function} gsl::sf::bessel_K0_scaled_e x

implements @code{gsl_sf_bessel_K0_scaled_e}.
@end deffn

@geindex gsl sf bessel_K1_scaled function
@anchor{51}@anchor{gsl sf bessel_k1_scaled}
@deffn {Function} gsl::sf::bessel_K1_scaled x

implements @code{gsl_sf_bessel_K1_scaled}.
@end deffn

@geindex gsl sf bessel_K1_scaled_e function
@anchor{52}@anchor{gsl sf bessel_k1_scaled_e}
@deffn {Function} gsl::sf::bessel_K1_scaled_e x

implements @code{gsl_sf_bessel_K1_scaled_e}.
@end deffn

@geindex gsl sf bessel_Kn_scaled function
@anchor{53}@anchor{gsl sf bessel_kn_scaled}
@deffn {Function} gsl::sf::bessel_Kn_scaled n::int  x

implements @code{gsl_sf_bessel_Kn_scaled}.
@end deffn

@geindex gsl sf bessel_Kn_scaled_e function
@anchor{54}@anchor{gsl sf bessel_kn_scaled_e}
@deffn {Function} gsl::sf::bessel_Kn_scaled_e n::int  x

implements @code{gsl_sf_bessel_Kn_scaled_e}.
@end deffn

@geindex gsl sf bessel_Kn_scaled_array function
@anchor{55}@anchor{gsl sf bessel_kn_scaled_array}
@deffn {Function} gsl::sf::bessel_Kn_scaled_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_Kn_array}.
@end deffn

@geindex gsl sf bessel_j0 function
@deffn {Function} gsl::sf::bessel_j0 x

implements @code{gsl_sf_bessel_j0}.
@end deffn

@geindex gsl sf bessel_j0_e function
@deffn {Function} gsl::sf::bessel_j0_e x

implements @code{gsl_sf_bessel_j0_e}.
@end deffn

@geindex gsl sf bessel_j1 function
@deffn {Function} gsl::sf::bessel_j1 x

implements @code{gsl_sf_bessel_j1}.
@end deffn

@geindex gsl sf bessel_j1_e function
@deffn {Function} gsl::sf::bessel_j1_e x

implements @code{gsl_sf_bessel_j1_e}.
@end deffn

@geindex gsl sf bessel_j2 function
@anchor{56}@anchor{gsl sf bessel_j2}
@deffn {Function} gsl::sf::bessel_j2 x

implements @code{gsl_sf_bessel_j2}.
@end deffn

@geindex gsl sf bessel_j2_e function
@anchor{57}@anchor{gsl sf bessel_j2_e}
@deffn {Function} gsl::sf::bessel_j2_e x

implements @code{gsl_sf_bessel_j2_e}.
@end deffn

@geindex gsl sf bessel_jl function
@anchor{58}@anchor{gsl sf bessel_jl}
@deffn {Function} gsl::sf::bessel_jl l::int  x

implements @code{gsl_sf_bessel_jl}.
@end deffn

@geindex gsl sf bessel_jl_e function
@anchor{59}@anchor{gsl sf bessel_jl_e}
@deffn {Function} gsl::sf::bessel_jl_e l::int  x

implements @code{gsl_sf_bessel_jl_e}.
@end deffn

@geindex gsl sf bessel_jl_array function
@anchor{5a}@anchor{gsl sf bessel_jl_array}
@deffn {Function} gsl::sf::bessel_jl_array lmax::int  x

implements @code{gsl_sf_bessel_jl_array}.
@end deffn

@geindex gsl sf bessel_jl_steed_array function
@anchor{5b}@anchor{gsl sf bessel_jl_steed_array}
@deffn {Function} gsl::sf::bessel_jl_steed_array lmax::int  x

implements @code{gsl_sf_bessel_jl_steed_array}.
@end deffn

@geindex gsl sf bessel_y0 function
@deffn {Function} gsl::sf::bessel_y0 x

implements @code{gsl_sf_bessel_y0}.
@end deffn

@geindex gsl sf bessel_y0_e function
@deffn {Function} gsl::sf::bessel_y0_e x

implements @code{gsl_sf_bessel_y0_e}.
@end deffn

@geindex gsl sf bessel_y1 function
@deffn {Function} gsl::sf::bessel_y1 x

implements @code{gsl_sf_bessel_y1}.
@end deffn

@geindex gsl sf bessel_y1_e function
@deffn {Function} gsl::sf::bessel_y1_e x

implements @code{gsl_sf_bessel_y1_e}.
@end deffn

@geindex gsl sf bessel_y2 function
@anchor{5c}@anchor{gsl sf bessel_y2}
@deffn {Function} gsl::sf::bessel_y2 x

implements @code{gsl_sf_bessel_y2}.
@end deffn

@geindex gsl sf bessel_y2_e function
@anchor{5d}@anchor{gsl sf bessel_y2_e}
@deffn {Function} gsl::sf::bessel_y2_e x

implements @code{gsl_sf_bessel_y2_e}.
@end deffn

@geindex gsl sf bessel_yl function
@anchor{5e}@anchor{gsl sf bessel_yl}
@deffn {Function} gsl::sf::bessel_yl l::int  x

implements @code{gsl_sf_bessel_yl}.
@end deffn

@geindex gsl sf bessel_yl_e function
@anchor{5f}@anchor{gsl sf bessel_yl_e}
@deffn {Function} gsl::sf::bessel_yl_e l::int  x

implements @code{gsl_sf_bessel_yl_e}.
@end deffn

@geindex gsl sf bessel_yl_array function
@anchor{60}@anchor{gsl sf bessel_yl_array}
@deffn {Function} gsl::sf::bessel_yl_array lmax::int  x

implements @code{gsl_sf_bessel_yl_array}.
@end deffn

@geindex gsl sf bessel_i0_scaled function
@deffn {Function} gsl::sf::bessel_i0_scaled x

implements @code{gsl_sf_bessel_i0_scaled}.
@end deffn

@geindex gsl sf bessel_i0_scaled_e function
@deffn {Function} gsl::sf::bessel_i0_scaled_e x

implements @code{gsl_sf_bessel_i0_scaled_e}.
@end deffn

@geindex gsl sf bessel_i1_scaled function
@deffn {Function} gsl::sf::bessel_i1_scaled x

implements @code{gsl_sf_bessel_i1_scaled}.
@end deffn

@geindex gsl sf bessel_i1_scaled_e function
@deffn {Function} gsl::sf::bessel_i1_scaled_e x

implements @code{gsl_sf_bessel_i1_scaled_e}.
@end deffn

@geindex gsl sf bessel_i2_scaled function
@anchor{61}@anchor{gsl sf bessel_i2_scaled}
@deffn {Function} gsl::sf::bessel_i2_scaled x

implements @code{gsl_sf_bessel_i2_scaled}.
@end deffn

@geindex gsl sf bessel_i2_scaled_e function
@anchor{62}@anchor{gsl sf bessel_i2_scaled_e}
@deffn {Function} gsl::sf::bessel_i2_scaled_e x

implements @code{gsl_sf_bessel_i2_scaled_e}.
@end deffn

@geindex gsl sf bessel_il_scaled function
@anchor{63}@anchor{gsl sf bessel_il_scaled}
@deffn {Function} gsl::sf::bessel_il_scaled l::int  x

implements @code{gsl_sf_bessel_il_scaled}.
@end deffn

@geindex gsl sf bessel_il_scaled_e function
@anchor{64}@anchor{gsl sf bessel_il_scaled_e}
@deffn {Function} gsl::sf::bessel_il_scaled_e l::int  x

implements @code{gsl_sf_bessel_il_scaled_e}.
@end deffn

@geindex gsl sf bessel_il_scaled_array function
@anchor{65}@anchor{gsl sf bessel_il_scaled_array}
@deffn {Function} gsl::sf::bessel_il_scaled_array lmax::int  x

implements @code{gsl_sf_bessel_il_scaled_array}.
@end deffn

@geindex gsl sf bessel_k0_scaled function
@deffn {Function} gsl::sf::bessel_k0_scaled x

implements @code{gsl_sf_bessel_k0_scaled}.
@end deffn

@geindex gsl sf bessel_k0_scaled_e function
@deffn {Function} gsl::sf::bessel_k0_scaled_e x

implements @code{gsl_sf_bessel_k0_scaled_e}.
@end deffn

@geindex gsl sf bessel_k1_scaled function
@deffn {Function} gsl::sf::bessel_k1_scaled x

implements @code{gsl_sf_bessel_k1_scaled}.
@end deffn

@geindex gsl sf bessel_k1_scaled_e function
@deffn {Function} gsl::sf::bessel_k1_scaled_e x

implements @code{gsl_sf_bessel_ik_scaled_e}.
@end deffn

@geindex gsl sf bessel_k2_scaled function
@anchor{66}@anchor{gsl sf bessel_k2_scaled}
@deffn {Function} gsl::sf::bessel_k2_scaled x

implements @code{gsl_sf_bessel_k2_scaled}.
@end deffn

@geindex gsl sf bessel_k2_scaled_e function
@anchor{67}@anchor{gsl sf bessel_k2_scaled_e}
@deffn {Function} gsl::sf::bessel_k2_scaled_e x

implements @code{gsl_sf_bessel_k2_scaled_e}.
@end deffn

@geindex gsl sf bessel_kl_scaled function
@anchor{68}@anchor{gsl sf bessel_kl_scaled}
@deffn {Function} gsl::sf::bessel_kl_scaled l::int  x

implements @code{gsl_sf_bessel_kl_scaled}.
@end deffn

@geindex gsl sf bessel_kl_scaled_e function
@anchor{69}@anchor{gsl sf bessel_kl_scaled_e}
@deffn {Function} gsl::sf::bessel_kl_scaled_e l::int  x

implements @code{gsl_sf_bessel_kl_scaled_e}.
@end deffn

@geindex gsl sf bessel_kl_scaled_array function
@anchor{6a}@anchor{gsl sf bessel_kl_scaled_array}
@deffn {Function} gsl::sf::bessel_kl_scaled_array lmax::int  x

implements @code{gsl_sf_bessel_il_scaled_array}.
@end deffn

@geindex gsl sf bessel_Jnu function
@anchor{6b}@anchor{gsl sf bessel_jnu}
@deffn {Function} gsl::sf::bessel_Jnu nu  x

implements @code{gsl_sf_bessel_Jnu}.
@end deffn

@geindex gsl sf bessel_Jnu_e function
@anchor{6c}@anchor{gsl sf bessel_jnu_e}
@deffn {Function} gsl::sf::bessel_Jnu_e nu  x

implements @code{gsl_sf_bessel_Jnu_e}.
@end deffn

@geindex gsl sf bessel_sequence_Jnu_e function
@anchor{6d}@anchor{gsl sf bessel_sequence_jnu_e}
@deffn {Function} gsl::sf::bessel_sequence_Jnu_e nu  v::matrix

implements @code{gsl_sf_bessel_sequence_Jnu_e}.
@end deffn

@geindex gsl sf bessel_Ynu function
@anchor{6e}@anchor{gsl sf bessel_ynu}
@deffn {Function} gsl::sf::bessel_Ynu nu  x

implements @code{gsl_sf_bessel_Ynu}.
@end deffn

@geindex gsl sf bessel_Ynu_e function
@anchor{6f}@anchor{gsl sf bessel_ynu_e}
@deffn {Function} gsl::sf::bessel_Ynu_e nu  x

implements @code{gsl_sf_bessel_Ynu_e}.
@end deffn

@geindex gsl sf bessel_Inu function
@anchor{70}@anchor{gsl sf bessel_inu}
@deffn {Function} gsl::sf::bessel_Inu nu  x

implements @code{gsl_sf_bessel_Inu}.
@end deffn

@geindex gsl sf bessel_Inu_e function
@anchor{71}@anchor{gsl sf bessel_inu_e}
@deffn {Function} gsl::sf::bessel_Inu_e nu  x

implements @code{gsl_sf_bessel_Inu_e}.
@end deffn

@geindex gsl sf bessel_Inu_scaled function
@anchor{72}@anchor{gsl sf bessel_inu_scaled}
@deffn {Function} gsl::sf::bessel_Inu_scaled nu  x

implements @code{gsl_sf_bessel_Inu_scaled}.
@end deffn

@geindex gsl sf bessel_Inu_scaled_e function
@anchor{73}@anchor{gsl sf bessel_inu_scaled_e}
@deffn {Function} gsl::sf::bessel_Inu_scaled_e nu  x

implements @code{gsl_sf_bessel_Inu_scaled_e}.
@end deffn

@geindex gsl sf bessel_Knu function
@anchor{74}@anchor{gsl sf bessel_knu}
@deffn {Function} gsl::sf::bessel_Knu nu  x

implements @code{gsl_sf_bessel_Knu}.
@end deffn

@geindex gsl sf bessel_Knu_e function
@anchor{75}@anchor{gsl sf bessel_knu_e}
@deffn {Function} gsl::sf::bessel_Knu_e nu  x

implements @code{gsl_sf_bessel_Knu}.
@end deffn

@geindex gsl sf bessel_lnKnu function
@anchor{76}@anchor{gsl sf bessel_lnknu}
@deffn {Function} gsl::sf::bessel_lnKnu nu  x

implements @code{gsl_sf_bessel_lnKnu}.
@end deffn

@geindex gsl sf bessel_lnKnu_e function
@anchor{77}@anchor{gsl sf bessel_lnknu_e}
@deffn {Function} gsl::sf::bessel_lnKnu_e nu  x

implements @code{gsl_sf_bessel_lnKnu_e}.
@end deffn

@geindex gsl sf bessel_Knu_scaled function
@anchor{78}@anchor{gsl sf bessel_knu_scaled}
@deffn {Function} gsl::sf::bessel_Knu_scaled nu x

implements @code{gsl_sf_bessel_Knu_scaled}.
@end deffn

@geindex gsl sf bessel_Knu_scaled_e function
@anchor{79}@anchor{gsl sf bessel_knu_scaled_e}
@deffn {Function} gsl::sf::bessel_Knu_scaled_e nu x

implements @code{gsl_sf_bessel_Knu_scaled_e}.
@end deffn

@geindex gsl sf bessel_zero_J0 function
@anchor{7a}@anchor{gsl sf bessel_zero_j0}
@deffn {Function} gsl::sf::bessel_zero_J0 s::int

implements @code{gsl_sf_bessel_zero_J0}.
@end deffn

@geindex gsl sf bessel_zero_J0_e function
@anchor{7b}@anchor{gsl sf bessel_zero_j0_e}
@deffn {Function} gsl::sf::bessel_zero_J0_e s::int

implements @code{gsl_sf_bessel_zero_J0_e}.
@end deffn

@geindex gsl sf bessel_zero_J1 function
@anchor{7c}@anchor{gsl sf bessel_zero_j1}
@deffn {Function} gsl::sf::bessel_zero_J1 s::int

implements @code{gsl_sf_bessel_zero_J1}.
@end deffn

@geindex gsl sf bessel_zero_J1_e function
@anchor{7d}@anchor{gsl sf bessel_zero_j1_e}
@deffn {Function} gsl::sf::bessel_zero_J1_e s::int

implements @code{gsl_sf_bessel_zero_J1_e}.
@end deffn

@geindex gsl sf bessel_zero_Jnu function
@anchor{7e}@anchor{gsl sf bessel_zero_jnu}
@deffn {Function} gsl::sf::bessel_zero_Jnu nu  s::int

implements @code{gsl_sf_bessel_zero_Jnu}.
@end deffn

@geindex gsl sf bessel_zero_Jnu_e function
@anchor{7f}@anchor{gsl sf bessel_zero_jnu_e}
@deffn {Function} gsl::sf::bessel_zero_Jnu_e nu  s::int

implements @code{gsl_sf_bessel_zero_Jnu}.
@end deffn


@node Examples<3>,Clausen Functions,Bessel Functions,Special Functions
@anchor{examples<3>}@anchor{80}@anchor{id2}
@section Examples
The following illustrate the Bessel functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> bessel_J0 (-1.2);
0.671132744264363
> bessel_J0_e 0.75;
[0.864242275166649,7.07329111491049e-16]
> bessel_J1 1.2;
0.498289057567216
> bessel_J1_e (-0.2);
[-0.099500832639236,5.00768737808415e-17]
> bessel_Jn 0 (-1.2);
0.671132744264363
> bessel_Jn_e 2 0.75;
[0.0670739972996506,5.48959386474892e-17]
> bessel_Jn_array 0 4 0.5;
[0.938469807240813,0.242268457674874,0.0306040234586826,
 0.00256372999458724,0.000160736476364288]
> bessel_Y0 0.25;
-0.931573024930059
> bessel_Y0_e 0.25;
[-0.931573024930059,6.4279898430593e-16]
> bessel_Y1 0.125;
-5.19993611253477
> bessel_Y1_e 4.325;
[0.343041276811844,2.74577716760089e-16]
> bessel_Yn 3 4.325;
-0.0684784962694202
> bessel_Yn_e 3 4.325;
[-0.0684784962694202,3.37764590906247e-16]
> bessel_Yn_array 2 4 1.35;
[-1.07379345815726,-2.66813016175689,-10.7845628163178]
> bessel_I0 1.35;
1.51022709775726
> bessel_I0_e 1.35;
[1.51022709775726,2.37852166449918e-15]
> bessel_I1 0.35;
0.177693400031422
> bessel_I1_e 0.35;
[0.177693400031422,1.55520651386126e-16]
> bessel_In 2 3.0;
2.24521244092995
> bessel_In_e 2 3.0;
2.24521244092995,5.98244771302867e-15]
> bessel_In_array 3 5 (-0.1);
[-2.08463574223272e-05,2.60546902129966e-07,-2.6052519298937e-09]
> bessel_I0_scaled 1.05;
0.453242541279856
> bessel_I0_scaled_e 1.05;
[0.453242541279856,4.10118141697477e-16]
> bessel_I1_scaled 1.05;
0.210226017612868
> bessel_I1_scaled_e 1.05;
[0.210226017612868,2.12903131803686e-16]
> bessel_In_scaled 3 1.05;
0.00903732602788281
> bessel_In_scaled_e 3 1.05;
[0.00903732602788281,2.00668948743994e-17]
> bessel_In_scaled_array 3 5 1.05;
[0.00903732602788281,0.0011701685245855,0.000121756316755217]
> bessel_K0 2.3;
0.0791399330020936
> bessel_K0_e 2.3;
[0.0791399330020936,1.15144454318261e-16]
> bessel_K1 2.3;
0.0949824438453627
> bessel_K1_e 2.3;
[0.0949824438453627,9.85583638959967e-17]
> bessel_Kn 2 3.4;
0.0366633035851529
> bessel_Kn_e 2 3.4;
[0.0366633035851529,2.01761856558251e-16]
> bessel_Kn_array 1 3 2.5;
[0.0738908163477471,0.121460206278564,0.268227146393449]
> bessel_K0_scaled 1.5;
0.367433609054158
> bessel_K0_scaled_e 1.5;
[0.958210053294896,1.25816573186951e-14]
> bessel_K1_scaled 1.5;
1.24316587355255
> bessel_K1_scaled_e 1.5;
[1.24316587355255,2.32370553362606e-15]
> bessel_Kn_scaled 4 1.5;
35.4899165934682
> bessel_Kn_scaled_e 4 1.5;
[35.4899165934682,3.89252285021454e-14]
> bessel_Kn_scaled_array 4 6 1.5;
[35.4899165934682,197.498093175689,1352.14387109806]
> bessel_j0 0.01;
0.999983333416666
> bessel_j0_e 0.01;
[0.999983333416666,4.44081808400239e-16]
> bessel_j1 0.2;
0.0664003806703222
> bessel_j1_e 0.2;
[0.0664003806703222,2.94876925856268e-17]
> bessel_j2 0.3;
0.00596152486862022
> bessel_j2_e 0.3;
[0.00596152486862022,2.64744886840705e-18]
> bessel_jl 4 0.3;
8.53642426502516e-06
> bessel_jl_e 4 0.3;
[8.53642426502516e-06,1.02355215483598e-19]
> bessel_jl_array 2 1.2;
[0.776699238306022,0.34528456985779,0.0865121863384538]
> bessel_jl_steed_array 2 1.2;
[0.776699238306022,0.34528456985779,0.0865121863384538]
> bessel_y0 1;
-0.54030230586814
> bessel_y0_e 3;
[0.329997498866815,2.93096657048522e-16]
> bessel_y1 3;
0.062959163602316
> bessel_y1_e 3.0;
[0.062959163602316,1.04609100698801e-16]
> bessel_yl 3 5;
-0.0154429099129942
> bessel_yl_e 3 5;
[-0.0154429099129942,2.87258769784673e-17]
> bessel_i0_scaled 3;
0.166253541303889
> bessel_i0_scaled_e 3;
[0.166253541303889,7.38314037924188e-17]
> bessel_i1_scaled 3;
0.111661944928148
> bessel_i1_scaled_e 3;
[0.111661944928148,4.95878648934625e-17]
> bessel_i2_scaled 3;
0.0545915963757409
> bessel_i2_scaled_e 3;
[0.0545915963757409,2.42435388989563e-17]
> bessel_il_scaled 3 1;
0.0037027398773348
> bessel_il_scaled_e 3 1;
[0.0037027398773348,8.46838615599053e-17]
> bessel_il_scaled_array 3 1;
[0.432332358381693,0.135335283236613,0.0263265086718556,0.0037027398773348]
> bessel_k0_scaled 3;
0.523598775598299
> bessel_k0_scaled_e 3;
[0.523598775598299,2.32524566533909e-16]
> bessel_k1_scaled 4;
0.490873852123405
> bessel_k1_scaled_e 4;
[0.490873852123405,2.17991781125539e-16]
> bessel_k2_scaled 4;
0.760854470791278
> bessel_k2_scaled_e 4;
[0.760854470791278,3.37887260744586e-16]
> bessel_kl_scaled 2 4;
0.760854470791278
> bessel_kl_scaled_e 2 4;
[0.760854470791278,3.37887260744586e-16]
> bessel_kl_scaled_array 2 4;
[0.392699081698724,0.490873852123405,0.760854470791278]
> bessel_Jnu 2 2.3;
0.413914591732062
> bessel_Jnu_e 2 2.3;
[0.413914591732062,6.43352513956959e-16]
> bessel_sequence_Jnu_e 2 @{.1,.2,.3@};
[0.00124895865879992,0.00498335415278356,0.011165861949064]
> bessel_Ynu 1 0.5;
-1.47147239267024
> bessel_Ynu_e 1 0.5;
[-1.47147239267024,8.49504515830242e-15]
> bessel_Inu 1.2 3.4;
5.25626563437082
> bessel_Inu_e 1.2 3.4;
[5.25626563437082,1.00839636820646e-13]
> bessel_Inu_scaled 1.2 3.4;
0.175418771999042
> bessel_Inu_scaled_e 1.2 3.4;
[0.175418771999042,3.15501414592188e-15]
> bessel_Knu 3 3;
0.122170375757184
> bessel_Knu_e 3 3;
[0.122170375757184,4.34036365096743e-16]
> bessel_lnKnu 3 3;
-2.10233868587978
> bessel_lnKnu_e 3 3;
[-2.10233868587978,4.24157124665032e-15]
> bessel_Knu_scaled 3 3;
2.45385759319062
> bessel_Knu_scaled_e 3 3;
[2.45385759319062,7.6281217575122e-15]
> bessel_zero_J0 3;
8.65372791291102
> bessel_zero_J0_e 3;
[8.65372791291102,2.59611837387331e-14]
> bessel_zero_J1 3;
10.1734681350627
> bessel_zero_J1_e 3;
[10.1734681350627,2.03469362701254e-13]
> bessel_zero_Jnu 1.2 3;
10.46769
> bessel_zero_Jnu_e 1.2 3;
[10.4676986203553,2.09353972407105e-14]86203553
@end example

@noindent

@node Clausen Functions,Examples<4>,Examples<3>,Special Functions
@anchor{clausen functions}@anchor{81}@anchor{clausen-functions}
@section Clausen Functions

@geindex gsl sf clausen function
@anchor{82}@anchor{gsl sf clausen}
@deffn {Function} gsl::sf::clausen x

implements @code{gsl_sf_clausen}.
@end deffn

@geindex gsl sf clausen_e function
@anchor{83}@anchor{gsl sf clausen_e}
@deffn {Function} gsl::sf::clausen_e x

implements @code{gsl_sf_clausen_e}.
@end deffn


@node Examples<4>,Colomb Functions,Clausen Functions,Special Functions
@anchor{examples<4>}@anchor{84}@anchor{id3}
@section Examples
The following illustrate the Clausen functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> clausen 4.5;
-0.831839220823219
> clausen_e 4.5;
[-0.831839220823219,8.60688668835964e-16]
@end example

@noindent

@node Colomb Functions,Examples<5>,Examples<4>,Special Functions
@anchor{colomb functions}@anchor{85}@anchor{colomb-functions}
@section Colomb Functions
The results of the Coulomb wave functions are returned as a list whose
elements are ordered corresponding to the argument order of the
corresponding C functions in GSL library.

@geindex gsl sf hydrogenicR_1 function
@anchor{86}@anchor{gsl sf hydrogenicr_1}
@deffn {Function} gsl::sf::hydrogenicR_1 Z  r

implements @code{gsl_sf_hydrogenicR_1}.
@end deffn

@geindex gsl sf hydrogenicR_1_e function
@anchor{87}@anchor{gsl sf hydrogenicr_1_e}
@deffn {Function} gsl::sf::hydrogenicR_1_e Z  r

implements @code{gsl_sf_hydrogenicR_1_e}.
@end deffn

@geindex gsl sf hydrogenicR function
@anchor{88}@anchor{gsl sf hydrogenicr}
@deffn {Function} gsl::sf::hydrogenicR n::int  l::int  Z  r

implements @code{gsl_sf_hydrogenicR_1}.
@end deffn

@geindex gsl sf hydrogenicR_e function
@anchor{89}@anchor{gsl sf hydrogenicr_e}
@deffn {Function} gsl::sf::hydrogenicR_e n::int  l::int  Z  r

implements @code{gsl_sf_hydrogenicR_1_e}.
@end deffn

@geindex gsl sf coulomb_wave_FG_e function
@anchor{8a}@anchor{gsl sf coulomb_wave_fg_e}
@deffn {Function} gsl::sf::coulomb_wave_FG_e eta  x  L_F  k::int

implements @code{gsl_sf_coulomb_wave_FG_e}.
@end deffn

@geindex gsl sf coulomb_wave_F_array function
@anchor{8b}@anchor{gsl sf coulomb_wave_f_array}
@deffn {Function} gsl::sf::coulomb_wave_F_array L_min  kmax::int  eta  x

implements @code{gsl_sf_coulomb_wave_F_array}.
@end deffn

@geindex gsl sf coulomb_wave_FG_array function
@anchor{8c}@anchor{gsl sf coulomb_wave_fg_array}
@deffn {Function} gsl::sf::coulomb_wave_FG_array L_min  kmax::int  eta  x

implements @code{gsl_sf_coulomb_wave_FG_array}.
@end deffn

@geindex gsl sf coulomb_wave_FGp_array function
@anchor{8d}@anchor{gsl sf coulomb_wave_fgp_array}
@deffn {Function} gsl::sf::coulomb_wave_FGp_array L_min  kmax::int  eta x

implements @code{gsl_sf_coulomb_wave_FGp_array}.
@end deffn

@geindex gsl sf coulomb_wave_sphF_array function
@anchor{8e}@anchor{gsl sf coulomb_wave_sphf_array}
@deffn {Function} gsl::sf::coulomb_wave_sphF_array L_min  kmax::int  eta  x

implements @code{gsl_sf_coulomb_wave_sphF_array}.
@end deffn

@geindex gsl sf coulomb_CL_e function
@anchor{8f}@anchor{gsl sf coulomb_cl_e}
@deffn {Function} gsl::sf::coulomb_CL_e L  eta

implements @code{gsl_sf_coulomb_wave_CL_e}.
@end deffn

@geindex gsl sf coulomb_CL_array function
@anchor{90}@anchor{gsl sf coulomb_cl_array}
@deffn {Function} gsl::sf::coulomb_CL_array Lmin  kmax  eta

implements @code{gsl_sf_coulomb_wave_CL_array}.
@end deffn


@node Examples<5>,Coupling Coefficients,Colomb Functions,Special Functions
@anchor{examples<5>}@anchor{91}@anchor{id4}
@section Examples
The following illustrate the Coulomb functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> hydrogenicR_1 0.2 4;
0.0803784086420537
> hydrogenicR_1_e 0.2 4;
[0.0803784086420537,2.85561471862841e-17]
> hydrogenicR 3 1 0.25 3.2;
0.00802954301593587
> hydrogenicR_e 3 1 0.25 3.2;
[0.00802954301593587,3.90138748076797e-17]
> coulomb_wave_F_array 1 2 0.5 0.5;
[@{0.0387503306520188,0.0038612830533923,0.000274978904710252@},0.0]
> coulomb_wave_FG_array 1 2 0.5 0.5;
[@{0.0387503306520188,0.0038612830533923,0.000274978904710252@},
 @{4.13731494044202,25.4479852847406,257.269816591168@},0.0,0.0]
> coulomb_wave_FGp_array 1 2 0.5 0.5;
[@{0.0387503306520188,0.0038612830533923,0.000274978904710252@},
 @{4.13731494044202,25.4479852847406,257.269816591168@},0.0,0.0]
> coulomb_wave_sphF_array 1 2 0.5 0.5;
[@{0.0775006613040376,0.0077225661067846,0.000549957809420504@},0.0]
> coulomb_CL_e (-0.5) 3;
[0.000143036170217949,2.92195771135514e-18]
> coulomb_CL_array (-0.5) 4 1.5;
[0.0159218263353144,0.0251746178646226,0.00890057150292734,
 0.00172996014234001,0.000235267570111599]
@end example

@noindent

@node Coupling Coefficients,Examples<6>,Examples<5>,Special Functions
@anchor{coupling coefficients}@anchor{92}@anchor{coupling-coefficients}
@section Coupling Coefficients

@geindex gsl sf coupling_3j function
@anchor{93}@anchor{gsl sf coupling_3j}
@deffn {Function} gsl::sf::coupling_3j m::matrix

implements @code{gsl_sf_coupling_3j} except the input is a 2x3 (row by
column) integer matrix instead of six integer arguments.
@end deffn

@geindex gsl sf coupling_3j_e function
@anchor{94}@anchor{gsl sf coupling_3j_e}
@deffn {Function} gsl::sf::coupling_3j_e m::matrix

implements @code{gsl_sf_coupling_3j_e} except the input is a 2x3 (row by
column) integer matrix instead of six integer arguments.
@end deffn

@geindex gsl sf coupling_6j function
@anchor{95}@anchor{gsl sf coupling_6j}
@deffn {Function} gsl::sf::coupling_6j m::matrix

implements @code{gsl_sf_coupling_6j} except the input is a 2x3 (row by
column) integer matrix instead of six integer arguments.
@end deffn

@geindex gsl sf coupling_6j_e function
@anchor{96}@anchor{gsl sf coupling_6j_e}
@deffn {Function} gsl::sf::coupling_6j_e m::matrix

implements @code{gsl_sf_coupling_6j_e} except the input is a 2x3 (row by
column) integer matrix instead of six integer arguments.
@end deffn

@geindex gsl sf coupling_9j function
@anchor{97}@anchor{gsl sf coupling_9j}
@deffn {Function} gsl::sf::coupling_9j m::matrix

implements @code{gsl_sf_coupling_9j} except the input is a 3x3 integer
matrix instead of six integer arguments.
@end deffn

@geindex gsl sf coupling_9j_e function
@anchor{98}@anchor{gsl sf coupling_9j_e}
@deffn {Function} gsl::sf::coupling_9j_e m::matrix

implements @code{gsl_sf_coupling_9j_e} except the input is a 3x3 integer
matrix instead of six integer arguments.
@end deffn


@node Examples<6>,Dawson Function,Coupling Coefficients,Special Functions
@anchor{examples<6>}@anchor{99}@anchor{id5}
@section Examples
The following illustrate the coupling coefficient functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> coupling_3j @{6,4,2;0,0,0@};
-0.29277002188456
> coupling_3j_e @{6,4,2;0,0,0@};
[-0.29277002188456,1.300160076865e-16]
> coupling_6j @{1,2,3;2,1,2@};
-0.166666666666667
> coupling_6j_e @{1,2,3;2,1,2@};
[-0.166666666666667,2.22044604925031e-16]
> coupling_9j @{1,2,3;2,1,2;1,1,1@};
-0.0962250448649376
> coupling_9j_e @{1,2,3;2,1,2;1,1,1@};
[-0.0962250448649376,4.84948508304183e-16]
@end example

@noindent

@node Dawson Function,Examples<7>,Examples<6>,Special Functions
@anchor{dawson function}@anchor{9a}@anchor{dawson-function}
@section Dawson Function

@geindex gsl sf dawson function
@anchor{9b}@anchor{gsl sf dawson}
@deffn {Function} gsl::sf::dawson x

implements @code{gsl_sf_dawson}.
@end deffn

@geindex gsl sf dawson_e function
@anchor{9c}@anchor{gsl sf dawson_e}
@deffn {Function} gsl::sf::dawson_e x

implements @code{gsl_sf_dawson_e}.
@end deffn


@node Examples<7>,Debye Functions,Dawson Function,Special Functions
@anchor{examples<7>}@anchor{9d}@anchor{id6}
@section Examples
The following illustrate the dawson functions.

@example
> dawson 3;/**-
0.178271030610558
> dawson_e 3;
[0.178271030610558,8.9920386788099e-16]
@end example

@noindent

@node Debye Functions,Examples<8>,Examples<7>,Special Functions
@anchor{debye functions}@anchor{9e}@anchor{debye-functions}
@section Debye Functions

@geindex gsl sf debye_1 function
@anchor{9f}@anchor{gsl sf debye_1}
@deffn {Function} gsl::sf::debye_1 x

implements @code{gsl_sf_debye_1}.
@end deffn

@geindex gsl sf debye_1_e function
@anchor{a0}@anchor{gsl sf debye_1_e}
@deffn {Function} gsl::sf::debye_1_e x

implements @code{gsl_sf_debye_1_e}.
@end deffn

@geindex gsl sf debye_2 function
@anchor{a1}@anchor{gsl sf debye_2}
@deffn {Function} gsl::sf::debye_2 x

implements @code{gsl_sf_debye_2}.
@end deffn

@geindex gsl sf debye_2_e function
@anchor{a2}@anchor{gsl sf debye_2_e}
@deffn {Function} gsl::sf::debye_2_e x

implements @code{gsl_sf_debye_2_e}.
@end deffn

@geindex gsl sf debye_3 function
@anchor{a3}@anchor{gsl sf debye_3}
@deffn {Function} gsl::sf::debye_3 x

implements @code{gsl_sf_debye_3}.
@end deffn

@geindex gsl sf debye_3_e function
@anchor{a4}@anchor{gsl sf debye_3_e}
@deffn {Function} gsl::sf::debye_3_e x

implements @code{gsl_sf_debye_3_e}.
@end deffn

@geindex gsl sf debye_4 function
@anchor{a5}@anchor{gsl sf debye_4}
@deffn {Function} gsl::sf::debye_4 x

implements @code{gsl_sf_debye_4}.
@end deffn

@geindex gsl sf debye_4_e function
@anchor{a6}@anchor{gsl sf debye_4_e}
@deffn {Function} gsl::sf::debye_4_e x

implements @code{gsl_sf_debye_4_e}.
@end deffn

@geindex gsl sf debye_5 function
@anchor{a7}@anchor{gsl sf debye_5}
@deffn {Function} gsl::sf::debye_5 x

implements @code{gsl_sf_debye_5}.
@end deffn

@geindex gsl sf debye_5_e function
@anchor{a8}@anchor{gsl sf debye_5_e}
@deffn {Function} gsl::sf::debye_5_e x

implements @code{gsl_sf_debye_5_e}.
@end deffn

@geindex gsl sf debye_6 function
@anchor{a9}@anchor{gsl sf debye_6}
@deffn {Function} gsl::sf::debye_6 x

implements @code{gsl_sf_debye_6}.
@end deffn

@geindex gsl sf debye_6_e function
@anchor{aa}@anchor{gsl sf debye_6_e}
@deffn {Function} gsl::sf::debye_6_e x

implements @code{gsl_sf_debye_6_e}.
@end deffn


@node Examples<8>,Dilogarithm,Debye Functions,Special Functions
@anchor{examples<8>}@anchor{ab}@anchor{id7}
@section Examples
The following illustrate the debye functions.

@example
> debye_1 0.4;
0.904437352623294
> debye_1_e 0.4;
[0.904437352623294,3.84040456356756e-16]
> debye_2 1.4;
0.613281386045505
> debye_2_e 1.4;
[0.613281386045505,5.15090106564116e-16]
> debye_3 2.4;
0.370136882985216
> debye_3_e 2.4;
[0.370136882985216,6.0792125556598e-16]
> debye_4 3.4;
0.205914922541978
> debye_4_e 3.4;
[0.205914922541978,7.42872979584512e-16]
> debye_5 4.4;
0.107477287722471
> debye_5_e 4.4;
[0.107477287722471,2.38647518907499e-17]
> debye_6 5.4;
0.0533132925698824
> debye_6_e 5.4;
[0.0533132925698824,1.18379289859322e-17]
@end example

@noindent

@node Dilogarithm,Examples<9>,Examples<8>,Special Functions
@anchor{dilogarithm}@anchor{ac}
@section Dilogarithm

@geindex gsl sf dilog function
@anchor{ad}@anchor{gsl sf dilog}
@deffn {Function} gsl::sf::dilog x

implements @code{gsl_sf_dilog}.
@end deffn

@geindex gsl sf dilog function
@deffn {Function} gsl::sf::dilog (r<:theta)

implements @code{gsl_sf_complex_dilog_e} except that results are returned
as the complex value @code{re+:im} and the error values are not returned.
@end deffn

@geindex gsl sf dilog_e function
@anchor{ae}@anchor{gsl sf dilog_e}
@deffn {Function} gsl::sf::dilog_e x

implements @code{gsl_sf_dilog_e}.
@end deffn

@geindex gsl sf dilog_e function
@deffn {Function} gsl::sf::dilog_e (r<:theta)

implements @code{gsl_sf_complex_dilog_e} except the results are returned as
the list @code{[re+:im, re_error, im_error]}.
@end deffn


@node Examples<9>,Examples<10>,Dilogarithm,Special Functions
@anchor{examples<9>}@anchor{af}@anchor{id8}
@section Examples
The following illustrate the dilog functions.

@example
> dilog 1.0;
1.64493406684823
> dilog (1<:2);
-0.496658586741567+:0.727146050863279
> dilog_e (1%3);
[0.366213229977064,8.22687466397711e-15]
> dilog_e (1<:3);
[-0.817454913536463+:0.0980262093913011,3.8224192909699e-15,
 1.47247478976757e-15]
@end example

@noindent
@geindex gsl sf multiply_e function
@anchor{b0}@anchor{gsl sf multiply_e}
@deffn {Function} gsl::sf::multiply_e x  y

implements @code{gsl_sf_multiply_e}.
@end deffn

@geindex gsl sf multiply_err_e function
@anchor{b1}@anchor{gsl sf multiply_err_e}
@deffn {Function} gsl::sf::multiply_err_e x  dx  y  dy

implements @code{gsl_sf_multiply_err_e}.
@end deffn


@node Examples<10>,,Examples<9>,Special Functions
@anchor{examples<10>}@anchor{b2}@anchor{id9}
@section Examples
The following illustrate the multiply functions.

@example
> multiply_e 10.0 11.0;
[110.0,4.88498130835069e-14]
> multiply_err_e 10.0 0.04 11.0 0.002;
[110.0,0.460000000000049]
@end example

@noindent

@node Matrices,Least-Squares Fitting,Special Functions,Top
@anchor{matrices}@anchor{b3}@anchor{module-gsl matrix}@anchor{b4}
@chapter Matrices

@geindex gsl matrix module
This module is loaded via the command @code{using gsl::matrix} and provides
wrappers for many of the GSL matrix, BLAS, and linear algebra routines
found in Chapters 8, 12, and 13, respectively of the GSL Reference
Manual:

@itemize *
@item
@uref{http://www.gnu.org/software/gsl/manual/html_node/Vectors-and-Matrices.html,Vectors and Matrices}
@item
@uref{http://www.gnu.org/software/gsl/manual/html_node/BLAS-Support.html,BLAS Support}
@item
@uref{http://www.gnu.org/software/gsl/manual/html_node/Linear-Algebra.html,Linear Algebra}
@end itemize

It also contains some general utility functions for creating various types
of matrices.

@anchor{b5}@anchor{vectors-and-matrices}@anchor{b6}@anchor{blas-support}@anchor{b7}@anchor{linear-algebra}
@menu
* Matrix Creation::
* Matrix Operators and Functions::
* Singular Value Decomposition::
@end menu


@node Matrix Creation,Matrix Operators and Functions,,Matrices
@anchor{matrix creation}@anchor{b8}@anchor{matrix-creation}
@section Matrix Creation
The utility functions @code{zeros} and @code{ones} create matrices with all
elements zero or one, respectively, and @code{eye} creates identity
matrices. These functions can be invoked either with a pair @strong{(n,m)}
denoting the desired number of rows or columns, or an integer @strong{n} in which
case a square @strong{n} x @strong{n} matrix is created. The result is always a double
matrix. Analogous functions @code{izeros}, @code{czeros}, etc. are provided to
create integer and complex matrices, respectively.

@geindex gsl matrix zeros function
@anchor{b9}@anchor{gsl matrix zeros}
@deffn {Function} gsl::matrix::zeros (n :: int, m :: int)

creates an @strong{n} x @strong{m} double matrix with all of its entries being zero.
@end deffn

@geindex gsl matrix zeros function
@deffn {Function} gsl::matrix::zeros n :: int

creates an @strong{n} x @strong{n} double matrix with all of its entries being zero.
@end deffn

@geindex gsl matrix izeros function
@anchor{ba}@anchor{gsl matrix izeros}
@deffn {Function} gsl::matrix::izeros (n :: int, m :: int)

creates an @strong{n} x @strong{m} integer matrix with all of its entries being zero.
@end deffn

@geindex gsl matrix izeros function
@deffn {Function} gsl::matrix::izeros n :: int

creates an @strong{n`x`n} integer matrix with all of its entries being zero.
@end deffn

@geindex gsl matrix czeros function
@anchor{bb}@anchor{gsl matrix czeros}
@deffn {Function} gsl::matrix::czeros (n :: int, m :: int)

creates an @strong{n} x @strong{m} complex matrix with all of its entries being zero.
@end deffn

@geindex gsl matrix czeros function
@deffn {Function} gsl::matrix::czeros n :: int

creates an @strong{n} x @strong{n} complex matrix with all of its entries being zero.
@end deffn

@geindex gsl matrix ones function
@anchor{bc}@anchor{gsl matrix ones}
@deffn {Function} gsl::matrix::ones (n :: int, m :: int)

creates an @strong{n} x @strong{m} double matrix with all of its entries being one.
@end deffn

@geindex gsl matrix ones function
@deffn {Function} gsl::matrix::ones n :: int

creates an @strong{n} x @strong{n} double matrix with all of its entries being one.
@end deffn

@geindex gsl matrix iones function
@anchor{bd}@anchor{gsl matrix iones}
@deffn {Function} gsl::matrix::iones (n :: int, m :: int)

creates an @strong{n} x @strong{m} integer matrix with all of its entries being one.
@end deffn

@geindex gsl matrix iones function
@deffn {Function} gsl::matrix::iones n :: int

creates an @strong{n} x @strong{n} integer matrix with all of its entries being one.
@end deffn

@geindex gsl matrix cones function
@anchor{be}@anchor{gsl matrix cones}
@deffn {Function} gsl::matrix::cones (n :: int, m :: int)

creates an @strong{n} x @strong{m} complex matrix with all of its entries being one.
@end deffn

@geindex gsl matrix cones function
@deffn {Function} gsl::matrix::cones n :: int

creates an @strong{n} x @strong{n} complex matrix with all of its entries being one.
@end deffn

@geindex gsl matrix eye function
@anchor{bf}@anchor{gsl matrix eye}
@deffn {Function} gsl::matrix::eye (n :: int, m :: int)

creates an @strong{n} x @strong{m} identity matrix with double entries.
@end deffn

@geindex gsl matrix eye function
@deffn {Function} gsl::matrix::eye n :: int

creates an @strong{n} x @strong{n} identity matrix with double entries.
@end deffn

@geindex gsl matrix ieye function
@anchor{c0}@anchor{gsl matrix ieye}
@deffn {Function} gsl::matrix::ieye (n :: int, m :: int)

creates an @strong{n} x @strong{m} identity matrix with integer entries.
@end deffn

@geindex gsl matrix ieye function
@deffn {Function} gsl::matrix::ieye n :: int

creates an @strong{n} x @strong{n} identity matrix with integer entries.
@end deffn

@geindex gsl matrix ceye function
@anchor{c1}@anchor{gsl matrix ceye}
@deffn {Function} gsl::matrix::ceye (n :: int, m :: int)

creates an @strong{n} x @strong{m} identity matrix with complex entries.
@end deffn

@geindex gsl matrix ceye function
@deffn {Function} gsl::matrix::ceye n :: int

creates an @strong{n} x @strong{n} identity matrix with complex entries.
@end deffn


@node Matrix Operators and Functions,Singular Value Decomposition,Matrix Creation,Matrices
@anchor{matrix operators and functions}@anchor{c2}@anchor{matrix-operators-and-functions}
@section Matrix Operators and Functions
The following operations are defined for constant @code{a} and matrices
@code{x} and @code{y}. Some operators are not defined in the GSL library but
are provided here for convenience.

@geindex + infix function
@anchor{c3}@anchor{+/gsl_matrix}
@deffn {Function} a + x

@deffnx {Function} x + a

returns a matrix with entries @code{a + x!(i,j)}.
@end deffn

@geindex + infix function
@deffn {Function} x + y

adds matrix @code{x} to matrix @code{y}.
@end deffn

@geindex - prefix function
@anchor{c4}@anchor{-/gsl_matrix}
@deffn {Function} - x

returns a matrix with entries @code{- x!(i,j)}. Note that @code{neg x} is
equivalent to @code{- x}.
@end deffn

@geindex - infix function
@deffn {Function} a - x

returns a matrix with entries @code{a - x!(i,j)}.
@end deffn

@geindex - infix function
@deffn {Function} x - a

returns a matrix with entries @code{x!(i,j) - a}.
@end deffn

@geindex - infix function
@deffn {Function} x - y

subtracts matrix @code{y} from matrix @code{x}.
@end deffn

@geindex * infix function
@anchor{c5}@anchor{*/gsl_matrix}
@deffn {Function} a * x

@deffnx {Function} x * a

returns a matrix with entries @code{a * x!(i,j)}.
@end deffn

@geindex * infix function
@deffn {Function} x .* y

multiplies, element-wise, matrix @code{x} to matrix @code{y}.
@end deffn

@geindex * infix function
@deffn {Function} x * y

multiplies matrix @code{x} to matrix @code{y}.
@end deffn

@geindex / infix function
@anchor{c6}@anchor{//gsl_matrix}
@deffn {Function} a / x

returns a matrix with entries @code{a / x!(i,j)}. Note that matrix @code{x}
must not have any zero entries.
@end deffn

@geindex / infix function
@deffn {Function} x / a

returns a matrix with entries @code{x!(i,j) / a}. Note that @code{a} must be
nonzero.
@end deffn

@geindex / infix function
@deffn {Function} x ./ y

divides, element-wise, matrix @strong{x} by matrix @strong{y}.
@end deffn

@geindex / infix function
@deffn {Function} x / y

right divides matrix @strong{x} by matrix @strong{y}.
@end deffn

@geindex \ infix function
@anchor{c7}@anchor{\/gsl_matrix}
@deffn {Function} x \ y

left divides matrix @strong{x} by matrix @strong{y}.
@end deffn

@geindex div infix function
@anchor{c8}@anchor{div/gsl_matrix}
@deffn {Function} a div x

returns an integer matrix with entries @code{a div x!(i,j)}. Note that @strong{a}
must be an integer and matrix @code{x} must be an integer matrix with
nonzero entries.
@end deffn

@geindex div infix function
@deffn {Function} x div a

returns an integer matrix with entries @code{x!(i,j) div a}. Note that
@code{a} must be a nonzero integer and matrix @code{x} must have integer
entries.
@end deffn

@geindex div infix function
@deffn {Function} x div y

computes the quotient integer matrix @code{x} by integer matrix @code{y}.
@end deffn

@geindex mod infix function
@anchor{c9}@anchor{mod/gsl_matrix}
@deffn {Function} a mod x

returns an integer matrix with entries @code{a mod x!(i,j)}. Note that
@code{a} must be an integer and matrix @code{x} must be an integer matrix with
nonzero entries.
@end deffn

@geindex mod infix function
@deffn {Function} x mod a

returns an integer matrix with entries @code{a mod x!(i,j)}. Note that
@code{a} must be an integer and matrix @code{x} must be an integer matrix with
nonzero entries.
@end deffn

@geindex mod infix function
@deffn {Function} x mod y

returns the remainder integer matrix @code{x} mod integer matrix @code{y}.
@end deffn

@geindex not prefix function
@anchor{ca}@anchor{not/gsl_matrix}
@deffn {Function} not x

returns a matrix with integer entries @code{not x!(i,j)}. Note that @code{x}
must be a matrix with integer entries and @code{not} is the bitwise
negation operation.
@end deffn

@geindex ^ infix function
@anchor{cb}@anchor{^/gsl_matrix}
@deffn {Function} a ^ x

returns a matrix with entries @code{a ^ x!(i,j)}. Note that @code{0^0} is
defined as 1.
@end deffn

@geindex ^ infix function
@deffn {Function} x ^ a

returns a matrix with entries @code{x!(i,j) ^ a}. Note that @code{0^0} is
defined as 1.
@end deffn

@geindex ^ infix function
@deffn {Function} x .^ y

returns a matrix with entries @code{x!(i,j) ^ y!(i,j)}.
@end deffn

@geindex ^ infix function
@deffn {Function} x ^ y

returns a matrix with entries @code{x!(i,j) ^ y!(i,j)}.
@end deffn

@geindex << infix function
@anchor{cc}@anchor{<</gsl_matrix}
@deffn {Function} x << a

returns an integer matrix with entries @code{x!(i,j) << a}. Note that
@code{a} must be an integer and matrix @code{x} must have integer entries.
@end deffn

@geindex << infix function
@deffn {Function} x << y

returns an integer matrix with entries @code{x!(i,j) << y!(i,j)}. Note
that @code{x} and @code{y} must have integer entries.
@end deffn

@geindex >> infix function
@anchor{cd}@anchor{>>/gsl_matrix}
@deffn {Function} x >> a

returns an integer matrix with entries @code{x!(i,j) >> a}. Note that
@code{a} must be an integer and matrix @code{x} must have integer entries.
@end deffn

@geindex >> infix function
@deffn {Function} x >> y

returns an integer matrix with entries @code{x!(i,j) >> y!(i,j)}. Note
that @code{x} and @code{y} must have integer entries.
@end deffn

@geindex and infix function
@anchor{ce}@anchor{and/gsl_matrix}
@deffn {Function} x and a

@deffnx {Function} a and x

returns an integer matrix with entries @code{a and x!(i,j)}. Note that
@code{a} must be an integer, matrix @code{x} must have integer entries, and
@code{and} is a bitwise operator.
@end deffn

@geindex and infix function
@deffn {Function} x and y

returns an integer matrix with entries @code{x!(i,j) and y!(i,j)}. Note
that @code{x} and @code{y} must be matrices with integer entries.
@end deffn

@geindex or infix function
@anchor{cf}@anchor{or/gsl_matrix}
@deffn {Function} x or a

@deffnx {Function} a or x

returns an integer matrix with entries @code{a or x!(i,j)}. Note that @code{a}
must be an integer, matrix @code{x} must have integer entries, and @code{or}
is a bitwise operator.
@end deffn

@geindex or infix function
@deffn {Function} x or y

returns an integer matrix with entries @code{x!(i,j) or y!(i,j)}. Note
that @code{x} and @code{y} must be matrices with integer entries.
@end deffn

The @code{pow} function computes powers of matrices by repeated matrix
multiplication.

@geindex pow function
@anchor{d0}@anchor{pow/gsl_matrix}
@deffn {Function} pow x :: matrix  k :: int

@deffnx {Function} pow x :: matrix  k :: bigint

Raises matrix @code{x} to the @code{k} th power. Note @code{x} must be a
square matrix and @code{k} a nonnegative integer.
@end deffn


@node Singular Value Decomposition,,Matrix Operators and Functions,Matrices
@anchor{singular value decomposition}@anchor{d1}@anchor{singular-value-decomposition}
@section Singular Value Decomposition
For a given @strong{n} x @strong{m} matrix @code{x}, these functions yield a
singular-value decomposition @code{u}, @code{s}, @code{v} of the matrix such
that @code{x == u*s*transpose v}, where @code{u} and @code{v} are orthogonal
matrices of dimensions @strong{n} x @strong{m} and @strong{n} x @strong{n}, respectively, and @strong{s} is
a @strong{n} x @strong{n} diagonal matrix which has the singular values in its
diagonal, in descending order. Note that GSL implements this only for
double matrices right now. Also, GSL only handles the case of square or
overdetermined systems, but we work around that in our wrapper functions
by just adding a suitable number of zero rows in the underdetermined
case.

@geindex gsl matrix svd function
@anchor{d2}@anchor{gsl matrix svd}
@deffn {Function} gsl::matrix::svd x

singular-value decomposition of matrix @code{x}.
@end deffn

@geindex gsl matrix svd_mod function
@anchor{d3}@anchor{gsl matrix svd_mod}
@deffn {Function} gsl::matrix::svd_mod x

This uses the modified Golub-Reinsch algorithm, which is faster if
@code{n > m} but needs @strong{O(m^2)} extra memory as internal workspace.
@end deffn

@geindex gsl matrix svd_jacobi function
@anchor{d4}@anchor{gsl matrix svd_jacobi}
@deffn {Function} gsl::matrix::svd_jacobi x

This uses one-sided Jacobi orthogonalization which provides better
relative accuracy but is slower.
@end deffn

@geindex gsl matrix svd_solve function
@anchor{d5}@anchor{gsl matrix svd_solve}
@deffn {Function} gsl::matrix::svd_solve (u, s, v)  b

Solve the system @code{Ax=b}, using the SVD of @code{A}. @code{svd_solve} takes
the result @code{(u,s,v)} of a @code{svd} call, and a column vector @code{b} of
the appropriate dimension. The result is another column vector solving
the system (possibly in the least-squares sense).
@end deffn

@geindex gsl matrix pinv function
@anchor{d6}@anchor{gsl matrix pinv}
@deffn {Function} gsl::matrix::pinv x

Computes the pseudo inverse of a matrix from its singular value
decomposition.
@end deffn


@node Least-Squares Fitting,Statistics,Matrices,Top
@anchor{least-squares fitting}@anchor{d7}@anchor{module-gsl fit}@anchor{d8}@anchor{least-squares-fitting}
@chapter Least-Squares Fitting

@geindex gsl fit module
This module is loaded via the command @code{using gsl::fit} and provides Pure
wrappers for the GSL least-squares fitting routines found in Chapter 36 of
the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Least_002dSquares-Fitting.html}.


@menu
* Routines: Routines<2>.
* Examples: Examples<11>.
@end menu


@node Routines<2>,Examples<11>,,Least-Squares Fitting
@anchor{routines<2>}@anchor{d9}@anchor{id10}
@section Routines

@geindex gsl fit linear function
@anchor{da}@anchor{gsl fit linear}
@deffn {Function} gsl::fit::linear x::matrix  y::matrix

implements @code{gsl_fit_linear} without the @code{xstride}, @code{ystride}, and
@code{n} parameters. Results are returned as a list @code{[c0, c1, cov00,
cov01, cov11, sumsq]}.
@end deffn

@geindex gsl fit wlinear function
@anchor{db}@anchor{gsl fit wlinear}
@deffn {Function} gsl::fit::wlinear x::matrix  w::matrix  y::matrix

implements @code{gsl_fit_wlinear} without the @code{xstride}, @code{wstride},
@code{ystride}, and @code{n} parameters. Results are given as a list
@code{[c0, c1, cov00, cov01, cov11, chisq]}.
@end deffn

@geindex gsl fit linear_est function
@anchor{dc}@anchor{gsl fit linear_est}
@deffn {Function} gsl::fit::linear_est x  c0::double  c1::double  cov00::double  cov01::double  cov11::double

implements @code{gsl_fit_linear_est}. Results are returned as a list
@code{[y, y_err]}.
@end deffn

@geindex gsl fit mul function
@anchor{dd}@anchor{gsl fit mul}
@deffn {Function} gsl::fit::mul x::matrix  y::matrix

implements @code{gsl_fit_mul} omitting the parameters @code{xstride},
@code{ystride}, and @code{n}. Results are returned as a list
@code{[c1, cov11, sumsq]}.
@end deffn

@geindex gsl fit wmul function
@anchor{de}@anchor{gsl fit wmul}
@deffn {Function} gsl::fit::wmul x::matrix  w::matrix  y::matrix

implements @code{gsl_fit_wmul} omitting the parametrs @code{xstride},
@code{ystride}, and @code{n}. Results are returned as a list
@code{[c1, cov11, sumsq]}.
@end deffn

@geindex gsl fit mul_est function
@anchor{df}@anchor{gsl fit mul_est}
@deffn {Function} gsl::fit::mul_est x  c1::double  cov11::double

implements @code{gsl_fit_mul_est}. Results are returned as a list
@code{[y, y_err]}.
@end deffn


@node Examples<11>,,Routines<2>,Least-Squares Fitting
@anchor{examples<11>}@anchor{e0}@anchor{id11}
@section Examples
Usage of each implemented library routine is illustrated below.

@example
> using gsl::fit;
> using namespace gsl::fit;
@end example

@noindent
The following code determines the equation for the least-squares line
through the points (1,0.01), (2,1.11), (3,1.9), (4,2.85), and (5,4.01).

@example
> Y x = '(a + b * x)
> when
>   a:b:_ = linear @{1,2,3,4,5@} @{0.01,1.11,1.9,2.85,4.01@}
> end;
> Y x;
-0.946+0.974*x
> eval $ Y 2;
1.002
@end example

@noindent
The following code illustrates estimating y-values without
constructing an equation for the least-squares line determined by
the points @code{@{x1,x2,x3,...,xn@}}, @code{@{y1,y2,y3,...,yn@}}. Here we
estimate the @strong{y}-value at @strong{x} = 1, @strong{x} = 2, and @strong{x} = 3. Compare the output
above at @strong{x} = 2 to the output at @strong{x} = 2 below.

@example
> let c0:c1:cov00:cov01:cov11:_ = linear @{1,2,3,4,5@}
>   @{0.01,1.11,1.9,2.85,4.01@};
> linear_est 1 c0 c1 cov00 cov01 cov11;
[0.028,0.0838570211729465]
> linear_est 2 c0 c1 cov00 cov01 cov11;
[1.002,0.0592958683214944]
> linear_est 3 c0 c1 cov00 cov01 cov11;
[1.976,0.0484148737476408]
@end example

@noindent
Next, we determine a least-squares line through the points (1,0.01),
(2,1.11), (3,1.9), (4,2.85), and (5,4.01) using weights 0.1, 0.2, 0.3,
0.4, and 0.5.

@example
> W x = '(a + b * x)
> when
>   a:b:_ = wlinear (matrix (1..5))
>           @{0.1, 0.2, 0.3, 0.4, 0.5@}
>           @{0.01, 1.11, 1.9, 2.85, 4.01@};
> end;
> W u;
-0.99+0.986*u
> eval $ W 2;
0.982
@end example

@noindent
The least-squares slope for @code{Y = c1 * X} using the points (1,3),
(2,5), and (3,7) is calculated below. Also, the @strong{y}-values and
standard error about @strong{x} = 1, 2, and 3 are given.

@example
> let c1:cov11:sumsq:_ = mul @{1,2,3@} @{3,5,7@};
> mul_est 1 c1 cov11;
[2.42857142857143,0.123717914826348]
> mul_est 2 c1 cov11;
[4.85714285714286,0.247435829652697]
> mul_est 3 c1 cov11;
[7.28571428571428,0.371153744479045]
@end example

@noindent
The least-squares slope for @code{Y = c1 * X} using the points (1,3),
(2,5), and (3,7), and weights 0.4, 0.9, and 0.4 is calculated below.
The approximation of y-values and standard error about @strong{x} = 1, 2, and
3 follows.

@example
> let c1:cov11:sumsq:_ = wmul @{1,2,3@} @{0.4,0.9,0.4@} @{3,5,7@};
> mul_est 1 c1 cov11;
[2.44736842105263,0.362738125055006]
> mul_est 2 c1 cov11;
[4.89473684210526,0.725476250110012]
> mul_est 3 c1 cov11;
[7.34210526315789,1.08821437516502]
@end example

@noindent

@node Statistics,Random Number Distributions,Least-Squares Fitting,Top
@anchor{statistics}@anchor{e1}@anchor{module-gsl stats}@anchor{e2}
@chapter Statistics

@geindex gsl stats module
This module is loaded via the command @code{using gsl::stats} and provides
Pure wrappers for the GSL Statistics routines found in Chapter 20 of the
GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Statistics.html}.


@menu
* Routines: Routines<3>.
* Examples: Examples<12>.
@end menu


@node Routines<3>,Examples<12>,,Statistics
@anchor{routines<3>}@anchor{e3}@anchor{id12}
@section Routines

@geindex gsl stats mean function
@anchor{e4}@anchor{gsl stats mean}
@deffn {Function} gsl::stats::mean data::matrix

implements @code{gsl_stats_mean} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats variance function
@anchor{e5}@anchor{gsl stats variance}
@deffn {Function} gsl::stats::variance data::matrix

implements @code{gsl_stats_variance} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats variance function
@deffn {Function} gsl::stats::variance data::matrix  mean

implements @code{gsl_stats_variance_m} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl stats sd function
@anchor{e6}@anchor{gsl stats sd}
@deffn {Function} gsl::stats::sd data::matrix

implements @code{gsl_stats_sd} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats sd_m function
@anchor{e7}@anchor{gsl stats sd_m}
@deffn {Function} gsl::stats::sd_m data::matrix  mean

implements @code{gsl_stats_sd_m} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats tss function
@anchor{e8}@anchor{gsl stats tss}
@deffn {Function} gsl::stats::tss data::matrix

implements @code{gsl_stats_tss} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats tss_m function
@anchor{e9}@anchor{gsl stats tss_m}
@deffn {Function} gsl::stats::tss_m data::matrix  mean

implements @code{gsl_stats_tss_m} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl stats variance_with_fixed_mean function
@anchor{ea}@anchor{gsl stats variance_with_fixed_mean}
@deffn {Function} gsl::stats::variance_with_fixed_mean data::matrix  mean

implements @code{gsl_stats_variance_with_fixed_mean} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats sd_with_fixed_mean function
@anchor{eb}@anchor{gsl stats sd_with_fixed_mean}
@deffn {Function} gsl::stats::sd_with_fixed_mean data::matrix  mean

implements @code{gsl_stats_sd_with_fixed_mean} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats absdev function
@anchor{ec}@anchor{gsl stats absdev}
@deffn {Function} gsl::stats::absdev data::matrix

implements @code{gsl_stats_absdev} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats absdev_m function
@anchor{ed}@anchor{gsl stats absdev_m}
@deffn {Function} gsl::stats::absdev_m data::matrix  mean

implements @code{gsl_stats_absdev_m} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl stats skew function
@anchor{ee}@anchor{gsl stats skew}
@deffn {Function} gsl::stats::skew data::matrix  mean

implements @code{gsl_stats_skew} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl stats skew_m_sd function
@anchor{ef}@anchor{gsl stats skew_m_sd}
@deffn {Function} gsl::stats::skew_m_sd data::matrix  mean  sd

implements @code{gsl_stats_skew_m_sd} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl stats kurtosis function
@anchor{f0}@anchor{gsl stats kurtosis}
@deffn {Function} gsl::stats::kurtosis data::matrix

implements @code{gsl_stats_kurtosis} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl stats kurtosis_m_sd function
@anchor{f1}@anchor{gsl stats kurtosis_m_sd}
@deffn {Function} gsl::stats::kurtosis_m_sd data::matrix  mean  sd

implements @code{gsl_stats_kurtosis_m_sd} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats lag1_autocorrelation function
@anchor{f2}@anchor{gsl stats lag1_autocorrelation}
@deffn {Function} gsl::stats::lag1_autocorrelation data::matrix

implements @code{gsl_stats_lag1_autocorrelation} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats lag1_autocorrelation_m function
@anchor{f3}@anchor{gsl stats lag1_autocorrelation_m}
@deffn {Function} gsl::stats::lag1_autocorrelation_m data::matrix  mean

implements @code{gsl_stats_lag1_autocorrelation_m} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats covariance function
@anchor{f4}@anchor{gsl stats covariance}
@deffn {Function} gsl::stats::covariance d1::matrix  d2::matrix

implements @code{gsl_stats_covariance} without @code{stride1},
@code{stride2}, and @code{n} arguments.
@end deffn

@geindex gsl stats covariance_m function
@anchor{f5}@anchor{gsl stats covariance_m}
@deffn {Function} gsl::stats::covariance_m d1::matrix  d2::matrix  mean1  mean2

implements @code{gsl_stats_covariance_m} without @code{stride1},
@code{stride2}, and @code{n} arguments.
@end deffn

@geindex gsl stats correlation function
@anchor{f6}@anchor{gsl stats correlation}
@deffn {Function} gsl::stats::correlation d1::matrix  d2::matrix

implements @code{gsl_stats_correlation} without @code{stride1},
@code{stride2}, and @code{n} arguments.
@end deffn

@geindex gsl stats wmean function
@anchor{f7}@anchor{gsl stats wmean}
@deffn {Function} gsl::stats::wmean weight::matrix  data::matrix

implements @code{gsl_stats_wmean} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats wvariance function
@anchor{f8}@anchor{gsl stats wvariance}
@deffn {Function} gsl::stats::wvariance weight::matrix  data::matrix

implements @code{gsl_stats_wvariance} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats wvariance_m function
@anchor{f9}@anchor{gsl stats wvariance_m}
@deffn {Function} gsl::stats::wvariance_m weight::matrix  data::matrix  mean

implements @code{gsl_stats_wvariance_m} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats wsd function
@anchor{fa}@anchor{gsl stats wsd}
@deffn {Function} gsl::stats::wsd weight::matrix  data::matrix

implements @code{gsl_stats_wsd} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl stats wsd_m function
@anchor{fb}@anchor{gsl stats wsd_m}
@deffn {Function} gsl::stats::wsd_m weight::matrix  data::matrix  mean

implements @code{gsl_stats_wsd_m} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl stats wvariance_with_fixed_mean function
@anchor{fc}@anchor{gsl stats wvariance_with_fixed_mean}
@deffn {Function} gsl::stats::wvariance_with_fixed_mean weight::matrix  data::matrix  mean

implements @code{gsl_stats_wvariance_with_fixed_mean} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats wsd_with_fixed_mean function
@anchor{fd}@anchor{gsl stats wsd_with_fixed_mean}
@deffn {Function} gsl::stats::wsd_with_fixed_mean weight::matrix  data::matrix  mean

implements @code{gsl_stats_wsd_with_fixed_mean} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats wtss function
@anchor{fe}@anchor{gsl stats wtss}
@deffn {Function} gsl::stats::wtss weight::matrix  data::matrix

implements @code{gsl_stats_wtss} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl stats wtss_m function
@anchor{ff}@anchor{gsl stats wtss_m}
@deffn {Function} gsl::stats::wtss_m weight::matrix  data::matrix  mean

implements @code{gsl_stats_wtss_m} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl stats wabsdev function
@anchor{100}@anchor{gsl stats wabsdev}
@deffn {Function} gsl::stats::wabsdev weight::matrix  data::matrix

implements @code{gsl_stats_wabsdev} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl stats wabsdev_m function
@anchor{101}@anchor{gsl stats wabsdev_m}
@deffn {Function} gsl::stats::wabsdev_m weight::matrix  data::matrix  mean

implements @code{gsl_stats_wabsdev_m} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl stats wskew function
@anchor{102}@anchor{gsl stats wskew}
@deffn {Function} gsl::stats::wskew weight::matrix  data::matrix

implements @code{gsl_stats_wskew} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl stats wskew_m_sd function
@anchor{103}@anchor{gsl stats wskew_m_sd}
@deffn {Function} gsl::stats::wskew_m_sd weight::matrix  data::matrix  mean  sd

implements @code{gsl_stats_wskew_m_sd} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl stats wkurtosis function
@anchor{104}@anchor{gsl stats wkurtosis}
@deffn {Function} gsl::stats::wkurtosis weight::matrix  data::matrix

implements @code{gsl_stats_wkurtosis} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl stats wkurtosis_m_sd function
@anchor{105}@anchor{gsl stats wkurtosis_m_sd}
@deffn {Function} gsl::stats::wkurtosis_m_sd weight::matrix  data::matrix

implements @code{gsl_stats_wkurtosis_m_sd} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats max function
@anchor{106}@anchor{gsl stats max}
@deffn {Function} gsl::stats::max data::matrix

implements @code{gsl_stats_max} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats min function
@anchor{107}@anchor{gsl stats min}
@deffn {Function} gsl::stats::min data::matrix

implements @code{gsl_stats_min} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats minmax function
@anchor{108}@anchor{gsl stats minmax}
@deffn {Function} gsl::stats::minmax data::matrix

implements @code{gsl_stats_minmax} without @code{stride}
and @code{n} arguments. Results are returned as a list
@code{[min, max]}.
@end deffn

@geindex gsl stats min_index function
@anchor{109}@anchor{gsl stats min_index}
@deffn {Function} gsl::stats::min_index data::matrix

implements @code{gsl_stats_min_index} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats max_index function
@anchor{10a}@anchor{gsl stats max_index}
@deffn {Function} gsl::stats::max_index data::matrix

implements @code{gsl_stats_max_index} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl stats minmax_index function
@anchor{10b}@anchor{gsl stats minmax_index}
@deffn {Function} gsl::stats::minmax_index data::matrix

implements @code{gsl_stats_minmax_index} without @code{stride}
and @code{n} arguments. Results are returned as a list
@code{[min_index, max_index]}.
@end deffn

@geindex gsl stats median_from_sorted_data function
@anchor{10c}@anchor{gsl stats median_from_sorted_data}
@deffn {Function} gsl::stats::median_from_sorted_data data::matrix

implements @code{gsl_stats_median_from_sorted_data} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl stats quantile_from_sorted_data function
@anchor{10d}@anchor{gsl stats quantile_from_sorted_data}
@deffn {Function} gsl::stats::quantile_from_sorted_data data::matrix  f::double

implements @code{gsl_stats_quantile_from_sorted_data} without
@code{stride} and @code{n} arguments.
@end deffn


@node Examples<12>,,Routines<3>,Statistics
@anchor{examples<12>}@anchor{10e}@anchor{id13}
@section Examples
The following illustrates the use of each function in the @code{stats} module.

@example
> using gsl::stats;
> using namespace gsl::stats;
> mean @{1,2,3,4,5@};
3.0
> variance @{1,2,3,4,5@};
2.5
> variance_m @{1,2,3,4,5@}  4;
3.75
> sd @{1,2,3,4,5@};
1.58113883008419
> sd_m @{1,2,3,4,5@} 4;
1.93649167310371
> tss @{1,2,3,4,5@};
10.0
> tss_m @{1,2,3,4,5@} 4;
15.0
> variance_with_fixed_mean @{0.0,1.2,3.4,5.6,6.0@} 4.1;
6.314
> sd_with_fixed_mean @{0.0,1.2,3.4,5.6,6.0@} 4.1;
2.51276739870606
> absdev @{2,2,3,4,4@};
0.8
> absdev_m @{2,2,3,4,4@} 4;
1.0
> skew @{1,1,1,1,2,2,2,2,2,2,2,2,3,30@};
2.94796699504537
> skew_m_sd @{1,2,2,3,3,3,3,3,3,3,4,4,5@} 3 1;
0.0
> kurtosis  @{1,2,2,3,3,3,3,3,3,3,4,4,5@};
-0.230769230769231
> kurtosis_m_sd @{1,2,2,3,3,3,3,3,3,3,4,4,5@} 3 1;
-0.230769230769231
> lag1_autocorrelation @{1,2,3,4,5@};
0.4
> lag1_autocorrelation_m @{1,2,3,4,5@} 2.5;
0.444444444444444
> covariance @{1,2,3,4,5@} @{3.0,4.5,6.0,7.5,9.0@};
3.75
> covariance_m @{1,2,3,4,5@} @{3.0,4.5,6.0,7.5,9.0@} 3 6;
3.75
> correlation @{1,2,3,4@} @{2,3,4,5@};
1.0
> wmean @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@};
3.93333333333333
> wvariance @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@};
2.7752808988764
> wvariance_m @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@} 3.0;
3.87640449438202
> wsd @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@};
1.66591743459164
> wsd_m @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@} 3.0;
1.96885867811329
> wvariance_with_fixed_mean @{1,2,3,4@} @{1,2,3,4@} 2.5;
1.25
> wsd_with_fixed_mean @{1,2,3,4@} @{1,2,3,4@} 2.5;
1.11803398874989
> wtss @{1,1,2,2@} @{2,3,4,5@};
6.83333333333333
> wtss_m @{1,1,2,2@} @{2,3,4,5@} 3.1;
10.06
> wabsdev @{1,1,2,2@} @{2,3,4,5@};
0.888888888888889
> wabsdev_m @{1,1,2,2@} @{2,3,4,5@} 3.1;
1.13333333333333
> wskew @{1,1,2,2@} @{2,3,4,5@};
-0.299254338484713
> wskew_m_sd @{1,1,2,2@} @{2,3,4,5@} 3.1 1.2;
1.33526234567901
> wkurtosis @{1,1,2,2@} @{2,3,4,5@};
-1.96206512878137
> wkurtosis_m_sd @{1,1,2,2@} @{2,3,4,5@} 3.1 1.2;
-0.681921939300412
> min @{9,4,2,1,9@};
1
> max @{9.1,4.2,2.6,1.1,9.2@};
9.2
> minmax @{9.0,4.0,2.0,1.0,9.0@};
[1.0,9.0]
> min_index @{9.1,4.2,2.6,1.1,9.2@};
3
> max_index @{9,4,2,1,9@};
0
> minmax_index @{9,4,2,1,0,9@};
[4,0]
> median_from_sorted_data @{1.0,2.0,3.0@};
2.0
> quantile_from_sorted_data @{1.0,2.0,3.0@} 0.25;
1.5
@end example

@noindent

@node Random Number Distributions,Sorting,Statistics,Top
@anchor{random number distributions}@anchor{10f}@anchor{module-gsl randist}@anchor{110}@anchor{random-number-distributions}
@chapter Random Number Distributions

@geindex gsl randist module
This module is loaded via the command @code{using gsl::randist} and provides
Pure wrappers for the GSL random distribution routines found in Chapter
19 of the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html}.

There are two namespaces provided by randist.pure, @code{gsl::ran} for
probability densitity functions and @code{gsl::cdf} for cumulative
distribution functions. The two namespaces minimize typing of the
prefixes @code{gsl_ran_} and @code{gsl_cdf_} respectively.


@menu
* Routines: Routines<4>.
* Examples: Examples<13>.
@end menu


@node Routines<4>,Examples<13>,,Random Number Distributions
@anchor{routines<4>}@anchor{111}@anchor{id14}
@section Routines

@geindex gsl ran ugaussian_pdf function
@anchor{112}@anchor{gsl ran ugaussian_pdf}
@deffn {Function} gsl::ran::ugaussian_pdf x

implements @code{gsl_ran_ugaussian}.
@end deffn

@geindex gsl ran gaussian_pdf function
@anchor{113}@anchor{gsl ran gaussian_pdf}
@deffn {Function} gsl::ran::gaussian_pdf x  sigma

implements @code{gsl_ran_gaussian_pdf}.
@end deffn

@geindex gsl ran gaussian_tail_pdf function
@anchor{114}@anchor{gsl ran gaussian_tail_pdf}
@deffn {Function} gsl::ran::gaussian_tail_pdf x  a  sigma

implements @code{gsl_ran_gaussian_tail_pdf}.
@end deffn

@geindex gsl ran ugaussian_tail_pdf function
@anchor{115}@anchor{gsl ran ugaussian_tail_pdf}
@deffn {Function} gsl::ran::ugaussian_tail_pdf x  a

implements @code{gsl_ran_ugaussian_tail_pdf}.
@end deffn

@geindex gsl ran bivariate_gaussian_pdf function
@anchor{116}@anchor{gsl ran bivariate_gaussian_pdf}
@deffn {Function} gsl::ran::bivariate_gaussian_pdf x  a

implements @code{gsl_ran_bivariate_gaussian_pdf}.
@end deffn

@geindex gsl ran exponential_pdf function
@anchor{117}@anchor{gsl ran exponential_pdf}
@deffn {Function} gsl::ran::exponential_pdf x  mu

implements @code{gsl_ran_exponential_pdf}.
@end deffn

@geindex gsl ran laplace_pdf function
@anchor{118}@anchor{gsl ran laplace_pdf}
@deffn {Function} gsl::ran::laplace_pdf x  a

implements @code{gsl_ran_laplace_pdf}.
@end deffn

@geindex gsl ran exppow_pdf function
@anchor{119}@anchor{gsl ran exppow_pdf}
@deffn {Function} gsl::ran::exppow_pdf x  a  b

implements @code{gsl_ran_exppow_pdf}.
@end deffn

@geindex gsl ran cauchy_pdf function
@anchor{11a}@anchor{gsl ran cauchy_pdf}
@deffn {Function} gsl::ran::cauchy_pdf x  a

implements @code{gsl_ran_cauchy_pdf}.
@end deffn

@geindex gsl ran rayleigh_pdf function
@anchor{11b}@anchor{gsl ran rayleigh_pdf}
@deffn {Function} gsl::ran::rayleigh_pdf x  sigma

implements @code{gsl_ran_rayleigh_pdf}.
@end deffn

@geindex gsl ran rayleigh_tail_pdf function
@anchor{11c}@anchor{gsl ran rayleigh_tail_pdf}
@deffn {Function} gsl::ran::rayleigh_tail_pdf x  a  sigma

implements @code{gsl_ran_rayleigh_tail_pdf}.
@end deffn

@geindex gsl ran landau_pdf function
@anchor{11d}@anchor{gsl ran landau_pdf}
@deffn {Function} gsl::ran::landau_pdf x

implements @code{gsl_ran_landau_pdf}.
@end deffn

@geindex gsl ran gamma_pdf function
@anchor{11e}@anchor{gsl ran gamma_pdf}
@deffn {Function} gsl::ran::gamma_pdf x  a  b

implements @code{gsl_ran_gamma_pdf}.
@end deffn

@geindex gsl ran flat_pdf function
@anchor{11f}@anchor{gsl ran flat_pdf}
@deffn {Function} gsl::ran::flat_pdf x  a  b

implements @code{gsl_ran_flat_pdf}.
@end deffn

@geindex gsl ran lognormal_pdf function
@anchor{120}@anchor{gsl ran lognormal_pdf}
@deffn {Function} gsl::ran::lognormal_pdf x  zeta  sigma

implements @code{gsl_ran_lognormal_pdf}.
@end deffn

@geindex gsl ran chisq_pdf function
@anchor{121}@anchor{gsl ran chisq_pdf}
@deffn {Function} gsl::ran::chisq_pdf x  nu

implements @code{gsl_ran_chisq_pdf}.
@end deffn

@geindex gsl ran fdist_pdf function
@anchor{122}@anchor{gsl ran fdist_pdf}
@deffn {Function} gsl::ran::fdist_pdf x  nu1  nu2

implements @code{gsl_ran_fdist_pdf}.
@end deffn

@geindex gsl ran tdist_pdf function
@anchor{123}@anchor{gsl ran tdist_pdf}
@deffn {Function} gsl::ran::tdist_pdf x  nu

implements @code{gsl_ran_tdist_pdf}.
@end deffn

@geindex gsl ran beta_pdf function
@anchor{124}@anchor{gsl ran beta_pdf}
@deffn {Function} gsl::ran::beta_pdf x  a  b

implements @code{gsl_ran_beta_pdf}.
@end deffn

@geindex gsl ran logistic_pdf function
@anchor{125}@anchor{gsl ran logistic_pdf}
@deffn {Function} gsl::ran::logistic_pdf x  a

implements @code{gsl_ran_logistic_pdf}.
@end deffn

@geindex gsl ran pareto_pdf function
@anchor{126}@anchor{gsl ran pareto_pdf}
@deffn {Function} gsl::ran::pareto_pdf x  a  b

implements @code{gsl_ran_pareto_pdf}.
@end deffn

@geindex gsl ran weibull_pdf function
@anchor{127}@anchor{gsl ran weibull_pdf}
@deffn {Function} gsl::ran::weibull_pdf x  a  b

implements @code{gsl_ran_weibull_pdf}.
@end deffn

@geindex gsl ran gumbel1_pdf function
@anchor{128}@anchor{gsl ran gumbel1_pdf}
@deffn {Function} gsl::ran::gumbel1_pdf x  a  b

implements @code{gsl_ran_gumbel1_pdf}.
@end deffn

@geindex gsl ran gumbel2_pdf function
@anchor{129}@anchor{gsl ran gumbel2_pdf}
@deffn {Function} gsl::ran::gumbel2_pdf x  a  b

implements @code{gsl_ran_gumbel2_pdf}.
@end deffn

@geindex gsl ran dirichlet_pdf function
@anchor{12a}@anchor{gsl ran dirichlet_pdf}
@deffn {Function} gsl::ran::dirichlet_pdf alpha::matrix  theta::matrix

implements @code{gsl_ran_dirichlet_pdf}.
@end deffn

@geindex gsl ran dirichlet_lnpdf function
@anchor{12b}@anchor{gsl ran dirichlet_lnpdf}
@deffn {Function} gsl::ran::dirichlet_lnpdf alpha::matrix  theta::matrix

implements @code{gsl_ran_dirichlet_lnpdf}.
@end deffn

@geindex gsl ran discrete_preproc function
@anchor{12c}@anchor{gsl ran discrete_preproc}
@deffn {Function} gsl::ran::discrete_preproc p::matrix

implements @code{gsl_ran_discrete_preproc} without the
@code{K} parameter.
@end deffn

@geindex gsl ran discrete_pdf function
@anchor{12d}@anchor{gsl ran discrete_pdf}
@deffn {Function} gsl::ran::discrete_pdf k::int  p::pointer

implements @code{gsl_ran_discrete_pdf} without the
@code{K} parameter.
@end deffn

@geindex gsl ran discrete_free function
@anchor{12e}@anchor{gsl ran discrete_free}
@deffn {Function} gsl::ran::discrete_free p::pointer

implements @code{gsl_ran_discrete_free}
@end deffn

@geindex gsl ran poisson_pdf function
@anchor{12f}@anchor{gsl ran poisson_pdf}
@deffn {Function} gsl::ran::poisson_pdf k::int  mu

implements @code{gsl_ran_poisson_pdf}.
@end deffn

@geindex gsl ran bernoulli_pdf function
@anchor{130}@anchor{gsl ran bernoulli_pdf}
@deffn {Function} gsl::ran::bernoulli_pdf k::int  p

implements @code{gsl_ran_bernoulli_pdf}.
@end deffn

@geindex gsl ran binomial_pdf function
@anchor{131}@anchor{gsl ran binomial_pdf}
@deffn {Function} gsl::ran::binomial_pdf k::int  p  n::int

implements @code{gsl_ran_binomial_pdf}.
@end deffn

@geindex gsl ran multinomial_pdf function
@anchor{132}@anchor{gsl ran multinomial_pdf}
@deffn {Function} gsl::ran::multinomial_pdf p::matrix  n::matrix

implements @code{gsl_ran_multinomial_pdf}.
@end deffn

@geindex gsl ran multinomial_lnpdf function
@anchor{133}@anchor{gsl ran multinomial_lnpdf}
@deffn {Function} gsl::ran::multinomial_lnpdf p::matrix  n::matrix

implements @code{gsl_ran_multinomial_lnpdf}.
@end deffn

@geindex gsl ran negative_binomial_pdf function
@anchor{134}@anchor{gsl ran negative_binomial_pdf}
@deffn {Function} gsl::ran::negative_binomial_pdf k::int  p  n

implements @code{gsl_ran_negative_binomial_pdf}.
@end deffn

@geindex gsl ran pascal_pdf function
@anchor{135}@anchor{gsl ran pascal_pdf}
@deffn {Function} gsl::ran::pascal_pdf k::int  p  n::int

implements @code{gsl_ran_pascal_pdf}.
@end deffn

@geindex gsl ran geometric_pdf function
@anchor{136}@anchor{gsl ran geometric_pdf}
@deffn {Function} gsl::ran::geometric_pdf k::int  p

implements @code{gsl_ran_geometric_pdf}.
@end deffn

@geindex gsl ran hypergeometric_pdf function
@anchor{137}@anchor{gsl ran hypergeometric_pdf}
@deffn {Function} gsl::ran::hypergeometric_pdf k::int  n1::int  n2::int  t::int

implements @code{gsl_ran_hypergeometric_pdf}.
@end deffn

@geindex gsl ran logarithmic_pdf function
@anchor{138}@anchor{gsl ran logarithmic_pdf}
@deffn {Function} gsl::ran::logarithmic_pdf k::int  p

implements @code{gsl_ran_logarithmic_pdf}.
@end deffn

@geindex gsl cdf ugaussian_P function
@anchor{139}@anchor{gsl cdf ugaussian_p}
@deffn {Function} gsl::cdf::ugaussian_P x

implements @code{gsl_cdf_ugaussian_P}.
@end deffn

@geindex gsl cdf ugaussian_Q function
@anchor{13a}@anchor{gsl cdf ugaussian_q}
@deffn {Function} gsl::cdf::ugaussian_Q x

implements @code{gsl_cdf_ugaussian_Q}.
@end deffn

@geindex gsl cdf ugaussian_Pinv function
@anchor{13b}@anchor{gsl cdf ugaussian_pinv}
@deffn {Function} gsl::cdf::ugaussian_Pinv p

implements @code{gsl_cdf_ugaussian_Pinv}.
@end deffn

@geindex gsl cdf ugaussian_Qinv function
@anchor{13c}@anchor{gsl cdf ugaussian_qinv}
@deffn {Function} gsl::cdf::ugaussian_Qinv q

implements @code{gsl_cdf_ugaussian_Qinv}.
@end deffn

@geindex gsl cdf gaussian_P function
@anchor{13d}@anchor{gsl cdf gaussian_p}
@deffn {Function} gsl::cdf::gaussian_P x  sigma

implements @code{gsl_cdf_gaussian_P}.
@end deffn

@geindex gsl cdf gaussian_Q function
@anchor{13e}@anchor{gsl cdf gaussian_q}
@deffn {Function} gsl::cdf::gaussian_Q x  sigma

implements @code{gsl_cdf_gaussian_Q}.
@end deffn

@geindex gsl cdf gaussian_Pinv function
@anchor{13f}@anchor{gsl cdf gaussian_pinv}
@deffn {Function} gsl::cdf::gaussian_Pinv p  sigma

implements @code{gsl_cdf_gaussian_Pinv}.
@end deffn

@geindex gsl cdf guassian_Qinv function
@anchor{140}@anchor{gsl cdf guassian_qinv}
@deffn {Function} gsl::cdf::guassian_Qinv q  sigma

implements @code{gsl_cdf_gaussian_Qinv}.
@end deffn

@geindex gsl cdf exponential_P function
@anchor{141}@anchor{gsl cdf exponential_p}
@deffn {Function} gsl::cdf::exponential_P x  mu

implements @code{gsl_cdf_exponential_P}.
@end deffn

@geindex gsl cdf exponential_Q function
@anchor{142}@anchor{gsl cdf exponential_q}
@deffn {Function} gsl::cdf::exponential_Q x  mu

implements @code{gsl_cdf_exponential_Q}.
@end deffn

@geindex gsl cdf exponential_Pinv function
@anchor{143}@anchor{gsl cdf exponential_pinv}
@deffn {Function} gsl::cdf::exponential_Pinv p  mu

implements @code{gsl_cdf_exponential_Pinv}.
@end deffn

@geindex gsl cdf exponential_Qinv function
@anchor{144}@anchor{gsl cdf exponential_qinv}
@deffn {Function} gsl::cdf::exponential_Qinv q  mu

implements @code{gsl_cdf_exponential_Qinv}.
@end deffn

@geindex gsl cdf laplace_P function
@anchor{145}@anchor{gsl cdf laplace_p}
@deffn {Function} gsl::cdf::laplace_P x  a

implements @code{gsl_cdf_laplace_P}.
@end deffn

@geindex gsl cdf laplace_Q function
@anchor{146}@anchor{gsl cdf laplace_q}
@deffn {Function} gsl::cdf::laplace_Q x  a

implements @code{gsl_cdf_laplace_Q}.
@end deffn

@geindex gsl cdf laplace_Pinv function
@anchor{147}@anchor{gsl cdf laplace_pinv}
@deffn {Function} gsl::cdf::laplace_Pinv p  a

implements @code{gsl_cdf_laplace_Pinv}.
@end deffn

@geindex gsl cdf laplace_Qinv function
@anchor{148}@anchor{gsl cdf laplace_qinv}
@deffn {Function} gsl::cdf::laplace_Qinv q  a

implements @code{gsl_cdf_laplace_Qinv}.
@end deffn

@geindex gsl cdf exppow_P function
@anchor{149}@anchor{gsl cdf exppow_p}
@deffn {Function} gsl::cdf::exppow_P x  a  b

implements @code{gsl_cdf_exppow_P}.
@end deffn

@geindex gsl cdf exppow_Q function
@anchor{14a}@anchor{gsl cdf exppow_q}
@deffn {Function} gsl::cdf::exppow_Q x  a  b

implements @code{gsl_cdf_exppow_Q}.
@end deffn

@geindex gsl cdf cauchy_P function
@anchor{14b}@anchor{gsl cdf cauchy_p}
@deffn {Function} gsl::cdf::cauchy_P x  a

implements @code{gsl_cdf_cauchy_P}.
@end deffn

@geindex gsl cdf cauchy_Q function
@anchor{14c}@anchor{gsl cdf cauchy_q}
@deffn {Function} gsl::cdf::cauchy_Q x  a

implements @code{gsl_cdf_cauchy_Q}.
@end deffn

@geindex gsl cdf cauchy_Pinv function
@anchor{14d}@anchor{gsl cdf cauchy_pinv}
@deffn {Function} gsl::cdf::cauchy_Pinv p  a

implements @code{gsl_cdf_cauchy_Pinv}.
@end deffn

@geindex gsl cdf cauchy_Qinv function
@anchor{14e}@anchor{gsl cdf cauchy_qinv}
@deffn {Function} gsl::cdf::cauchy_Qinv q  a

implements @code{gsl_cdf_cauchy_Qinv}.
@end deffn

@geindex gsl cdf rayleigh_P function
@anchor{14f}@anchor{gsl cdf rayleigh_p}
@deffn {Function} gsl::cdf::rayleigh_P x  sigma

implements @code{gsl_cdf_rayleigh_P}.
@end deffn

@geindex gsl cdf rayleigh_Q function
@anchor{150}@anchor{gsl cdf rayleigh_q}
@deffn {Function} gsl::cdf::rayleigh_Q x  sigma

implements @code{gsl_cdf_rayleigh_Q}.
@end deffn

@geindex gsl cdf rayleigh_Pinv function
@anchor{151}@anchor{gsl cdf rayleigh_pinv}
@deffn {Function} gsl::cdf::rayleigh_Pinv p  sigma

implements @code{gsl_cdf_rayleigh_Pinv}.
@end deffn

@geindex gsl cdf rayleigh_Qinv function
@anchor{152}@anchor{gsl cdf rayleigh_qinv}
@deffn {Function} gsl::cdf::rayleigh_Qinv q  sigma

implements @code{gsl_cdf_rayleigh_Qinv}.
@end deffn

@geindex gsl cdf gamma_P function
@anchor{153}@anchor{gsl cdf gamma_p}
@deffn {Function} gsl::cdf::gamma_P x  a  b

implements @code{gsl_cdf_gamma_P}.
@end deffn

@geindex gsl cdf gamma_Q function
@anchor{154}@anchor{gsl cdf gamma_q}
@deffn {Function} gsl::cdf::gamma_Q x  a  b

implements @code{gsl_cdf_gamMa_Q}.
@end deffn

@geindex gsl cdf gamma_Pinv function
@anchor{155}@anchor{gsl cdf gamma_pinv}
@deffn {Function} gsl::cdf::gamma_Pinv p  a  b

implements @code{gsl_cdf_gamma_Pinv}.
@end deffn

@geindex gsl cdf gamma_Qinv function
@anchor{156}@anchor{gsl cdf gamma_qinv}
@deffn {Function} gsl::cdf::gamma_Qinv q  a  b

implements @code{gsl_cdf_gamma_Qinv}.
@end deffn

@geindex gsl cdf flat_P function
@anchor{157}@anchor{gsl cdf flat_p}
@deffn {Function} gsl::cdf::flat_P x  a  b

implements @code{gsl_cdf_flat_P}.
@end deffn

@geindex gsl cdf flat_Q function
@anchor{158}@anchor{gsl cdf flat_q}
@deffn {Function} gsl::cdf::flat_Q x  a  b

implements @code{gsl_cdf_flat_Q}.
@end deffn

@geindex gsl cdf flat_Pinv function
@anchor{159}@anchor{gsl cdf flat_pinv}
@deffn {Function} gsl::cdf::flat_Pinv p  a  b

implements @code{gsl_cdf_flat_Pinv}.
@end deffn

@geindex gsl cdf flat_Qinv function
@anchor{15a}@anchor{gsl cdf flat_qinv}
@deffn {Function} gsl::cdf::flat_Qinv q  a  b

implements @code{gsl_cdf_flat_Qinv}.
@end deffn

@geindex gsl cdf lognormal_P function
@anchor{15b}@anchor{gsl cdf lognormal_p}
@deffn {Function} gsl::cdf::lognormal_P x  zeta  sigma

implements @code{gsl_cdf_lognormal_P}.
@end deffn

@geindex gsl cdf lognormal_Q function
@anchor{15c}@anchor{gsl cdf lognormal_q}
@deffn {Function} gsl::cdf::lognormal_Q x  zeta  sigma

implements @code{gsl_cdf_lognormal_Q}.
@end deffn

@geindex gsl cdf lognormal_Pinv function
@anchor{15d}@anchor{gsl cdf lognormal_pinv}
@deffn {Function} gsl::cdf::lognormal_Pinv p  zeta  sigma

implements @code{gsl_cdf_lognormal_Pinv}.
@end deffn

@geindex gsl cdf lognormal_Qinv function
@anchor{15e}@anchor{gsl cdf lognormal_qinv}
@deffn {Function} gsl::cdf::lognormal_Qinv q  zeta  sigma

implements @code{gsl_cdf_lognormal_Qinv}.
@end deffn

@geindex gsl cdf chisq_P function
@anchor{15f}@anchor{gsl cdf chisq_p}
@deffn {Function} gsl::cdf::chisq_P x  nu

implements @code{gsl_cdf_chisq_P}.
@end deffn

@geindex gsl cdf chisq_Q function
@anchor{160}@anchor{gsl cdf chisq_q}
@deffn {Function} gsl::cdf::chisq_Q x  nu

implements @code{gsl_cdf_chisq_Q}.
@end deffn

@geindex gsl cdf chisq_Pinv function
@anchor{161}@anchor{gsl cdf chisq_pinv}
@deffn {Function} gsl::cdf::chisq_Pinv p  nu

implements @code{gsl_cdf_chisq_Pinv}.
@end deffn

@geindex gsl cdf chisq_Qinv function
@anchor{162}@anchor{gsl cdf chisq_qinv}
@deffn {Function} gsl::cdf::chisq_Qinv q  nu

implements @code{gsl_cdf_chisq_Qinv}.
@end deffn

@geindex gsl cdf fdist_P function
@anchor{163}@anchor{gsl cdf fdist_p}
@deffn {Function} gsl::cdf::fdist_P x  nu1  nu2

implements @code{gsl_cdf_fdist_P}.
@end deffn

@geindex gsl cdf fdist_Q function
@anchor{164}@anchor{gsl cdf fdist_q}
@deffn {Function} gsl::cdf::fdist_Q x  nu1  nu2

implements @code{gsl_cdf_fdist_Q}.
@end deffn

@geindex gsl cdf fdist_Pinv function
@anchor{165}@anchor{gsl cdf fdist_pinv}
@deffn {Function} gsl::cdf::fdist_Pinv p  nu1  nu2

implements @code{gsl_cdf_fdist_Pinv}.
@end deffn

@geindex gsl cdf fdist_Qinv function
@anchor{166}@anchor{gsl cdf fdist_qinv}
@deffn {Function} gsl::cdf::fdist_Qinv q  nu1  nu2

implements @code{gsl_cdf_fdist_Qinv}.
@end deffn

@geindex gsl cdf tdist_P function
@anchor{167}@anchor{gsl cdf tdist_p}
@deffn {Function} gsl::cdf::tdist_P x  nu

implements @code{gsl_cdf_tdist_P}.
@end deffn

@geindex gsl cdf tdist_Q function
@anchor{168}@anchor{gsl cdf tdist_q}
@deffn {Function} gsl::cdf::tdist_Q x  nu

implements @code{gsl_cdf_tdist_Q}.
@end deffn

@geindex gsl cdf tdist_Pinv function
@anchor{169}@anchor{gsl cdf tdist_pinv}
@deffn {Function} gsl::cdf::tdist_Pinv p  nu

implements @code{gsl_cdf_tdist_Pinv}.
@end deffn

@geindex gsl cdf tdist_Qinv function
@anchor{16a}@anchor{gsl cdf tdist_qinv}
@deffn {Function} gsl::cdf::tdist_Qinv q  nu

implements @code{gsl_cdf_tdist_Qinv}.
@end deffn

@geindex gsl cdf beta_P function
@anchor{16b}@anchor{gsl cdf beta_p}
@deffn {Function} gsl::cdf::beta_P x  a  b

implements @code{gsl_cdf_beta_P}.
@end deffn

@geindex gsl cdf beta_Q function
@anchor{16c}@anchor{gsl cdf beta_q}
@deffn {Function} gsl::cdf::beta_Q x  a  b

implements @code{gsl_cdf_beta_Q}.
@end deffn

@geindex gsl cdf beta_Pinv function
@anchor{16d}@anchor{gsl cdf beta_pinv}
@deffn {Function} gsl::cdf::beta_Pinv p  a  b

implements @code{gsl_cdf_beta_Pinv}.
@end deffn

@geindex gsl cdf beta_Qinv function
@anchor{16e}@anchor{gsl cdf beta_qinv}
@deffn {Function} gsl::cdf::beta_Qinv q  a  b

implements @code{gsl_cdf_beta_Qinv}.
@end deffn

@geindex gsl cdf logistic_P function
@anchor{16f}@anchor{gsl cdf logistic_p}
@deffn {Function} gsl::cdf::logistic_P x  a

implements @code{gsl_cdf_logistic_P}.
@end deffn

@geindex gsl cdf logistic_Q function
@anchor{170}@anchor{gsl cdf logistic_q}
@deffn {Function} gsl::cdf::logistic_Q x  a

implements @code{gsl_cdf_logistic_Q}.
@end deffn

@geindex gsl cdf logistic_Pinv function
@anchor{171}@anchor{gsl cdf logistic_pinv}
@deffn {Function} gsl::cdf::logistic_Pinv p  a

implements @code{gsl_cdf_logistic_Pinv}.
@end deffn

@geindex gsl cdf logistic_Qinv function
@anchor{172}@anchor{gsl cdf logistic_qinv}
@deffn {Function} gsl::cdf::logistic_Qinv q  a

implements @code{gsl_cdf_logistic_Qinv}.
@end deffn

@geindex gsl cdf pareto_P function
@anchor{173}@anchor{gsl cdf pareto_p}
@deffn {Function} gsl::cdf::pareto_P x  a  b

implements @code{gsl_cdf_pareto_P}.
@end deffn

@geindex gsl cdf pareto_Q function
@anchor{174}@anchor{gsl cdf pareto_q}
@deffn {Function} gsl::cdf::pareto_Q x  a  b

implements @code{gsl_cdf_pareto_Q}.
@end deffn

@geindex gsl cdf pareto_Pinv function
@anchor{175}@anchor{gsl cdf pareto_pinv}
@deffn {Function} gsl::cdf::pareto_Pinv p  a  b

implements @code{gsl_cdf_pareto_Pinv}.
@end deffn

@geindex gsl cdf pareto_Qinv function
@anchor{176}@anchor{gsl cdf pareto_qinv}
@deffn {Function} gsl::cdf::pareto_Qinv q  a  b

implements @code{gsl_cdf_pareto_Qinv}.
@end deffn

@geindex gsl cdf weibull_P function
@anchor{177}@anchor{gsl cdf weibull_p}
@deffn {Function} gsl::cdf::weibull_P x  a  b

implements @code{gsl_cdf_weibull_P}.
@end deffn

@geindex gsl cdf weibull_Q function
@anchor{178}@anchor{gsl cdf weibull_q}
@deffn {Function} gsl::cdf::weibull_Q x  a  b

implements @code{gsl_cdf_weibull_Q}.
@end deffn

@geindex gsl cdf weibull_Pinv function
@anchor{179}@anchor{gsl cdf weibull_pinv}
@deffn {Function} gsl::cdf::weibull_Pinv p  a  b

implements @code{gsl_cdf_weibull_Pinv}.
@end deffn

@geindex gsl cdf weibull_Qinv function
@anchor{17a}@anchor{gsl cdf weibull_qinv}
@deffn {Function} gsl::cdf::weibull_Qinv q  a  b

implements @code{gsl_cdf_weibull_Qinv}.
@end deffn

@geindex gsl cdf gumbel1_P function
@anchor{17b}@anchor{gsl cdf gumbel1_p}
@deffn {Function} gsl::cdf::gumbel1_P x  a  b

implements @code{gsl_cdf_gumbel1_P}.
@end deffn

@geindex gsl cdf gumbel1_Q function
@anchor{17c}@anchor{gsl cdf gumbel1_q}
@deffn {Function} gsl::cdf::gumbel1_Q x  a  b

implements @code{gsl_cdf_gumbel1_Q}.
@end deffn

@geindex gsl cdf gumbel1_Pinv function
@anchor{17d}@anchor{gsl cdf gumbel1_pinv}
@deffn {Function} gsl::cdf::gumbel1_Pinv p  a  b

implements @code{gsl_cdf_gumbel1_Pinv}.
@end deffn

@geindex gsl cdf gumbel1_Qinv function
@anchor{17e}@anchor{gsl cdf gumbel1_qinv}
@deffn {Function} gsl::cdf::gumbel1_Qinv q  a  b

implements @code{gsl_cdf_gumbel1_Qinv}.
@end deffn

@geindex gsl cdf gumbel2_P function
@anchor{17f}@anchor{gsl cdf gumbel2_p}
@deffn {Function} gsl::cdf::gumbel2_P x  a  b

implements @code{gsl_cdf_gumbel2_P}.
@end deffn

@geindex gsl cdf gumbel2_Q function
@anchor{180}@anchor{gsl cdf gumbel2_q}
@deffn {Function} gsl::cdf::gumbel2_Q x  a  b

implements @code{gsl_cdf_gumbel2_Q}.
@end deffn

@geindex gsl cdf gumbel2_Pinv function
@anchor{181}@anchor{gsl cdf gumbel2_pinv}
@deffn {Function} gsl::cdf::gumbel2_Pinv p  a  b

implements @code{gsl_cdf_gumbel2_Pinv}.
@end deffn

@geindex gsl cdf gumbel2_Qinv function
@anchor{182}@anchor{gsl cdf gumbel2_qinv}
@deffn {Function} gsl::cdf::gumbel2_Qinv q  a  b

implements @code{gsl_cdf_gumbel2_Qinv}.
@end deffn

@geindex gsl cdf poisson_P function
@anchor{183}@anchor{gsl cdf poisson_p}
@deffn {Function} gsl::cdf::poisson_P k::int  mu

implements @code{gsl_cdf_poisson_P}.
@end deffn

@geindex gsl cdf poisson_Q function
@anchor{184}@anchor{gsl cdf poisson_q}
@deffn {Function} gsl::cdf::poisson_Q k::int  mu

implements @code{gsl_cdf_poisson_Q}.
@end deffn

@geindex gsl cdf binomial_P function
@anchor{185}@anchor{gsl cdf binomial_p}
@deffn {Function} gsl::cdf::binomial_P k::int  p  n::int

implements @code{gsl_cdf_binomial_P}.
@end deffn

@geindex gsl cdf binomial_Q function
@anchor{186}@anchor{gsl cdf binomial_q}
@deffn {Function} gsl::cdf::binomial_Q k::int  q  n::int

implements @code{gsl_cdf_binomial_Q}.
@end deffn

@geindex gsl cdf negative_binomial_P function
@anchor{187}@anchor{gsl cdf negative_binomial_p}
@deffn {Function} gsl::cdf::negative_binomial_P k::int  p  n

implements @code{gsl_cdf_negative_binomial_P}.
@end deffn

@geindex gsl cdf negative_binomial_Q function
@anchor{188}@anchor{gsl cdf negative_binomial_q}
@deffn {Function} gsl::cdf::negative_binomial_Q k::int  p  n

implements @code{gsl_cdf_negative_binomial_Q}.
@end deffn

@geindex gsl cdf pascal_P function
@anchor{189}@anchor{gsl cdf pascal_p}
@deffn {Function} gsl::cdf::pascal_P k::int  p  n::int

implements @code{gsl_cdf_pascal_P}.
@end deffn

@geindex gsl cdf pascal_Q function
@anchor{18a}@anchor{gsl cdf pascal_q}
@deffn {Function} gsl::cdf::pascal_Q k::int  p  n::int

implements @code{gsl_cdf_pascal_Q}.
@end deffn

@geindex gsl cdf geometric_P function
@anchor{18b}@anchor{gsl cdf geometric_p}
@deffn {Function} gsl::cdf::geometric_P k::int  p

implements @code{gsl_cdf_geometric_P}.
@end deffn

@geindex gsl cdf geometric_Q function
@anchor{18c}@anchor{gsl cdf geometric_q}
@deffn {Function} gsl::cdf::geometric_Q k::int  p

implements @code{gsl_cdf_geometric_Q}.
@end deffn

@geindex gsl cdf hypergeometric_P function
@anchor{18d}@anchor{gsl cdf hypergeometric_p}
@deffn {Function} gsl::cdf::hypergeometric_P k::int  n1::int  n2::int  t::int

implements @code{gsl_cdf_hypergeometric_P}.
@end deffn

@geindex gsl cdf hypergeometric_Q function
@anchor{18e}@anchor{gsl cdf hypergeometric_q}
@deffn {Function} gsl::cdf::hypergeometric_Q k::int  n1::int  n2::int  t::int

implements @code{gsl_cdf_hypergeometric_Q}.
@end deffn


@node Examples<13>,,Routines<4>,Random Number Distributions
@anchor{examples<13>}@anchor{18f}@anchor{id15}
@section Examples
The following illustrates the use of each function in the @code{randist} module.
The pdf functions are illustrated first.

@example
> using gsl::stats;
> using namespace gsl::ran;
> ugaussian_pdf 1.2;
0.194186054983213
> gaussian_pdf (-1.3) 1.5;
0.182690978264686
> gaussian_tail_pdf 2.0 1.0 1.5;
0.433042698395299
> ugaussian_tail_pdf 2.0 1.0;
0.34030367841782
> bivariate_gaussian_pdf 1.2 0.9 1.0 1.0 0.95;
0.184646843689817
> exponential_pdf 1.0 0.5;
0.270670566473225
> laplace_pdf 1.5 2.0;
0.118091638185254
> exppow_pdf 0.0 1.0 1.5;
0.553866083716236
> cauchy_pdf (-1.0) 1.0;
0.159154943091895
> rayleigh_pdf 2.5 1.0;
0.109842334058519
> rayleigh_tail_pdf 1.5 1.0 1.0;
0.802892142778485
> landau_pdf 1.1;
0.140968737919623
> gamma_pdf 1.0 1.0 1.5;
0.342278079355061
> flat_pdf 1.0 0.5 2.5;
0.5
> lognormal_pdf 0.01 0.0 1.0;
0.000990238664959182
> chisq_pdf 1.0 2.0;
0.303265329856317
> fdist_pdf 0.5 3.0 2.0;
0.480970043785452
> tdist_pdf 0.1 10.0;
0.386975225815181
> beta_pdf 0.5 4.0 1.0;
0.499999999999999
> logistic_pdf (-1.0) 2.0;
0.117501856100797
> pareto_pdf 0.01 3.0 2.0;
0.0
> weibull_pdf  0.01 1.0 1.0;
0.990049833749168
> gumbel1_pdf 0.01 1.0 1.0;
0.367861108816436
> gumbel2_pdf 0.01 1.0 1.0;
3.72007597602084e-40
> dirichlet_pdf @{0.1,0.2,0.8@} @{2.0,2.0,2.0@};
0.00501316294425874
> dirichlet_lnpdf @{0.1,0.2,0.8@} @{2.0,2.0,2.0@};
-5.29568823688856
> poisson_pdf 4 0.4;
0.000715008049104682
> bernoulli_pdf 1 0.7;
0.7
> binomial_pdf 3 0.5 9;
0.1640625
> multinomial_pdf @{0.1,0.2,0.7@} @{2,2,2@};
0.0
> multinomial_lnpdf @{0.1,0.2,0.7@} @{2,2,2@};
-1728120799.71174
> negative_binomial_pdf 10 0.5 3.5;
0.0122430486923836
> pascal_pdf 10 0.5 3;
0.00805664062499999
> geometric_pdf 5 0.4;
0.05184
> hypergeometric_pdf 1 5 20 3;
0.413043478260872
> logarithmic_pdf 10 0.7;
0.00234619293712492
> test_discrete
>   = v
>     when
>       px = discrete_preproc @{0.1,0.3,0.4@};
>       v = discrete_pdf 0 px +
>           discrete_pdf 1 px +
>           discrete_pdf 2 px;
>       _ = discrete_free px
>     end;
> test_discrete;
1.0
@end example

@noindent
The cumulative distribution functions are shown.

@example
> using namespace gsl::cdf;
> ugaussian_P  (-1.3);
0.0968004845856103
> ugaussian_Q  (-1.3);
0.90319951541439
> ugaussian_Pinv  0.84;
0.994457883209753
> ugaussian_Qinv  0.84;
-0.994457883209753
> gaussian_P  (1.3)  1.5;
0.806937662858093
> gaussian_Q  (1.3)  1.5;
0.193062337141907
> gaussian_Pinv  0.4  5.0;
-1.266735515679
> gaussian_Qinv  0.4 5.0;
1.266735515679
> exponential_P  1.0  0.5;
0.864664716763387
> exponential_Q  1.0  0.5;
0.135335283236613
> exponential_Pinv  0.6  0.5;
0.458145365937077
> exponential_Qinv  0.6  0.5;
0.255412811882995
> laplace_P  1.5  2.0;
0.763816723629493
> laplace_Q  1.5  2.0;
0.236183276370507
> laplace_Pinv  0.6  2.0;
0.446287102628419
> laplace_Qinv  0.4  2.0;
0.446287102628419
> exppow_P  0.0  1.0  2.5;
0.5
> exppow_Q  0.0  1.0  0.5;
0.5
> cauchy_P  (-1.0)  1.0;
0.25
> cauchy_Q  (-1.0)  1.0;
0.75
> cauchy_Pinv  0.75  1.0;
1.0
> cauchy_Qinv  0.25  1.0;
1.0
> rayleigh_P  1.5  2.0;
0.245160398010993
> rayleigh_Q  0.5  1.0;
0.882496902584595
> rayleigh_Pinv  0.5  1.0;
1.17741002251547
> rayleigh_Qinv  0.5  1.0;
1.17741002251547
> gamma_P  1.0  1.0  3.0;
0.283468689426211
> gamma_Q  1.0  1.0  3.0;
0.716531310573789
> gamma_Pinv  0.5  1.0  1.0;
0.693147180559945
> gamma_Qinv  0.5  1.0  1.0;
0.693147180559945
> flat_P  2.0  1.2  4.8;
0.222222222222222
> flat_Q  2.0  1.2  4.8;
0.777777777777778
> flat_Pinv  0.2  0.5  2.5;
0.9
> flat_Qinv  0.2  0.5  2.5;
2.1
> lognormal_P  0.01  0.0  1.0;
2.06064339597172e-06
> lognormal_Q  0.01  0.0  1.0;
0.999997939356604
> lognormal_Pinv  0.1  0.0  1.0;
0.27760624185201
> lognormal_Qinv  0.1  0.0  1.0;
3.60222447927916
> chisq_P  1.0  2.0;
0.393469340287367
> chisq_Q  1.0  2.0;
0.606530659712633
> chisq_Pinv  0.5  2.0;
0.221199216928595
> chisq_Qinv  0.5  2.0;
1.38629436111989
> fdist_P  1.0  3.0  2.0;
0.46475800154489
> fdist_Q  1.0  3.0  2.0;
0.53524199845511
> fdist_Pinv  0.5  3.0  2.0;
1.13494292261288
> fdist_Qinv  0.5  3.0  2.0;
1.13494292261288
> tdist_P  2.1  10.0;
0.968961377898891
> tdist_Q  (-2.1)  10.0;
0.968961377898891
> tdist_Pinv  0.68  10.0;
0.482264205919689
> tdist_Qinv  0.68  10.0;
-0.482264205919689
> beta_P  0.75  2.0  2.0;
0.84375
> beta_Q  0.75  2.0  2.0;
0.15625
> beta_Pinv  0.75  2.0  2.0;
0.673648177666931
> beta_Qinv  0.25  2.0  2.0;
0.673648177666931
> logistic_P  (-1.0)  2.0;
1
> logistic_Q  (-1.0)  2.0;
0.622459331201855
> logistic_Pinv  0.75  1.0;
1.09861228866811
> logistic_Qinv  0.25  1.0;
1.09861228866811
> pareto_P  2.01  3.0  2.0;
0.0148512406901899
> pareto_Q  2.01  3.0  2.0;
0.98514875930981
> pareto_Pinv  0.1  3.0  2.0;
2.07148833730257
> pareto_Qinv  0.1  3.0  2.0;
4.30886938006377
> weibull_P  1.01  1.0  2.0;
0.639441117518024
> weibull_Q  1.01  2.0  3.0;
0.879160657465162
> weibull_Pinv  0.1  1.0  2.0;
0.324592845974501
> weibull_Qinv  0.1  1.0  2.0;
1.51742712938515
> gumbel1_P  1.01  1.0  1.0;
0.694739044426344
> gumbel1_Q  1.01  1.0  1.0;
0.305260955573656
> gumbel1_Pinv  0.1  1.0  1.0;
-0.834032445247956
> gumbel1_Qinv  0.1  1.0  1.0;
2.25036732731245
> gumbel2_P  1.01  1.0  1.0;
0.371539903071873
> gumbel2_Q  1.01  1.0  1.0;
0.628460096928127
> gumbel2_Pinv  0.1  1.0  1.0;
0.434294481903252
> gumbel2_Qinv  0.1  1.0  1.0;
9.4912215810299
> poisson_P  4  0.4;
0.999938756672898
> poisson_Q  4  0.6;
0.000394486018340255
> binomial_P  3  0.5  10;
0.171874999999999
> binomial_Q  3  0.5  10;
0.828125000000001
> negative_binomial_P  10  0.5  3.0;
0.98876953125
> negative_binomial_Q  10  0.5  3.0;
0.01123046875
> pascal_P  10  0.5  3;
0.98876953125
> pascal_Q  10  0.5  3;
0.01123046875
> geometric_P  5  0.4;
0.92224
> geometric_Q  5  0.6;
0.01024
> hypergeometric_P  1  5  20  3;
0.908695652173913
> hypergeometric_Q  1  5  20  3;
0.0913043478260873
@end example

@noindent

@node Sorting,Index,Random Number Distributions,Top
@anchor{sorting}@anchor{190}@anchor{module-gsl sort}@anchor{191}
@chapter Sorting

@geindex gsl sort module
This module is loaded via the command @code{using gsl::sort} and
provides Pure wrappers for the GSL sorting
routines found in Chapter 11 of the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Sorting.html}.


@menu
* Routines: Routines<5>.
* Examples: Examples<14>.
@end menu


@node Routines<5>,Examples<14>,,Sorting
@anchor{routines<5>}@anchor{192}@anchor{id16}
@section Routines

@geindex gsl sort_vector function
@anchor{193}@anchor{gsl sort_vector}
@deffn {Function} gsl::sort_vector m::matrix

implements @code{gsl_sort} and @code{gsl_sort_int} without @code{stride} and
@code{n} parameters.
@end deffn

@geindex gsl sort_vector_index function
@anchor{194}@anchor{gsl sort_vector_index}
@deffn {Function} gsl::sort_vector_index m::matrix

implements @code{gsl_sort_index} and @code{gsl_sort_int_index} without
@code{stride} and @code{n} parameters.
@end deffn


@node Examples<14>,,Routines<5>,Sorting
@anchor{examples<14>}@anchor{195}@anchor{id17}
@section Examples
Usage of each library routine is illustrated below.

@example
> using gsl::sort;
> using namespace gsl;
> sort_vector @{0,3,2,4,5@};
@{0,2,3,4,5@}
> sort_vector_index @{0.0,1.0,5.0,2.0,8.0,0.0@};
@{5,0,1,3,2,4@}
@end example

@noindent

@node Index,,Sorting,Top
@anchor{index}
@unnumbered Index
@printindex ge

@c %**end of body
@bye
