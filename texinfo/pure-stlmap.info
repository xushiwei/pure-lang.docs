This is pure-stlmap.info, produced by makeinfo version 4.13 from
pure-stlmap.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-stlmap: (pure-stlmap.info).    pure-stlmap
END-INFO-DIR-ENTRY


File: pure-stlmap.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-stlmap
***********

  Version 0.2, June 03, 2012

    Peter Summerland <<p.summerland@gmail.com>> 
  pure-stlmap is a Pure (http://pure-lang.googlecode.com) interface to
six associative containers provided by the C++ Standard Library
(http://en.cppreference.com/w/cpp): map, set, multimap, multiset,
unordered_map and unordered_set.

* Menu:

* Copying::
* Introduction::
* Installation::
* Examples::
* Quick Start::
* Concepts::
* Modules::
* Container Operations::
* Iterators: Iterators<2>.
* Backward Compatibilty::
* Index::

 --- The Detailed Node Listing ---

Introduction

* Supported Containers::
* Interface::

Quick Start

* Example Containers::
* Constructors::
* Ranges::
* Inserting and Replacing Elements::
* Access::
* Erasing Elements::
* Conversions::
* Functional Programming::

Concepts

* Containers and Elements::
* Ranges: Ranges<2>.
* Iterators::
* Selecting Elements Using Keys::
* C++ Implementation::

Modules

* The stlhmap Module::
* The stlmap Module::
* The stlmmap Module::

Container Operations

* Container Construction::
* Information::
* Modification::
* Accessing Elements::
* Conversions: Conversions<2>.
* Functional Programming: Functional Programming<2>.
* Comparison::
* Set Algorithms::
* Direct C Calls::

Iterators

* Concepts: Concepts<2>.
* Exceptions::
* Functions::
* Examples: Examples<2>.

Backward Compatibilty

* pure-stlmap-0 2::


File: pure-stlmap.info,  Node: Copying,  Next: Introduction,  Prev: Top,  Up: Top

1 Copying
*********

    Copyright (c) 2012 by Peter Summerland <<p.summerland@gmail.com>>. 
All rights reserved.

  pure-stlmap is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  pure-stlmap is distributed under a BSD-style license, see the COPYING
file for details.


File: pure-stlmap.info,  Node: Introduction,  Next: Installation,  Prev: Copying,  Up: Top

2 Introduction
**************

This is pure-stlmap-0.1, the first release of pure-stlmap. It is
possible that some of the functions might be changed slightly or even
removed. Comments and questions would be especially appreciated at this
early stage.

* Menu:

* Supported Containers::
* Interface::


File: pure-stlmap.info,  Node: Supported Containers,  Next: Interface,  Up: Introduction

2.1 Supported Containers
========================

The Standard C++ Containers Library, often refered to as the standard
template library ("STL"), provides templates for generic containers and
generic algorithms. pure-stlmap provides six mutable containers,
"stlmap", "stlset", "stlmmap", "stlmset", "stlhmap" and "stlhset", that
are thin wrappers around the corresponding associative containers
provided by the STL, map, set, multimap, multiset, unordered_map and
unordered_set, specialized to hold pure-expressions. pure-stlmap does
not provide wrappers for unordered_multimap and unordered_multiset.


File: pure-stlmap.info,  Node: Interface,  Prev: Supported Containers,  Up: Introduction

2.2 Interface
=============

pure-stlmap provides a "key-based" interface that can be used to work
with the supported STL containers in a way that should feel natural to
Pure programmers. For example, the (!) function can be used to access
values associated with keys and functions like *note map: a, *note
foldl: b, *note filter: c. and *note do: d. can be used to operate on
all or part of a container's elements without using an explict tail
recursive loop. In addition, for the ordered containers, stlmap,
stlmmap, stlset and stlmset, pure-stlmap provides an "interator-based"
interface that corresponds to the C++ interface, mostly on a one-to-one
basis.

  The interface for the unordered or "hash table" containers, stlhmap
and stlhset, is limited compared to that provided for the ordered
containers. In particular iterators, operations on subsequences
(ranges) and set operations are not supported.

  In some cases, the STL's associative containers have different
semantics than the the associative containers provided by the Pure
standard library. Where there is a conflict, pure-stlmap follows the
STL.

  Many of the functions provided by pure-stlmap, such as the
constructors, equivalence and lexicographical comparison operations,
insert and erase operations, and the set operations are just thin
wrappers around the the corresponding C++ functions. Users can consult
the C++ Library documentation to understand the performance
characteristics and corner case behavior of any pure-stlmap function
that has a corresponding function in the STL.

  The C++ library is sometimes more complicated than the Pure Standard
Library. For example many of the applicable C++ functions, including set
operations and tests for equality, assume that the containers are
lexicographically ordered. The reward for playing by the rules (which
occurs automatically for stlmap and stlset) is O(n) time complexity for
comparison and set operations.


File: pure-stlmap.info,  Node: Installation,  Next: Examples,  Prev: Introduction,  Up: Top

3 Installation
**************

pure-stlmap-0.2 is included in the "umbrella" addon, `pure-stllib'
which is available at
<http://code.google.com/p/pure-lang/downloads/list>. After you have
downloaded and installed `pure-stllib', you will be able to use
pure-stlmap (and `pure-stlvec', as well).


File: pure-stlmap.info,  Node: Examples,  Next: Quick Start,  Prev: Installation,  Up: Top

4 Examples
**********

The pure-stlmap/uts subdirectory contains Pure scripts that are used to
test pure-stlmap. These scripts contain simple tests, each of which
consists of a single line of code followed by a comment that contains
the expected output. E.g.,

    let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
    //- ()

    sm1!stl::smbeg, sm1!"a", sm1!"d", sm1!"e"
    //- 1,1,4,5

    catch id $ sm1!"0";
    //- out_of_bounds

You might consider pasting parts of these scripts into a temporary file
that you can play with if you are curious about how something works.

  Two short example programs, anagrams.pure and poly.pure, can be found
in the pure-stlmap/examples subdirectory.


File: pure-stlmap.info,  Node: Quick Start,  Next: Concepts,  Prev: Examples,  Up: Top

5 Quick Start
*************

This section introduces the basic functions you need to get up and
running with pure-stlmap. For a quick look at the other functions
provided by pure-stlmap, you can refer to pure-stllib-cheatsheet.pdf,
which can be found in the pure-stllib/doc directory.

* Menu:

* Example Containers::
* Constructors::
* Ranges::
* Inserting and Replacing Elements::
* Access::
* Erasing Elements::
* Conversions::
* Functional Programming::


File: pure-stlmap.info,  Node: Example Containers,  Next: Constructors,  Up: Quick Start

5.1 Example Containers
======================

The code snippets that appear in the examples that follow assume that
six containers have been created by entering the following at the
prompt.

    $> pure -q
    > using stlmap, stlhmap, stlmmap;
    > using namespace stl;

    > // Make some maps and sets with default characteristics
    > let sm  = stlmap  ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
    > let shm = stlhmap ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
    > let smm = stlmmap ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5];
    > let ss  = stlset  ["a","b","c","d","e"];
    > let shs = stlhset ["a","b","c","d","e"];
    > let sms = stlmset ["a","b","c","c","d"];

The `using' statement imports the three modules provided by pure-stlmap:
*note stlmap: 4. provides the interface for the stlmap and stlset
containers, *note stlmmap: 0. provides the interface the stlmmap and
stlmset containers, and *note stlhmap: 1. provides the interface to the
stlhmap and stlhset containers. The `let' statements set up an instance
of each of the containers provided by pure-stlmap, loaded with some
sample elements.

  To save typing you can run readme-data.pure, a file that contains the
corresponding source code. It can be found in in the
pure-stlmap/examples directory.


File: pure-stlmap.info,  Node: Constructors,  Next: Ranges,  Prev: Example Containers,  Up: Quick Start

5.2 Constructors
================

You can construct empty pure-stlmap containers using the *note
emptystlmap: 13, *note emptystlset: 14, *note emptystlmmap: 15, *note
emptystlmset: 16, *note emptystlhmap: 17. and *note emptystlhset: 18.
functions.

    > let sm1 = emptystlmap;   // uses (<) to order keys

You can construct a pure-stlmap container and fill it with elements all
in one go using the *note stlmap: 19, *note stlset: 1a, *note stlmmap:
1b, *note stlmset: 1c, *note stlhmap: 1d. and *note stlhset: 1e.
functions.

    > let shm1 = stlhmap ["a"=>1,"b"=>2,"c"=>3];

    > members shm1;
    ["c"=>3,"a"=>1,"b"=>2]

    > smh1!"b";
    2

As opposed to the hashed containers (stlhmap and stlhset), the ordered
containers (stlmap, stlset, stlmmap and stlmset) keep their elements
ordered by key.

    > let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>3]; members sm1;
    ["a"=>1,"b"=>2,"c"=>3]



File: pure-stlmap.info,  Node: Ranges,  Next: Inserting and Replacing Elements,  Prev: Constructors,  Up: Quick Start

5.3 Ranges
==========

For the ordered containers (stlmap, stlset, stlmmap and stlmset) you
can work with subsequences, called "ranges", of the containers'
elements. A range is specified by a tuple that consists of a container
and two keys. If (sm, first_key, last_key) designates a range, the
elements of the range are all of elements of the container sm whose
keys are equivalent to or greater than first_key and less than
last_key. If first_key and last_key are left out of the tuple, the
range consists of all of sm's elements.

    > members sm;               // no range keys - the whole container
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

    > members (sm,"b","e");     // a range from "b" up but not including "e"
    ["b"=>2,"c"=>3,"d"=>4]

    > members (sm,"c1","z");    // keys do not have to be stored
    ["d"=>4,"e"=>5]

    > members shm;              // works on a unordered set (with no range keys)
    ["c"=>3,"d"=>4,"e"=>5,"a"=>1,"b"=>2]

Two special keys, *note stl smbeg: 20. and *note stl smend: 21. are
reserved for use in ranges to designate the first element in a
container and the imaginary "past-end" element.

    > members (sm,smbeg,"d");
    ["a"=>1,"b"=>2,"c"=>3]

    > members (sm,"b",smend);
    ["b"=>2,"c"=>3,"d"=>4,"e"=>5]

Perhaps it should go without saying, but you cannot use either of these
symbols as the keys of elements stored in a pure-stlmap container.


File: pure-stlmap.info,  Node: Inserting and Replacing Elements,  Next: Access,  Prev: Ranges,  Up: Quick Start

5.4 Inserting and Replacing Elements
====================================

You can insert elements and, for the maps (stlmap, stlmmap and stlhmap),
replace the values associated with keys that are already stored in the
map, using the *note insert: 23, *note replace: 24. and *note
insert_or_replace: 25. functions. For the maps, the elements to
inserted are specified as (key=>value) hash-pairs.

    > let sm1 = emptystlmap;

    > insert sm1 ("e"=>5);              // returns number of elements inserted
    1
    > members sm1;
    ["e"=>5]

    > replace sm1 "e" 15;               // returns value
    15
    > members sm1;
    ["e"=>15]

    > catch id $ replace sm1 "x" 10;    // replace never inserts new elements
    out_of_bounds

    > insert sm1 ("e"=>25);             // insert never changes existing elements
    0
    > members sm1;
    ["e"=>15]

    > insert_or_replace sm1 ("e"=>25);  // 1 value changed
    1
    > members sm1;
    ["e"=>25]
    >

The *note insert: 23. and *note insert_or_replace: 25. functions are
overloaded to insert or replace elements specified in a list, vector,
stlvec or another pure-stlmap container (of the same type). E.g.,

    > let sm2 = emptystlmap;

    > insert sm2 ["b"=>2,"a"=>1];       // insert from a list
    2

    > insert sm2 (sm,"c","e");          // insert from a range
    2

    > members sm2;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4]

    > insert_or_replace sm2 {"a"=>11,"e"=>15};
    2

    > members sm2;
    ["a"=>11,"b"=>2,"c"=>3,"d"=>4,"e"=>15]



File: pure-stlmap.info,  Node: Access,  Next: Erasing Elements,  Prev: Inserting and Replacing Elements,  Up: Quick Start

5.5 Access
==========

If you want to see if a key is stored in a container use the *note
member: 27. function. (A key, k, is considered to be "stored" in a
container if there is an element in the container that is equivalent to
k.)

    > member sm "x";  // ("x"=>val) is not an element of sm for any val
    0

    > member sm "a";  // ("a"=>1) is an element with key equivalent to "a"
    1

The value (or values for a multi-key container) associated with a key
can be accessed using the (!) function.

    > sm!"a";   // return the value associated with "a"
    1

    > shm!"b";  // try it with a hashed map
    2

    > smm!"c";  // multimap returns a the list of values associated with "c"
    [31,32]

    > ss!"a";   // with sets, return the key
    "a"

    > sms!"c";  // with multisets, return a list of keys
    ["c","c"]

If the key is not stored in the container, (!) throws an `out_of_bounds'
exception.

    > catch id $ sm!"x"; // "x" is not stored as a key in sm
    out_of_bounds

Please note that all access is strictly by keys. For example you cannot
use the *note member: 27. function to determine if ("a"=>1) is an
element stored in sm; you can only ask if the key "a" is stored in sm.


File: pure-stlmap.info,  Node: Erasing Elements,  Next: Conversions,  Prev: Access,  Up: Quick Start

5.6 Erasing Elements
====================

For any pure-stlmap container, you can use the *note erase: 29. function
to remove all the elements associated with a given key in the
container, all of the elements in the container or, unless the
container is a stlhmap or stlhset, all of the elements in a range
defined on the container.

    > let shm1 = stlhmap shm;       // make some copies of maps
    > let smm1 = stlmmap smm;
    > let sm1 = stlmap sm;

    > members smm1;                 // smm1 has multiple values for "c"
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

    > erase (shm1,"c");             // erase "c" keyed elements from a stlmmap
    1
    > members shm1;                 // all the "c" keyed elements are gone
    ["d"=>4,"e"=>5,"a"=>1,"b"=>2]

    > erase shm1;                   // erase all elements
    4
    > empty shm1;
    1

    > erase (sm1,"b","d");         // erase a subsequence
    2
    > members sm1;
    ["a"=>1,"d"=>4,"e"=>5]

    > erase (sm1,"x");             // attempt to erase something not there
    0

    > erase (smm1,"c");            // erase all elements with key "c"
    2
    > members smm1;
    ["a"=>1,"b"=>2,"d"=>4,"e"=>5]



File: pure-stlmap.info,  Node: Conversions,  Next: Functional Programming,  Prev: Erasing Elements,  Up: Quick Start

5.7 Conversions
===============

The elements of an associated container be copied into a list, vector or
stlvec using the *note members: 2b, *note stl vector: 2c. and *note
stlvec: 2d. functions. For ordered containers (stlmap, stlset, stlmmap
and stlmset) the list, vector or stlvec can be built from a range.

    > members ss;
    ["a","b","c","d","e"]

    > members (ss,"b","d"); // list subsequence from "b" up to but not "d"
    ["b","c"]

    > members (smm,"c","e");
    ["c"=>31,"c"=>32,"d"=>4]

    > members (shm,"b","d"); // fails - ranges not supported for stlhmaps
    stl::members (#<pointer 0x83b4908>,"b","d")

    > members shm;          // ok - all elements are copied
    ["d"=>4,"e"=>5,"a"=>1,"b"=>2,"c"=>3]

    > vector (sm,smbeg,"d");
    {"a"=>1,"b"=>2,"c"=>3}

    > using stlvec;
    > members $ stlvec sm;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

You can convert the contents of an ordered container (stlmap, stlset,
stlmmap or stlmset) or a range defined on one to a stream using the
*note stream: 2e. function.

    > let ss1 = stlhset (0..100000);

    > stats -m

    > let xx = drop 99998 $ scanl (+) 0 (stream ss);
    0.3s, 18 cells

    > list xx;
    [704782707,704882705,704982704,705082704]
    0s, 17 cells



File: pure-stlmap.info,  Node: Functional Programming,  Prev: Conversions,  Up: Quick Start

5.8 Functional Programming
==========================

Most of the Pure list operations, including *note map: a, *note do: d,
*note filter: c, *note catmap: 30, *note foldl: b. and *note foldl1:
31. can be applied to any of pure-stlmap's associative containers. E.g.,

    > map (\x->x-32) shs;
    ["D","E","A","B","C"]

    > using system;

    > do (puts . str) (sm,smbeg,"c");
    "a"=>1
    "b"=>2
    ()

List comprehensions also work.

    > [k-32=>v+100 | (k=>v) = smm; k>"a" && k<"e"];
    ["B"=>102,"C"=>131,"C"=>132,"D"=>104]

    > {k-32=>v+100 | (k=>v) = (smm,"b","e")};
    {"B"=>102,"C"=>131,"C"=>132,"D"=>104}

It is highly recommended that you use the functional programming
operations, as opposed to recursive loops, whenever possible.


File: pure-stlmap.info,  Node: Concepts,  Next: Modules,  Prev: Quick Start,  Up: Top

6 Concepts
**********

This section describes pure-stlmap's containers, iterators, ranges,
elements, keys, values and how these objects are related to each other.
It also describes a group of functions associated with containers that
help define the container's behavior. E.g., each ordered container
(stlmap, stlset, stlmmap or stlmset) stores a function that it used to
order its keys and to determine if two keys are equivalent.

* Menu:

* Containers and Elements::
* Ranges: Ranges<2>.
* Iterators::
* Selecting Elements Using Keys::
* C++ Implementation::


File: pure-stlmap.info,  Node: Containers and Elements,  Next: Ranges<2>,  Up: Concepts

6.1 Containers and Elements
===========================

The six associative containers supported by pure-stlmap can be grouped
together in terms of certain defining attributes.

  The three "maps" provided by pure-stlmap, stlmap, stlmmap and stlhmap,
associate values with keys. If a value v is associated with a key, k,
in an map, m, then we say that (k=>v) is an element of m, k is a key
stored in m and v is a value stored in m.

  The three "sets" provided by pure-stlmap, stlset, stlmset and
stlhset, hold single elements, as opposed to key value pairs. If an
element e is contained a set, s, we say that e is simultaneously an
element, key and value stored s. In other words, we sometimes speak of
a set as if it were a map where each element, key and value are the
same object.

  The "ordered" containers, stlmap, stlset, stlmmap and stlmset, each
have a "key-less-than" function that they use keep their elements in a
sequence that is ordered by keys. The default key-less-than function is
`(<)', but this can be changed when the container is created. The
elements stored in a stlmap or stlset have unique keys, i.e., two
elements stored in the container will never have equivalent keys. For
these purposes, two keys are "equivalent" if neither key is
key-less-than the other. In contrast, stlmmap and stlmset do not have
unique keys. I.e., it is possible for different elements stored in a
stlmmap or stlmset can have equivalent keys.

  The "hashed" containers, sthmap and stlhset do not keep their
elements in a sequence. Instead they store their elments in a hash
table using a "key-hash" function and a "key-equal" function. Currently
the key-hash function is always `hash' and the key-equal function is
always (===), both of which are defined in the Prelude. The elements
stored in a hashed container have unique keys. I.e., two elements
stored in the container will never by "key-equal". At times we say that
two keys stored in a hashed container are "equivalent" if they are
key-equal.

  The "ordered maps", stlmap and stlmmap, each have a "value-less-than"
function and a "value-equal" function that is used for lexicographical
comparisons. The default functions are `(<)' and (==) respectively, but
these can customized when the container is created.

  As is the case for the underlying C++ functions, set operations
(i.e., union, intersection, etc.) and container equivalence for the
ordered containers are based on lexicographical comparisons. For these
purposes one element, e1, is less than another, e2, if (a) e1's key is
less-than e2's key and, (b) if the ordered container is a stlmap or
stlmap, e1's value is value-less-than e2's value. Finally, for purposes
of determining if two ordered containers are equal, e1 and e2 are
considered to be equal if (a) their keys are equivalent and (b), in the
case of stlmap or stlmmap, their values are value-equal.

  Set operations are not provided for the hashed containers, stlhmap and
stlhset.


File: pure-stlmap.info,  Node: Ranges<2>,  Next: Iterators,  Prev: Containers and Elements,  Up: Concepts

6.2 Ranges
==========

For the ordered containers (stlmap, stlset, stlmmap and stlmset), you
can work with a subsequence or "range" of a container's elements. Given
an ordered container, oc, and keys f and l, the range (oc,f,l) consists
of all of the elements in oc starting with the first element that is
not less than f up to but not including the first element that is
greater or equal to l. Note that f and l do not have to be stored in oc.

    > members (sm,"b","e");
    ["b"=>2,"c"=>3,"d"=>4]

    > members (sm,"c1",smend);
    ["d"=>4,"e"=>5]

When a range is passed to a function provided by pure-stlmap, the keys
can be dropped, in which case the range consists of all of the
container's elements.

    > members sm;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

Please note that support for ranges is not provided for the unordered
containers (stlhmap and stlhset). Most pure-stlmap functions that act on
ranges can, however, operate on stlhmaps or stlhsets as well, except
that, for stlhmaps and stlhsets, they always operate on all of the
container's elements. Accordingly, whenever the documentation of a
function refers to a range, and the container in question is a a
stlhmap or stlhset, the range simply refers to the container itself.


File: pure-stlmap.info,  Node: Iterators,  Next: Selecting Elements Using Keys,  Prev: Ranges<2>,  Up: Concepts

6.3 Iterators
=============

The native STL interface is based on "iterators" that point to elements
in containers. pure-stlmap provides support for iterators defined on
its ordered containers (stlmap, stlmmap, stlset and stlmset) but not
for its unordered containers (stlhmap and stlhset).

  Iterators are most useful when dealing with stlmmaps where elements
with different values can have equivalent keys. In most cases, it is
recommended that you avoid using iterators. The functions that operate
on or return iterators are discussed separately at the end of this
document.


File: pure-stlmap.info,  Node: Selecting Elements Using Keys,  Next: C++ Implementation,  Prev: Iterators,  Up: Concepts

6.4 Selecting Elements Using Keys
=================================

Throughout pure-stlmap, unless you resort to using iterators, you can
only specify elements and ranges of elements using keys. For example
you cannot use the *note member: 27. function to see if a specific key,
value pair is an element of a stlmap.

    > members sm;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

    > member sm "a";
    1

    > catch id $ member sm (a=>1);
    bad_argument

In the last line of code, *note member: 27. treats (a=>1) as a key.
Because (a=>1) cannot be compared to a string using `(<)', the ersatz
key is treated as a bad argument.

  This "key access only" approach can be an issue for stlmmaps and
because multiple elements can have equivalent keys. I.e., given a
stlmmap, smm, that containes multiple element with keys equivalent to,
say, k, which element should (!) return? pure-stlmap dodges this issue
by returning all on them. Thus, for stlmmap and stlmset (!) and *note
replace: 24. work with lists of elements associated with a given key
rather than, say, the first elment with the given key.

    > members smm;
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4];

    > smm!"c";
    "c"=>[31,32]

    > replace smm "c" [31,32,33]; members smm;
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>33,"d"=>4]

    > replace smm "c" []; members smm;
    ["a"=>1,"b"=>2,"d"=>4,"e"=>5]

If selecting and replacing lists of elements with the same key is not
convenient, you can always use iterators to track down and modify any
specific element.


File: pure-stlmap.info,  Node: C++ Implementation,  Prev: Selecting Elements Using Keys,  Up: Concepts

6.5 C++ Implementation
======================

For those that want to refer to the C++ standard library documentation
(http://en.cppreference.com/w/cpp), stlmap is (essentially)
map<px*,px*>, stlmmap is multimap<px*,px*> and stlhmap is
unordered_map<px*,px*>, where px is defined by "typedef pure_expr px".
I.e., in C++ Containers library speak, key_type is px*, mapped_type is
px* and value_type is pair<px*,px*>. This might be a bit confusing
because pure-stlmap's (key=>value) "elements" correspond to C++
value_types, a pair<key_type,mapped_type>, and pure-stlmap's values
correspond to mapped_types. The C++ objects for stlset, stlmset and
stlhset are the same as stlmap, stmmap and stlhmap except that
pure-stlmap ensures that the second member of the C++ value_type pair
is always NULL.


File: pure-stlmap.info,  Node: Modules,  Next: Container Operations,  Prev: Concepts,  Up: Top

7 Modules
*********

pure-stlmap provides three separate modules *note stlmap: 4, *note
stlmmap: 0. and *note stlhmap: 1.

  Importing any one of these modules defines the stl namespace as well
as two important symbols, *note stl smbeg: 20. and *note stl smend: 21.

 -- constructor: stl::smbeg
 -- constructor: stl::smend
     These symbols are used to designate the key of the first element
     in an ordered container (stlmap, stlset, stlmmap or stlmset) and
     the key of an imaginary element that would come immediately after
     the last element of in the constainer. They are used to define
     ranges over the ordered containers.

  E.g.,

    > members sm;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

    > members (sm,"c",smend);
    ["c"=>3,"d"=>4,"e"=>5]


* Menu:

* The stlhmap Module::
* The stlmap Module::
* The stlmmap Module::


File: pure-stlmap.info,  Node: The stlhmap Module,  Next: The stlmap Module,  Up: Modules

7.1 The stlhmap Module
======================

If all you want is fast insertion and lookup, you don't care about the
order of the elements stored in the container, and you do not want to
use set operations like *note stl map_intersection: 3b, then *note
stlhmap: 1. is probably your best choice. The supported containers,
stlhmap and stlhset are simpler to use and faster than the other
containers provided by pure-stlmap.

  The *note stlhmap: 1. module defines stlhmaps and stlhsets and
provides functions for dealing with them. You can import it by adding
the following `using' statement to your code.

    > using stlhmap;

The *note stlhmap: 1. module defines types two types:

 -- type: stlhmap
 -- type: stlhset

  Please note that a stlhset is just a stlhmap where the values
associated with keys cannot be accessed or modified. I.e., a stlhset is
a specialized kind of stlhmap.


File: pure-stlmap.info,  Node: The stlmap Module,  Next: The stlmmap Module,  Prev: The stlhmap Module,  Up: Modules

7.2 The stlmap Module
=====================

The *note stlmap: 4. module provides you with stlmaps and stlsets and
the functions that operate on them. Consider using these containers if
you want their elements to be orderd by key, want to use ranges or if
you are using any set operations (*note stl map_union: 3f, *note stl
map_intersection: 3b, etc).

  You can import the stlmap module by adding the following using
statement to your code.

    > using stlmap;

Importing the stlmap module introduces types to describe stlmap and
stlset, their iterators and ranges defined on them.

 -- type: stlmap
 -- type: stlset

 -- type: stlmap_iter

 -- type: stlmap_rng

  Please note that a stlset is just a stlmap where the values
associated with keys cannot be accessed or modified. I.e., a stlset is
a specialized kind of stlmap. Accordingly, it is not necessary, for
example, to define a separate type for iterators on stlsets as opposed
to iterators on stlmaps.


File: pure-stlmap.info,  Node: The stlmmap Module,  Prev: The stlmap Module,  Up: Modules

7.3 The stlmmap Module
======================

If you need a multi-keyed container, the *note stlmmap: 0. module,
which provides support for stlmaps and stlmsets, is your only choice.
Set operations and ranges are supported, but the semantics are more
complicated than is the case for stlmap and stlset. Because the keys
stored in multi-keyed containers are not unique you might have to
resort to using iterators when working with them.

  You can import the *note stlmmap: 0. module by adding the following
using statement to your code.

    > using stlmmap;

Importing the stlmmap module introduces types to describe stlmmap and
stlmset, along with their iterators and ranges defined on them.

 -- type: stlmmap
 -- type: stlmset

 -- type: stlmmap_iter

 -- type: stlmmap_rng

  Please note that a stlmset is just a stlmmap where the values
associated with keys cannot be accessed or modified. I.e., a stlmset is
a specialized kind of stlmmap. Accordingly, it is not necessary, for
example, to define a separate type for iterators on stlmsets as opposed
to iterators on stlmmaps.


File: pure-stlmap.info,  Node: Container Operations,  Next: Iterators<2>,  Prev: Modules,  Up: Top

8 Container Operations
**********************

Each of the six associative containers supported by pure-stlmap has its
own set of unique characteristics. Because of this the description of
functions that operate on more than one type of container can get a
little complicated.  When reading this section it might be helpful to
consult pure-stllib-cheatsheet.pdf which can be found in the
pure-stlib/doc directory.

* Menu:

* Container Construction::
* Information::
* Modification::
* Accessing Elements::
* Conversions: Conversions<2>.
* Functional Programming: Functional Programming<2>.
* Comparison::
* Set Algorithms::
* Direct C Calls::


File: pure-stlmap.info,  Node: Container Construction,  Next: Information,  Up: Container Operations

8.1 Container Construction
==========================

New empty ordered containers (stlmap, stlset, stlmmap and stlmset) can
be constructed using optional parameters that allow you to specify
customized key-less-than functions, default values, value-less-than and
value-equal functions.

 -- Function: mkstlmap (klt,dflt,vlt,veq)
 -- Function: mkstlmmap (klt,dflt,vlt,veq)
     Create a new stlmap or stlmmap where `klt' is the map's
     key-less-than function. dflt is the maps default value (used by
     replace_with and find_with_default). vlt is the map's
     value-compare function and veq is its value-equal function.  Only
     `klt' is required, and the default values for dflt, vlt, veq are
     [], (<) and (==) respectively.

 -- Function: mkstlset klt
 -- Function: mkstlmset klt
     Create a new stlset or stlmset where `klt' is the set's
     key-less-than function.

  The internal lookup functions for the ordered containers (stlmap,
stlset, stlmmap and stlmset) are optimized to avoid callbacks if the
container's key-less-than function is is `(>)' or `(<)' and the keys
being compared are a pair of strings, ints, bigints or doubles.

  You can create an empty associative container using default values
for using *note emptystlmap: 13. and friends.

 -- Function: emptystlmap
 -- Function: emptystlmmap
 -- Function: emptystlset
 -- Function: emptystlmset
     Create a new ordered map or set using default values. I.e.,
     emptystlmap is the same as mkstlmap `(<)', and so on.

 -- Function: emptystlhmap
 -- Function: emptystlhset
     Create a new stlhmap or stlhset with default values. The
     hash-function is hash and the value-equal function is (===).

  Convenience functions are also provided to construct an empty
container and insert elements into it in one go. The source of the
elements can be a list, vector, a stlvec, or a range defined on another
container of the same type as the new container.

 -- Function: stlmap src
 -- Function: stlmmap src
 -- Function: stlset src
 -- Function: stlmset src
 -- Function: stlhmap src
 -- Function: stlhset src
     Create an associative constructor using default values and insert
     elements from copied from `src'. `src' can be a list, vector or
     stlvec of elements or a range defined over a container of the same
     type as the new container. If the new container is a stlmap,
     stlmmap or stlhmap, the elements of src must be (key=>val) pairs.
     If the new container is a stlset, stlmset or stlhset they can be
     any pure expression that can be used as a key (i.e., anything
     except for *note stl smbeg: 20. or *note stl smend: 21.).


File: pure-stlmap.info,  Node: Information,  Next: Modification,  Prev: Container Construction,  Up: Container Operations

8.2 Information
===============

This group of functions allows you make inquiries regarding the number
of elments in a container, the number of instances of a given key held
by a container, the upper and lower bounds of a range and other
information. In addition this group includes a function that can be
used to change the number of slots used by a stlhmap or stlhset.

 -- Function: # acon
     Return the number of elements in `acon'.

 -- Function: stl::empty acon
     Return true if `acon' is empty, else false.

 -- Function: stl::distance rng
     Returns the number of elements contained in `rng' where rng is a
     range defined on an ordered container (stlmap, stlmmap, stlset,
     stlmset).

 -- Function: stl::count acon k
     Returns the number of elements in an associative container, acon,
     that have a key that is equivalent to `k'.

 -- Function: stl::bounds rng
     Return a pair of keys, first and last, such that first <= k < last
     for each k, where k is the key of an element in `rng'. If there is
     no such last, the second member of the returned pair will be *note
     stl smend: 21. If first is the key of the first element of `rng's'
     container, the first member of the returned pair will *note stl
     smbeg: 20.

  Here are two examples using the *note stl bounds: 54. function. Notice
that bounds returns *note stl smbeg: 20. instead of "a" in the first
example.

    > members sm;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

    > bounds sm;
    stl::smbeg,stl::smend

    > bounds (sm,"a1","e");
    "b","e"


 -- Function: stl::container_info acon
     If `acon' is a stlmap or stlmmap, returns (0, klt, dflt, vlt, veq)
     where klt is `acon''s key-less-than function, dflt is its default
     value, vlt is its value-less-than function and veq is its
     value_equal function. If `acon' is a stlset or stlmset, returns
     (1,klt,_,_,_) where klt is `acon''s key-less-than function. If
     `acon' is a stlhmap or stlhset, returns (is_set, bucket_count,
     load_factor, max_load_factor).

 -- Function: stl::bucket_size hacon n
     Returns the number of elements in `hacon''s nth (zero-based)
     bucket where `hacon' is a stlhmap or stlhset.

 -- Function: stl::hmap_reserve hacon mlf size
     Sets `hacon''s max_load_factor to `mlf', sets the number of `hacon
     's buckets to ``size'/`mlf` and rehashes ``hacon' where `hacon' is
     a stlhmap or stlhset.


File: pure-stlmap.info,  Node: Modification,  Next: Accessing Elements,  Prev: Information,  Up: Container Operations

8.3 Modification
================

You can insert new items or, for the maps (stlmap, stlmmap and stlhmap),
replace values associated with keys using the *note insert: 23, *note
replace: 24. or *note insert_or_replace: 25. functions.

  Please note that when working with the ordered containers (stlmap,
stlset, stlmmap and stlmset) the keys of elements passed to these
functions must be compatible with the container's key-less-than
function and keys that are already inserted. E.g.,

    > members ss;
    ["a","b","c","d","e"]

    > catch id $ insert ss 1;   // e.g., 1<"a" is not defined
    bad_argument

Currently there is no similar restriction for stlhmaps and stlhsets
because (a) they do not have a key-less-than function and (b) the
function they do use for testing equality, the key-equal function is
always (===), a function that can compare any two objects.

    > members shs;
    ["c","d","e","a","b"]

    > insert shs 1;
    1
    > members shs;
    ["c",1,"d","e","a","b"]

Elements can be inserted into a pure-stlmap container individually or
en masse from a list, vector, stlvec or another container of the same
type. If there is a key in the container that is equivalent to the key
of the element being inserted, the element will not be inserted (unless
the container is a stlmmap or stlmset, both of which can hold multiple
elements with equivalent keys).

 -- Function: insert acon src
     Attempts to copy elements from `src' a valid "insert source" into
     `acon' which can be any pure-stlmap container. A valid insert
     source is (a) a single element, (b) a list, vector, stlvec of
     elements or (c), a range over an associative container of the same
     type as `acon'. If `acon' is an associative map (stlmap, stlmmap
     or stlhmap), the `src' itself, or all the elements of `src', must
     be key value pairs of the form (k=>v). In contrast, if `acon' is a
     stlset, stlmset or stlhset, `src' or all of its elements can be
     any pure object (except *note stl smbeg: 20. or *note stl smend:
     21.). If `acon' is a stlmap, stlset, stlhmap or stlhset, the
     element will not be inserted if its key is already stored in the
     target container. Returns the number of elements inserted, if any.

  If you are dealing with a stlmap or stlhmap and want to override the
values of elements have keys that equivalent to the keys of the items
you wan to insert you can use the *note insert_or_replace: 25. function.

 -- Function: insert_or_replace acon src
     The same as *note insert: 23. except that (a) `acon' must be a
     stlmap or a stlhmap and (b) if an element (key=>newval) is about
     to be inserted and the container already contains an element
     (key=>oldval) the element in the container will be changed to
     (key=>newval). Returns the number of elements inserted or updated.

 -- Function: replace map key x
     `map' must be a stlmap, stlmmap or stlhmap. If `key' is not stored
     in `map' this function throws `out_of_bounds'. If `map' is a stlmap
     or stlhmap and (oldkey=>oldval) is an element of `map', where
     oldkey is equivalent to `key', change the element to
     (oldkey=>"x"). If `map' is a stlmmap and `key' is stored in `map',
     change the values of elements with key eqivalent to `key', one by
     one, to the elements of `x'. Add or delete elements as necessary
     so that, when the smoke clears, the values of `map'!"key" are
     copies of the elements of `x'. In all cases, if `key' is stored in
     `map' returns `x'.

  Here are some examples using *note replace: 24.

    > members sm1;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

    > replace sm1 "e" 50;
    50

    > members sm1;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>50]

    > members smm1;
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

    > replace smm1 "c" [31,33,35,36] $$ smm1!"c";
    [31,33,35,36]

    > replace smm1 "c" [] $$ smm1!"c";
    []

    > members smm1;
    ["a"=>1,"b"=>2,"d"=>4,"e"=>5]


 -- Function: replace_with fun map (k=>v)
     `map' must be a stlmap. The effect of this function is as follows:
     (a) if ~ *note member: 27. `map' `k' then *note insert: 23. `map'
     (`k``=>dflt) else (), where dflt is ``map''s dflt value, (b) *note
     replace: 24. `map' `k' nv when nv = `fun' `v' (`map'!"k") end.
     Returns `map'.

  Here is an example using *note replace_with: 59. in which a stlmmap is
converted to a stlmap.

    > let sm1 = emptystlmap;

    > members smm;
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

    > do (replace_with (:) sm1) smm;
    ()

    > members sm1;
    ["a"=>[1],"b"=>[2],"c"=>[32,31],"d"=>[4],"e"=>[5]]

Here is another example in which items are counted.

    > let sm1 = mkstlmap ( (<), 0 );

    > members sms;
    ["a","b","c","c","d"]

    > do (\x->replace_with (+) sm1 (x=>1)) sms;
    ()

    > members sm1;
    ["a"=>1,"b"=>1,"c"=>2,"d"=>1]

You can remove all the elements in a container, remove all the elements
equivalent to a given key or a remove a range of elements using the
*note erase: 29. function.

 -- Function: erase acon
 -- Function: erase (acon,k)
 -- Function: erase (acon,k1,k2)
     The first form erases all elements in `acon' which can be any
     container provided by pure-stlmap. The second erases all elements
     in `acon' with key equivalent to `k'. The third erases the
     elements in the range (`acon',"k1","k2"). The third form only
     applys to the ordered containers (stlmap, stlmmap, stlset and
     stlmset), not stlhmap or stlhset (because ranges are not defined
     for stlhmaps or stlhsets). Returns the number of elements removed
     from the container.

  Here are some examples using *note erase: 29.

    > members smm;
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

    > erase (sm,"z");
    0

    > erase (smm,"c");
    2

    > members smm;
    ["a"=>1,"b"=>2,"d"=>4,"e"=>5]

    > erase (smm,"b","e");
    2

    > members smm;;
    ["a"=>1,"e"=>5]


 -- Function: stl::swap acon1 acon2
     Swaps the elements of the two containers, `acon1' and `acon2' where
     `acon1' and `acon2' are the same type of container (E.g., both are
     stlmaps or both are stlmsets).


File: pure-stlmap.info,  Node: Accessing Elements,  Next: Conversions<2>,  Prev: Modification,  Up: Container Operations

8.4 Accessing Elements
======================

You can test if a key is stored in a container and access the value
associated with a key using the familiar *note member: 27. and (!)
functions.

 -- Function: member acon k
     Returns true if `acon', any container provided by pure-stlmap,
     contains an element that has a key that is equivalent to `k'.

 -- Function: acon ! k
     If `acon' is not a stlmmap then (a) if `acon' has an element with
     key equivalent to `k' return its value, otherwise (b) throw an
     `out_of_bounds' exception. If `acon' is a stlmmap then (a) if acon
     has as least one element with key equivalent to `k' return a list
     of values of all the elements with key equivalent to `k',
     otherwise (b) return an null list.

  E.g.:

    > sm!"c";
    3

    > catch id $ sm!"f";    // "f" is not stored in sm
    out_of_bounds

    > catch id $ sm!100;    // 100 cannot be compared to strings using (<)
    bad_argument

    > smm!"c";              // for stlmmap, return list of values
    [31,32]

    > smm!"f";              // stlmmap returns null list if key is not stored
    []

You can access a sequence of elements in an ordered container (stlmap,
stlset, stlmmap or stlmset) without resorting to iterators using the
next_key and prev_key functions.

 -- Function: stl::next_key acon k
 -- Function: stl::prev_key acon k
     `acon' must be a stlmap, stlset, stlmmap or stlmmap. Also if `k'
     is not *note stl smbeg: 20, *note stl smend: 21. or an element of
     acon an `out_of_bounds' exception will be throw.  *note next_key:
     5d.  returns the key of the first element in acon that has a key
     that is greater than `k'. If no such element exists or if `k' is
     *note stl smend: 21, returns *note stl smend: 21.  *note prev_key:
     5e. returns the last element in acon that has a key that is less
     that `k', or, if no such element exists, throws an `out_of_bounds'
     exception.

  For various reasons, it is very common to see a call to (!) or *note
replace: 24. preceded by a call to *note member: 27. with the same
container and key. E.g.,

    > bump_wc sm w = if member sm w then replace sm w (sm!w + 1)
                     else insert sm (w=>1);

In general, this function would require two lookups to add a new word
and three lookups to bump the count for an existing word. For the
ordered containers, lookups have O(log N) complexity which can be
relatively slow for large containers.

  To speed things up, each stlmap or stlset maintains a small cache of
(key, C++ iterator) pairs for recently accessed keys. During lookup,
the cache is checked for a matching key, and if the key is found, the
element pointed to by the C++ iterator is used immediately. Thus, when
applied to a stlmap or stlset bump_wc will use only one O(log N)
search, rather than two or three. For these purposes, a key matches a
key in the cache only if it is the same Pure object (i.e., the test is
C++ pointer equality, not Pure's (===) or (==) functions). For example,
the following will result in two O(log N) lookups.

    > if member sm "a" then sm!"a" else insert sm ("a"=>10);

Here each "a" is a distinct Pure object. The two "a"s satisfy (==) and
even (===) but they are not the same internally and the caching
mechanism will not help.

  Almost any pure-stlmap function that accepts a stlmap or stlset as an
argument will check the container's cache before doing an O(log N)
lookup.  Currently the cache is limited to hold only the most recently
used key.

  Here are some examples produced by compiling pure-stlmap with a trace
function that shows caching in action.

    > let a_key = "a";

    > members sm;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

    > member sm a_key;           // a_key is not yet in the cache
    1

    > sm!a_key;                  // a_key is found in the cache
    found iterator for: "a"
    1

    > replace sm a_key 10;
    found iterator for: "a"
    10

    > sm!"a";                    // "a" is a new key, not same C++ pointer as k or a_key
    1

    > let k = next_key sm a_key; // now k is in the cache, in front of a_key
    found iterator for: "a"

    > let k1 = next_key sm k;    // now k1 is at the head of the queue
    found iterator for: "b"

    > replace sm k1 30;
    found iterator for: "c"
    30

    > members sm;
    ["a"=>10,"b"=>2,"c"=>30,"d"=>4,"e"=>5]

These examples show that caching can be effective wnen visiting
elements of a stlmap or stlset in order using `next_key' or `prev_key'.


File: pure-stlmap.info,  Node: Conversions<2>,  Next: Functional Programming<2>,  Prev: Accessing Elements,  Up: Container Operations

8.5 Conversions
===============

The contents of a pure-stlmap container can be copied to a list, vector,
stlvec. For stlmaps, stlsets, stlmmaps and stlmsets, these operations
act on ranges as well as on the entire container.

 -- Function: members rng
     Returns a list of the elments in the range, `rng'.

 -- Function: keys rng
 -- Function: vals rng
     Return the keys and vals of the range's elements.

  Here are some examples using the *note members: 2b, *note keys: 60.
and *note vals: 61. functions.

     > members shm;   // must do all of shm elements because shm is a stlhmap
    ["d"=>4,"e"=>5,"a"=>1,"b"=>2,"c"=>3]

    > keys (sm,"b","e"); // can ask for a range - sm is an ordered container
    ["b","c","d"]

    > vals (sm,"b","e");
    [2,3,4]


 -- Function: stl::vector rng
     Return a vector containing the elments of in the range, rng.

 -- Function: stlvec rng
     returns a stlvec containing the elments of in the range, rng.

  You can also convert an ordered container (stlmap, stlset, stlmmap or
stlmset) into a stream of elements.

 -- Function: stream rng
     Returns a stream consisting of the range's elements.

  Here is an example using the stream function on a stlmmap.

    > members smm;
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

    > take 3 $ stream smm;
    ("a"=>1):#<thunk 0xb70f438c>

    > list ans;
    ["a"=>1,"b"=>2,"c"=>31]



File: pure-stlmap.info,  Node: Functional Programming<2>,  Next: Comparison,  Prev: Conversions<2>,  Up: Container Operations

8.6 Functional Programming
==========================

pure-stlmap provides the most commonly used functional programming
operations, implemented to act on ranges as if they were lists.

 -- Function: do fun rng
 -- Function: map fun rng
 -- Function: filter pred rng
 -- Function: foldl fun x rng
 -- Function: foldl1 fun rng
 -- Function: foldr fun x rng
 -- Function: foldr1 fun rng
     These functions are the same as the corresponding functions
     provided in the Prelude for lists. `rng' is a rng defined on a
     stlmap, stlset, stlmmap or stlmset or `rng' is simply a stlhmap or
     stlhset. *note foldr: 63. and *note foldr1: 64. are not defined
     for stlhmaps or stlhsets.

  Here are some examples.

    > members sm;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

    > map (\(k=>v)->k+str v) (sm,"b","e");
    ["b2","c3","d4"]

    > foldr1 (\(k=>v) (ks=>sum)-> (k+ks=>v+sum)) (sm,"b","e");
    "bcd"=>9

    > filter (\(k=>v)->v mod 2) sm;
    ["a"=>1,"c"=>3,"e"=>5]


 -- Function: listmap fun rng
 -- Function: catmap fun rng
 -- Function: rowmap fun rng
 -- Function: rowcatmap fun rng
 -- Function: colmap fun rng
 -- Function: colcatmap fun rng
     These functions are the same as the corresponding functions
     provided in the Prelude for lists. `rng' is a rng defined on a
     stlmap, stlset, stlmmap or stlmset or simply a stlhmap or stlhset.

  These functions are provided primarily to enable the use of list and
matrix comprehensions over pure-stlmap's containers. E.g.,

    > [ k + str v | (k=>v) = (sm,"b","e")];
    ["b2","c3","d4"]

    > [ k=>v | (k=>v) = sm; v mod 2];
    ["a"=>1,"c"=>3,"e"=>5]

    > { {k;v} |  (k=>v) = sm; v mod 2};
    {"a","c","e";1,3,5}

The functional programming operations work directly on the underlying
data structure.

    > let ints = 0..10000;

    stats -m
    > filter (==99) ints;
    [99]
    0s, 6 cells



File: pure-stlmap.info,  Node: Comparison,  Next: Set Algorithms,  Prev: Functional Programming<2>,  Up: Container Operations

8.7 Comparison
==============

Two associative containers of the same type are considered to be equal
if they contain the same number of elements and if each pair of their
corresponding elements are equal. Two elements are equal if their keys
are equivalent and, if the container is a stlmap, stlmap or stlhmap,
the values associated with equal keys are equal (using the container's
value-equal function).

 -- Function: stl::map_equal rng1 rng2

 -- Function: rng1 == rng2
 -- Function: rng1 ~= rng2
     Test `rng1' and `rng2' for equality or nonequality where `rng1' and
     `rng2' are ranges defined over containers of the same type.

  You need to be careful when using these operators. E.g.,

    > members ss;
    ["a","b","c","d","e"]

    > let xx = stlset ss;

    > xx == ss;
    1

    > (xx,"a","c") == (ss,"a","c");  // oops!
    0

The second comparison was intended to compare identical ranges and
return true. It failed to do so because (==) is defined in the Prelude
to compare tuples element by element, long before it is defined in the
stlmap module to compare ranges. The tuple operation take precedence
and determines that the tuples are not equal because `xx' and `ss' are
different (pointers) for purposes of this comparison. To avoid this
issue when using ranges, you can use the *note stl map_equal: 6b.
function.

     > map_equal (xx,"a","c") (ss,"a","c"); 1

  The other comparison operators `(<)', `(<=)', `(>)' and `(>=)' are
provided only for the ordered containers (stlmap, stlset, stlmmap and
stlmset). These operators reflect lexicographical comparisons of keys
and, then if the keys are equal, lexicographical comparisons of values.
I.e., this is not set inclusion - order matters. Accordingly, these
comparison operators are not defined for a stlhmap or stlhset.

 -- Function: rng1 < rng2
     Traverse the ranges comparing pairs of elements e1 and e2. If e1
     is less than e2, stop and return true; if e2 is less than e1 then
     stop and return false. If rng1 is exhausted but rng2 is not,
     return true, else return false.  The two ranges must be defined on
     ordered associative containers of the same type.

 -- Function: rng1 > rng2
 -- Function: rng1 <= rng2
 -- Function: rng1 >= rng2
     The these three operators are the same as `rng2' < `rng1',
     ~(`rng1'>"rng2`) and ~(`rng1``<``rng2') respectively.

  You also have to be careful when using equivalence and comparison
operators with stlmmaps because elements with the same key and
different values are not necessarily ordered by values.

    > let smm2 = stlmmap ["a"=>1,"b"=>2,"c"=>32,"c"=>31,"d"=>4];

    > members smm;
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4]

    > members smm2;
    ["a"=>1,"b"=>2,"c"=>32,"c"=>31,"d"=>4]

    > smm == smm2; // probably not what you want
    0

These operations do not make much sense for a stlmmap unless elements
with equivalent keys are stored by value, in the order enforced by the
stlmmap's value-comp function. In this regard it is worth noting that,
depending on your implementation, the *note insert: 23. function may or
may not preserve the order of insertion of elements with equivalent
keys (C++11 does preserve the order).


File: pure-stlmap.info,  Node: Set Algorithms,  Next: Direct C Calls,  Prev: Comparison,  Up: Container Operations

8.8 Set Algorithms
==================

pure-stlmap provides wrappers for the STL set algorithms that apply to
ranges defined on the four ordered associative containers (stlmap,
stlset, stlmmap and stlmset). These algorithms are very efficient, with
linear time complexity, but they do require that the elements of the
two ranges be ordered. Accordingly, the set algorithms are not
applicable to stlhmap or stlhset. Also, when dealing with stlmmaps,
care must be taken to ensure that items with the equivalent keys are
ordered by their values.

 -- Function: stl::map_merge rng1 rng2
     Constructs a new ordered container from `rng1' and then insert the
     elments of `rng2' into the new container and return it. `rng1' and
     `rng2' must be defined on the same type of ordered container.

 -- Function: stl::map_union rng1 rng2
 -- Function: stl::map_difference rng1 rng2
 -- Function: stl::map_intersection rng1 rng2
 -- Function: stl::map_symmetric_difference rng1 rng2
 -- Function: stl::map_includes rng1 rng2
     Returns a new ordered associative container of the same type as
     the ordered containers underlying `rng1' and `rng2'. If the ranges
     are defined over a stlmap or stlmmap elements of `rng1' have
     priority over the elments of `rng2'. Uses `rng1''s key-less-than,
     value-less-than and value-equal functions.

  pure-stlmap's set functions do not necessarily produce the same
results as their Pure standard library counterparts. In particular,
when applied to multi-keyed contaners, *note stl map_union: 3f.
Produces the multiset union of its arguments while (+) in the Pure
standard library produces the multiset sum. If you want the multiset
sum of a stlmmap or stlhmap, use *note stl map_merge: 73. Also, in
pure-stlmap, as in the STL, the left hand map or set has priority of
elements while in the Pure standard library the right hand set has
priority of elements. This can make a difference when applying set
operations to a pair of stlmaps or stlmmaps. E.g.,

    > let smm1 = stlmmap ["a"=>1,"b"=>2,"c"=>31,"c"=>32];
    > let smm2 = stlmmap ["c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5];

    > members $ map_merge smm1 smm2; // three "c"=>32
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5]

    > members $ map_union smm1 smm2;  // two "c"=>32
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5]

    > let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>31];
    > let sm2 = stlmap ["c"=>32,"d"=>4,"e"=>5];

    > members $ map_union sm1 sm2; // "c"=>31 from sm1, not "c"=>32 from sm2
    ["a"=>1,"b"=>2,"c"=>31,"d"=>4,"e"=>5]

    > members $ map_intersection sm1 sm2; // "c"=>31 from sm1
    ["c"=>31]



File: pure-stlmap.info,  Node: Direct C Calls,  Prev: Set Algorithms,  Up: Container Operations

8.9 Direct C Calls
==================

It is common to encounter code that (a) tests if a key is stored in a
container using *note member: 27. and (b) in the case of maps, retreives
the value or values associated with the key using (!) and/or (c)
changes the value or values using *note replace: 24. Depending on what
modules have been loaded, these functions may be heavily overloaded
which can cause a small delay when the functions are called. To avoid
this, pure-stlmap exposes the corresponding C functions so that they
can be called directly. The C functions have the same name as the
overloaded functions except for a prefix. E.g.,

 -- Function: stl::sm_member sm key
 -- Function: stl::sm_get sm key
 -- Function: stl::sm_put sm key val
     The first two functions are the direct C call equivalents of
     (*note member: 27. `sm' `key') and (`sm!key'). The third is like
     (*note replace: 24. `sm' `key' `val') except that it will insert
     (key=>val) if key is not already stored in `sm'. Here, `sm' is a
     stlmap or a stlset (except that sm_put is not defined for stlsets).

 -- Function: stl::shm_member shm key
 -- Function: stl::shm_get shm key
 -- Function: stl::shm_put shm key val
     The first two functions are the direct C call equivalents of
     (*note member: 27. `shm' `key') and (`shm!key'). The third is like
     (*note replace: 24. `shm' `key' `val') except that it will insert
     (key=>val) if key is not already stored in `shm'. Here, `shm' is a
     stlhmap or a stlhset (except that shm_put is not defined for
     stlhsets).

 -- Function: stl::smm_member smm key
 -- Function: stl::smm_get smm key
 -- Function: stl::smm_put smm key vals
     The first two functions are the direct C call equivalents of
     (*note member: 27. `smm' `key') and (`smm!key'). The third is like
     (*note replace: 24. `smm' `key' `val') except that it will insert
     (key=>val1, key=>val2, ...) if key is not already stored in `smm'.
     Here, `smm' is a stlmmap or a stlmset (except that smm_put is not
     defined for stlmsets).


File: pure-stlmap.info,  Node: Iterators<2>,  Next: Backward Compatibilty,  Prev: Container Operations,  Up: Top

9 Iterators
***********

This section provides a quick overview of pure-stlmap's "iterator-based"
interface.

* Menu:

* Concepts: Concepts<2>.
* Exceptions::
* Functions::
* Examples: Examples<2>.


File: pure-stlmap.info,  Node: Concepts<2>,  Next: Exceptions,  Up: Iterators<2>

9.1 Concepts
============

Given a valid iterator you can access, modify or erase the element it
points to.

    > let sm1 = stlmap sm; members sm1;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];

    > let i = find sm1 "b";   // use find to get an iterator - like C++

    > get_elm i;
    "b"=>2

    > get_val i;
    2

    > put_val i 20;
    20

    > members sm1;
    ["a"=>1,"b"=>20,"c"=>3,"d"=>4,"e"=>5]

Please note that you can never modify an element's key, only its value.
If you want to change both key and value, you have to erase the element
and insert a new element.

    > erase (sm1,i) $$ insert sm1 ("b1"=>21);
    1

    > members sm1;
    ["a"=>1,"b1"=>21,"c"=>3,"d"=>4,"e"=>5]

Given two iterators, i and j, pointing into a ordered container oc, the
range (i,j), denotes oc's elements starting with "oc[i]", the element
pointed to by i, up to but not including oc[j]. In pure-stlmap, this
range is denoted by the tuple (i,j).

    > members sm;
    ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

    > let i = stl::find sm1 "b"; // get the iterator

    > let j = stl::find sm1 "e";

    > members (i,j);             // get the elements in the range
    ["b"=>2,"c"=>3,"d"=>4]

Perhaps it is worth mentioning that functions that act on ranges do not
care if the range is specified by a pair of iterators or by keys.

    > members ss;
    ["a","b","c","d","e"]

    > map (+21) (ss,"c",smend);
    ["x","y","z"]

    > let i = find ss "c";
    > let j = pastend ss;
    > map (+21) (i,j);
    ["x","y","z"]



File: pure-stlmap.info,  Node: Exceptions,  Next: Functions,  Prev: Concepts<2>,  Up: Iterators<2>

9.2 Exceptions
==============

In pure-stlmap functions that accept iterators throw a `bad_argument'
exception if called with an invalid iterator. An iterator remains valid
until the element it was pointing to has been erased. These functions
also attempt to throw bad argument exceptions for invalid usage that
would otherwise result in undefined behavior. An example of an invalid
use would be a range specified by iterators from different containers.
Here are some examples of iterator errors.

    > let i,j = find sm "a", find sm "d";

    > get_elm i, get_elm j;
    "a"=>1,"d"=>4

    > members (i,j);
    ["a"=>1,"b"=>2,"c"=>3]

    > catch id $ members (j,i); // j and i transposed, C++ would segfault
    bad_argument

    > erase (sm,"b");  // erase "b"=>2, leaving i and j valid
    1

    > get_elm i; // still valid
    "a"=>1

    > erase (sm,"a");  // erase "a"=>1 - invalidating i
    1

    > catch id $ get_elm i; // bad iterator exception
    bad_argument



File: pure-stlmap.info,  Node: Functions,  Next: Examples<2>,  Prev: Exceptions,  Up: Iterators<2>

9.3 Functions
=============

In this section "acon" always denotes one of the containers that
supports interators (stlmap, stlset, stlmmap and stlmset).

 -- Function: stl::iterator i
     Returns a new iterator that points to the same element as `i'.

 -- Function: stl::begin acon
 -- Function: stl::pastend acon
     Returns `acon''s begin or past-end iterator.

 -- Function: stl::find acon k
     Creates a new iterator that points to an element in `acon' with key
     equivalent to `k' (if any) or `acon''s past-end iterator if no such
     element exists.

 -- Function: stl::find_with_default map k
     Returns an iterator pointing to the element in `map', a stlmap,
     with key equivalent to `k'. If no such element existed before the
     call, one is created and inserted using `k' and `map''s default
     value. This function is pure-stlmap's version of C++'s [] operator
     for associative containers.

 -- Function: stl::insert_elm acon elm
     Attempts to insert `elm' into `acon'. (If `acon' is a stlmap or
     stlmmap, then elm must be a key value pair, (k=>v)). If acon is a
     stlmap or stlset (i.e., with unique keys) *note insert_elm: 8a.
     returns a pair, the first of which is an iterator pointing to the
     element with key k that was just inserted (or the pre-existing
     element that blocked the insertion). The second element in the
     pair is a boolean value that is true if a new element was
     inserted. In contrast, if `acon' is a multi-keyed container
     (stlmmap or stlmset) the insert will always be successful and
     *note insert_elm: 8a. returns an iterator pointing to the element
     with key k that was just inserted, instead of an (iterator,
     boolean) tuple.

 -- Function: stl::insert_elm acon (elm,i)
     This is the same as the previous function except that (a) `i' is
     passed in as a hint to where the new element should be inserted
     and (b) a single iterator is returned rather than a
     iterator,boolean pair. If the new element is inserted just after
     `i', the insertion can have constant time complexity.

 -- Function: stl::l_bound acon k
     Return a new iterator that points to the first element in `acon', a
     stlmap, stlset, stlmmap or stlmset, that is not less than `k', or
     `acon''s past-end iterator if none exists.

 -- Function: stl::u_bound acon k
     Return a new iterator that points to the first element in `acon', a
     stlmap, stlset, stlmmap or stlmset, that is greater than `k', or
     `acon''s past-end iterator if none exists.

 -- Function: stl::lu_bounds acon k
     Return the pair l_bound `acon' `k', u_bound `acon' `k'.

  E.g.,

    > let ok, smx, f, l = stl::range_info (sm1,"b","e");

    > ok, smx === sm1, stl::members (f,l);
    1,1,["b"=>2,"c"=>3,"d"=>4]


 -- Function: stl::inc i
 -- Function: stl::dec i
 -- Function: stl::move i n::int
     Move the iterator `i' forward one, back one or forward `n' elements
     respectively, where n can be negative.  The iterator is mutated by
     these operations, provided the move is successful. An attempt to
     move to a position before the first element's position causes an
     `out_of_bounds' exception. Moves past the last element return the
     past-end iterator for the container that `i' is defined on.

 -- Function: stl::get_elm i
 -- Function: stl::get_key i
 -- Function: stl::get_val i
     Return the element pointed to by the iterator `i', or the
     element's key or value. For maps the element is returned as a
     key=>value hash rocket pair. For sets, get_elem, get_key and
     get_val all return the element (which is the same as its key).

 -- Function: stl::put_val i newvalue
     Change the value of the element pointed to by the iterator `i' to
     `newvalue'. The element's key cannot be changed. The iterator must
     point into a stlmap or stlmmap.

 -- Function: stl::beginp i
 -- Function: stl::pastendp i
     Returns true if the iterator `i' is the begin iterator or pastend
     iterator of the container it is defined on.

 -- Function: stl::get_info i
     Returns a tuple (is_valid,acon,key,val) where is_valid is true if
     the iterator `i' is valid or false if not, acon is the container
     that i is defined on, and key, val are the key and value of the
     element `i' points to, if any. If `i' is the past-end iterator,
     key and val are set to *note stl smend: 21. and `[]', respectively.

 -- Function: i == j
     Returns true if the iterators `i' and `j' point to the same
     element.

 -- Function: erase (acon,i)
 -- Function: erase (acon,i,j)
     Erases the element pointed to by `i' or the elements in the range
     (`i', `j'). Both `i' and `j' must be iterators defined on `acon'
     (or a `bad_argument' exception will be thrown).


File: pure-stlmap.info,  Node: Examples<2>,  Prev: Functions,  Up: Iterators<2>

9.4 Examples
============

Here are some examples using iterators.

    > let b,e = begin smm, pastend smm;

    > members (b,e);
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

    > let i,j = lu_bounds smm "c";

    > members (b,i);
    ["a"=>1,"b"=>2]

    > members (i,j);
    ["c"=>31,"c"=>32]

    > members (j,e);
    ["d"=>4,"e"=>5]

    > get_elm i;
    "c"=>31

    > get_elm (inc i);
    "c"=>32

    > put_val i 132;
    132

    > map (\(k=>_)->k=>ord k) (b,i);
    ["a"=>97,"b"=>98,"c"=>99]

    > let is_set, smm1, k, v = get_info i; is_set, members smm1, k, v;
    1,["a"=>1,"b"=>2,"c"=>31,"c"=>132,"d"=>4,"e"=>5],"c",132

    > get_elm (dec j);
    "c"=>132

    > inc j $$ inc j $$ get_elm j;
    "e"=>5

    > inc j $$ endp j;
    1



File: pure-stlmap.info,  Node: Backward Compatibilty,  Next: Index,  Prev: Iterators<2>,  Up: Top

10 Backward Compatibilty
************************

This section documents changes in pure-stlmap that might have introduced
backward compatiblity issues.

* Menu:

* pure-stlmap-0 2::


File: pure-stlmap.info,  Node: pure-stlmap-0 2,  Up: Backward Compatibilty

10.1 pure-stlmap-0.2
====================

Version 0.2 made no changes to the user interface.


File: pure-stlmap.info,  Node: Index,  Prev: Backward Compatibilty,  Up: Top

Index
*****

 [index ]
* Menu:

* # prefix function:                     Information.         (line  12)
* < infix function:                      Comparison.          (line  51)
* <= infix function:                     Comparison.          (line  58)
* == infix function <1>:                 Functions.           (line 105)
* == infix function:                     Comparison.          (line  15)
* > infix function:                      Comparison.          (line  58)
* >= infix function:                     Comparison.          (line  58)
* catmap function:                       Functional Programming<2>.
                                                              (line  36)
* colcatmap function:                    Functional Programming<2>.
                                                              (line  36)
* colmap function:                       Functional Programming<2>.
                                                              (line  36)
* do function:                           Functional Programming<2>.
                                                              (line   9)
* emptystlhmap function:                 Container Construction.
                                                              (line  40)
* emptystlhset function:                 Container Construction.
                                                              (line  40)
* emptystlmap function:                  Container Construction.
                                                              (line  33)
* emptystlmmap function:                 Container Construction.
                                                              (line  33)
* emptystlmset function:                 Container Construction.
                                                              (line  33)
* emptystlset function:                  Container Construction.
                                                              (line  33)
* erase function <1>:                    Functions.           (line 109)
* erase function:                        Modification.        (line 140)
* filter function:                       Functional Programming<2>.
                                                              (line   9)
* foldl function:                        Functional Programming<2>.
                                                              (line   9)
* foldl1 function:                       Functional Programming<2>.
                                                              (line   9)
* foldr function:                        Functional Programming<2>.
                                                              (line   9)
* foldr1 function:                       Functional Programming<2>.
                                                              (line   9)
* infix function:                        Accessing Elements.  (line  14)
* insert function:                       Modification.        (line  41)
* insert_or_replace function:            Modification.        (line  59)
* keys function:                         Conversions<2>.      (line  13)
* listmap function:                      Functional Programming<2>.
                                                              (line  36)
* map function:                          Functional Programming<2>.
                                                              (line   9)
* member function:                       Accessing Elements.  (line  10)
* members function:                      Conversions<2>.      (line  10)
* mkstlmap function:                     Container Construction.
                                                              (line  11)
* mkstlmmap function:                    Container Construction.
                                                              (line  11)
* mkstlmset function:                    Container Construction.
                                                              (line  20)
* mkstlset function:                     Container Construction.
                                                              (line  20)
* replace function:                      Modification.        (line  66)
* replace_with function:                 Modification.        (line 101)
* rowcatmap function:                    Functional Programming<2>.
                                                              (line  36)
* rowmap function:                       Functional Programming<2>.
                                                              (line  36)
* stl begin function:                    Functions.           (line  12)
* stl beginp function:                   Functions.           (line  93)
* stl bounds function:                   Information.         (line  27)
* stl bucket_size function:              Information.         (line  58)
* stl container_info function:           Information.         (line  48)
* stl count function:                    Information.         (line  23)
* stl dec function:                      Functions.           (line  69)
* stl distance function:                 Information.         (line  18)
* stl empty function:                    Information.         (line  15)
* stl find function:                     Functions.           (line  16)
* stl find_with_default function:        Functions.           (line  21)
* stl get_elm function:                  Functions.           (line  80)
* stl get_info function:                 Functions.           (line  98)
* stl get_key function:                  Functions.           (line  80)
* stl get_val function:                  Functions.           (line  80)
* stl hmap_reserve function:             Information.         (line  62)
* stl inc function:                      Functions.           (line  69)
* stl insert_elm function:               Functions.           (line  28)
* stl iterator function:                 Functions.           (line   9)
* stl l_bound function:                  Functions.           (line  49)
* stl lu_bounds function:                Functions.           (line  59)
* stl map_difference function:           Set Algorithms.      (line  20)
* stl map_equal function:                Comparison.          (line  13)
* stl map_includes function:             Set Algorithms.      (line  20)
* stl map_intersection function:         Set Algorithms.      (line  20)
* stl map_merge function:                Set Algorithms.      (line  15)
* stl map_symmetric_difference function: Set Algorithms.      (line  20)
* stl map_union function:                Set Algorithms.      (line  20)
* stl move function:                     Functions.           (line  69)
* stl next_key function:                 Accessing Elements.  (line  43)
* stl pastend function:                  Functions.           (line  12)
* stl pastendp function:                 Functions.           (line  93)
* stl prev_key function:                 Accessing Elements.  (line  43)
* stl put_val function:                  Functions.           (line  88)
* stl shm_get function:                  Direct C Calls.      (line  25)
* stl shm_member function:               Direct C Calls.      (line  25)
* stl shm_put function:                  Direct C Calls.      (line  25)
* stl sm_get function:                   Direct C Calls.      (line  16)
* stl sm_member function:                Direct C Calls.      (line  16)
* stl sm_put function:                   Direct C Calls.      (line  16)
* stl smbeg constructor:                 Modules.             (line  12)
* stl smend constructor:                 Modules.             (line  12)
* stl smm_get function:                  Direct C Calls.      (line  35)
* stl smm_member function:               Direct C Calls.      (line  35)
* stl smm_put function:                  Direct C Calls.      (line  35)
* stl swap function:                     Modification.        (line 172)
* stl u_bound function:                  Functions.           (line  54)
* stl vector function:                   Conversions<2>.      (line  29)
* stlhmap function:                      Container Construction.
                                                              (line  50)
* stlhmap module:                        Top.                 (line   6)
* stlhmap type:                          The stlhmap Module.  (line  21)
* stlhset function:                      Container Construction.
                                                              (line  50)
* stlhset type:                          The stlhmap Module.  (line  21)
* stlmap function:                       Container Construction.
                                                              (line  50)
* stlmap module:                         Top.                 (line   6)
* stlmap type:                           The stlmap Module.   (line  20)
* stlmap_iter type:                      The stlmap Module.   (line  23)
* stlmap_rng type:                       The stlmap Module.   (line  25)
* stlmmap function:                      Container Construction.
                                                              (line  50)
* stlmmap module:                        Top.                 (line   6)
* stlmmap type:                          The stlmmap Module.  (line  21)
* stlmmap_iter type:                     The stlmmap Module.  (line  24)
* stlmmap_rng type:                      The stlmmap Module.  (line  26)
* stlmset function:                      Container Construction.
                                                              (line  50)
* stlmset type:                          The stlmmap Module.  (line  21)
* stlset function:                       Container Construction.
                                                              (line  50)
* stlset type:                           The stlmap Module.   (line  20)
* stlvec function:                       Conversions<2>.      (line  33)
* stream function:                       Conversions<2>.      (line  39)
* vals function:                         Conversions<2>.      (line  13)
* ~= infix function:                     Comparison.          (line  15)



Tag Table:
Node: Top253
Ref: 0344
Ref: module-stlmmap344
Ref: 1344
Ref: module-stlhmap344
Ref: 2658
Ref: pure658
Ref: 3658
Ref: c-standard-library658
Node: Copying1710
Ref: copying1795
Ref: 41795
Ref: module-stlmap1795
Ref: 51795
Ref: 61795
Node: Introduction2183
Ref: introduction2277
Ref: 72277
Node: Supported Containers2578
Ref: supported containers2670
Ref: 82670
Ref: supported-containers2670
Node: Interface3274
Ref: interface3366
Ref: 93366
Node: Installation5309
Ref: installation5404
Ref: e5404
Node: Examples5699
Ref: examples5793
Ref: f5793
Node: Quick Start6492
Ref: quick start6582
Ref: 106582
Ref: quick-start6582
Node: Example Containers7041
Ref: example containers7133
Ref: 117133
Ref: example-containers7133
Node: Constructors8401
Ref: constructors8508
Ref: 128508
Node: Ranges9403
Ref: ranges9524
Ref: 1f9524
Node: Inserting and Replacing Elements10927
Ref: inserting and replacing elements11042
Ref: 2211042
Ref: inserting-and-replacing-elements11042
Node: Access12556
Ref: access12681
Ref: 2612681
Node: Erasing Elements13892
Ref: erasing elements13996
Ref: 2813996
Ref: erasing-elements13996
Node: Conversions15184
Ref: conversions15304
Ref: 2a15304
Node: Functional Programming16556
Ref: functional programming16651
Ref: 2f16651
Ref: functional-programming16651
Node: Concepts17406
Ref: concepts17495
Ref: 3217495
Node: Containers and Elements18058
Ref: containers and elements18149
Ref: 3318149
Ref: containers-and-elements18149
Node: Ranges<2>21117
Ref: ranges<2>21226
Ref: 3421226
Ref: id121226
Node: Iterators22478
Ref: iterators22593
Ref: 3522593
Node: Selecting Elements Using Keys23173
Ref: selecting elements using keys23297
Ref: 3623297
Ref: selecting-elements-using-keys23297
Node: C++ Implementation24829
Ref: c++ implementation24935
Ref: 3724935
Ref: c-implementation24935
Ref: 3825730
Ref: c-standard-library-documentation25730
Node: Modules25730
Ref: modules25828
Ref: 3925828
Ref: 2026095
Ref: stl smbeg/stlmap26095
Ref: 2126123
Ref: stl smend/stlmap26123
Node: The stlhmap Module26678
Ref: the stlhmap module26771
Ref: 3a26771
Ref: the-stlhmap-module26771
Ref: 3c27455
Ref: stlhmap/type27455
Ref: 3d27473
Ref: stlhset/type27473
Node: The stlmap Module27660
Ref: the stlmap module27780
Ref: 3e27780
Ref: the-stlmap-module27780
Ref: 4028366
Ref: stlmap/type28366
Ref: 4128383
Ref: stlset/type28383
Ref: 4228401
Ref: stlmap_iter/type28401
Ref: 4328424
Ref: stlmap_rng/type28424
Node: The stlmmap Module28744
Ref: the stlmmap module28837
Ref: 4428837
Ref: the-stlmmap-module28837
Ref: 4529533
Ref: stlmmap/type29533
Ref: 4629551
Ref: stlmset/type29551
Ref: 4729570
Ref: stlmmap_iter/type29570
Ref: 4829594
Ref: stlmmap_rng/type29594
Node: Container Operations29921
Ref: container operations30023
Ref: 4930023
Ref: container-operations30023
Node: Container Construction30668
Ref: container construction30772
Ref: 4a30772
Ref: container-construction30772
Ref: 4b31061
Ref: mkstlmap/stlmap31061
Ref: 4c31103
Ref: mkstlmmap/stlmap31103
Ref: 4d31513
Ref: mkstlset/stlmap31513
Ref: 4e31540
Ref: mkstlmset/stlmap31540
Ref: 1332046
Ref: emptystlmap/stlmap32046
Ref: 1532072
Ref: emptystlmmap/stlmap32072
Ref: 1432099
Ref: emptystlset/stlmap32099
Ref: 1632125
Ref: emptystlmset/stlmap32125
Ref: 1732277
Ref: emptystlhmap/stlmap32277
Ref: 1832304
Ref: emptystlhset/stlmap32304
Ref: 1932713
Ref: stlmap/stlmap32713
Ref: 1b32738
Ref: stlmmap/stlmap32738
Ref: 1a32764
Ref: stlset/stlmap32764
Ref: 1c32789
Ref: stlmset/stlmap32789
Ref: 1d32815
Ref: stlhmap/stlmap32815
Ref: 1e32841
Ref: stlhset/stlmap32841
Node: Information33417
Ref: information33542
Ref: 4f33542
Ref: 5033915
Ref: #/stlmap33915
Ref: 5133983
Ref: stl empty/stlmap33983
Ref: 5234063
Ref: stl distance/stlmap34063
Ref: 5334250
Ref: stl count/stlmap34250
Ref: 5434402
Ref: stl bounds/stlmap34402
Ref: 5535103
Ref: stl container_info/stlmap35103
Ref: 5635591
Ref: stl bucket_size/stlmap35591
Ref: 5735748
Ref: stl hmap_reserve/stlmap35748
Node: Modification35967
Ref: modification36088
Ref: 5836088
Ref: 2337469
Ref: insert/stlmap37469
Ref: 2538552
Ref: insert_or_replace/stlmap38552
Ref: 2438937
Ref: replace/stlmap38937
Ref: 5940066
Ref: replace_with/stlmap40066
Ref: 2941145
Ref: erase/stlmap41145
Ref: 5a42042
Ref: stl swap/stlmap42042
Node: Accessing Elements42261
Ref: accessing elements42385
Ref: 5b42385
Ref: accessing-elements42385
Ref: 2742579
Ref: member/stlmap42579
Ref: 5c42743
Ref: !/stlmap42743
Ref: 5d43688
Ref: stl next_key/stlmap43688
Ref: 5e43723
Ref: stl prev_key/stlmap43723
Node: Conversions<2>46903
Ref: conversions<2>47040
Ref: 5f47040
Ref: id247040
Ref: 2b47267
Ref: members/stlmap47267
Ref: 6047350
Ref: keys/stlmap47350
Ref: 6147373
Ref: vals/stlmap47373
Ref: 2c47808
Ref: stl vector/stlmap47808
Ref: 2d47906
Ref: stlvec/stlmap47906
Ref: 2e48108
Ref: stream/stlmap48108
Node: Functional Programming<2>48431
Ref: functional programming<2>48560
Ref: 6248560
Ref: id348560
Ref: d48747
Ref: do/stlmap48747
Ref: a48772
Ref: map/stlmap48772
Ref: c48798
Ref: filter/stlmap48798
Ref: b48828
Ref: foldl/stlmap48828
Ref: 3148858
Ref: foldl1/stlmap48858
Ref: 6348887
Ref: foldr/stlmap48887
Ref: 6448917
Ref: foldr1/stlmap48917
Ref: 6549545
Ref: listmap/stlmap49545
Ref: 3049576
Ref: catmap/stlmap49576
Ref: 6649605
Ref: rowmap/stlmap49605
Ref: 6749634
Ref: rowcatmap/stlmap49634
Ref: 6849666
Ref: colmap/stlmap49666
Ref: 6949695
Ref: colcatmap/stlmap49695
Node: Comparison50442
Ref: comparison50571
Ref: 6a50571
Ref: 6b50978
Ref: stl map_equal/stlmap50978
Ref: 6c51018
Ref: ==/stlmap51018
Ref: 6d51045
Ref: ~=/stlmap51045
Ref: 6e52373
Ref: </stlmap52373
Ref: 6f52733
Ref: >/stlmap52733
Ref: 7052759
Ref: <=/stlmap52759
Ref: 7152786
Ref: >=/stlmap52786
Node: Set Algorithms53765
Ref: set algorithms53883
Ref: 7253883
Ref: set-algorithms53883
Ref: 7354427
Ref: stl map_merge/stlmap54427
Ref: 3f54678
Ref: stl map_union/stlmap54678
Ref: 7454717
Ref: stl map_difference/stlmap54717
Ref: 3b54761
Ref: stl map_intersection/stlmap54761
Ref: 7554807
Ref: stl map_symmetric_difference/stlmap54807
Ref: 7654861
Ref: stl map_includes/stlmap54861
Node: Direct C Calls56555
Ref: direct c calls56654
Ref: 7756654
Ref: direct-c-calls56654
Ref: 7857294
Ref: stl sm_member/stlmap57294
Ref: 7957330
Ref: stl sm_get/stlmap57330
Ref: 7a57363
Ref: stl sm_put/stlmap57363
Ref: 7b57750
Ref: stl shm_member/stlmap57750
Ref: 7c57788
Ref: stl shm_get/stlmap57788
Ref: 7d57823
Ref: stl shm_put/stlmap57823
Ref: 7e58226
Ref: stl smm_member/stlmap58226
Ref: 7f58264
Ref: stl smm_get/stlmap58264
Ref: 8058299
Ref: stl smm_put/stlmap58299
Node: Iterators<2>58720
Ref: iterators<2>58836
Ref: 8158836
Ref: id458836
Node: Concepts<2>59035
Ref: concepts<2>59119
Ref: 8259119
Ref: id559119
Node: Exceptions60636
Ref: exceptions60738
Ref: 8360738
Node: Functions61716
Ref: functions61818
Ref: 8461818
Ref: 8561972
Ref: stl iterator/stlmap61972
Ref: 8662071
Ref: stl begin/stlmap62071
Ref: 8762101
Ref: stl pastend/stlmap62101
Ref: 8862184
Ref: stl find/stlmap62184
Ref: 8962383
Ref: stl find_with_default/stlmap62383
Ref: 8a62741
Ref: stl insert_elm/stlmap62741
Ref: 8b63918
Ref: stl l_bound/stlmap63918
Ref: 8c64145
Ref: stl u_bound/stlmap64145
Ref: 8d64371
Ref: stl lu_bounds/stlmap64371
Ref: 8e64611
Ref: stl inc/stlmap64611
Ref: 8f64637
Ref: stl dec/stlmap64637
Ref: 9064662
Ref: stl move/stlmap64662
Ref: 9165117
Ref: stl get_elm/stlmap65117
Ref: 9265146
Ref: stl get_key/stlmap65146
Ref: 9365175
Ref: stl get_val/stlmap65175
Ref: 9465469
Ref: stl put_val65469
Ref: 9565688
Ref: stl beginp/stlmap65688
Ref: 9665716
Ref: stl pastendp/stlmap65716
Ref: 9765867
Ref: stl get_info/stlmap65867
Node: Examples<2>66606
Ref: examples<2>66689
Ref: 9866689
Ref: id666689
Node: Backward Compatibilty67446
Ref: backward compatibilty67547
Ref: 9967547
Ref: backward-compatibilty67547
Node: pure-stlmap-0 267732
Ref: 9a67810
Ref: pure-stlmap-0-267810
Node: Index67905
Ref: index67985

End Tag Table


Local Variables:
coding: utf-8
End:
