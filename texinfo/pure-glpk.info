This is pure-glpk.info, produced by makeinfo version 4.12 from
pure-glpk.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-glpk: (pure-glpk.info).    Pure-GLPK - GLPK interface for the Pure programming language
END-INFO-DIR-ENTRY


File: pure-glpk.info,  Node: Top,  Next: Installation,  Up: (dir)

pure-glpk
*********

  Version 0.1, January 18, 2011

  Jiri Spitz <<jiri.spitz@bluetone.cz>>

  This module provides a feature complete GLPK interface for the Pure
programming language, which lets you use all capabilities of the GNU
Linear Programming Kit (GLPK) directly from Pure.

  GLPK (see <http://www.gnu.org/software/glpk>) contains an efficient
simplex LP solver, a simplex LP solver in exact arithmetics, an
interior-point solver, a branch-and-cut solver for mixed integer
programming and some specialized algorithms for net/grid problems.
Using this interface you can build, modify and solve the problem,
retrieve the solution, load and save the problem and solution data in
standard formats and use any of advanced GLPK features.

  The interface uses native Pure data types - lists and tuples - so
that you need not perform any data conversions to/from GLPK internal
data structures.

  To make this module work, you must have a GLPK installation on your
system, the version 4.38 is required.

* Menu:

* Installation::
* Error Handling::
* Further Information and Examples::
* Interface description::
* Descriptions of interface functions::
* Index::

 --- The Detailed Node Listing ---

Descriptions of interface functions

* Basic API routines::
* Utility API routines::
* Advanced API routines::
* Branch-and-cut API routines::
* Graph and network API routines::
* Miscellaneous routines::


File: pure-glpk.info,  Node: Installation,  Next: Error Handling,  Prev: Top,  Up: Top

1 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-glpk-0.1.tar.gz>.

  Run `make' to compile the module and `make install' (as root) to
install it in the Pure library directory. This requires GNU make, and
of course you need to have Pure installed.

  The default make options suppose that GLPK was configured with the
following options: `--enable-dl --enable-odbc --enable-mysql --with-gmp
--with-zlib'

  Using the given options the depndencies are:

   - GNU Multiprecision Library (GMP) - serves for the exact simplex
     solver.  When disabled, the exact solver still works but it is
     much slower.

   - ODBC library - serves for reading data directly from database
     tables within the GNU MathProg language translator through the
     ODBC interface.

   - zlib compression library - enables reading and writing gzip
     compressed problem and solution files.

   - MySQL client library - serves for reading data directly from MySQL
     tables within the GNU MathProg language translator.

   - ltdl dlopen library - must be enabled together with any of ODBC,
     zlib or MySQL.

  `make' tries to guess your Pure installation directory and
platform-specific setup. If it gets this wrong, you can set some
variables manually. In particular, `make install prefix=/usr' sets the
installation prefix, and `make PIC=-fPIC' or some similar flag might be
needed for compilation on 64 bit systems. The variable `ODBCLIB'
specifies the ODBC library to be linked with. The default value is
`ODBCLIB=-lodbc'. Please see the Makefile for details.


File: pure-glpk.info,  Node: Error Handling,  Next: Further Information and Examples,  Prev: Installation,  Up: Top

2 Error Handling
****************

When an error condition occurs, the GLPK library itself prints an error
mesage and terminates the application. This behaviour is not pleasant
when working within an interpreter. Therefore, the Pure - GLPK bindings
catches at least the most common errors like indices out of bounds. On
such an error an appropriate message is returned to the interpreter.
The less common errors are still trapped by the GLPK library.

  When one of the most common errors occurs, an error term of the form
`glp::error message' will be returned, which specifies what kind of
error happend. For instance, an index out of boundsd will cause a
report like the following:

  `glp::error "[Pure GLPK error] row index out of bounds"'

  You can check for such return values and take some appropriate
action. By redefining `glp::error' accordingly, you can also have it
generate exceptions or print an error message. For instance:

  `glp::error message = fprintf stderr "%s\n" message $$ ();'

  *NOTE_* When redefining `glp::error' in this manner, you should be
aware that the return value of `glp::error' is what will be returned by
the other operations of this module in case of an error condition.
These return values are checked by other functions. Thus the return
value should still indicate that an error has happened, and not be
something that might be interpreted as a legal return value, such as an
integer or a nonempty tuple. It is usually safe to have `glp::error'
return an empty tuple or throw an exception, but other types of return
values should be avoided.

  *IMPORTANT:* It is really good to define a `glp::error' function,
otherwise the errors might remain unnoticed.


File: pure-glpk.info,  Node: Further Information and Examples,  Next: Interface description,  Prev: Error Handling,  Up: Top

3 Further Information and Examples
**********************************

For further details about the operations provided by this module please
see the GLPK Reference Manual. Sample scripts illustrating the usage of
the module can be found in the examples directory.


File: pure-glpk.info,  Node: Interface description,  Next: Descriptions of interface functions,  Prev: Further Information and Examples,  Up: Top

4 Interface description
***********************

Most GLPK functions and symbols live in the namespace `glp'. There are
a few functions and symbols in the namespace `lpx'. These functions and
symbols are likely to be removed and replaced by new ones in the future.

  In general, when you replace the `glp_' prefix from the GLPK
Reference Manual with the namespace specification `glp::' then you
receive the function name in this module. The same is valid for `lpx_'
and `lpx::'. The symbolic constants are converted into lower case in
this module, again obeying the same prefix rules.


File: pure-glpk.info,  Node: Descriptions of interface functions,  Next: Index,  Prev: Interface description,  Up: Top

5 Descriptions of interface functions
*************************************

* Menu:

* Basic API routines::
* Utility API routines::
* Advanced API routines::
* Branch-and-cut API routines::
* Graph and network API routines::
* Miscellaneous routines::


File: pure-glpk.info,  Node: Basic API routines,  Next: Utility API routines,  Up: Descriptions of interface functions

5.1 Basic API routines
======================

* Menu:

* Problem creating and modifying routines::
* Problem retrieving routines::
* Row and column searching routines::
* Problem scaling routines::
* LP basis constructing routines::
* Simplex method routines::
* Interior-point method routines::
* Mixed integer programming routines::
* Additional routines::


File: pure-glpk.info,  Node: Problem creating and modifying routines,  Next: Problem retrieving routines,  Up: Basic API routines

5.1.1 Problem creating and modifying routines
---------------------------------------------

* Menu:

* Create the GLPK problem object::
* Set the problem name::
* Set objective name::
* Set the objective direction::
* Add new rows to the problem::
* Add new columns to the problem::
* Set the row name::
* Set the column name::
* Set change row bounds::
* Set change column bounds::
* Set change objective coefficient or constant term::
* Load or replace matrix row::
* Load or replace matrix column::
* Load or replace the whole problem matrix::
* Check for duplicate elements in sparse matrix::
* Sort elements of the constraint matrix::
* Delete rows from the matrix::
* Delete columns from the matrix::
* Copy the whole content of the GLPK problem object to another one::
* Erase all data from the GLPK problem object::
* Delete the GLPK problem object::


File: pure-glpk.info,  Node: Create the GLPK problem object,  Next: Set the problem name,  Up: Problem creating and modifying routines

5.1.1.1 Create the GLPK problem object
......................................

*Synopsis*:

    glp::create_prob

*Parameters*:

     none

  *Returns*:

     pointer to the LP problem object

  *Example*:

    > let lp = glp::create_prob;
    > lp;
    #<pointer 0x9de7168>



File: pure-glpk.info,  Node: Set the problem name,  Next: Set objective name,  Prev: Create the GLPK problem object,  Up: Problem creating and modifying routines

5.1.1.2 Set the problem name
............................

*Synopsis*:

    glp::set_prob_name lp name

*Parameters*:

          lp: pointer to the LP problem object

          name: problem name

  *Returns*:

     `()'

  *Example*:

    > glp::set_prob_name lp "Testing problem";
    ()



File: pure-glpk.info,  Node: Set objective name,  Next: Set the objective direction,  Prev: Set the problem name,  Up: Problem creating and modifying routines

5.1.1.3 Set objective name
..........................

*Synopsis*:

    glp::set_obj_name lp name

*Parameters*:

          lp: pointer to the LP problem object

          name: objective name

  *Returns*:

     `()'

  *Example*:

    > glp::set_obj_name lp "Total costs";
    ()



File: pure-glpk.info,  Node: Set the objective direction,  Next: Add new rows to the problem,  Prev: Set objective name,  Up: Problem creating and modifying routines

5.1.1.4 Set the objective direction
...................................

*Synopsis*:

    glp::set_obj_dir lp direction

*Parameters*:

          lp: pointer to the LP problem object

          direction: one of the following:

               glp::min: minimize

               glp::max: maximize

  *Returns*:

     `()'

  *Example*:

    > glp::set_obj_dir lp glp::min;
    ()



File: pure-glpk.info,  Node: Add new rows to the problem,  Next: Add new columns to the problem,  Prev: Set the objective direction,  Up: Problem creating and modifying routines

5.1.1.5 Add new rows to the problem
...................................

*Synopsis*:

    glp::add_rows lp count

*Parameters*:

          lp: pointer to the LP problem object

          count: number of rows to add

  *Returns*:

     index of the first row added

  *Example*:

    > let first_added_row = glp_add_rows lp 3;
    > first_added_row;
    6



File: pure-glpk.info,  Node: Add new columns to the problem,  Next: Set the row name,  Prev: Add new rows to the problem,  Up: Problem creating and modifying routines

5.1.1.6 Add new columns to the problem
......................................

*Synopsis*:

    glp::add_cols lp count

*Parameters*:

          lp: pointer to the LP problem object

          count: number of columns to add

  *Returns*:

     index of the first column added

  *Example*:

    > let first_added_col = glp_add_cols lp 3;
    > first_added_col;
    5



File: pure-glpk.info,  Node: Set the row name,  Next: Set the column name,  Prev: Add new columns to the problem,  Up: Problem creating and modifying routines

5.1.1.7 Set the row name
........................

*Synopsis*:

    glp::set_row_name lp (rowindex, rowname)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          rowname: row name

  *Returns*:

     `()'

  *Example*:

    > glp::set_row_name lp (3, "The third row");
    ()



File: pure-glpk.info,  Node: Set the column name,  Next: Set change row bounds,  Prev: Set the row name,  Up: Problem creating and modifying routines

5.1.1.8 Set the column name
...........................

*Synopsis*:

    glp::set_col_name lp (colindex, colname)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          colname: column name

  *Returns*:

     `()'

  *Example*:

    > glp::set_col_name lp (3, "The third column");
    ()



File: pure-glpk.info,  Node: Set change row bounds,  Next: Set change column bounds,  Prev: Set the column name,  Up: Problem creating and modifying routines

5.1.1.9 Set (change) row bounds
...............................

*Synopsis*:

    glp::set_row_bnds lp (rowindex, rowtype, lowerbound, upperbound)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          rowtype: one of the following:

               glp::fr: free variable (both bounds are ignored)

               glp::lo: variable with lower bound (upper bound is
               ignored)

               glp::up: variable with upper bound (lower bound is
               ignored)

               glp::db: double bounded variable

               glp::fx: fixed variable (lower bound applies, upper
               bound is ignored)

          lowerbound: lower row bound

          upperbound: upper row bound

*Returns*:
     `()'

*Example*::
     `glp::set_row_bnds lp (3, glp::up, 0.0, 150.0);'


File: pure-glpk.info,  Node: Set change column bounds,  Next: Set change objective coefficient or constant term,  Prev: Set change row bounds,  Up: Problem creating and modifying routines

5.1.1.10 Set (change) column bounds
...................................

*Synopsis*:

    glp::set_col_bnds lp (colindex, coltype, lowerbound, upperbound)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          coltype: one of the following:

               glp::fr: free variable (both bounds are ignored)

               glp::lo: variable with lower bound (upper bound is
               ignored)

               glp::up: variable with upper bound (lower bound is
               ignored)

               glp::db: double bounded variable

               glp::fx: fixed variable (lower bound applies, upper
               bound is ignored)

          lowerbound: lower column bound

          upperbound: upper column bound

  *Returns*:

     `()'

  *Example*:

    > glp::set_col_bnds lp (3, glp::db, 100.0, 150.0);
    ()



File: pure-glpk.info,  Node: Set change objective coefficient or constant term,  Next: Load or replace matrix row,  Prev: Set change column bounds,  Up: Problem creating and modifying routines

5.1.1.11 Set (change) objective coefficient or constant term
............................................................

*Synopsis*:

    glp::set_obj_coef lp (colindex, coefficient)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index, zero index denotes the constant term
          (objective shift)

  *Returns*:

     `()'

  *Example*:

    > glp::set_obj_coef lp (3, 15.8);
    ()



File: pure-glpk.info,  Node: Load or replace matrix row,  Next: Load or replace matrix column,  Prev: Set change objective coefficient or constant term,  Up: Problem creating and modifying routines

5.1.1.12 Load or replace matrix row
...................................

*Synopsis*:

    glp::set_mat_row lp (rowindex, rowvector)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          rowvector: list of tuples (colindex, coefficient); only
          non-zero coefficients have to be specified, the order of
          column indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Example*:

    > glp::set_mat_row lp (3, [(1, 3.0), (4, 5.2)]);
    ()



File: pure-glpk.info,  Node: Load or replace matrix column,  Next: Load or replace the whole problem matrix,  Prev: Load or replace matrix row,  Up: Problem creating and modifying routines

5.1.1.13 Load or replace matrix column
......................................

*Synopsis*:

    glp::set_mat_col lp (colindex, colvector)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          colvector: list of tuples (rowindex, coefficient); only
          non-zero coefficients have to be specified, the order of row
          indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Example*:

    > glp::set_mat_col lp (2, [(4, 2.0), (2, 1.5)]);
    ()



File: pure-glpk.info,  Node: Load or replace the whole problem matrix,  Next: Check for duplicate elements in sparse matrix,  Prev: Load or replace matrix column,  Up: Problem creating and modifying routines

5.1.1.14 Load or replace the whole problem matrix
.................................................

*Synopsis*:

    glp::load_matrix lp matrix

*Parameters*:

          lp: pointer to the LP problem object

          matrix: list of tuples (rowindex, colindex, coefficient);
          only non-zero coefficients have to be specified, the order of
          indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Example*:

    > glp::load_matrix lp [(1, 3, 5.0), (2, 2, 3.5), (3, 1, -2.0), (3, 2, 1.0)];
    ()



File: pure-glpk.info,  Node: Check for duplicate elements in sparse matrix,  Next: Sort elements of the constraint matrix,  Prev: Load or replace the whole problem matrix,  Up: Problem creating and modifying routines

5.1.1.15 Check for duplicate elements in sparse matrix
......................................................

*Synopsis*:

    glp::check_dup numrows numcols indices

*Parameters*:

          numrows: number of rows

          numcols: number of columns

          indices: list of tuples (rowindex, colindex); indices of only
          non-zero coefficients have to be specified, the order of
          indices is not important

  *Returns*:

     returns one of the following:

               0: the matrix has no duplicate elements

               -k: rowindex or colindex of the k-th element in indices
               is out of range

               +k: the k-th element in indices is duplicate

  *Remark:*

     Notice, that `k' counts from 1, whereas list members are counted
     from 0.

  *Example*:

    > glp::check_dup 3 3  [(1, 3), (2, 2), (3, 1), (2, 2)];
    4



File: pure-glpk.info,  Node: Sort elements of the constraint matrix,  Next: Delete rows from the matrix,  Prev: Check for duplicate elements in sparse matrix,  Up: Problem creating and modifying routines

5.1.1.16 Sort elements of the constraint matrix
...............................................

*Synopsis*:

    glp::sort_matrix lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::sort_matrix lp;
    ()



File: pure-glpk.info,  Node: Delete rows from the matrix,  Next: Delete columns from the matrix,  Prev: Sort elements of the constraint matrix,  Up: Problem creating and modifying routines

5.1.1.17 Delete rows from the matrix
....................................

*Synopsis*:

    glp::del_rows lp rows

*Parameters*:

          lp: pointer to the LP problem object

          rows: list of indices of rows to be deleted; the order of
          indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Remark:*

     Deleting rows involves changing ordinal numbers of other rows
     remaining in the problem object. New ordinal numbers of the
     remaining rows are assigned under the assumption that the original
     order of rows is not changed.

  *Example*:

    > glp::del_rows lp [3, 4, 7];
    ()



File: pure-glpk.info,  Node: Delete columns from the matrix,  Next: Copy the whole content of the GLPK problem object to another one,  Prev: Delete rows from the matrix,  Up: Problem creating and modifying routines

5.1.1.18 Delete columns from the matrix
.......................................

*Synopsis*:

    glp::del_cols lp cols

*Parameters*:

          lp: pointer to the LP problem object

          cols: list of indices of columns to be deleted; the order of
          indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Remark:*

     Deleting columns involves changing ordinal numbers of other columns
     remaining in the problem object. New ordinal numbers of the
     remaining columns are assigned under the assumption that the
     original order of columns is not changed.

  *Example*:

    > glp::del_cols lp [6, 4, 5];
    ()



File: pure-glpk.info,  Node: Copy the whole content of the GLPK problem object to another one,  Next: Erase all data from the GLPK problem object,  Prev: Delete columns from the matrix,  Up: Problem creating and modifying routines

5.1.1.19 Copy the whole content of the GLPK problem object to another one
.........................................................................

*Synopsis*:

    glp::copy_prob destination source names

*Parameters*:

          destination: pointer to the destination LP problem object
          (must already exist)

          source: pointer to the source LP problem object

          names: one of the following:

               glp::on: copy all symbolic names as well

               glp::off: do not copy the symbolic names

  *Returns*:

     `()'

  *Example*:

    > glp::copy_prob lp_dest lp_src glp::on;
    ()



File: pure-glpk.info,  Node: Erase all data from the GLPK problem object,  Next: Delete the GLPK problem object,  Prev: Copy the whole content of the GLPK problem object to another one,  Up: Problem creating and modifying routines

5.1.1.20 Erase all data from the GLPK problem object
....................................................

*Synopsis*:

    glp::erase_prob lp

*Parameters*:

          lp: pointer to the LP problem object, it remains still valid
          after the function call

  *Returns*:

     `()'

  *Example*:

    > glp::erase_prob lp;
    ()



File: pure-glpk.info,  Node: Delete the GLPK problem object,  Prev: Erase all data from the GLPK problem object,  Up: Problem creating and modifying routines

5.1.1.21 Delete the GLPK problem object
.......................................

*Synopsis*:

    glp::delete_prob lp

*Parameters*:

          lp: pointer to the LP problem object, it is not valid any
          more after the function call

  *Returns*:

     `()'

  *Example*:

    > glp::delete_prob lp;
    ()



File: pure-glpk.info,  Node: Problem retrieving routines,  Next: Row and column searching routines,  Prev: Problem creating and modifying routines,  Up: Basic API routines

5.1.2 Problem retrieving routines
---------------------------------

* Menu:

* Get the problem name::
* Get the objective name::
* Get the objective direction::
* Get number of rows::
* Get number of columns::
* Get name of a row::
* Get name of a column::
* Get row type::
* Get row lower bound::
* Get row upper bound::
* Get column type::
* Get column lower bound::
* Get column upper bound::
* Get objective coefficient::
* Get number of nonzero coefficients::
* Retrive a row from the problem matrix::
* Retrive a column from the problem matrix::


File: pure-glpk.info,  Node: Get the problem name,  Next: Get the objective name,  Up: Problem retrieving routines

5.1.2.1 Get the problem name
............................

*Synopsis*:

    glp::get_prob_name lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     name of the problem

  *Example*:

    > glp::get_prob_name lp;
    "Testing problem"



File: pure-glpk.info,  Node: Get the objective name,  Next: Get the objective direction,  Prev: Get the problem name,  Up: Problem retrieving routines

5.1.2.2 Get the objective name
..............................

*Synopsis*:

    glp::get_obj_name lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     name of the objective

  *Example*:

    > glp::get_obj_name lp;
    "Total costs"



File: pure-glpk.info,  Node: Get the objective direction,  Next: Get number of rows,  Prev: Get the objective name,  Up: Problem retrieving routines

5.1.2.3 Get the objective direction
...................................

*Synopsis*:

    glp::get_obj_dir lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     returns one of the following:

               glp::min: minimize

               glp::max: maximize

  *Example*:

    > glp::get_obj_dir lp;
    glp::min



File: pure-glpk.info,  Node: Get number of rows,  Next: Get number of columns,  Prev: Get the objective direction,  Up: Problem retrieving routines

5.1.2.4 Get number of rows
..........................

*Synopsis*:

    glp::get_num_rows lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of rows (constraints)

  *Example*:

    > glp::get_num_rows lp;
    58



File: pure-glpk.info,  Node: Get number of columns,  Next: Get name of a row,  Prev: Get number of rows,  Up: Problem retrieving routines

5.1.2.5 Get number of columns
.............................

*Synopsis*:

    glp::get_num_cols lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of columns (structural variables)

  *Example*:

    > glp::get_num_cols lp;
    65



File: pure-glpk.info,  Node: Get name of a row,  Next: Get name of a column,  Prev: Get number of columns,  Up: Problem retrieving routines

5.1.2.6 Get name of a row
.........................

*Synopsis*:

    glp::get_row_name lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     name of the given row

  *Example*:

    > glp::get_row_name lp 3;
    "The third row"



File: pure-glpk.info,  Node: Get name of a column,  Next: Get row type,  Prev: Get name of a row,  Up: Problem retrieving routines

5.1.2.7 Get name of a column
............................

*Synopsis*:

    glp::get_col_name lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     name of the given column

  *Example*:

    > glp::get_col_name lp 2;
    "The second column"



File: pure-glpk.info,  Node: Get row type,  Next: Get row lower bound,  Prev: Get name of a column,  Up: Problem retrieving routines

5.1.2.8 Get row type
....................

*Synopsis*:

    glp::get_row_type lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     returns one of the following:

               glp::fr: free variable

               glp::lo: variable with lower bound

               glp::up: variable with upper bound

               glp::db: double bounded variable

               glp::fx: fixed variable

  *Example*:

    > glp::get_row_type lp 3;
    glp::db



File: pure-glpk.info,  Node: Get row lower bound,  Next: Get row upper bound,  Prev: Get row type,  Up: Problem retrieving routines

5.1.2.9 Get row lower bound
...........................

*Synopsis*:

    glp::get_row_lb lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     the row lower bound; if the row has no lower bound then it returns
     the smallest double number

  *Example*:

    > glp::get_row_lb lp 3;
    50.0



File: pure-glpk.info,  Node: Get row upper bound,  Next: Get column type,  Prev: Get row lower bound,  Up: Problem retrieving routines

5.1.2.10 Get row upper bound
............................

*Synopsis*:

    glp::get_row_ub lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     the row upper bound; if the row has no upper bound then it returns
     the biggest double number

  *Example*:

    > glp::get_row_ub lp 3;
    150.0



File: pure-glpk.info,  Node: Get column type,  Next: Get column lower bound,  Prev: Get row upper bound,  Up: Problem retrieving routines

5.1.2.11 Get column type
........................

*Synopsis*:

    glp::get_col_type lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     returns one of the following:

               glp::fr: free variable

               glp::lo: variable with lower bound

               glp::up: variable with upper bound

               glp::db: double bounded variable

               glp::fx: fixed variable

  *Example*:

    > glp::get_col_type lp 2;
    glp::up



File: pure-glpk.info,  Node: Get column lower bound,  Next: Get column upper bound,  Prev: Get column type,  Up: Problem retrieving routines

5.1.2.12 Get column lower bound
...............................

*Synopsis*:

    glp::get_col_lb lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     the column lower bound; if the column has no lower bound then it
     returns the smallest double number

  *Example*:

    > glp::get_col_lb lp 3;
    -1.79769313486232e+308



File: pure-glpk.info,  Node: Get column upper bound,  Next: Get objective coefficient,  Prev: Get column lower bound,  Up: Problem retrieving routines

5.1.2.13 Get column upper bound
...............................

*Synopsis*:

    glp::get_col_ub lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     the column upper bound; if the column has no upper bound then it
     returns the biggest double number

  *Example*:

    > glp::get_col_lb lp 3;
    150.0



File: pure-glpk.info,  Node: Get objective coefficient,  Next: Get number of nonzero coefficients,  Prev: Get column upper bound,  Up: Problem retrieving routines

5.1.2.14 Get objective coefficient
..................................

*Synopsis*:

    glp::get_obj_coef lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index; zero index denotes the constant term
          (objective shift)

  *Returns*:

     the coefficient of given column in the objective

  *Example*:

    > glp::get_obj_coef lp 3;
    5.8



File: pure-glpk.info,  Node: Get number of nonzero coefficients,  Next: Retrive a row from the problem matrix,  Prev: Get objective coefficient,  Up: Problem retrieving routines

5.1.2.15 Get number of nonzero coefficients
...........................................

*Synopsis*:

    glp::get_num_nz lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of non-zero coefficients in the problem matrix

  *Example*:

    > glp::get_num_nz lp;
    158



File: pure-glpk.info,  Node: Retrive a row from the problem matrix,  Next: Retrive a column from the problem matrix,  Prev: Get number of nonzero coefficients,  Up: Problem retrieving routines

5.1.2.16 Retrive a row from the problem matrix
..............................................

*Synopsis*:

    glp::get_mat_row lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     non-zero coefficients of the given row in a list form of tuples
     (colindex, coefficient)

  *Example*:

    > get_mat_row lp 3;
    [(3,6.0),(2,2.0),(1,2.0)]



File: pure-glpk.info,  Node: Retrive a column from the problem matrix,  Prev: Retrive a row from the problem matrix,  Up: Problem retrieving routines

5.1.2.17 Retrive a column from the problem matrix
.................................................

*Synopsis*:

    glp::get_mat_col lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     non-zero coefficients of the given column in a list form of tuples
     (rowindex, coefficient)

  *Example*:

    > get_mat_col lp 2;
    [(3,2.0),(2,4.0),(1,1.0)]



File: pure-glpk.info,  Node: Row and column searching routines,  Next: Problem scaling routines,  Prev: Problem retrieving routines,  Up: Basic API routines

5.1.3 Row and column searching routines
---------------------------------------

* Menu:

* Create index for searching rows and columns by their names::
* Find a row number by name::
* Find a column number by name::
* Delete index for searching rows and columns by their names::


File: pure-glpk.info,  Node: Create index for searching rows and columns by their names,  Next: Find a row number by name,  Up: Row and column searching routines

5.1.3.1 Create index for searching rows and columns by their names
..................................................................

*Synopsis*:

    glp::create_index lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::create_index lp;
    ()



File: pure-glpk.info,  Node: Find a row number by name,  Next: Find a column number by name,  Prev: Create index for searching rows and columns by their names,  Up: Row and column searching routines

5.1.3.2 Find a row number by name
.................................

*Synopsis*:

    glp::find_row lp rowname

*Parameters*:

          lp: pointer to the LP problem object

          rowname: row name

  *Returns*:

     ordinal number (index) of the row

  *Remark*:

     The search index is automatically created if it does not already
     exists.

  *Example*:

    > glp::find_row lp "The third row";
    3



File: pure-glpk.info,  Node: Find a column number by name,  Next: Delete index for searching rows and columns by their names,  Prev: Find a row number by name,  Up: Row and column searching routines

5.1.3.3 Find a column number by name
....................................

*Synopsis*:

    glp::find_col lp colname

*Parameters*:

          lp: pointer to the LP problem object

          colname: column name

  *Returns*:

     ordinal number (index) of the column

  *Remark*:

     The search index is automatically created if it does not already
     exists.

  *Example*:

    > glp::find_col lp "The second row";
    2



File: pure-glpk.info,  Node: Delete index for searching rows and columns by their names,  Prev: Find a column number by name,  Up: Row and column searching routines

5.1.3.4 Delete index for searching rows and columns by their names
..................................................................

*Synopsis*:

    glp::delete_index lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::delete:index lp;
    ()



File: pure-glpk.info,  Node: Problem scaling routines,  Next: LP basis constructing routines,  Prev: Row and column searching routines,  Up: Basic API routines

5.1.4 Problem scaling routines
------------------------------

* Menu:

* Set the row scale factor::
* Set the column scale factor::
* Retrieve the row scale factor::
* Retrieve the column scale factor::
* Scale the problem data according to supplied flags::
* Unscale the problem data::


File: pure-glpk.info,  Node: Set the row scale factor,  Next: Set the column scale factor,  Up: Problem scaling routines

5.1.4.1 Set the row scale factor
................................

*Synopsis*:

    glp::set_rii lp (rowindex, coefficient)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          coefficient: scaling coefficient

  *Returns*:

     `()'

  *Example*:

    > glp::set_rii lp (3, 258.6);
    ()



File: pure-glpk.info,  Node: Set the column scale factor,  Next: Retrieve the row scale factor,  Prev: Set the row scale factor,  Up: Problem scaling routines

5.1.4.2 Set the column scale factor
...................................

*Synopsis*:

    glp::set_sjj lp (colindex, coefficient)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          coefficient: scaling coefficient

  *Returns*:

     `()'

  *Example*:

    > glp::set_sjj lp (2, 12.8);
    ()



File: pure-glpk.info,  Node: Retrieve the row scale factor,  Next: Retrieve the column scale factor,  Prev: Set the column scale factor,  Up: Problem scaling routines

5.1.4.3 Retrieve the row scale factor
.....................................

*Synopsis*:

    glp::get_rii lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     scaling coefficient of given row

  *Example*:

    > glp::get_rii lp 3;
    258.6



File: pure-glpk.info,  Node: Retrieve the column scale factor,  Next: Scale the problem data according to supplied flags,  Prev: Retrieve the row scale factor,  Up: Problem scaling routines

5.1.4.4 Retrieve the column scale factor
........................................

*Synopsis*:

    glp::get_sjj lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     scaling coefficient of given column

  *Example*:

    > glp::get_sjj lp 2;
    12.8



File: pure-glpk.info,  Node: Scale the problem data according to supplied flags,  Next: Unscale the problem data,  Prev: Retrieve the column scale factor,  Up: Problem scaling routines

5.1.4.5 Scale the problem data according to supplied flags
..........................................................

*Synopsis*:

    glp::scale_prob lp flags

*Parameters*:

          lp: pointer to the LP problem object

          flags: symbolic integer constants which can be combined
          together by arithmetic *or*; the possible constants are:

               glp::sf_gm: perform geometric mean scaling

               glp::sf_eq: perform equilibration scaling

               glp::sf_2n: round scale factors to power of two

               glp::sf_skip: skip if problem is well scaled

               glp::sf_auto: choose scaling options automatically

  *Returns*:

     `()'

  *Example*:

    > glp::scale_prob lp (glp::sf_gm || glp::sf_2n);
    ()



File: pure-glpk.info,  Node: Unscale the problem data,  Prev: Scale the problem data according to supplied flags,  Up: Problem scaling routines

5.1.4.6 Unscale the problem data
................................

*Synopsis*:

    glp::unscale_prob lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::unscale_prob lp;
    ()



File: pure-glpk.info,  Node: LP basis constructing routines,  Next: Simplex method routines,  Prev: Problem scaling routines,  Up: Basic API routines

5.1.5 LP basis constructing routines
------------------------------------

* Menu:

* Set the row status::
* Set the column status::
* Construct standard problem basis::
* Construct advanced problem basis::
* Construct Bixby's problem basis::


File: pure-glpk.info,  Node: Set the row status,  Next: Set the column status,  Up: LP basis constructing routines

5.1.5.1 Set the row status
..........................

*Synopsis*:

    glp::set_row_stat lp (rowindex, status)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          status: one of the following:

               glp::bs: make the row basic (make the constraint
               inactive)

               glp::nl: make the row non-basic (make the constraint
               active)

               glp::nu: make the row non-basic and set it to the upper
               bound; if the row is not double-bounded, this status is
               equivalent to glp::nl (only in the case of this routine)

               glp::nf: the same as glp::nl (only in the case of this
               routine)

               glp::ns: the same as glp::nl (only in the case of this
               routine)

  *Returns*:

     `()'

  *Example*:

    > glp::set_row_stat lp (3, glp::nu);
    ()



File: pure-glpk.info,  Node: Set the column status,  Next: Construct standard problem basis,  Prev: Set the row status,  Up: LP basis constructing routines

5.1.5.2 Set the column status
.............................

*Synopsis*:

    glp::set_col_stat lp (colindex, status)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          status: one of the following:

               glp::bs: make the column basic

               glp::nl: make the column non-basic

               glp::nu: make the column non-basic and set it to the
               upper bound; if the column is not double-bounded, this
               status is equivalent to glp::nl (only in the case of
               this routine)

               glp::nf: the same as glp::nl (only in the case of this
               routine)

               glp::ns: the same as glp::nl (only in the case of this
               routine)

  *Returns*:

     `()'

  *Example*:

    > glp::set_col_stat lp (2, glp::bs);
    ()



File: pure-glpk.info,  Node: Construct standard problem basis,  Next: Construct advanced problem basis,  Prev: Set the column status,  Up: LP basis constructing routines

5.1.5.3 Construct standard problem basis
........................................

*Synopsis*:

    glp::std_basis lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::std_basis lp;
    ()



File: pure-glpk.info,  Node: Construct advanced problem basis,  Next: Construct Bixby's problem basis,  Prev: Construct standard problem basis,  Up: LP basis constructing routines

5.1.5.4 Construct advanced problem basis
........................................

*Synopsis*:

    glp::adv_basis lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::adv_basis lp;
    ()



File: pure-glpk.info,  Node: Construct Bixby's problem basis,  Prev: Construct advanced problem basis,  Up: LP basis constructing routines

5.1.5.5 Construct Bixby's problem basis
.......................................

*Synopsis*:

    glp::cpx_basis lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::cpx_basis lp;
    ()



File: pure-glpk.info,  Node: Simplex method routines,  Next: Interior-point method routines,  Prev: LP basis constructing routines,  Up: Basic API routines

5.1.6 Simplex method routines
-----------------------------

* Menu:

* Solve the LP problem using simplex method::
* Solve the LP problem using simplex method in exact arithmetics::
* Retrieve generic status of basic solution::
* Retrieve generic status of primal solution::
* Retrieve generic status of dual solution::
* Retrieve value of the objective function::
* Retrieve generic status of a row variable::
* Retrieve row primal value::
* Retrieve row dual value::
* Retrieve generic status of a column variable::
* Retrieve column primal value::
* Retrieve column dual value::
* Determine variable causing unboundedness::


File: pure-glpk.info,  Node: Solve the LP problem using simplex method,  Next: Solve the LP problem using simplex method in exact arithmetics,  Up: Simplex method routines

5.1.6.1 Solve the LP problem using simplex method
.................................................

*Synopsis*:

    glp::simplex lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::msg_lev:

              (default: glp::msg_all) - message level for
                    terminal output:

                   *glp::msg_off:* no output 
                   *glp::msg_err:* error and warning messages only 
                   *glp::msg_on:*  normal output; 
                   *glp::msg_all:* full output (including informational messages) 

               glp::meth: (default: glp::primal) - simplex method option

                   *glp::primal:* use two-phase primal simplex 
                   *glp::dual:* use two-phase dual simplex; 
                   *glp::dualp:* use two-phase dual simplex, and if it fails, switch to the primal simplex 

               glp::pricing: (default: glp::pt_pse) - pricing technique

                   *glp::pt_std:* standard (textbook) 
                   *glp::pt_pse:* projected steepest edge 

               glp::r_test: (default: glp::rt_har) - ratio test
               technique

                   *glp::rt_std:* standard (textbook) 
                   *glp::rt_har:* Harris' two-pass ratio test 

               glp::tol_bnd: (default: 1e-7) - tolerance used to check
               if the basic solution is primal feasible

               glp::tol_dj: (default: 1e-7) - tolerance used to check
               if the basic solution is dual feasible

               glp::tol_piv: (default: 1e-10) - tolerance used to choose
               eligble pivotal elements of the simplex table

               glp::obj_ll: (default: -DBL_MAX) - lower limit of the
               objective function - if the objective function reaches
               this limit and continues decreasing, the solver
               terminates the search - used in the dual simplex only

               glp::obj_ul: (default: +DBL_MAX) - upper limit of the
               objective function. If the objective function reaches
               this limit and continues increasing, the solver
               terminates the search - used in the dual simplex only

               glp::it_lim: (default: INT_MAX) - simplex iteration limit

               glp::tm lim: (default: INT_MAX) - searching time limit,
               in milliseconds

               glp::out_frq: (default: 200) - output frequency, in
               iterations - this parameter specifies how frequently the
               solver sends information about the solution process to
               the terminal

               glp::out_dly: (default: 0) - output delay, in
               milliseconds - this parameter specifies how long the
               solver should delay sending information about the
               solution process to the terminal

               glp::presolve: (default: glp::off) - LP presolver option:

                   *glp::on:* enable using the LP presolver 
                   *glp::off:* disable using the LP presolver 

  *Returns*:

     one of the following:

          glp::ok: the LP problem instance has been successfully
          solved; this code does not necessarily mean that the solver
          has found optimal solution, it only means that the solution
          process was successful

          glp::ebadb: unable to start the search, because the initial
          basis specified in the problem object is invalid - the number
          of basic (auxiliary and structural) variables is not the same
          as the number of rows in the problem object

          glp::esing: unable to start the search, because the basis
          matrix corresponding to the initial basis is singular within
          the working precision

          glp::econd: unable to start the search, because the basis
          matrix corresponding to the initial basis is ill-conditioned,
          i.e. its condition number is too large

          glp::ebound: unable to start the search, because some
          double-bounded (auxiliary or structural) variables have
          incorrect bounds

          glp::efail: the search was prematurely terminated due to the
          solver failure

          glp::eobjll: the search was prematurely terminated, because
          the objective function being maximized has reached its lower
          limit and continues decreasing (the dual simplex only)

          glp::eobjul: the search was prematurely terminated, because
          the objective function being minimized has reached its upper
          limit and continues increasing (the dual simplex only)

          glp::eitlim: the search was prematurely terminated, because
          the simplex iteration limit has been exceeded

          glp::etmlim: the search was prematurely terminated, because
          the time limit has been exceeded

          glp::enopfs: the LP problem instance has no primal feasible
          solution (only if the LP presolver is used)

          glp::enodfs: the LP problem instance has no dual feasible
          solution (only if the LP presolver is used)

     When the list of options contains some bad option(s) then a list
     of bad options is returned instead.

  *Remark*:

     Options not mentioned in the option list are set to their default
     values.

  *Example*:

    > glp::simplex lp [(glp::presolve, glp::on), (glp::msg_lev, glp::msg_all)];
    glp_simplex: original LP has 3 rows, 3 columns, 9 non-zeros
    glp_simplex: presolved LP has 3 rows, 3 columns, 9 non-zeros
    Scaling...
     A: min|aij| = 1,000e+000  max|aij| = 1,000e+001  ratio = 1,000e+001
    Problem data seem to be well scaled
    Crashing...
    Size of triangular part = 3
    *     0: obj =  0,000000000e+000  infeas = 0,000e+000 (0)
    *     2: obj =  7,333333333e+002  infeas = 0,000e+000 (0)
    OPTIMAL SOLUTION FOUND
    glp::ok



File: pure-glpk.info,  Node: Solve the LP problem using simplex method in exact arithmetics,  Next: Retrieve generic status of basic solution,  Prev: Solve the LP problem using simplex method,  Up: Simplex method routines

5.1.6.2 Solve the LP problem using simplex method in exact arithmetics
......................................................................

*Synopsis*:

    glp::exact lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::it_lim: (default: INT_MAX) - simplex iteration limit

               glp::tm lim: (default: INT_MAX) - searching time limit,
               in milliseconds

  *Returns*:

     one of the following:

          glp::ok: the LP problem instance has been successfully
          solved; this code does not necessarily mean that the solver
          has found optimal solution, it only means that the solution
          process was successful

          glp::ebadb: unable to start the search, because the initial
          basis specified in the problem object is invalid - the number
          of basic (auxiliary and structural) variables is not the same
          as the number of rows in the problem object

          glp::esing: unable to start the search, because the basis
          matrix corresponding to the initial basis is singular within
          the working precision

          glp::ebound: unable to start the search, because some
          double-bounded (auxiliary or structural) variables have
          incorrect bounds

          glp::efail: the search was prematurely terminated due to the
          solver failure

          glp::eitlim: the search was prematurely terminated, because
          the simplex iteration limit has been exceeded

          glp::etmlim: the search was prematurely terminated, because
          the time limit has been exceeded

     When the list of options contains some bad option(s) then a list
     of bad options is returned instead.

  *Remark*:

     Options not mentioned in the option list are set to their default
     values.

  *Example*:

    > glp::exact lp [];
    glp_exact: 3 rows, 3 columns, 9 non-zeros
    GNU MP bignum library is being used
    *     2:   objval =                      0   (0)
    *     4:   objval =       733,333333333333   (0)
    OPTIMAL SOLUTION FOUND
    glp::ok



File: pure-glpk.info,  Node: Retrieve generic status of basic solution,  Next: Retrieve generic status of primal solution,  Prev: Solve the LP problem using simplex method in exact arithmetics,  Up: Simplex method routines

5.1.6.3 Retrieve generic status of basic solution
.................................................

*Synopsis*:

    glp::get_status lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: solution is undefined

          glp::feas: solution is feasible

          glp::infeas: solution is infeasible

          glp::nofeas: no feasible solution exists

          glp::opt: solution is optimal

          glp::unbnd: solution is unbounded

  *Example*:

    > glp::get_status lp;
    glp::opt



File: pure-glpk.info,  Node: Retrieve generic status of primal solution,  Next: Retrieve generic status of dual solution,  Prev: Retrieve generic status of basic solution,  Up: Simplex method routines

5.1.6.4 Retrieve generic status of primal solution
..................................................

*Synopsis*:

    glp::get_prim_stat lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: primal solution is undefined

          glp::feas: primal solution is feasible

          glp::infeas: primal solution is infeasible

          glp::nofeas: no primal feasible solution exists

  *Example*:

    > glp::get_prim_stat lp;
    glp::feas



File: pure-glpk.info,  Node: Retrieve generic status of dual solution,  Next: Retrieve value of the objective function,  Prev: Retrieve generic status of primal solution,  Up: Simplex method routines

5.1.6.5 Retrieve generic status of dual solution
................................................

*Synopsis*:

    glp::get_dual_stat lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: dual solution is undefined

          glp::feas: dual solution is feasible

          glp::infeas: dual solution is infeasible

          glp::nofeas: no dual feasible solution exists

  *Example*:

    > glp::get_dual_stat lp;
    glp::feas



File: pure-glpk.info,  Node: Retrieve value of the objective function,  Next: Retrieve generic status of a row variable,  Prev: Retrieve generic status of dual solution,  Up: Simplex method routines

5.1.6.6 Retrieve value of the objective function
................................................

*Synopsis*:

    glp::get_obj_val lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     value of the objective function

  *Example*:

    > glp::get_obj_val lp
    733.333333333333



File: pure-glpk.info,  Node: Retrieve generic status of a row variable,  Next: Retrieve row primal value,  Prev: Retrieve value of the objective function,  Up: Simplex method routines

5.1.6.7 Retrieve generic status of a row variable
.................................................

*Synopsis*:

    glp::get_row_stat lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     one of the following:

          glp::bs: basic variable

          glp::nl: non-basic variable on its lower bound

          glp::nu: non-basic variable on its upper bound

          glp::nf: non-basic free (unbounded) variable

          glp::ns: non-basic fixed variable

  *Example*:

    > glp::get_row_stat lp 3;
    glp::bs



File: pure-glpk.info,  Node: Retrieve row primal value,  Next: Retrieve row dual value,  Prev: Retrieve generic status of a row variable,  Up: Simplex method routines

5.1.6.8 Retrieve row primal value
.................................

*Synopsis*::
     glp::get_row_prim lp rowindex

  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     primal value of the row (auxiliary) variable

  *Example*:

    > glp::get_row_prim lp 3;
    200.0



File: pure-glpk.info,  Node: Retrieve row dual value,  Next: Retrieve generic status of a column variable,  Prev: Retrieve row primal value,  Up: Simplex method routines

5.1.6.9 Retrieve row dual value
...............................

*Synopsis*:

    glp::get_row_dual lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     dual value of the row (auxiliary) variable

  *Example*:

    > glp::get_row_dual lp 3;
    0.0



File: pure-glpk.info,  Node: Retrieve generic status of a column variable,  Next: Retrieve column primal value,  Prev: Retrieve row dual value,  Up: Simplex method routines

5.1.6.10 Retrieve generic status of a column variable
.....................................................

*Synopsis*:

    glp::get_col_stat lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     one of the following:

          glp::bs: basic variable

          glp::nl: non-basic variable on its lower bound

          glp::nu: non-basic variable on its upper bound

          glp::nf: non-basic free (unbounded) variable

          glp::ns: non-basic fixed variable

  *Example*:

    > glp::get_col_stat lp 2;
    glp::bs



File: pure-glpk.info,  Node: Retrieve column primal value,  Next: Retrieve column dual value,  Prev: Retrieve generic status of a column variable,  Up: Simplex method routines

5.1.6.11 Retrieve column primal value
.....................................

*Synopsis*:

    glp::get_col_prim lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     primal value of the column (structural) variable

  *Example*:

    > glp::get_col_prim lp 2;
    66.6666666666667



File: pure-glpk.info,  Node: Retrieve column dual value,  Next: Determine variable causing unboundedness,  Prev: Retrieve column primal value,  Up: Simplex method routines

5.1.6.12 Retrieve column dual value
...................................

*Synopsis*:

    glp::get_col_dual lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     dual value of the column (structural) variable

  *Example*:

    > glp::get_col_dual lp 2;
    0.0



File: pure-glpk.info,  Node: Determine variable causing unboundedness,  Prev: Retrieve column dual value,  Up: Simplex method routines

5.1.6.13 Determine variable causing unboundedness
.................................................

*Synopsis*:

    glp::get_unbnd_ray lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     The routine glp_get_unbnd_ray returns the number k of a variable,
     which causes primal or dual unboundedness. If 1 <= k <= m, it is
     k-th auxiliary variable, and if m + 1 <= k <= m + n, it is (k -
     m)-th structural variable, where m is the number of rows, n is the
     number of columns in the problem object. If such variable is not
     defined, the routine returns 0.

  *Remark*:

     If it is not exactly known which version of the simplex solver
     detected unboundedness, i.e. whether the unboundedness is primal
     or dual, it is sufficient to check the status of the variable with
     the routine glp::get_row_stat or glp::get_col_stat. If the
     variable is non-basic, the unboundedness is primal, otherwise, if
     the variable is basic, the unboundedness is dual (the latter case
     means that the problem has no primal feasible dolution).

  *Example*:

    > glp::get_unbnd_ray lp;
    0



File: pure-glpk.info,  Node: Interior-point method routines,  Next: Mixed integer programming routines,  Prev: Simplex method routines,  Up: Basic API routines

5.1.7 Interior-point method routines
------------------------------------

* Menu:

* Solve the LP problem using interior-point method::
* Retrieve status of interior-point solution::
* Retrieve the objective function value of interior-point solution::
* Retrieve row primal value of interior-point solution::
* Retrieve row dual value of interior-point solution::
* Retrieve column primal value of interior-point solution::
* Retrieve column dual value of interior-point solution::


File: pure-glpk.info,  Node: Solve the LP problem using interior-point method,  Next: Retrieve status of interior-point solution,  Up: Interior-point method routines

5.1.7.1 Solve the LP problem using interior-point method
........................................................

*Synopsis*:

    glp::interior lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::msg_lev:

              (default: glp::msg_all) - message level for
                    terminal output:

                   *glp::msg_off:* no output 
                   *glp::msg_err:* error and warning messages only 
                   *glp::msg_on:* normal output; 
                   *glp::msg_all:* full output (including informational messages) 

               glp::ord_alg: (default: glp::ord_amd) - ordering
               algorithm option

                   *glp::ord_none:* use natural (original) ordering 
                   *glp::ord_qmd:* quotient minimum degree (QMD) 
                   *glp::ord_amd:* approximate minimum degree (AMD) 
                   *glp::ord_sysamd:* approximate minimum degree (SYSAMD) 

  *Returns*:

     one of the following:

          glp::ok: the LP problem instance has been successfully solved;
          this code does not necessarily mean that the solver has found
          optimal solution, it only means that the solution process was
          successful

          glp::efail: the problem has no rows/columns

          glp::enocvg: very slow convergence or divergence

          glp::eitlim: iteration limit exceeded

          glp::einstab: numerical instability on solving Newtonian
          system

  *Example*:

    > glp::interior lp [(glp::ord_alg, glp::ord_amd)];
    Original LP has 3 row(s), 3 column(s), and 9 non-zero(s)
    Working LP has 3 row(s), 6 column(s), and 12 non-zero(s)
    Matrix A has 12 non-zeros
    Matrix S = A*A' has 6 non-zeros (upper triangle)
    Approximate minimum degree ordering (AMD)...
    Computing Cholesky factorization S = L*L'...
    Matrix L has 6 non-zeros
    Guessing initial point...
    Optimization begins...
      0: obj = -8,218489503e+002; rpi = 3,6e-001; rdi = 6,8e-001; gap = 2,5e-001
      1: obj = -6,719060895e+002; rpi = 3,6e-002; rdi = 1,9e-001; gap = 1,4e-002
      2: obj = -6,917210389e+002; rpi = 3,6e-003; rdi = 9,3e-002; gap = 3,0e-002
      3: obj = -7,267557732e+002; rpi = 2,1e-003; rdi = 9,3e-003; gap = 4,4e-002
      4: obj = -7,323038146e+002; rpi = 2,1e-004; rdi = 1,1e-003; gap = 4,8e-003
      5: obj = -7,332295932e+002; rpi = 2,1e-005; rdi = 1,1e-004; gap = 4,8e-004
      6: obj = -7,333229585e+002; rpi = 2,1e-006; rdi = 1,1e-005; gap = 4,8e-005
      7: obj = -7,333322959e+002; rpi = 2,1e-007; rdi = 1,1e-006; gap = 4,8e-006
      8: obj = -7,333332296e+002; rpi = 2,1e-008; rdi = 1,1e-007; gap = 4,8e-007
      9: obj = -7,333333230e+002; rpi = 2,1e-009; rdi = 1,1e-008; gap = 4,8e-008
     10: obj = -7,333333323e+002; rpi = 2,1e-010; rdi = 1,1e-009; gap = 4,8e-009
    OPTIMAL SOLUTION FOUND
    glp::ok



File: pure-glpk.info,  Node: Retrieve status of interior-point solution,  Next: Retrieve the objective function value of interior-point solution,  Prev: Solve the LP problem using interior-point method,  Up: Interior-point method routines

5.1.7.2 Retrieve status of interior-point solution
..................................................

*Synopsis*:

    glp::ipt_status lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following

          glp::undef: interior-point solution is undefined

          glp::opt: interior-point solution is optimal

          glp::infeas: interior-point solution is infeasible

          glp::nofeas: no feasible primal-dual solution exists

  *Example*:

    > glp::ipt_status lp;
    glp::opt



File: pure-glpk.info,  Node: Retrieve the objective function value of interior-point solution,  Next: Retrieve row primal value of interior-point solution,  Prev: Retrieve status of interior-point solution,  Up: Interior-point method routines

5.1.7.3 Retrieve the objective function value of interior-point solution
........................................................................

*Synopsis*:

    glp::ipt_obj_val lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     objective function value of interior-point solution

  *Example*:

    > glp::ipt_obj_val lp;
    733.333332295849



File: pure-glpk.info,  Node: Retrieve row primal value of interior-point solution,  Next: Retrieve row dual value of interior-point solution,  Prev: Retrieve the objective function value of interior-point solution,  Up: Interior-point method routines

5.1.7.4 Retrieve row primal value of interior-point solution
............................................................

*Synopsis*:

    glp::ipt_row_prim lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     primal value of the row (auxiliary) variable

  *Example*:

    > glp::ipt_row_prim lp 3;
    200.000000920688



File: pure-glpk.info,  Node: Retrieve row dual value of interior-point solution,  Next: Retrieve column primal value of interior-point solution,  Prev: Retrieve row primal value of interior-point solution,  Up: Interior-point method routines

5.1.7.5 Retrieve row dual value of interior-point solution
..........................................................

*Synopsis*:

    glp::ipt_row_dual lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     dual value of the row (auxiliary) variable

  *Example*:

    > glp::ipt_row_dual lp 3;
    2.50607466186742e-008



File: pure-glpk.info,  Node: Retrieve column primal value of interior-point solution,  Next: Retrieve column dual value of interior-point solution,  Prev: Retrieve row dual value of interior-point solution,  Up: Interior-point method routines

5.1.7.6 Retrieve column primal value of interior-point solution
...............................................................

*Synopsis*:

    glp::ipt_col_prim lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     primal value of the column (structural) variable

  *Example*:

    > glp::ipt_col_prim lp 2;
    66.666666406779



File: pure-glpk.info,  Node: Retrieve column dual value of interior-point solution,  Prev: Retrieve column primal value of interior-point solution,  Up: Interior-point method routines

5.1.7.7 Retrieve column dual value of interior-point solution
.............................................................

*Synopsis*:

    glp::ipt_col_dual lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     dual value of the column (structural) variable

  *Example*:

    > glp::ipt_col_dual lp 2;
    2.00019467655466e-009



File: pure-glpk.info,  Node: Mixed integer programming routines,  Next: Additional routines,  Prev: Interior-point method routines,  Up: Basic API routines

5.1.8 Mixed integer programming routines
----------------------------------------

* Menu:

* Set column kind::
* Retrieve column kind::
* Retrieve number of integer columns::
* Retrieve number of binary columns::
* Solve the MIP problem using branch-and-cut method::
* Retrieve status of mip solution::
* Retrieve the objective function value of mip solution::
* Retrieve row value of mip solution::
* Retrieve column value of mip solution::


File: pure-glpk.info,  Node: Set column kind,  Next: Retrieve column kind,  Up: Mixed integer programming routines

5.1.8.1 Set column kind
.......................

*Synopsis*:

    glp::set_col_kind lp (colindex, colkind)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          colkind: column kind - one of the following:

               glp::cv: continuous variable

               glp::iv: integer variable

               glp::bv: binary variable

  *Returns*:

     `()'

  *Example*:

    > glp::set_col_kind lp (1, glp::iv);
    ()



File: pure-glpk.info,  Node: Retrieve column kind,  Next: Retrieve number of integer columns,  Prev: Set column kind,  Up: Mixed integer programming routines

5.1.8.2 Retrieve column kind
............................

*Synopsis*:

    glp::get_col_kind lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     one of the following:

          glp::cv: continuous variable

          glp::iv: integer variable

          glp::bv: binary variable

  *Example*:

    > glp::get_col_kind lp 1;
    glp::iv



File: pure-glpk.info,  Node: Retrieve number of integer columns,  Next: Retrieve number of binary columns,  Prev: Retrieve column kind,  Up: Mixed integer programming routines

5.1.8.3 Retrieve number of integer columns
..........................................

*Synopsis*:

    glp::get_num_int lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of integer columns (including binary columns)

  *Example*:

    > glp_get_num_int lp;
    1



File: pure-glpk.info,  Node: Retrieve number of binary columns,  Next: Solve the MIP problem using branch-and-cut method,  Prev: Retrieve number of integer columns,  Up: Mixed integer programming routines

5.1.8.4 Retrieve number of binary columns
.........................................

*Synopsis*:

    glp::get_num_bin lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of binary columns

  *Example*:

    > glp::get_num_bin lp
    0



File: pure-glpk.info,  Node: Solve the MIP problem using branch-and-cut method,  Next: Retrieve status of mip solution,  Prev: Retrieve number of binary columns,  Up: Mixed integer programming routines

5.1.8.5 Solve the MIP problem using branch-and-cut method
.........................................................

*Synopsis*:

    glp::intopt lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::msg_lev:

              (default: glp::msg_all) - message level for
                    terminal output:

                   *glp::msg_off:* no output 
                   *glp::msg_err:* error and warning messages only 
                   *glp::msg_on:* normal output; 
                   *glp::msg_all:* full output (including informational messages) 

               glp::br_tech: (default: glp::bt::blb) - branching
               technique

                   *glp::br_ffv:* first fractional variable 
                   *glp::br_lfv:* last fractional variable 
                   *glp::br_mfv:* most fractional variable 
                   *glp::br_dth:* heuristic by Driebeck and Tomlin 
                   *glp::br_pch:* hybrid pseudocost heuristic 

               glp::bt_tech: (default: glp::pt_pse) - backtracking
               technique

                   *glp::bt_dfs:* depth first search; 
                   *glp::bt_bfs:* breadth first search; 
                   *glp::bt_blb:* best local bound; 
                   *glp::bt_bph:* best projection heuristic. 

               glp::pp_tech: (default: glp::pp_all) - preprocessing
               technique

                   *glp::pp_none:* disable preprocessing; 
                   *glp::pp_root:* perform preprocessing only on the root level 
                   *glp::pp_all:* perform preprocessing on all levels 

               glp::fp_heur: (default: glp::off) - feasibility pump
               heuristic:

                   *glp::on:* enable applying the feasibility pump heuristic 
                   *glp::off:* disable applying the feasibility pump heuristic 

               glp::gmi_cuts:

              (default: glp::off) - Gomory’s mixed integer
                    cuts:

                   *glp::on:* enable generating Gomory’s cuts; 
                   *glp::off:* disable generating Gomory’s cuts. 

               glp::mir_cuts:

              (default: glp::off) - mixed integer rounding
                    (MIR) cuts:

                   *glp::on:* enable generating MIR cuts; 
                   *glp::off:* disable generating MIR cuts. 

               glp::cov_cuts: (default: glp::off) - mixed cover cuts:

                   *glp::on:* enable generating mixed cover cuts; 
                   *glp::off:* disable generating mixed cover cuts. 

               glp::clq_cuts (default: glp::off) - clique cuts:

                   *glp::on:* enable generating clique cuts; 
                   *glp::off:* disable generating clique cuts. 

               glp::tol_int: (default: 1e-5) - absolute tolerance used
               to check if optimal solution to the current LP
               relaxation is integer feasible

               glp::tol_obj: (default: 1e-7) - relative tolerance used
               to check if the objective value in optimal solution to
               the current LP relaxation is not better than in the best
               known integer feasible solution

               glp::mip_gap: (default: 0.0) - the relative mip gap
               tolerance; if the relative mip gap for currently known
               best integer feasible solution falls below this
               tolerance, the solver terminates the search - this
               allows obtainig suboptimal integer feasible solutions if
               solving the problem to optimality takes too long time

               glp::tm lim: (default: INT_MAX) - searching time limit,
               in milliseconds

               glp::out_frq: (default: 5000) - output frequency, in
               miliseconds - this parameter specifies how frequently
               the solver sends information about the solution process
               to the terminal

               glp::out_dly: (default: 10000) - output delay, in
               milliseconds - this parameter specifies how long the
               solver should delay sending information about the
               solution of the current LP relaxation with the simplex
               method to the terminal

               glp::cb_func:

              (default: glp::off) - specifies whether to use
                    the user-defined callback routine

                   *glp::on:* use user-defined callback function - the function `glp::mip_cb tree info' *must* be defined by the user 
                   *glp::off:* do not use user-defined callback function 

               glp::cb_info: (default: NULL) - transit pointer passed
               to the routine `glp::mip_cb tree info' (see above)

               glp::cb_size: (default: 0) - the number of extra (up to
               256) bytes allocated for each node of the
               branch-and-bound tree to store application-specific data
               - on creating a node these bytes are initialized by
               binary zeros

               glp::presolve: (default: glp::off) - LP presolver option:

                   *glp::on:* enable using the MIP presolver 
                   *glp::off:* disable using the MIP presolver 

               glp::binarize:

              (default: glp::off) - binarization (used only if
                    the presolver is enabled):

                   *glp::on:* replace general integer variables by binary ones 
                   *glp::off:* do not use binarization 

  *Returns*:

     one of the following:

          glp::ok: the MIP problem instance has been successfully
          solved; this code does not necessarily mean that the solver
          has found optimal solution, it only means that the solution
          process was successful

          glp::ebound: unable to start the search, because some
          double-bounded (auxiliary or structural) variables have
          incorrect bounds or some integer variables have non-integer
          (fractional) bounds

          glp::eroot: unable to start the search, because optimal basis
          for initial LP relaxation is not provided - this code may
          appear only if the presolver is disabled

          glp::enopfs: unable to start the search, because LP
          relaxation of the MIP problem instance has no primal feasible
          solution - this code may appear only if the presolver is
          enabled

          glp::enodfs: unable to start the search, because LP
          relaxation of the MIP problem instance has no dual feasible
          solution; in other word, this code means that if the LP
          relaxation has at least one primal feasible solution, its
          optimal solution is unbounded, so if the MIP problem has at
          least one integer feasible solution, its (integer) optimal
          solution is also unbounded - this code may appear only if the
          presolver is enabled

          glp::efail: the search was prematurely terminated due to the
          solver failure

          glp::emipgap: the search was prematurely terminated, because
          the relative mip gap tolerance has been reached

          glp::etmlim: the search was prematurely terminated, because
          the time limit has been exceeded

          glp::estop: the search was prematurely terminated by
          application - this code may appear only if the advanced solver
          interface is used

     When the list of options contains some bad option(s) then a list
     of bad options is returned instead.

  *Remark*:

     Options not mentioned in the option list are set to their default
     values.

  *Example*:

    > glp::intopt lp [(glp::presolve, glp::on)];
    ipp_basic_tech:  0 row(s) and 0 column(s) removed
    ipp_reduce_bnds: 2 pass(es) made, 3 bound(s) reduced
    ipp_basic_tech:  0 row(s) and 0 column(s) removed
    ipp_reduce_coef: 1 pass(es) made, 0 coefficient(s) reduced
    glp_intopt: presolved MIP has 3 rows, 3 columns, 9 non-zeros
    glp_intopt: 3 integer columns, none of which are binary
    Scaling...
     A: min|aij| =  1,000e+00  max|aij| =  1,000e+01  ratio =  1,000e+01
    Problem data seem to be well scaled
    Crashing...
    Size of triangular part = 3
    Solving LP relaxation...
    *     2: obj =   0,000000000e+00  infeas =  0,000e+00 (0)
    *     5: obj =   7,333333333e+02  infeas =  0,000e+00 (0)
    OPTIMAL SOLUTION FOUND
    Integer optimization begins...
    +     5: mip =     not found yet <=              +inf        (1; 0)
    +     6: >>>>>   7,320000000e+02 <=   7,320000000e+02   0.0% (2; 0)
    +     6: mip =   7,320000000e+02 <=     tree is empty   0.0% (0; 3)
    INTEGER OPTIMAL SOLUTION FOUND
    glp::ok



File: pure-glpk.info,  Node: Retrieve status of mip solution,  Next: Retrieve the objective function value of mip solution,  Prev: Solve the MIP problem using branch-and-cut method,  Up: Mixed integer programming routines

5.1.8.6 Retrieve status of mip solution
.......................................

*Synopsis*:

    glp::mip_status lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: MIP solution is undefined

          glp::opt: MIP solution is integer optimal

          glp::feas: MIP solution is integer feasible, however, its
          optimality (or non-optimality) has not been proven, perhaps
          due to premature termination of the search

          glp::nofeas: problem has no integer feasible solution (proven
          by the solver)

  *Example*:

    > glp::mip_status lp;
    glp::opt



File: pure-glpk.info,  Node: Retrieve the objective function value of mip solution,  Next: Retrieve row value of mip solution,  Prev: Retrieve status of mip solution,  Up: Mixed integer programming routines

5.1.8.7 Retrieve the objective function value of mip solution
.............................................................

*Synopsis*:

    glp::mip_obj_val lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     objective function value of mip solution

  *Example*:

    > glp::mip_obj_val lp;
    732.0



File: pure-glpk.info,  Node: Retrieve row value of mip solution,  Next: Retrieve column value of mip solution,  Prev: Retrieve the objective function value of mip solution,  Up: Mixed integer programming routines

5.1.8.8 Retrieve row value of mip solution
..........................................

*Synopsis*:

    glp::mip_row_val lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     row value (value of auxiliary variable)

  *Example*:

    > glp::mip_row_val lp 3;
    200.0



File: pure-glpk.info,  Node: Retrieve column value of mip solution,  Prev: Retrieve row value of mip solution,  Up: Mixed integer programming routines

5.1.8.9 Retrieve column value of mip solution
.............................................

*Synopsis*:

    glp::mip_col_val lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     column value (value of structural variable)

  *Example*:

    > glp::mip_col_val lp 2;
    67.0



File: pure-glpk.info,  Node: Additional routines,  Prev: Mixed integer programming routines,  Up: Basic API routines

5.1.9 Additional routines
-------------------------

* Menu:

* Check Karush-Kuhn-Tucker conditions::


File: pure-glpk.info,  Node: Check Karush-Kuhn-Tucker conditions,  Up: Additional routines

5.1.9.1 Check Karush-Kuhn-Tucker conditions
...........................................

*Synopsis*:

    lpx::check_kkt lp scaled

*Parameters*:

          lp: pointer to the LP problem object

          scaled: one of the following:

               true: test the scaled problem

               false: test the unscaled problem

  *Returns*:

     list of four tuples with five mebers (see GLPK reference manual):

     Condition       Member           Comment
     -------------------------------------------------------------------------------------- 
     (KKT.PE)        pe_ae_max        Largest absolute error
                     pe_ae_row        Number of row with largest absolute error
                     pe_re_max        Largest relative error
                     pe_re_row        Number of row with largest relative error
                     pe_quality       Quality of primal solution
     (KKT.PB)        pb_ae_max        Largest absolute error
                     pb_ae_ind        Number of variable with largest absolute error
                     pb_re_max        Largest relative error
                     pb_re_ind        Number of variable with largest relative error
                     pb_quality       Quality of primal feasibility
     (KKT.DE)        de_ae_max        Largest absolute error
                     de_ae_col        Number of column with largest absolute error
                     de_re_max        Largest relative error
                     de_re_col        Number of column with largest relative error
                     de_quality       Quality of dual solution
     (KKT.DB)        db_ae_max        Largest absolute error
                     db_ae_ind        Number of variable with largest absolute error
                     db_re_max        Largest relative error
                     db_re_ind        Number of variable with largest relative error
                     db_quality       Quality of dual feasibility

     where number of variable is (1 <= k <= m) for auxiliary variable
     and (m+1 <= k <= m+n) for structural variable

  *Example*:

    > lpx::check_kkt lp true;
    [(1.4210854715202e-14,2,3.54385404369127e-17,3,"H"),(0.0,0,0.0,0,"H"),
    (4.44089209850063e-16,1,2.11471052309554e-17,1,"H"),(0.0,0,0.0,0,"H")]



File: pure-glpk.info,  Node: Utility API routines,  Next: Advanced API routines,  Prev: Basic API routines,  Up: Descriptions of interface functions

5.2 Utility API routines
========================

* Menu:

* Problem data reading/writing routines::
* Routines for MathProg models::
* Problem solution reading/writing routines::


File: pure-glpk.info,  Node: Problem data reading/writing routines,  Next: Routines for MathProg models,  Up: Utility API routines

5.2.1 Problem data reading/writing routines
-------------------------------------------

* Menu:

* Read LP problem data from a MPS file::
* Write LP problem data into a MPS file::
* Read LP problem data from a CPLEX file::
* Write LP problem data into a CPLEX file::
* Read LP problem data in GLPK format::
* Write LP problem data in GLPK format::


File: pure-glpk.info,  Node: Read LP problem data from a MPS file,  Next: Write LP problem data into a MPS file,  Up: Problem data reading/writing routines

5.2.1.1 Read LP problem data from a MPS file
............................................

*Synopsis*:

    glp::read_mps lp format filename

*Parameters*:

          lp: pointer to the LP problem object

          format: one of the following

               glp::mps_deck: fixed (ancient) MPS file format

               glp::mps_file: free (modern) MPS file format

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::read_mps decompresses it “on the fly”

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_mps lp glp::mps_deck "examples/plan.mps";
    Reading problem data from `examples/plan.mps'...
    Problem PLAN
    Objective R0000000
    8 rows, 7 columns, 55 non-zeros
    63 records were read
    0



File: pure-glpk.info,  Node: Write LP problem data into a MPS file,  Next: Read LP problem data from a CPLEX file,  Prev: Read LP problem data from a MPS file,  Up: Problem data reading/writing routines

5.2.1.2 Write LP problem data into a MPS file
.............................................

*Synopsis*:

    glp::write_mps lp format filename

*Parameters*:

          lp: pointer to the LP problem object

          format: one of the following

               glp::mps_deck: fixed (ancient) MPS file format

               glp::mps_file: free (modern) MPS file format

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp_write_mps performs automatic compression on
          writing it

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_mps lp glp::mps_file "examples/plan1.mps";
    Writing problem data to `examples/plan1.mps'...
    63 records were written
    0



File: pure-glpk.info,  Node: Read LP problem data from a CPLEX file,  Next: Write LP problem data into a CPLEX file,  Prev: Write LP problem data into a MPS file,  Up: Problem data reading/writing routines

5.2.1.3 Read LP problem data from a CPLEX file
..............................................

*Synopsis*:

    glp::read_lp lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::read_lp decompresses it “on the fly”

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::read_lp lp "examples/plan.lp";
    reading problem data from `examples/plan.lp'...
    8 rows, 7 columns, 48 non-zeros
    39 lines were read
    0



File: pure-glpk.info,  Node: Write LP problem data into a CPLEX file,  Next: Read LP problem data in GLPK format,  Prev: Read LP problem data from a CPLEX file,  Up: Problem data reading/writing routines

5.2.1.4 Write LP problem data into a CPLEX file
...............................................

*Synopsis*:

    glp::write_lp lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::write_lp performs automatic compression on
          writing it

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_lp lp "examples/plan1.lp";
    writing problem data to `examples/plan1.lp'...
    29 lines were written
    0



File: pure-glpk.info,  Node: Read LP problem data in GLPK format,  Next: Write LP problem data in GLPK format,  Prev: Write LP problem data into a CPLEX file,  Up: Problem data reading/writing routines

5.2.1.5 Read LP problem data in GLPK format
...........................................

*Synopsis*:

    glp::read_prob lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::read_prob decompresses it “on the fly”

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::read_prob lp "examples/plan.glpk";
    reading problem data from `examples/plan.glpk'...
    8 rows, 7 columns, 48 non-zeros
    86 lines were read
    0



File: pure-glpk.info,  Node: Write LP problem data in GLPK format,  Prev: Read LP problem data in GLPK format,  Up: Problem data reading/writing routines

5.2.1.6 Write LP problem data in GLPK format
............................................

*Synopsis*:

    glp::write_prob lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::write_prob performs automatic compression on
          writing it

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_prob lp "examples/plan1.glpk";
    writing problem data to `examples/plan1.glpk'...
    86 lines were written
    0



File: pure-glpk.info,  Node: Routines for MathProg models,  Next: Problem solution reading/writing routines,  Prev: Problem data reading/writing routines,  Up: Utility API routines

5.2.2 Routines for MathProg models
----------------------------------

* Menu:

* Create the MathProg translator object::
* Read and translate model section::
* Read and translate data section::
* Generate the model::
* Build problem instance from the model::
* Postsolve the model::
* Delete the MathProg translator object::


File: pure-glpk.info,  Node: Create the MathProg translator object,  Next: Read and translate model section,  Up: Routines for MathProg models

5.2.2.1 Create the MathProg translator object
.............................................

*Synopsis*:

    glp::mpl_alloc_wksp

*Parameters*:

     none

  *Returns*:

     pointer to the MathProg translator object

  *Example*:

    > let mpt = glp::mpl_alloc_wksp;
    > mpt;
    #<pointer 0xa0d0180>



File: pure-glpk.info,  Node: Read and translate model section,  Next: Read and translate data section,  Prev: Create the MathProg translator object,  Up: Routines for MathProg models

5.2.2.2 Read and translate model section
........................................

*Synopsis*:

    glp::mpl_read_model tranobject filename skip

*Parameters*:

          tranobject: pointer to the MathProg translator object

          filename: file name

          skip: if *0* then the data section from the model file is
          read; if non-zero, the data section in the data model is
          skipped

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > mpl_read_model mpt "examples/sudoku.mod" 1;
    Reading model section from examples/sudoku.mod...
    examples/sudoku.mod:69: warning: data section ignored
    69 lines were read
    0



File: pure-glpk.info,  Node: Read and translate data section,  Next: Generate the model,  Prev: Read and translate model section,  Up: Routines for MathProg models

5.2.2.3 Read and translate data section
.......................................

*Synopsis*:

    glp::mpl_read_data tranobject filename

*Parameters*:

          tranobject: pointer to the MathProg translator object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::mpl_read_data mpt "examples/sudoku.dat";
    Reading data section from examples/sudoku.dat...
    16 lines were read
    0



File: pure-glpk.info,  Node: Generate the model,  Next: Build problem instance from the model,  Prev: Read and translate data section,  Up: Routines for MathProg models

5.2.2.4 Generate the model
..........................

*Synopsis*:

    glp::mpl_generate tranobject filename

*Parameters*:

          tranobject: pointer to the MathProg translator object

          filename: file name

  *Returns*:

     *0* if generating went OK; non-zero in case of an error

  *Example*:

    > glp::mpl_generate mpt "examples/sudoku.lst";
    Generating fa...
    Generating fb...
    Generating fc...
    Generating fd...
    Generating fe...
    Model has been successfully generated
    0



File: pure-glpk.info,  Node: Build problem instance from the model,  Next: Postsolve the model,  Prev: Generate the model,  Up: Routines for MathProg models

5.2.2.5 Build problem instance from the model
.............................................

*Synopsis*:

    glp::mpl_build_prob tranobject lp

*Parameters*:

          tranobject: pointer to the MathProg translator object

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::mpl_build_prob mpt lp;
    ()



File: pure-glpk.info,  Node: Postsolve the model,  Next: Delete the MathProg translator object,  Prev: Build problem instance from the model,  Up: Routines for MathProg models

5.2.2.6 Postsolve the model
...........................

*Synopsis*:

    glp::mpl_postsolve tran lp solution

*Parameters*:

          tranobject: pointer to the MathProg translator object

          lp: pointer to the LP problem object

          solution: one of the following:

               glp::sol: use the basic solution

               glp::ipt: use the interior-point solution

               glp::mip: use mixed integer solution

  *Returns*:

     *0* if postsolve went OK; non-zero in case of an error

  *Example*:

    > glp::mpl_postsolve mpt lp glp::sol;
    Model has been successfully processed
    0



File: pure-glpk.info,  Node: Delete the MathProg translator object,  Prev: Postsolve the model,  Up: Routines for MathProg models

5.2.2.7 Delete the MathProg translator object
.............................................

*Synopsis*:

    glp::mpl_free_wksp tranobject

*Parameters*:

          tranobject: pointer to the MathProg translator object

  *Returns*:

     `()'

  *Example*:

    > glp::mpl_free_wksp mpt;
    ()



File: pure-glpk.info,  Node: Problem solution reading/writing routines,  Prev: Routines for MathProg models,  Up: Utility API routines

5.2.3 Problem solution reading/writing routines
-----------------------------------------------

* Menu:

* Write basic solution in printable format::
* Read basic solution from a text file::
* Write basic solution into a text file::
* Print sensitivity analysis report::
* Write interior-point solution in printable format::
* Read interior-point solution from a text file::
* Write interior-point solution into a text file::
* Write MIP solution in printable format::
* Read MIP solution from a text file::
* Write MIP solution into a text file::


File: pure-glpk.info,  Node: Write basic solution in printable format,  Next: Read basic solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.1 Write basic solution in printable format
................................................

*Synopsis*:

    glp::print_sol lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::print_sol lp "examples/test.txt";
    Writing basic solution to `examples/test.txt'...
    0



File: pure-glpk.info,  Node: Read basic solution from a text file,  Next: Write basic solution into a text file,  Prev: Write basic solution in printable format,  Up: Problem solution reading/writing routines

5.2.3.2 Read basic solution from a text file
............................................

*Synopsis*:

    glp::read_sol lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_sol lp "examples/test.txt";
    Reading basic solution from `examples/test.txt'...
    1235 lines were read
    0



File: pure-glpk.info,  Node: Write basic solution into a text file,  Next: Print sensitivity analysis report,  Prev: Read basic solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.3 Write basic solution into a text file
.............................................

*Synopsis*:

    glp::write_sol lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_sol lp "examples/test.txt";
    Writing basic solution to `examples/test.txt'...
    1235 lines were written
    0



File: pure-glpk.info,  Node: Print sensitivity analysis report,  Next: Write interior-point solution in printable format,  Prev: Write basic solution into a text file,  Up: Problem solution reading/writing routines

5.2.3.4 Print sensitivity analysis report
.........................................

*Synopsis*:

    glp::print_ranges lp indices filename

*Parameters*:

          lp: pointer to the LP problem object

          indices: list indices k of of rows and columns to be included
          in the report.  If 1 ≤ k ≤ m, the basic variable is k-th
          auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic
          variable is (k − m)-th structural variable, where m is the
          number of rows and n is the number of columns in the
          specified problem object. An empty lists means printing
          report for all rows and columns.

          filename: file name

  *Returns*:

          0: if the operation was successful

          non-zero: if the operation failed

  *Example*:

    > glp::print_ranges lp [] "sensitivity.rpt";
    Write sensitivity analysis report to `sensitivity.rpt'...
    0



File: pure-glpk.info,  Node: Write interior-point solution in printable format,  Next: Read interior-point solution from a text file,  Prev: Print sensitivity analysis report,  Up: Problem solution reading/writing routines

5.2.3.5 Write interior-point solution in printable format
.........................................................

*Synopsis*:

    glp::print_ipt lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::print_ipt lp "examples/test.txt";
    Writing interior-point solution to `examples/test.txt'...
    0



File: pure-glpk.info,  Node: Read interior-point solution from a text file,  Next: Write interior-point solution into a text file,  Prev: Write interior-point solution in printable format,  Up: Problem solution reading/writing routines

5.2.3.6 Read interior-point solution from a text file
.....................................................

*Synopsis*:

    glp::read_ipt lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_ipt lp "examples/test.txt";
    Reading interior-point solution from `examples/test.txt'...
    1235 lines were read
    0



File: pure-glpk.info,  Node: Write interior-point solution into a text file,  Next: Write MIP solution in printable format,  Prev: Read interior-point solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.7 Write interior-point solution into a text file
......................................................

*Synopsis*:

    glp::write_ipt lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_ipt lp "examples/test.txt";
    Writing interior-point solution to `examples/test.txt'...
    1235 lines were written
    0



File: pure-glpk.info,  Node: Write MIP solution in printable format,  Next: Read MIP solution from a text file,  Prev: Write interior-point solution into a text file,  Up: Problem solution reading/writing routines

5.2.3.8 Write MIP solution in printable format
..............................................

*Synopsis*:

    glp::print_mip lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::print_mip lp "examples/test.txt";
    Writing MIP solution to `examples/test.txt'...
    0



File: pure-glpk.info,  Node: Read MIP solution from a text file,  Next: Write MIP solution into a text file,  Prev: Write MIP solution in printable format,  Up: Problem solution reading/writing routines

5.2.3.9 Read MIP solution from a text file
..........................................

*Synopsis*:

    glp::read_mip lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_mip lp "examples/test.txt";
    Reading MIP solution from `examples/test.txt'...
    1235 lines were read
    0



File: pure-glpk.info,  Node: Write MIP solution into a text file,  Prev: Read MIP solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.10 Write MIP solution into a text file
............................................

*Synopsis*:

    glp::write_mip lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_mip lp "examples/test.txt";
    Writing MIP solution to `examples/test.txt'...
    1235 lines were written
    0



File: pure-glpk.info,  Node: Advanced API routines,  Next: Branch-and-cut API routines,  Prev: Utility API routines,  Up: Descriptions of interface functions

5.3 Advanced API routines
=========================

* Menu:

* LP basis routines::
* Simplex tableau routines::


File: pure-glpk.info,  Node: LP basis routines,  Next: Simplex tableau routines,  Up: Advanced API routines

5.3.1 LP basis routines
-----------------------

* Menu:

* Check whether basis factorization exists::
* Compute the basis factorization::
* Check whether basis factorization has been updated::
* Get basis factorization parameters::
* Change basis factorization parameters::
* Retrieve the basis header information::
* Retrieve row index in the basis header::
* Retrieve column index in the basis header::
* Perform forward transformation::
* Perform backward transformation::
* Warm up LP basis::


File: pure-glpk.info,  Node: Check whether basis factorization exists,  Next: Compute the basis factorization,  Up: LP basis routines

5.3.1.1 Check whether basis factorization exists
................................................

*Synopsis*:

    glp::bf_exists lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

          non-zero: the basis factorization exists and can be used for
          calculations

          0: the basis factorization does not exist

  *Example*:

    > glp::bf:exists lp;
    1



File: pure-glpk.info,  Node: Compute the basis factorization,  Next: Check whether basis factorization has been updated,  Prev: Check whether basis factorization exists,  Up: LP basis routines

5.3.1.2 Compute the basis factorization
.......................................

*Synopsis*:

    glp::factorize lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::ok: the basis factorization has been successfully
          computed

          glp::ebadb: the basis matrix is invalid, because the number
          of basic (auxiliary and structural) variables is not the same
          as the number of rows in the problem object

          glp::esing: the basis matrix is singular within the working
          precision

          glp::exond: the basis matrix is ill-conditioned, i.e. its
          condition number is too large

  *Example*:

    > glp::factorize lp;
    glp::ok



File: pure-glpk.info,  Node: Check whether basis factorization has been updated,  Next: Get basis factorization parameters,  Prev: Compute the basis factorization,  Up: LP basis routines

5.3.1.3 Check whether basis factorization has been updated
..........................................................

*Synopsis*:

    glp::bf_updated lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

          0: if the basis factorization has been just computed from
          “scratch”

          non-zero: if the factorization has been updated at least once

  *Example*:

    > glp::bf_updated lp;
    0



File: pure-glpk.info,  Node: Get basis factorization parameters,  Next: Change basis factorization parameters,  Prev: Check whether basis factorization has been updated,  Up: LP basis routines

5.3.1.4 Get basis factorization parameters
..........................................

*Synopsis*:

    glp::get_bfcp lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     complete list of options in a form of tuples (option_name, value):

          glp::type: basis factorization type:

               glp::bf_ft: LU + Forrest–Tomlin update

               glp::bf_bg: LU + Schur complement + Bartels–Golub update

               glp::bf_gr: LU + Schur complement + Givens rotation
               update

          glp::lu_size: the initial size of the Sparse Vector Area, in
          non-zeros, used on computing LU-factorization of the basis
          matrix for the first time - if this parameter is set to 0,
          the initial SVA size is determined automatically

          glp::piv_tol: threshold pivoting (Markowitz) tolerance, 0 <
          piv_tol < 1, used on computing LU-factorization of the basis
          matrix

          glp::piv_lim: this parameter is used on computing
          LU-factorization of the basis matrix and specifies how many
          pivot candidates needs to be considered on choosing a pivot
          element, piv_lim ≥ 1

          glp::suhl: this parameter is used on computing
          LU-factorization of the basis matrix

               glp::on: enables applying the heuristic proposed by Uwe
               Suhl

               glp::off: disables this heuristic

          glp::eps_tol: epsilon tolerance, eps_tol ≥ 0, used on
          computing LU-factorization of the basis matrix

          glp::max_gro: maximal growth of elements of factor U, max_gro
          ≥ 1, allowable on computing LU-factorization of the basis
          matrix

          glp::nfs_max: maximal number of additional row-like factors
          (entries of the eta file), nfs_max ≥ 1, which can be added to
          LU-factorization of the basis matrix on updating it with the
          Forrest–Tomlin technique

          glp::upd_tol: update tolerance, 0 < upd_tol < 1, used on
          updating LU-factorization of the basis matrix with the
          Forrest–Tomlin technique

          glp::nrs_max: maximal number of additional rows and columns,
          nrs_max ≥ 1, which can be added to LU-factorization of the
          basis matrix on updating it with the Schur complement
          technique

          glp::rs_size: the initial size of the Sparse Vector Area, in
          non-zeros, used to store non-zero elements of additional rows
          and columns introduced on updating LU-factorization of the
          basis matrix with the Schur complement technique - if this
          parameter is set to 0, the initial SVA size is determined
          automatically

  *Example*:

    > glp::get_bfcp lp;
    [(glp::type,glp::bf_ft),(glp::lu_size,0),(glp::piv_tol,0.1),(glp::piv_lim,4),
    (glp::suhl,glp::on),(glp::eps_tol,1e-15),(glp::max_gro,10000000000.0),
    (glp::nfs_max,50),(glp::upd_tol,1e-06),(glp::nrs_max,50),(glp::rs_size,0)]



File: pure-glpk.info,  Node: Change basis factorization parameters,  Next: Retrieve the basis header information,  Prev: Get basis factorization parameters,  Up: LP basis routines

5.3.1.5 Change basis factorization parameters
.............................................

*Synopsis*:

    glp::set_bfcp lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of options in a form of tuples (option_name,
          value):

          glp::type: (default: glp::bf_ft) - basis factorization type:

               glp::bf_ft: LU + Forrest–Tomlin update

               glp::bf_bg: LU + Schur complement + Bartels–Golub update

               glp::bf_gr: LU + Schur complement + Givens rotation
               update

          glp::lu_size: (default: 0) - the initial size of the Sparse
          Vector Area, in non-zeros, used on computing LU-factorization
          of the basis matrix for the first time - if this parameter is
          set to 0, the initial SVA size is determined automatically

          glp::piv_tol: (default: 0.10) - threshold pivoting
          (Markowitz) tolerance, 0 < piv_tol < 1, used on computing
          LU-factorization of the basis matrix.

          glp::piv_lim: (default: 4) - this parameter is used on
          computing LU-factorization of the basis matrix and specifies
          how many pivot candidates needs to be considered on choosing
          a pivot element, piv_lim ≥ 1

          glp::suhl: (default: glp::on) - this parameter is used on
          computing LU-factorization of the basis matrix.

               glp::on: enables applying the heuristic proposed by Uwe
               Suhl

               glp::off: disables this heuristic

          glp::eps_tol: (default: 1e-15) - epsilon tolerance, eps_tol ≥
          0, used on computing LU -factorization of the basis matrix.

          glp::max_gro: (default: 1e+10) - maximal growth of elements
          of factor U, max_gro ≥ 1, allowable on computing
          LU-factorization of the basis matrix.

          glp::nfs_max: (default: 50) - maximal number of additional
          row-like factors (entries of the eta file), nfs_max ≥ 1,
          which can be added to LU-factorization of the basis matrix on
          updating it with the Forrest–Tomlin technique.

          glp::upd_tol: (default: 1e-6) - update tolerance, 0 < upd_tol
          < 1, used on updating LU -factorization of the basis matrix
          with the Forrest–Tomlin technique.

          glp::nrs_max: (default: 50) - maximal number of additional
          rows and columns, nrs_max ≥ 1, which can be added to
          LU-factorization of the basis matrix on updating it with the
          Schur complement technique.

          glp::rs_size: (default: 0) - the initial size of the Sparse
          Vector Area, in non-zeros, used to store non-zero elements of
          additional rows and columns introduced on updating
          LU-factorization of the basis matrix with the Schur
          complement technique - if this parameter is set to 0, the
          initial SVA size is determined automatically

  *Remarks*:

     Options not mentioned in the option list are left unchanged.

     All options will be reset to their default values when an empty
     option list is supplied.

  *Returns*:

     `()' if all options are OK, otherwise returns a list of bad options

  *Example*:

    > glp_set_bfcp lp [(glp::type, glp::bf_ft), (glp::piv_tol, 0.15)];
    ()



File: pure-glpk.info,  Node: Retrieve the basis header information,  Next: Retrieve row index in the basis header,  Prev: Change basis factorization parameters,  Up: LP basis routines

5.3.1.6 Retrieve the basis header information
.............................................

*Synopsis*:

    glp::get_bhead lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: variable index in the basis matrix

  *Returns*:

     If basic variable (xB )k , 1 ≤ k ≤ m, is i-th auxiliary variable
     (1 ≤ i ≤ m), the routine returns i. Otherwise, if (xB )k is j-th
     structural variable (1 ≤ j ≤ n), the routine returns m+j. Here m
     is the number of rows and n is the number of columns in the
     problem object.

  *Example*:

    > glp::get_bhead lp 3;
    5



File: pure-glpk.info,  Node: Retrieve row index in the basis header,  Next: Retrieve column index in the basis header,  Prev: Retrieve the basis header information,  Up: LP basis routines

5.3.1.7 Retrieve row index in the basis header
..............................................

*Synopsis*:

    glp::get_row_bind lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤
     m, which is i-th auxiliary variable (that is, the auxiliary
     variable corresponding to i-th row), 1 ≤ i ≤ m, in the current
     basis associated with the specified problem object, where m is the
     number of rows. However, if i-th auxiliary variable is non-basic,
     the routine returns zero.

  *Example*:

    > glp::get_row_bind lp 3;
    1



File: pure-glpk.info,  Node: Retrieve column index in the basis header,  Next: Perform forward transformation,  Prev: Retrieve row index in the basis header,  Up: LP basis routines

5.3.1.8 Retrieve column index in the basis header
.................................................

*Synopsis*:

    glp::get_col_bind lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤
     m, which is j-th structural variable (that is, the structural
     variable corresponding to j-th column), 1 ≤ j ≤ n, in the current
     basis associated with the specified problem object, where m is the
     number of rows, n is the number of columns. However, if j-th
     structural variable is non-basic, the routine returns zero.

  *Example*:

    > glp::get_col_bind lp 2;
    3



File: pure-glpk.info,  Node: Perform forward transformation,  Next: Perform backward transformation,  Prev: Retrieve column index in the basis header,  Up: LP basis routines

5.3.1.9 Perform forward transformation
......................................

*Synopsis*:

    glp::ftran lp vector

*Parameters*:

          lp: pointer to the LP problem object

          vector: vector to be transformed - a dense vector in a form
          of a list of double numbers has to be supplied and the number
          of its members must exactly correspond to the number of LP
          problem constraints

  *Returns*:

     the transformed vector in the same format

  *Example*:

    > glp::ftran lp [1.5, 3.2, 4.8];
    [1.8,0.466666666666667,-1.96666666666667]



File: pure-glpk.info,  Node: Perform backward transformation,  Next: Warm up LP basis,  Prev: Perform forward transformation,  Up: LP basis routines

5.3.1.10 Perform backward transformation
........................................

*Synopsis*:

    glp::btran lp vector

*Parameters*:

          lp: pointer to the LP problem object

          vector: vector to be transformed - a dense vector in a form
          of a list of double numbers has to be supplied and the number
          of its members must exactly correspond to the number of LP
          problem constraints

  *Returns*:

     the transformed vector in the same format

  *Example*:

    > glp::btran lp [1.5, 3.2, 4.8];
    [-8.86666666666667,0.266666666666667,1.5]



File: pure-glpk.info,  Node: Warm up LP basis,  Prev: Perform backward transformation,  Up: LP basis routines

5.3.1.11 Warm up LP basis
.........................

*Synopsis*:

    glp::warm_up lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::ok: the LP basis has been successfully “warmed up”

          glp::ebadb: the LP basis is invalid, because the number of
          basic variables is not the same as the number of rows

          glp::esing: the basis matrix is singular within the working
          precision

          glp::econd: the basis matrix is ill-conditioned, i.e. its
          condition number is too large

  *Example*:

    > glp::warm_up lp;
    glp::e_ok



File: pure-glpk.info,  Node: Simplex tableau routines,  Prev: LP basis routines,  Up: Advanced API routines

5.3.2 Simplex tableau routines
------------------------------

* Menu:

* Compute row of the tableau::
* Compute column of the tableau::
* Transform explicitly specified row::
* Transform explicitly specified column::
* Perform primal ratio test::
* Perform dual ratio test::
* Analyze active bound of non-basic variable::
* Analyze objective coefficient at basic variable::


File: pure-glpk.info,  Node: Compute row of the tableau,  Next: Compute column of the tableau,  Up: Simplex tableau routines

5.3.2.1 Compute row of the tableau
..................................

*Synopsis*:

    glp::eval_tab_row lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: variable index such that it corresponds to some basic
          variable: if 1 ≤ k ≤ m, the basic variable is k-th auxiliary
          variable, and if m + 1 ≤ k ≤ m + n, the basic variable is (k
          − m)-th structural variable, where m is the number of rows
          and n is the number of columns in the specified problem
          object (the basis factorization must exist)

  *Returns*:

     simplex tableau row in a sparse form as a list of tuples (index,
     value), where index has the same meaning as k in parameters

  *Example*:

    > glp::eval_tab_row lp 3;
    [(1,2.0),(6,4.0)]



File: pure-glpk.info,  Node: Compute column of the tableau,  Next: Transform explicitly specified row,  Prev: Compute row of the tableau,  Up: Simplex tableau routines

5.3.2.2 Compute column of the tableau
.....................................

*Synopsis*:

    glp::eval_tab_col lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: variable index such that it corresponds to some non-basic
          variable: if 1 ≤ k ≤ m, the non-basic variable is k-th
          auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic
          variable is (k − m)-th structural variable, where m is the
          number of rows and n is the number of columns in the
          specified problem object (the basis factorization must exist)

  *Returns*:

     simplex tableau column in a sparse form as a list of tuples
     (index, value), where index has the same meaning as k in parameters

  *Example*:

    > glp::eval_tab_col lp 1;
    [(3,2.0),(4,-0.666666666666667),(5,1.66666666666667)]



File: pure-glpk.info,  Node: Transform explicitly specified row,  Next: Transform explicitly specified column,  Prev: Compute column of the tableau,  Up: Simplex tableau routines

5.3.2.3 Transform explicitly specified row
..........................................

*Synopsis*:

    glp::transform_row lp rowvector

*Parameters*:

          lp: pointer to the LP problem object

          rowvector: row vector to be transformed in a sparse form as a
          list of tuples (k, value): if 1 ≤ k ≤ m, the non-basic
          variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m +
          n, the non-basic variable is (k − m)-th structural variable,
          where m is the number of rows and n is the number of columns
          in the specified problem object (the basis factorization must
          exist)

  *Returns*:

     the transformed row in a sparse form as a list of tuples (index,
     value), where index has the same meaning as k in parameters

  *Example*:

    > glp::transform_row lp [(1, 3.0), (2, 3.5)];
    [(1,3.83333333333333),(2,-0.0833333333333333),(6,-3.41666666666667)]



File: pure-glpk.info,  Node: Transform explicitly specified column,  Next: Perform primal ratio test,  Prev: Transform explicitly specified row,  Up: Simplex tableau routines

5.3.2.4 Transform explicitly specified column
.............................................

*Synopsis*:

    glp::transform_col lp colvector

*Parameters*:

          lp: pointer to the LP problem object

          colvector: column vector to be transformed in a sparse form
          as a list of tuples (k, value): if 1 ≤ k ≤ m, the non-basic
          variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m +
          n, the non-basic variable is (k − m)-th structural variable,
          where m is the number of rows and n is the number of columns
          in the specified problem object (the basis factorization must
          exist)

  *Returns*:

     the transformed column in a sparse form as a list of tuples
     (index, value), where index has the same meaning as k in parameters

  *Example*:

    > glp::transform_col lp [(2, 1.0), (3, 2.3)];
    [(3,2.3),(4,-0.166666666666667),(5,0.166666666666667)]



File: pure-glpk.info,  Node: Perform primal ratio test,  Next: Perform dual ratio test,  Prev: Transform explicitly specified column,  Up: Simplex tableau routines

5.3.2.5 Perform primal ratio test
.................................

*Synopsis*:

    glp::prim_rtest lp colvector dir eps

*Parameters*:

          lp: pointer to the LP problem object

          colvector: simplex tableau column in a sparse form as a list
          of tuples (k, value): if 1 ≤ k ≤ m, the basic variable is k-th
          auxiliary variable, and if m + 1 ≤ k ≤ m + n, the basic
          variable is (k − m)-th structural variable, where m is the
          number of rows and n is the number of columns in the
          specified problem object (the basis factorization must exist
          and the primal solution must be feasible)

          dir: specifies in which direction the variable y changes on
          entering the basis: +1 means increasing, −1 means decreasing

          eps: relative tolerance (small positive number) used to skip
          small values in the column

  *Returns*:

     The routine returns the index, piv, in the colvector corresponding
     to the pivot element chosen, 1 ≤ piv ≤ len. If the adjacent basic
     solution is primal unbounded, and therefore the choice cannot be
     made, the routine returns zero.

  *Example*:

    > glp::prim_rtest lp [(3, 2.5), (5, 7.0)] 1 1.0e-5;
    3



File: pure-glpk.info,  Node: Perform dual ratio test,  Next: Analyze active bound of non-basic variable,  Prev: Perform primal ratio test,  Up: Simplex tableau routines

5.3.2.6 Perform dual ratio test
...............................

*Synopsis*:

    glp::dual_rtest lp rowvector dir eps

*Parameters*:

          lp: pointer to the LP problem object

          rowvector: simplex tableau row in a sparse form as a list of
          tuples (k, value): if 1 ≤ k ≤ m, the non-basic variable is
          k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the
          non-basic variable is (k − m)-th structural variable, where m
          is the number of rows and n is the number of columns in the
          specified problem object (the basis factorization must exist
          and the dual solution must be feasible)

          dir: specifies in which direction the variable y changes on
          leaving the basis: +1 means increasing, −1 means decreasing

          eps: relative tolerance (small positive number) used to skip
          small values in the row

  *Returns*:

     The routine returns the index, piv, in the rowvector corresponding
     to the pivot element chosen, 1 ≤ piv ≤ len. If the adjacent basic
     solution is dual unbounded, and therefore the choice cannot be
     made, the routine returns zero.

  *Example*:

    > glp::dual_rtest lp [(1, 1.5), (6, 4.0)] 1 1.0e-5;
    6



File: pure-glpk.info,  Node: Analyze active bound of non-basic variable,  Next: Analyze objective coefficient at basic variable,  Prev: Perform dual ratio test,  Up: Simplex tableau routines

5.3.2.7 Analyze active bound of non-basic variable
..................................................

*Synopsis*:

    glp::analyze_bound lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary
          variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is
          (k − m)-th structural variable, where m is the number of rows
          and n is the number of columns in the specified problem
          object (the basis factorization must exist and the solution
          must be optimal)

  *Returns*:

     The routine returns a tuple (limit1, var1, limit2 var2) where:

          value1: the minimal value of the active bound, at which the
          basis still remains primal feasible and thus optimal.
          -DBL_MAX means that the active bound has no lower limit.

          var1: the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) basic variable, which reaches its
          bound first and thereby limits further decreasing the active
          bound being analyzed. If value1 = -DBL_MAX, var1 is set to 0.

          value2: the maximal value of the active bound, at which the
          basis still remains primal feasible and thus optimal.
          +DBL_MAX means that the active bound has no upper limit.

          var2: the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) basic variable, which reaches its
          bound first and thereby limits further increasing the active
          bound being analyzed. If value2 = +DBL_MAX, var2 is set to 0.

  *Example*:

    > analyze_bound lp 2;
    1995.06864446899,12,2014.03478832467,4



File: pure-glpk.info,  Node: Analyze objective coefficient at basic variable,  Prev: Analyze active bound of non-basic variable,  Up: Simplex tableau routines

5.3.2.8 Analyze objective coefficient at basic variable
.......................................................

*Synopsis*:

    glp::analyze_coef lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: if 1 ≤ k ≤ m, the basic variable is k-th auxiliary
          variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is
          (k − m)-th structural variable, where m is the number of rows
          and n is the number of columns in the specified problem
          object (the basis factorization must exist and the solution
          must be optimal)

  *Returns*:

     The routine returns a tuple (coef1, var1, value1, coef2 var2,
     value2) where:

          coef1: the minimal value of the objective coefficient, at
          which the basis still remains dual feasible and thus optimal.
          -DBL_MAX means that the objective coefficient has no lower
          limit.

          var1: is the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) non-basic variable, whose reduced
          cost reaches its zero bound first and thereby limits further
          decreasing the objective coefficient being analyzed. If coef1
          = -DBL_MAX, var1 is set to 0.

          value1: value of the basic variable being analyzed in an
          adjacent basis, which is defined as follows. Let the
          objective coefficient reaches its minimal value (coef1) and
          continues decreasing. Then the reduced cost of the limiting
          non-basic variable (var1) becomes dual infeasible and the
          current basis becomes non-optimal that forces the limiting
          non-basic variable to enter the basis replacing there some
          basic variable that leaves the basis to keep primal
          feasibility. Should note that on determining the adjacent
          basis current bounds of the basic variable being analyzed are
          ignored as if it were free (unbounded) variable, so it cannot
          leave the basis. It may happen that no dual feasible adjacent
          basis exists, in which case value1 is set to -DBL_MAX or
          +DBL_MAX.

          coef2: the maximal value of the objective coefficient, at
          which the basis still remains dual feasible and thus optimal.
          +DBL_MAX means that the objective coefficient has no upper
          limit.

          var2: the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) non-basic variable, whose reduced
          cost reaches its zero bound first and thereby limits further
          increasing the objective coefficient being analyzed. If coef2
          = +DBL_MAX, var2 is set to 0.

          value2: value of the basic variable being analyzed in an
          adjacent basis, which is defined exactly in the same way as
          value1 above with exception that now the objective
          coefficient is increasing.

  *Example*:

    > analyze_coef lp 1;
    -1.0,3,306.771624713959,1.79769313486232e+308,0,296.216606498195



File: pure-glpk.info,  Node: Branch-and-cut API routines,  Next: Graph and network API routines,  Prev: Advanced API routines,  Up: Descriptions of interface functions

5.4 Branch-and-cut API routines
===============================

     All branch-and-cut API routines are supposed to be called from the
     callback routine. They cannot be called directly.

* Menu:

* Basic routines::
* The search tree exploring routines::
* The cut pool routines::


File: pure-glpk.info,  Node: Basic routines,  Next: The search tree exploring routines,  Up: Branch-and-cut API routines

5.4.1 Basic routines
--------------------

* Menu:

* Determine reason for calling the callback routine::
* Access the problem object::
* Determine additional row attributes::
* Compute relative MIP gap::
* Access application-specific data::
* Select subproblem to continue the search::
* Provide solution found by heuristic::
* Check whether can branch upon specified variable::
* Choose variable to branch upon::
* Terminate the solution process::


File: pure-glpk.info,  Node: Determine reason for calling the callback routine,  Next: Access the problem object,  Up: Basic routines

5.4.1.1 Determine reason for calling the callback routine
.........................................................

*Synopsis*:

    glp::ios_reason tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     one of the following:

          glp::irowgen: request for row generation

          glp::ibingo: better integer solution found

          glp::iheur: request for heuristic solution

          glp::icutgen: request for cut generation

          glp::ibranch: request for branching

          glp::iselect: request for subproblem selection

          glp::iprepro: request for preprocessing

  *Example*:

    glp::ios:reason tree;



File: pure-glpk.info,  Node: Access the problem object,  Next: Determine additional row attributes,  Prev: Determine reason for calling the callback routine,  Up: Basic routines

5.4.1.2 Access the problem object
.................................

*Synopsis*:

    glp::ios_get_prob tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns a pointer to the problem object used by the
     MIP solver.

  *Example*:

    glp::ios_get_prob tree;



File: pure-glpk.info,  Node: Determine additional row attributes,  Next: Compute relative MIP gap,  Prev: Access the problem object,  Up: Basic routines

5.4.1.3 Determine additional row attributes
...........................................

*Synopsis*:

    glp::ios_row_attr tree rowindex

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          rowindex: row index

  *Returns*:

     The routine returns a tuple consisting of three values (level,
     origin, klass):

          level: subproblem level at which the row was created

          origin: the row origin flag - one of the following:

               glp::rf_reg: regular constraint

               glp::rf_lazy: “lazy” constraint

               glp::rf_cut: cutting plane constraint

          klass: the row class descriptor, which is a number passed to
          the routine glp_ios_add_row as its third parameter - if the
          row is a cutting plane constraint generated by the solver,
          its class may be the following:

               glp::rf_gmi: Gomory’s mixed integer cut

               glp::rf_mir: mixed integer rounding cut

               glp::rf_cov: mixed cover cut

               glp::rf_clq: clique cut

  *Example*:

    glp::ios_row_attr tree 3;



File: pure-glpk.info,  Node: Compute relative MIP gap,  Next: Access application-specific data,  Prev: Determine additional row attributes,  Up: Basic routines

5.4.1.4 Compute relative MIP gap
................................

*Synopsis*:

    glp::ios_mip_gap tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the relative MIP gap.

  *Example*:

    > glp::ios_mip_gap tree;



File: pure-glpk.info,  Node: Access application-specific data,  Next: Select subproblem to continue the search,  Prev: Compute relative MIP gap,  Up: Basic routines

5.4.1.5 Access application-specific data
........................................

*Synopsis*:

    glp::ios_node_data tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine glp_ios_node_data returns a pointer to the memory
     block for the specified subproblem. Note that if cb_size = 0 was
     specified in the call of the *intopt* function, the routine
     returns a null pointer.

  *Example*:

    > glp::ios_node_data tree 23;



File: pure-glpk.info,  Node: Select subproblem to continue the search,  Next: Provide solution found by heuristic,  Prev: Access application-specific data,  Up: Basic routines

5.4.1.6 Select subproblem to continue the search
................................................

*Synopsis*:

    glp::ios_select_node tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of the subproblem from which the
          search will continue

  *Returns*:

     ()

  *Example*:

    > glp::ios_select_node tree 23;



File: pure-glpk.info,  Node: Provide solution found by heuristic,  Next: Check whether can branch upon specified variable,  Prev: Select subproblem to continue the search,  Up: Basic routines

5.4.1.7 Provide solution found by heuristic
...........................................

*Synopsis*:

    glp::ios_heur_sol tree colvector

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          colvector: solution found by a primal heuristic. Primal
          values of all variables (columns) found by the heuristic
          should be placed in the list, i. e. the list must contain n
          numbers where n is the number of columns in the original
          problem object.  Note that the routine does not check primal
          feasibility of the solution provided.

  *Returns*:

     If the provided solution is accepted, the routine returns zero.
     Otherwise, if the provided solution is rejected, the routine
     returns non-zero.

  *Example*:

    > glp::ios_heur_sol tree [15.7, (-3.1), 2.2];



File: pure-glpk.info,  Node: Check whether can branch upon specified variable,  Next: Choose variable to branch upon,  Prev: Provide solution found by heuristic,  Up: Basic routines

5.4.1.8 Check whether can branch upon specified variable
........................................................

*Synopsis*:

    glp::ios_can_branch tree j

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          j: variable (column) index

  *Returns*:

     The function returns non-zero if j-th variable can be used for
     branching.  Otherwise, it returns zero.

  *Example*:

    > glp::ios_can_branch tree 23;



File: pure-glpk.info,  Node: Choose variable to branch upon,  Next: Terminate the solution process,  Prev: Check whether can branch upon specified variable,  Up: Basic routines

5.4.1.9 Choose variable to branch upon
......................................

*Synopsis*:

    glp::ios_branch_upon tree j selection

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          j: ordinal number of the selected branching variable

          selection: one of the following:

               glp::dn_brnch: select down-branch

               glp::up_brnch: select up-branch

               glp::no_brnch: use general selection technique

  *Returns*:

     ()

  *Example*:

    > glp::ios_branch_upon tree 23 glp::up_brnch;



File: pure-glpk.info,  Node: Terminate the solution process,  Prev: Choose variable to branch upon,  Up: Basic routines

5.4.1.10 Terminate the solution process
.......................................

*Synopsis*:

    glp::ios_terminate tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     ()

  *Example*:

    > glp::ios_terminate tree;



File: pure-glpk.info,  Node: The search tree exploring routines,  Next: The cut pool routines,  Prev: Basic routines,  Up: Branch-and-cut API routines

5.4.2 The search tree exploring routines
----------------------------------------

* Menu:

* Determine the search tree size::
* Determine current active subproblem::
* Determine next active subproblem::
* Determine previous active subproblem::
* Determine parent active subproblem::
* Determine subproblem level::
* Determine subproblem local bound::
* Find active subproblem with the best local bound::


File: pure-glpk.info,  Node: Determine the search tree size,  Next: Determine current active subproblem,  Up: The search tree exploring routines

5.4.2.1 Determine the search tree size
......................................

*Synopsis*:

    glp::ios_tree_size tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns a tuple (a_cnt, n_cnt, t_cnt), where

          a_cnt: the current number of active nodes

          n_cnt: the current number of all (active and inactive) nodes

          t_cnt: the total number of nodes including those which have
          been already removed from the tree. This count is increased
          whenever a new node appears in the tree and never decreased.

  *Example*:

    > glp::ios_tree_size tree;



File: pure-glpk.info,  Node: Determine current active subproblem,  Next: Determine next active subproblem,  Prev: Determine the search tree size,  Up: The search tree exploring routines

5.4.2.2 Determine current active subproblem
...........................................

*Synopsis*:

    glp::ios_curr_node tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the reference number of the current active
     subproblem.  If the current subproblem does not exist, the routine
     returns zero.

  *Example*:

    > glp::ios_curr_node tree;



File: pure-glpk.info,  Node: Determine next active subproblem,  Next: Determine previous active subproblem,  Prev: Determine current active subproblem,  Up: The search tree exploring routines

5.4.2.3 Determine next active subproblem
........................................

*Synopsis*:

    glp::ios_next_node tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active subproblem or zero

  *Returns*:

     If the parameter p is zero, the routine returns the reference
     number of the first active subproblem. If the tree is empty, zero
     is returned.  If the parameter p is not zero, it must specify the
     reference number of some active subproblem, in which case the
     routine returns the reference number of the next active
     subproblem. If there is no next active subproblem in the list,
     zero is returned. All subproblems in the active list are ordered
     chronologically, i.e. subproblem A precedes subproblem B if A was
     created before B.

  *Example*:

    > glp::ios_next_node tree 23;



File: pure-glpk.info,  Node: Determine previous active subproblem,  Next: Determine parent active subproblem,  Prev: Determine next active subproblem,  Up: The search tree exploring routines

5.4.2.4 Determine previous active subproblem
............................................

*Synopsis*:

    glp::ios_prev_node tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active subproblem or zero

  *Returns*:

     If the parameter p is zero, the routine returns the reference
     number of the last active subproblem. If the tree is empty, zero
     is returned.  If the parameter p is not zero, it must specify the
     reference number of some active subproblem, in which case the
     routine returns the reference number of the previous active
     subproblem. If there is no previous active subproblem in the list,
     zero is returned. All subproblems in the active list are ordered
     chronologically, i.e. subproblem A precedes subproblem B if A was
     created before B.

  *Example*:

    > glp::ios_prev_node tree 23;



File: pure-glpk.info,  Node: Determine parent active subproblem,  Next: Determine subproblem level,  Prev: Determine previous active subproblem,  Up: The search tree exploring routines

5.4.2.5 Determine parent active subproblem
..........................................

*Synopsis*:

    glp::ios_up_node tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active or inactive subproblem

  *Returns*:

     The routine returns the reference number of its parent subproblem.
     If the specified subproblem is the root of the tree, the routine
     returns zero.

  *Example*:

    > glp::ios_up_node tree 23;



File: pure-glpk.info,  Node: Determine subproblem level,  Next: Determine subproblem local bound,  Prev: Determine parent active subproblem,  Up: The search tree exploring routines

5.4.2.6 Determine subproblem level
..................................

*Synopsis*:

    glp::ios_node_level tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active or inactive subproblem

  *Returns*:

     The routine returns the level of the given subproblem in the
     branch-and-bound tree. (The root subproblem has level 0.)

  *Example*:

    > glp::ios_node_level tree 23;



File: pure-glpk.info,  Node: Determine subproblem local bound,  Next: Find active subproblem with the best local bound,  Prev: Determine subproblem level,  Up: The search tree exploring routines

5.4.2.7 Determine subproblem local bound
........................................

*Synopsis*:

    glp::ios_node_bound tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active or inactive subproblem

  *Returns*:

     The routine returns the local bound for the given subproblem.

  *Example*:

    > glp::ios_node_bound tree 23;



File: pure-glpk.info,  Node: Find active subproblem with the best local bound,  Prev: Determine subproblem local bound,  Up: The search tree exploring routines

5.4.2.8 Find active subproblem with the best local bound
........................................................

*Synopsis*:

    glp::ios_best_node tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the reference number of the active subproblem,
     whose local bound is best (i.e. smallest in case of minimization
     or largest in case of maximization). If the tree is empty, the
     routine returns zero.

  *Example*:

    > glp::ios_best_node tree;



File: pure-glpk.info,  Node: The cut pool routines,  Prev: The search tree exploring routines,  Up: Branch-and-cut API routines

5.4.3 The cut pool routines
---------------------------

* Menu:

* Determine current size of the cut pool::
* Add constraint to the cut pool::
* Remove constraint from the cut pool::
* Remove all constraints from the cut pool::


File: pure-glpk.info,  Node: Determine current size of the cut pool,  Next: Add constraint to the cut pool,  Up: The cut pool routines

5.4.3.1 Determine current size of the cut pool
..............................................

*Synopsis*:

    glp::ios_pool_size tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the current size of the cut pool, that is, the
     number of cutting plane constraints currently added to it.

  *Example*:

    > glp::ios_pool_size tree;



File: pure-glpk.info,  Node: Add constraint to the cut pool,  Next: Remove constraint from the cut pool,  Prev: Determine current size of the cut pool,  Up: The cut pool routines

5.4.3.2 Add constraint to the cut pool
......................................

*Synopsis*:

    glp::ios_add_row tree (name, klass, flags, row, type, rhs)

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          name: symbolic name of the constraint

          klass: specifies the constraint class, which must be either
          zero or a number in the range from 101 to 200. The
          application may use this attribute to distinguish between
          cutting plane constraints of different classes.

          flags: currently is not used and must be zero

          row: list of pairs (colindex, coefficient)

          type: one of the following:

               glp::lo: ∑(aj.xj) ≥ RHS constraint

               glp::up: ∑(aj.xj) ≤ RHS constraint

          rhs: right hand side of the constraint

  *Returns*:

     The routine returns the ordinal number of the cutting plane
     constraint added, which is the new size of the cut pool.

  *Example*:

    > glp::ios_add_row tree ("new_constraint", 101, 0,
                             [(3, 15.0), (4, 6.7), (8, 1.25)], glp::up, 152.7);



File: pure-glpk.info,  Node: Remove constraint from the cut pool,  Next: Remove all constraints from the cut pool,  Prev: Add constraint to the cut pool,  Up: The cut pool routines

5.4.3.3 Remove constraint from the cut pool
...........................................

*Synopsis*:

    glp::ios_del_row tree rowindex

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          rowindex: index of row to be deleted from the cut pool

  *Returns*:

     ()

  *Remark*:

     Note that deleting a constraint from the cut pool leads to changing
     ordinal numbers of other constraints remaining in the pool. New
     ordinal numbers of the remaining constraints are assigned under
     assumption that the original order of constraints is not changed.

  *Example*:

    > glp::ios_del_row tree 5;



File: pure-glpk.info,  Node: Remove all constraints from the cut pool,  Prev: Remove constraint from the cut pool,  Up: The cut pool routines

5.4.3.4 Remove all constraints from the cut pool
................................................

*Synopsis*:

    glp::ios_clear_pool tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     ()

  *Example*:

    > glp::ios_clear_pool tree;



File: pure-glpk.info,  Node: Graph and network API routines,  Next: Miscellaneous routines,  Prev: Branch-and-cut API routines,  Up: Descriptions of interface functions

5.5 Graph and network API routines
==================================

* Menu:

* Basic graph routines::
* Graph analysis routines::
* Minimum cost flow problem::
* Maximum flow problem::


File: pure-glpk.info,  Node: Basic graph routines,  Next: Graph analysis routines,  Up: Graph and network API routines

5.5.1 Basic graph routines
--------------------------

* Menu:

* Create the GLPK graph object::
* Set the graph name::
* Add vertices to a graph::
* Add arc to a graph::
* Erase content of the GLPK graph object::
* Delete the GLPK graph object::
* Read graph in a plain text format::
* Write graph in a plain text format::


File: pure-glpk.info,  Node: Create the GLPK graph object,  Next: Set the graph name,  Up: Basic graph routines

5.5.1.1 Create the GLPK graph object
....................................

*Synopsis*:

    glp::create_graph v_size a_size

*Parameters*:

          v_size: size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256

          a_size: size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.

  *Returns*:

     The routine returns a pointer to the graph created.

  *Example*:

    > let g = glp::create_graph 32 64;
    > g;
    #<pointer 0x9de7168>



File: pure-glpk.info,  Node: Set the graph name,  Next: Add vertices to a graph,  Prev: Create the GLPK graph object,  Up: Basic graph routines

5.5.1.2 Set the graph name
..........................

*Synopsis*:

    glp::set_graph_name graph name

*Parameters*:

          graph: pointer to the graph object

          name: the graph name, an empty string erases the current name

  *Returns*:

     ()

  *Example*:

    > glp::set_graph_name graph "MyGraph";
    ()



File: pure-glpk.info,  Node: Add vertices to a graph,  Next: Add arc to a graph,  Prev: Set the graph name,  Up: Basic graph routines

5.5.1.3 Add vertices to a graph
...............................

*Synopsis*:

    glp::add_vertices graph count

*Parameters*:

          graph: pointer to the graph object

          count: number of vertices to add

  *Returns*:

     The routine returns the ordinal number of the first new vertex
     added to the graph.

  *Example*:

    > glp::add_vertices graph 5;
    18



File: pure-glpk.info,  Node: Add arc to a graph,  Next: Erase content of the GLPK graph object,  Prev: Add vertices to a graph,  Up: Basic graph routines

5.5.1.4 Add arc to a graph
..........................

*Synopsis*:

    glp::add_arc graph i j

*Parameters*:

          graph: pointer to the graph object

          i: index of the tail vertex

          j: index of the head vertex

  *Returns*:

     ()

  *Example*:

    > glp::add_arc graph 7 12;
    ()



File: pure-glpk.info,  Node: Erase content of the GLPK graph object,  Next: Delete the GLPK graph object,  Prev: Add arc to a graph,  Up: Basic graph routines

5.5.1.5 Erase content of the GLPK graph object
..............................................

*Synopsis*:

    glp::erase_graph graph v_size a_size

*Parameters*:

          graph: pointer to the graph object

          v_size: size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256

          a_size: size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.

  *Returns*:

     ()

  *Remark*:

     The routine reinitialises the graph object. Its efect is
     equivalent to calling delete_graph followed by a call to
     create_graph.

  *Example*:

    > glp::erase_graph graph 16 34;
    ()



File: pure-glpk.info,  Node: Delete the GLPK graph object,  Next: Read graph in a plain text format,  Prev: Erase content of the GLPK graph object,  Up: Basic graph routines

5.5.1.6 Delete the GLPK graph object
....................................

*Synopsis*:

    glp::delete_graph graph

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

     ()

  *Remark*:

     The routine destroys the graph object and invalidates the pointer.
     This is done automatically when the graph is not needed anymore,
     the routine need not be usually called.

  *Example*:

    > glp::delete_graph graph
    ()



File: pure-glpk.info,  Node: Read graph in a plain text format,  Next: Write graph in a plain text format,  Prev: Delete the GLPK graph object,  Up: Basic graph routines

5.5.1.7 Read graph in a plain text format
.........................................

*Synopsis*:

    glp::read_graph graph filename

*Parameters*:

          graph: pointer to the graph object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_graph graph "graph_data.txt";
    0



File: pure-glpk.info,  Node: Write graph in a plain text format,  Prev: Read graph in a plain text format,  Up: Basic graph routines

5.5.1.8 Write graph in a plain text format
..........................................

*Synopsis*:

    glp::write_graph graph filename

*Parameters*:

          graph: pointer to the graph object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::write_graph graph "graph_data.txt";
    0



File: pure-glpk.info,  Node: Graph analysis routines,  Next: Minimum cost flow problem,  Prev: Basic graph routines,  Up: Graph and network API routines

5.5.2 Graph analysis routines
-----------------------------

* Menu:

* Find all weakly connected components of a graph::
* Find all strongly connected components of a graph::


File: pure-glpk.info,  Node: Find all weakly connected components of a graph,  Next: Find all strongly connected components of a graph,  Up: Graph analysis routines

5.5.2.1 Find all weakly connected components of a graph
.......................................................

*Synopsis*:

    glp::weak_comp graph v_num

*Parameters*:

          graph: pointer to the graph object

          v_num: offset of the field of type int in the vertex data
          block, to which the routine stores the number of a weakly
          connected component containing that vertex - if v_num < 0, no
          component numbers are stored

  *Returns*:

     The routine returns the total number of components found.

  *Example*:

    > glp::weak_comp graph 16;
    3



File: pure-glpk.info,  Node: Find all strongly connected components of a graph,  Prev: Find all weakly connected components of a graph,  Up: Graph analysis routines

5.5.2.2 Find all strongly connected components of a graph
.........................................................

*Synopsis*:

    glp::strong_comp graph v_num

*Parameters*:

          graph: pointer to the graph object

          v_num: offset of the field of type int in the vertex data
          block, to which the routine stores the number of a strongly
          connected component containing that vertex - if v_num < 0, no
          component numbers are stored

  *Returns*:

  The routine returns the total number of components found.

  *Example*:

    > glp::strong_comp graph 16;
    4



File: pure-glpk.info,  Node: Minimum cost flow problem,  Next: Maximum flow problem,  Prev: Graph analysis routines,  Up: Graph and network API routines

5.5.3 Minimum cost flow problem
-------------------------------

* Menu:

* Read minimum cost flow problem data in DIMACS format::
* Write minimum cost flow problem data in DIMACS format::
* Convert minimum cost flow problem to LP::
* Solve minimum cost flow problem with out-of-kilter algorithm::
* Klingman's network problem generator::
* Grid-like network problem generator::


File: pure-glpk.info,  Node: Read minimum cost flow problem data in DIMACS format,  Next: Write minimum cost flow problem data in DIMACS format,  Up: Minimum cost flow problem

5.5.3.1 Read minimum cost flow problem data in DIMACS format
............................................................

*Synopsis*:

    glp::read_mincost graph v_rhs a_low a_cap a_cost filename

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, the value is not stored

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, the lower bound is not stored

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0, the upper bound
          is not stored

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, the cost is not stored

          fname: the name of a text file to be read in - if the file
          name name ends with the suffix ‘.gz’, the file is assumed to
          be compressed, in which case the routine decompresses it “on
          the fly”

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_mincost graph 0 8 16 24 "graphdata.txt";
    0



File: pure-glpk.info,  Node: Write minimum cost flow problem data in DIMACS format,  Next: Convert minimum cost flow problem to LP,  Prev: Read minimum cost flow problem data in DIMACS format,  Up: Minimum cost flow problem

5.5.3.2 Write minimum cost flow problem data in DIMACS format
.............................................................

*Synopsis*:

    glp::write_mincost graph v_rhs a_low a_cap a_cost fname

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, the value is not stored

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, the lower bound is not stored

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0, the upper bound
          is not stored

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, the cost is not stored

          fname: the name of a text file to be written out - if the
          file name name ends with the suffix ‘.gz’, the file is
          assumed to be compressed, in which case the routine
          compresses it “on the fly”

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::write_mincost graph 0 8 16 24 "graphdata.txt";
    0



File: pure-glpk.info,  Node: Convert minimum cost flow problem to LP,  Next: Solve minimum cost flow problem with out-of-kilter algorithm,  Prev: Write minimum cost flow problem data in DIMACS format,  Up: Minimum cost flow problem

5.5.3.3 Convert minimum cost flow problem to LP
...............................................

*Synopsis*:

    glp::mincost_lp lp graph names v_rhs a_low a_cap a_cost

*Parameters*:

          lp: pointer to the LP problem object

          graph: pointer to the graph object

          names: one of the following:

               glp::on: assign symbolic names of the graph object
               components to symbolic names of the LP problem object
               components

               glp::off: no symbolic names are assigned

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, it is assumed lij = 0 for all arcs

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij
          = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

  *Returns*:

     ()

  *Example*:

    > glp::mincost_lp lp graph glp::on 0 8 16 24;
    ()



File: pure-glpk.info,  Node: Solve minimum cost flow problem with out-of-kilter algorithm,  Next: Klingman's network problem generator,  Prev: Convert minimum cost flow problem to LP,  Up: Minimum cost flow problem

5.5.3.4 Solve minimum cost flow problem with out-of-kilter algorithm
....................................................................

*Synopsis*:

    glp::mincost_okalg graph v_rhs a_low a_cap a_cost a_x v_pi

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, it is assumed lij = 0 for all arcs

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij
          = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

          a_x: offset of the field of type double in the arc data block,
          to which the routine stores xij, the arc flow found - if a_x
          < 0, the arc flow value is not stored

          v_pi: specifies an offset of the field of type double in the
          vertex data block, to which the routine stores pi, the node
          potential, which is the Lagrange multiplier for the
          corresponding flow conservation equality constraint

  *Remark*:

     Note that all solution components (the objective value, arc flows,
     and node potentials) computed by the routine are always
     integer-valued.

  *Returns*:

     The function returns a tuple in the form *(code, obj)*, where
     *code* is one of the following

          glp::ok: optimal solution found

          glp::enopfs: no (primal) feasible solution exists

          glp::edata: unable to start the search, because some problem
          data are either not integer-valued or out of range; this code
          is also returned if the total supply, which is the sum of bi
          over all source nodes (nodes with bi > 0), exceeds INT_MAX

          glp::erange: the search was prematurely terminated because of
          integer overflow

          glp::efail: an error has been detected in the program logic -
          if this code is returned for your problem instance, please
          report to <<bug-glpk@gnu.org>>

     and *obj* is value of the objective function.

  *Example*:

    > glp::mincost_okalg graph 0 8 16 24 32 40;
    (glp::ok, 15)



File: pure-glpk.info,  Node: Klingman's network problem generator,  Next: Grid-like network problem generator,  Prev: Solve minimum cost flow problem with out-of-kilter algorithm,  Up: Minimum cost flow problem

5.5.3.5 Klingman's network problem generator
............................................

*Synopsis*:

    glp::netgen graph v_rhs a_cap a_cost parameters

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij
          = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

          parameters: tuple of exactly 15 integer numbers with the
          following meaning:

               parm[1]: iseed 8-digit positive random number seed

               parm[2]: nprob 8-digit problem id number

               parm[3]: nodes total number of nodes

               parm[4]: nsorc total number of source nodes (including
               transshipment nodes)

               parm[5]: nsink total number of sink nodes (including
               transshipment nodes)

               parm[6]: iarcs number of arc

               parm[7]: mincst minimum cost for arcs

               parm[8]: maxcst maximum cost for arcs

               parm[9]: itsup total supply

               parm[10]: ntsorc number of transshipment source nodes

               parm[11]: ntsink number of transshipment sink nodes

               parm[12]: iphic percentage of skeleton arcs to be given
               the maximum cost

               parm[13]: ipcap percentage of arcs to be capacitated

               parm[14]: mincap minimum upper bound for capacitated arcs

               parm[15]: maxcap maximum upper bound for capacitated arcs

  *Returns*:

     *0* if the instance was successfully generated, nonzero otherwise

  *Example*:

    > glp::netgen graph 0 8 16 (12345678, 87654321, 20, 12, 8,
                                25, 5, 20, 300, 6, 5, 15, 100, 1, 30);
    0



File: pure-glpk.info,  Node: Grid-like network problem generator,  Prev: Klingman's network problem generator,  Up: Minimum cost flow problem

5.5.3.6 Grid-like network problem generator
...........................................

*Synopsis*:

    glp::gridgen graph v_rhs a_cap a_cost parameters

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij
          = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

          parameters: tuple of exactly 14 integer numbers with the
          following meaning:

               parm[1]: two-ways arcs indicator:

                   *1:* if links in both direction should be generated 
                   *0:* otherwise 

               parm[2]: random number seed (a positive integer)

               parm[3]: number of nodes (the number of nodes generated
               might be slightly different to make the network a grid)

               parm[4]: grid width

               parm[5]: number of sources

               parm[6]: number of sinks

               parm[7]: average degree

               parm[8]: total flow

               parm[9]: distribution of arc costs:

                   *1:* uniform 
                   *2:* exponential 

               parm[10]: lower bound for arc cost (uniform), 100
               lambda¸ (exponential)

               parm[11]: upper bound for arc cost (uniform), not used
               (exponential)

               parm[12]: distribution of arc capacities:

                   *1:* uniform 
                   *2:* exponential 

               parm[13]: lower bound for arc capacity (uniform), 100
               lambda (exponential)

               parm[14]: upper bound for arc capacity (uniform), not
               used (exponential)

  *Returns*:

     *0* if the instance was successfully generated, nonzero otherwise

  *Example*:

    > glp::gridgen graph 0 8 16 (1, 123, 20, 4, 7, 5, 3, 300, 1, 1, 5, 1, 5, 30);
    0



File: pure-glpk.info,  Node: Maximum flow problem,  Prev: Minimum cost flow problem,  Up: Graph and network API routines

5.5.4 Maximum flow problem
--------------------------

* Menu:

* Read maximum cost flow problem data in DIMACS format::
* Write maximum cost flow problem data in DIMACS format::
* Convert maximum flow problem to LP::
* Solve maximum flow problem with Ford-Fulkerson algorithm::
* Goldfarb's maximum flow problem generator::


File: pure-glpk.info,  Node: Read maximum cost flow problem data in DIMACS format,  Next: Write maximum cost flow problem data in DIMACS format,  Up: Maximum flow problem

5.5.4.1 Read maximum cost flow problem data in DIMACS format
............................................................

*Synopsis*:

    glp::read_maxflow graph a_cap filename

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Write maximum cost flow problem data in DIMACS format,  Next: Convert maximum flow problem to LP,  Prev: Read maximum cost flow problem data in DIMACS format,  Up: Maximum flow problem

5.5.4.2 Write maximum cost flow problem data in DIMACS format
.............................................................

*Synopsis*:

    glp::write_maxflow graph s t a_cap filename

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Convert maximum flow problem to LP,  Next: Solve maximum flow problem with Ford-Fulkerson algorithm,  Prev: Write maximum cost flow problem data in DIMACS format,  Up: Maximum flow problem

5.5.4.3 Convert maximum flow problem to LP
..........................................

*Synopsis*:

    glp::maxflow_lp lp graph names s t a_cap

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Solve maximum flow problem with Ford-Fulkerson algorithm,  Next: Goldfarb's maximum flow problem generator,  Prev: Convert maximum flow problem to LP,  Up: Maximum flow problem

5.5.4.4 Solve maximum flow problem with Ford-Fulkerson algorithm
................................................................

*Synopsis*:

    glp::maxflow_ffalg graph s t a_cap a_x v_cut

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Goldfarb's maximum flow problem generator,  Prev: Solve maximum flow problem with Ford-Fulkerson algorithm,  Up: Maximum flow problem

5.5.4.5 Goldfarb's maximum flow problem generator
.................................................

*Synopsis*:

    glp::rmfgen graph a_cap parameters

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Miscellaneous routines,  Prev: Graph and network API routines,  Up: Descriptions of interface functions

5.6 Miscellaneous routines
==========================

* Menu:

* Library environment routines::


File: pure-glpk.info,  Node: Library environment routines,  Up: Miscellaneous routines

5.6.1 Library environment routines
----------------------------------

* Menu:

* Determine library version::
* Enable/disable terminal output::
* Enable/disable the terminal hook routine::
* Get memory usage information::
* Set memory usage limit::
* Free GLPK library environment::


File: pure-glpk.info,  Node: Determine library version,  Next: Enable/disable terminal output,  Up: Library environment routines

5.6.1.1 Determine library version
.................................

*Synopsis*:

    `glp::version

*Parameters*:

     none

  *Returns*:

     GLPK library version

  *Example*:

    > glp::version;
    "4.38"



File: pure-glpk.info,  Node: Enable/disable terminal output,  Next: Enable/disable the terminal hook routine,  Prev: Determine library version,  Up: Library environment routines

5.6.1.2 Enable/disable terminal output
......................................

*Synopsis*:

    glp::term_out switch

*Parameters*:

          switch: one of the following:

               glp::on: enable terminal output from GLPK routines

               glp::off: disable terminal output from GLPK routines

  *Returns*:

     `()'

  *Example*:

    > glp::term_out glp:off;
    ()



File: pure-glpk.info,  Node: Enable/disable the terminal hook routine,  Next: Get memory usage information,  Prev: Enable/disable terminal output,  Up: Library environment routines

5.6.1.3 Enable/disable the terminal hook routine
................................................

*Synopsis*:

    glp::term_hook switch info

*Parameters*:

          switch: one of the following:

               glp::on: use the terminal callback function

               glp::off: don't use the terminal callback function

          info: pointer to a memory block which can be used for passing
          additional information to the terminal callback function

  *Returns*:

     `()'

  *Example*:

    > glp::term_hook glp::on NULL;
    ()



File: pure-glpk.info,  Node: Get memory usage information,  Next: Set memory usage limit,  Prev: Enable/disable the terminal hook routine,  Up: Library environment routines

5.6.1.4 Get memory usage information
....................................

*Synopsis*:

    glp::mem_usage

*Parameters*:

     none

  *Returns*:

     tuple consisting of four numbers:

             * `count' (int) - the number of currently allocated memory
               blocks

             * `cpeak' (int) - the peak value of `count' reached since
               the initialization of the GLPK library environment

             * `total' (bigint) - the total amount, in bytes, of
               currently allocated memory blocks

             * `tpeak' (bigint) - the peak value of `total' reached
               since the initialization of the GLPK library envirionment

  *Example*:

    > glp::mem_usage;
    7,84,10172L,45304L



File: pure-glpk.info,  Node: Set memory usage limit,  Next: Free GLPK library environment,  Prev: Get memory usage information,  Up: Library environment routines

5.6.1.5 Set memory usage limit
..............................

*Synopsis*:

    glp::mem_limit limit

*Parameters*:

          limit: memory limit in megabytes

  *Returns*:

     `()'

  *Example*:

    > glp::mem_limit 200;
    ()



File: pure-glpk.info,  Node: Free GLPK library environment,  Prev: Set memory usage limit,  Up: Library environment routines

5.6.1.6 Free GLPK library environment
.....................................

*Synopsis*:

    glp::free_env

*Parameters*:

     none

  *Returns*:

     `()'

  *Example*:

    > glp_free_env;
    ()



File: pure-glpk.info,  Node: Index,  Prev: Descriptions of interface functions,  Up: Top

Index
*****

 [index ]
* Menu:


Tag Table:
Node: Top294
Node: Installation1772
Ref: installation1862
Ref: 01862
Ref: pure-glpk-glpk-interface-for-the-pure-programming-language1862
Ref: 11862
Node: Error Handling3468
Ref: error handling3587
Ref: 23587
Ref: error-handling3587
Node: Further Information and Examples5287
Ref: further information and examples5415
Ref: 35415
Ref: further-information-and-examples5415
Node: Interface description5682
Ref: interface description5831
Ref: 45831
Ref: interface-description5831
Node: Descriptions of interface functions6418
Ref: descriptions of interface functions6540
Ref: 56540
Ref: descriptions-of-interface-functions6540
Node: Basic API routines6795
Ref: basic api routines6917
Ref: 66917
Ref: basic-api-routines6917
Node: Problem creating and modifying routines7278
Ref: problem creating and modifying routines7411
Ref: 77411
Ref: problem-creating-and-modifying-routines7411
Node: Create the GLPK problem object8272
Ref: create the glpk problem object8410
Ref: 88410
Ref: create-the-glpk-problem-object8410
Node: Set the problem name8687
Ref: set the problem name8852
Ref: 98852
Ref: set-the-problem-name8852
Node: Set objective name9144
Ref: set objective name9306
Ref: a9306
Ref: set-objective-name9306
Node: Set the objective direction9590
Ref: set the objective direction9759
Ref: b9759
Ref: set-the-objective-direction9759
Node: Add new rows to the problem10141
Ref: add new rows to the problem10322
Ref: c10322
Ref: add-new-rows-to-the-problem10322
Node: Add new columns to the problem10680
Ref: add new columns to the problem10850
Ref: d10850
Ref: add-new-columns-to-the-problem10850
Node: Set the row name11220
Ref: set the row name11382
Ref: e11382
Ref: set-the-row-name11382
Node: Set the column name11712
Ref: set the column name11865
Ref: f11865
Ref: set-the-column-name11865
Node: Set change row bounds12210
Ref: set change row bounds12371
Ref: 1012371
Ref: set-change-row-bounds12371
Node: Set change column bounds13219
Ref: set change column bounds13410
Ref: 1113410
Ref: set-change-column-bounds13410
Node: Set change objective coefficient or constant term14289
Ref: set change objective coefficient or constant term14485
Ref: 1214485
Ref: set-change-objective-coefficient-or-constant-term14485
Node: Load or replace matrix row14920
Ref: load or replace matrix row15121
Ref: 1315121
Ref: load-or-replace-matrix-row15121
Node: Load or replace matrix column15655
Ref: load or replace matrix column15847
Ref: 1415847
Ref: load-or-replace-matrix-column15847
Node: Load or replace the whole problem matrix16387
Ref: load or replace the whole problem matrix16598
Ref: 1516598
Ref: load-or-replace-the-whole-problem-matrix16598
Node: Check for duplicate elements in sparse matrix17142
Ref: check for duplicate elements in sparse matrix17362
Ref: 1617362
Ref: check-for-duplicate-elements-in-sparse-matrix17362
Node: Sort elements of the constraint matrix18242
Ref: sort elements of the constraint matrix18449
Ref: 1718449
Ref: sort-elements-of-the-constraint-matrix18449
Node: Delete rows from the matrix18722
Ref: delete rows from the matrix18914
Ref: 1818914
Ref: delete-rows-from-the-matrix18914
Node: Delete columns from the matrix19561
Ref: delete columns from the matrix19779
Ref: 1919779
Ref: delete-columns-from-the-matrix19779
Node: Copy the whole content of the GLPK problem object to another one20447
Ref: copy the whole content of the glpk problem object to another one20681
Ref: 1a20681
Ref: copy-the-whole-content-of-the-glpk-problem-object-to-another-one20681
Node: Erase all data from the GLPK problem object21309
Ref: erase all data from the glpk problem object21543
Ref: 1b21543
Ref: erase-all-data-from-the-glpk-problem-object21543
Node: Delete the GLPK problem object21882
Ref: delete the glpk problem object22043
Ref: 1c22043
Ref: delete-the-glpk-problem-object22043
Node: Problem retrieving routines22360
Ref: problem retrieving routines22535
Ref: 1d22535
Ref: problem-retrieving-routines22535
Node: Get the problem name23089
Ref: get the problem name23207
Ref: 1e23207
Ref: get-the-problem-name23207
Node: Get the objective name23476
Ref: get the objective name23630
Ref: 1f23630
Ref: get-the-objective-name23630
Node: Get the objective direction23899
Ref: get the objective direction24051
Ref: 2024051
Ref: get-the-objective-direction24051
Node: Get number of rows24401
Ref: get number of rows24552
Ref: 2124552
Ref: get-number-of-rows24552
Node: Get number of columns24809
Ref: get number of columns24950
Ref: 2224950
Ref: get-number-of-columns24950
Node: Get name of a row25225
Ref: get name of a row25368
Ref: 2325368
Ref: get-name-of-a-row25368
Node: Get name of a column25671
Ref: get name of a column25805
Ref: 2425805
Ref: get-name-of-a-column25805
Node: Get row type26124
Ref: get row type26260
Ref: 2526260
Ref: get-row-type26260
Node: Get row lower bound26783
Ref: get row lower bound26918
Ref: 2626918
Ref: get-row-lower-bound26918
Node: Get row upper bound27287
Ref: get row upper bound27425
Ref: 2727425
Ref: get-row-upper-bound27425
Node: Get column type27796
Ref: get column type27937
Ref: 2827937
Ref: get-column-type27937
Node: Get column lower bound28471
Ref: get column lower bound28615
Ref: 2928615
Ref: get-column-lower-bound28615
Node: Get column upper bound29019
Ref: get column upper bound29173
Ref: 2a29173
Ref: get-column-upper-bound29173
Node: Get objective coefficient29559
Ref: get objective coefficient29725
Ref: 2b29725
Ref: get-objective-coefficient29725
Node: Get number of nonzero coefficients30130
Ref: get number of nonzero coefficients30311
Ref: 2c30311
Ref: get-number-of-nonzero-coefficients30311
Node: Retrive a row from the problem matrix30624
Ref: retrive a row from the problem matrix30820
Ref: 2d30820
Ref: retrive-a-row-from-the-problem-matrix30820
Node: Retrive a column from the problem matrix31239
Ref: retrive a column from the problem matrix31392
Ref: 2e31392
Ref: retrive-a-column-from-the-problem-matrix31392
Node: Row and column searching routines31823
Ref: row and column searching routines31983
Ref: 2f31983
Ref: row-and-column-searching-routines31983
Node: Create index for searching rows and columns by their names32263
Ref: create index for searching rows and columns by their names32428
Ref: 3032428
Ref: create-index-for-searching-rows-and-columns-by-their-names32428
Node: Find a row number by name32741
Ref: find a row number by name32943
Ref: 3132943
Ref: find-a-row-number-by-name32943
Node: Find a column number by name33360
Ref: find a column number by name33562
Ref: 3233562
Ref: find-a-column-number-by-name33562
Node: Delete index for searching rows and columns by their names33992
Ref: delete index for searching rows and columns by their names34160
Ref: 3334160
Ref: delete-index-for-searching-rows-and-columns-by-their-names34160
Node: Problem scaling routines34473
Ref: problem scaling routines34636
Ref: 3434636
Ref: problem-scaling-routines34636
Node: Set the row scale factor34925
Ref: set the row scale factor35049
Ref: 3535049
Ref: set-the-row-scale-factor35049
Node: Set the column scale factor35394
Ref: set the column scale factor35556
Ref: 3635556
Ref: set-the-column-scale-factor35556
Node: Retrieve the row scale factor35909
Ref: retrieve the row scale factor36079
Ref: 3736079
Ref: retrieve-the-row-scale-factor36079
Node: Retrieve the column scale factor36397
Ref: retrieve the column scale factor36590
Ref: 3836590
Ref: retrieve-the-column-scale-factor36590
Node: Scale the problem data according to supplied flags36919
Ref: scale the problem data according to supplied flags37107
Ref: 3937107
Ref: scale-the-problem-data-according-to-supplied-flags37107
Node: Unscale the problem data37876
Ref: unscale the problem data38023
Ref: 3a38023
Ref: unscale-the-problem-data38023
Node: LP basis constructing routines38268
Ref: lp basis constructing routines38421
Ref: 3b38421
Ref: lp-basis-constructing-routines38421
Node: Set the row status38665
Ref: set the row status38783
Ref: 3c38783
Ref: set-the-row-status38783
Node: Set the column status39707
Ref: set the column status39866
Ref: 3d39866
Ref: set-the-column-status39866
Node: Construct standard problem basis40736
Ref: construct standard problem basis40909
Ref: 3e40909
Ref: construct-standard-problem-basis40909
Node: Construct advanced problem basis41164
Ref: construct advanced problem basis41347
Ref: 3f41347
Ref: construct-advanced-problem-basis41347
Node: Construct Bixby's problem basis41602
Ref: construct bixby's problem basis41744
Ref: 4041744
Ref: construct-bixby-s-problem-basis41744
Node: Simplex method routines41997
Ref: simplex method routines42156
Ref: 4142156
Ref: simplex-method-routines42156
Node: Solve the LP problem using simplex method42785
Ref: solve the lp problem using simplex method42960
Ref: 4242960
Ref: solve-the-lp-problem-using-simplex-method42960
Node: Solve the LP problem using simplex method in exact arithmetics48975
Ref: solve the lp problem using simplex method in exact arithmetics49200
Ref: 4349200
Ref: solve-the-lp-problem-using-simplex-method-in-exact-arithmetics49200
Node: Retrieve generic status of basic solution51419
Ref: retrieve generic status of basic solution51645
Ref: 4451645
Ref: retrieve-generic-status-of-basic-solution51645
Node: Retrieve generic status of primal solution52216
Ref: retrieve generic status of primal solution52420
Ref: 4552420
Ref: retrieve-generic-status-of-primal-solution52420
Node: Retrieve generic status of dual solution52942
Ref: retrieve generic status of dual solution53145
Ref: 4653145
Ref: retrieve-generic-status-of-dual-solution53145
Node: Retrieve value of the objective function53655
Ref: retrieve value of the objective function53857
Ref: 4753857
Ref: retrieve-value-of-the-objective-function53857
Node: Retrieve generic status of a row variable54172
Ref: retrieve generic status of a row variable54359
Ref: 4854359
Ref: retrieve-generic-status-of-a-row-variable54359
Node: Retrieve row primal value54954
Ref: retrieve row primal value55124
Ref: 4955124
Ref: retrieve-row-primal-value55124
Node: Retrieve row dual value55459
Ref: retrieve row dual value55632
Ref: 4a55632
Ref: retrieve-row-dual-value55632
Node: Retrieve generic status of a column variable55956
Ref: retrieve generic status of a column variable56132
Ref: 4b56132
Ref: retrieve-generic-status-of-a-column-variable56132
Node: Retrieve column primal value56738
Ref: retrieve column primal value56917
Ref: 4c56917
Ref: retrieve-column-primal-value56917
Node: Retrieve column dual value57275
Ref: retrieve column dual value57450
Ref: 4d57450
Ref: retrieve-column-dual-value57450
Node: Determine variable causing unboundedness57789
Ref: determine variable causing unboundedness57927
Ref: 4e57927
Ref: determine-variable-causing-unboundedness57927
Node: Interior-point method routines59078
Ref: interior-point method routines59241
Ref: 4f59241
Ref: interior-point-method-routines59241
Node: Solve the LP problem using interior-point method59725
Ref: solve the lp problem using interior-point method59894
Ref: 5059894
Ref: solve-the-lp-problem-using-interior-point-method59894
Node: Retrieve status of interior-point solution62883
Ref: retrieve status of interior-point solution63125
Ref: 5163125
Ref: retrieve-status-of-interior-point-solution63125
Node: Retrieve the objective function value of interior-point solution63666
Ref: retrieve the objective function value of interior-point solution63912
Ref: 5263912
Ref: retrieve-the-objective-function-value-of-interior-point-solution63912
Node: Retrieve row primal value of interior-point solution64296
Ref: retrieve row primal value of interior-point solution64550
Ref: 5364550
Ref: retrieve-row-primal-value-of-interior-point-solution64550
Node: Retrieve row dual value of interior-point solution64947
Ref: retrieve row dual value of interior-point solution65192
Ref: 5465192
Ref: retrieve-row-dual-value-of-interior-point-solution65192
Node: Retrieve column primal value of interior-point solution65588
Ref: retrieve column primal value of interior-point solution65834
Ref: 5565834
Ref: retrieve-column-primal-value-of-interior-point-solution65834
Node: Retrieve column dual value of interior-point solution66243
Ref: retrieve column dual value of interior-point solution66430
Ref: 5666430
Ref: retrieve-column-dual-value-of-interior-point-solution66430
Node: Mixed integer programming routines66839
Ref: mixed integer programming routines66998
Ref: 5766998
Ref: mixed-integer-programming-routines66998
Node: Set column kind67442
Ref: set column kind67560
Ref: 5867560
Ref: set-column-kind67560
Node: Retrieve column kind68038
Ref: retrieve column kind68199
Ref: 5968199
Ref: retrieve-column-kind68199
Node: Retrieve number of integer columns68616
Ref: retrieve number of integer columns68795
Ref: 5a68795
Ref: retrieve-number-of-integer-columns68795
Node: Retrieve number of binary columns69104
Ref: retrieve number of binary columns69312
Ref: 5b69312
Ref: retrieve-number-of-binary-columns69312
Node: Solve the MIP problem using branch-and-cut method69591
Ref: solve the mip problem using branch-and-cut method69796
Ref: 5c69796
Ref: solve-the-mip-problem-using-branch-and-cut-method69796
Node: Retrieve status of mip solution78661
Ref: retrieve status of mip solution78886
Ref: 5d78886
Ref: retrieve-status-of-mip-solution78886
Node: Retrieve the objective function value of mip solution79556
Ref: retrieve the objective function value of mip solution79766
Ref: 5e79766
Ref: retrieve-the-objective-function-value-of-mip-solution79766
Node: Retrieve row value of mip solution80106
Ref: retrieve row value of mip solution80322
Ref: 5f80322
Ref: retrieve-row-value-of-mip-solution80322
Node: Retrieve column value of mip solution80665
Ref: retrieve column value of mip solution80819
Ref: 6080819
Ref: retrieve-column-value-of-mip-solution80819
Node: Additional routines81174
Ref: additional routines81294
Ref: 6181294
Ref: additional-routines81294
Node: Check Karush-Kuhn-Tucker conditions81397
Ref: check karush-kuhn-tucker conditions81491
Ref: 6281491
Ref: check-karush-kuhn-tucker-conditions81491
Node: Utility API routines83782
Ref: utility api routines83934
Ref: 6383934
Ref: utility-api-routines83934
Node: Problem data reading/writing routines84116
Ref: problem data reading/writing routines84250
Ref: 6484250
Ref: problem-data-reading-writing-routines84250
Node: Read LP problem data from a MPS file84600
Ref: read lp problem data from a mps file84759
Ref: 6584759
Ref: read-lp-problem-data-from-a-mps-file84759
Node: Write LP problem data into a MPS file85640
Ref: write lp problem data into a mps file85846
Ref: 6685846
Ref: write-lp-problem-data-into-a-mps-file85846
Node: Read LP problem data from a CPLEX file86680
Ref: read lp problem data from a cplex file86889
Ref: 6786889
Ref: read-lp-problem-data-from-a-cplex-file86889
Node: Write LP problem data into a CPLEX file87542
Ref: write lp problem data into a cplex file87749
Ref: 6887749
Ref: write-lp-problem-data-into-a-cplex-file87749
Node: Read LP problem data in GLPK format88396
Ref: read lp problem data in glpk format88601
Ref: 6988601
Ref: read-lp-problem-data-in-glpk-format88601
Node: Write LP problem data in GLPK format89258
Ref: write lp problem data in glpk format89415
Ref: 6a89415
Ref: write-lp-problem-data-in-glpk-format89415
Node: Routines for MathProg models90066
Ref: routines for mathprog models90250
Ref: 6b90250
Ref: routines-for-mathprog-models90250
Node: Create the MathProg translator object90577
Ref: create the mathprog translator object90723
Ref: 6c90723
Ref: create-the-mathprog-translator-object90723
Node: Read and translate model section91031
Ref: read and translate model section91217
Ref: 6d91217
Ref: read-and-translate-model-section91217
Node: Read and translate data section91908
Ref: read and translate data section92075
Ref: 6e92075
Ref: read-and-translate-data-section92075
Node: Generate the model92547
Ref: generate the model92719
Ref: 6f92719
Ref: generate-the-model92719
Node: Build problem instance from the model93237
Ref: build problem instance from the model93397
Ref: 7093397
Ref: build-problem-instance-from-the-model93397
Node: Postsolve the model93752
Ref: postsolve the model93931
Ref: 7193931
Ref: postsolve-the-model93931
Node: Delete the MathProg translator object94554
Ref: delete the mathprog translator object94687
Ref: 7294687
Ref: delete-the-mathprog-translator-object94687
Node: Problem solution reading/writing routines94986
Ref: problem solution reading/writing routines95124
Ref: 7395124
Ref: problem-solution-reading-writing-routines95124
Node: Write basic solution in printable format95674
Ref: write basic solution in printable format95840
Ref: 7495840
Ref: write-basic-solution-in-printable-format95840
Node: Read basic solution from a text file96271
Ref: read basic solution from a text file96483
Ref: 7596483
Ref: read-basic-solution-from-a-text-file96483
Node: Write basic solution into a text file96931
Ref: write basic solution into a text file97136
Ref: 7697136
Ref: write-basic-solution-into-a-text-file97136
Node: Print sensitivity analysis report97589
Ref: print sensitivity analysis report97807
Ref: 7797807
Ref: print-sensitivity-analysis-report97807
Node: Write interior-point solution in printable format98741
Ref: write interior-point solution in printable format98967
Ref: 7898967
Ref: write-interior-point-solution-in-printable-format98967
Node: Read interior-point solution from a text file99425
Ref: read interior-point solution from a text file99664
Ref: 7999664
Ref: read-interior-point-solution-from-a-text-file99664
Node: Write interior-point solution into a text file100139
Ref: write interior-point solution into a text file100367
Ref: 7a100367
Ref: write-interior-point-solution-into-a-text-file100367
Node: Write MIP solution in printable format100847
Ref: write mip solution in printable format101064
Ref: 7b101064
Ref: write-mip-solution-in-printable-format101064
Node: Read MIP solution from a text file101489
Ref: read mip solution from a text file101695
Ref: 7c101695
Ref: read-mip-solution-from-a-text-file101695
Node: Write MIP solution into a text file102137
Ref: write mip solution into a text file102296
Ref: 7d102296
Ref: write-mip-solution-into-a-text-file102296
Node: Advanced API routines102745
Ref: advanced api routines102906
Ref: 7e102906
Ref: advanced-api-routines102906
Node: LP basis routines103020
Ref: lp basis routines103131
Ref: 7f103131
Ref: lp-basis-routines103131
Node: Check whether basis factorization exists103630
Ref: check whether basis factorization exists103767
Ref: 80103767
Ref: check-whether-basis-factorization-exists103767
Node: Compute the basis factorization104174
Ref: compute the basis factorization104370
Ref: 81104370
Ref: compute-the-basis-factorization104370
Node: Check whether basis factorization has been updated105127
Ref: check whether basis factorization has been updated105317
Ref: 82105317
Ref: check-whether-basis-factorization-has-been-updated105317
Node: Get basis factorization parameters105764
Ref: get basis factorization parameters105960
Ref: 83105960
Ref: get-basis-factorization-parameters105960
Node: Change basis factorization parameters108995
Ref: change basis factorization parameters109178
Ref: 84109178
Ref: change-basis-factorization-parameters109178
Node: Retrieve the basis header information112520
Ref: retrieve the basis header information112707
Ref: 85112707
Ref: retrieve-the-basis-header-information112707
Node: Retrieve row index in the basis header113322
Ref: retrieve row index in the basis header113513
Ref: 86113513
Ref: retrieve-row-index-in-the-basis-header113513
Node: Retrieve column index in the basis header114204
Ref: retrieve column index in the basis header114388
Ref: 87114388
Ref: retrieve-column-index-in-the-basis-header114388
Node: Perform forward transformation115122
Ref: perform forward transformation115299
Ref: 88115299
Ref: perform-forward-transformation115299
Node: Perform backward transformation115883
Ref: perform backward transformation116035
Ref: 89116035
Ref: perform-backward-transformation116035
Node: Warm up LP basis116623
Ref: warm up lp basis116736
Ref: 8a116736
Ref: warm-up-lp-basis116736
Node: Simplex tableau routines117386
Ref: simplex tableau routines117497
Ref: 8b117497
Ref: simplex-tableau-routines117497
Node: Compute row of the tableau117873
Ref: compute row of the tableau118001
Ref: 8c118001
Ref: compute-row-of-the-tableau118001
Node: Compute column of the tableau118803
Ref: compute column of the tableau118974
Ref: 8d118974
Ref: compute-column-of-the-tableau118974
Node: Transform explicitly specified row119833
Ref: transform explicitly specified row120015
Ref: 8e120015
Ref: transform-explicitly-specified-row120015
Node: Transform explicitly specified column120953
Ref: transform explicitly specified column121131
Ref: 8f121131
Ref: transform-explicitly-specified-column121131
Node: Perform primal ratio test122067
Ref: perform primal ratio test122234
Ref: 90122234
Ref: perform-primal-ratio-test122234
Node: Perform dual ratio test123497
Ref: perform dual ratio test123669
Ref: 91123669
Ref: perform-dual-ratio-test123669
Node: Analyze active bound of non-basic variable124925
Ref: analyze active bound of non-basic variable125119
Ref: 92125119
Ref: analyze-active-bound-of-non-basic-variable125119
Node: Analyze objective coefficient at basic variable126843
Ref: analyze objective coefficient at basic variable127005
Ref: 93127005
Ref: analyze-objective-coefficient-at-basic-variable127005
Node: Branch-and-cut API routines130057
Ref: branch-and-cut api routines130228
Ref: 94130228
Ref: branch-and-cut-api-routines130228
Node: Basic routines130515
Ref: basic routines130639
Ref: 95130639
Ref: basic-routines130639
Node: Determine reason for calling the callback routine131090
Ref: determine reason for calling the callback routine131227
Ref: 96131227
Ref: determine-reason-for-calling-the-callback-routine131227
Node: Access the problem object131909
Ref: access the problem object132090
Ref: 97132090
Ref: access-the-problem-object132090
Node: Determine additional row attributes132419
Ref: determine additional row attributes132575
Ref: 98132575
Ref: determine-additional-row-attributes132575
Node: Compute relative MIP gap133702
Ref: compute relative mip gap133865
Ref: 99133865
Ref: compute-relative-mip-gap133865
Node: Access application-specific data134153
Ref: access application-specific data134321
Ref: 9a134321
Ref: access-application-specific-data134321
Node: Select subproblem to continue the search134821
Ref: select subproblem to continue the search135000
Ref: 9b135000
Ref: select-subproblem-to-continue-the-search135000
Node: Provide solution found by heuristic135395
Ref: provide solution found by heuristic135590
Ref: 9c135590
Ref: provide-solution-found-by-heuristic135590
Node: Check whether can branch upon specified variable136433
Ref: check whether can branch upon specified variable136618
Ref: 9d136618
Ref: check-whether-can-branch-upon-specified-variable136618
Node: Choose variable to branch upon137069
Ref: choose variable to branch upon137249
Ref: 9e137249
Ref: choose-variable-to-branch-upon137249
Node: Terminate the solution process137816
Ref: terminate the solution process137939
Ref: 9f137939
Ref: terminate-the-solution-process137939
Node: The search tree exploring routines138206
Ref: the search tree exploring routines138360
Ref: a0138360
Ref: the-search-tree-exploring-routines138360
Node: Determine the search tree size138766
Ref: determine the search tree size138914
Ref: a1138914
Ref: determine-the-search-tree-size138914
Node: Determine current active subproblem139570
Ref: determine current active subproblem139759
Ref: a2139759
Ref: determine-current-active-subproblem139759
Node: Determine next active subproblem140185
Ref: determine next active subproblem140380
Ref: a3140380
Ref: determine-next-active-subproblem140380
Node: Determine previous active subproblem141284
Ref: determine previous active subproblem141478
Ref: a4141478
Ref: determine-previous-active-subproblem141478
Node: Determine parent active subproblem142397
Ref: determine parent active subproblem142585
Ref: a5142585
Ref: determine-parent-active-subproblem142585
Node: Determine subproblem level143085
Ref: determine subproblem level143269
Ref: a6143269
Ref: determine-subproblem-level143269
Node: Determine subproblem local bound143727
Ref: determine subproblem local bound143925
Ref: a7143925
Ref: determine-subproblem-local-bound143925
Node: Find active subproblem with the best local bound144333
Ref: find active subproblem with the best local bound144496
Ref: a8144496
Ref: find-active-subproblem-with-the-best-local-bound144496
Node: The cut pool routines145026
Ref: the cut pool routines145157
Ref: a9145157
Ref: the-cut-pool-routines145157
Node: Determine current size of the cut pool145387
Ref: determine current size of the cut pool145525
Ref: aa145525
Ref: determine-current-size-of-the-cut-pool145525
Node: Add constraint to the cut pool145934
Ref: add constraint to the cut pool146116
Ref: ab146116
Ref: add-constraint-to-the-cut-pool146116
Node: Remove constraint from the cut pool147256
Ref: remove constraint from the cut pool147440
Ref: ac147440
Ref: remove-constraint-from-the-cut-pool147440
Node: Remove all constraints from the cut pool148084
Ref: remove all constraints from the cut pool148229
Ref: ad148229
Ref: remove-all-constraints-from-the-cut-pool148229
Node: Graph and network API routines148516
Ref: graph and network api routines148688
Ref: ae148688
Ref: graph-and-network-api-routines148688
Node: Basic graph routines148877
Ref: basic graph routines148999
Ref: af148999
Ref: basic-graph-routines148999
Node: Create the GLPK graph object149324
Ref: create the glpk graph object149439
Ref: b0149439
Ref: create-the-glpk-graph-object149439
Node: Set the graph name149894
Ref: set the graph name150041
Ref: b1150041
Ref: set-the-graph-name150041
Node: Add vertices to a graph150368
Ref: add vertices to a graph150505
Ref: b2150505
Ref: add-vertices-to-a-graph150505
Node: Add arc to a graph150887
Ref: add arc to a graph151044
Ref: b3151044
Ref: add-arc-to-a-graph151044
Node: Erase content of the GLPK graph object151356
Ref: erase content of the glpk graph object151518
Ref: b4151518
Ref: erase-content-of-the-glpk-graph-object151518
Node: Delete the GLPK graph object152122
Ref: delete the glpk graph object152299
Ref: b5152299
Ref: delete-the-glpk-graph-object152299
Node: Read graph in a plain text format152754
Ref: read graph in a plain text format152927
Ref: b6152927
Ref: read-graph-in-a-plain-text-format152927
Node: Write graph in a plain text format153294
Ref: write graph in a plain text format153430
Ref: b7153430
Ref: write-graph-in-a-plain-text-format153430
Node: Graph analysis routines153801
Ref: graph analysis routines153957
Ref: b8153957
Ref: graph-analysis-routines153957
Node: Find all weakly connected components of a graph154134
Ref: find all weakly connected components of a graph154302
Ref: b9154302
Ref: find-all-weakly-connected-components-of-a-graph154302
Node: Find all strongly connected components of a graph154900
Ref: find all strongly connected components of a graph155068
Ref: ba155068
Ref: find-all-strongly-connected-components-of-a-graph155068
Node: Minimum cost flow problem155673
Ref: minimum cost flow problem155829
Ref: bb155829
Ref: minimum-cost-flow-problem155829
Node: Read minimum cost flow problem data in DIMACS format156209
Ref: read minimum cost flow problem data in dimacs format156388
Ref: bc156388
Ref: read-minimum-cost-flow-problem-data-in-dimacs-format156388
Node: Write minimum cost flow problem data in DIMACS format157881
Ref: write minimum cost flow problem data in dimacs format158108
Ref: bd158108
Ref: write-minimum-cost-flow-problem-data-in-dimacs-format158108
Node: Convert minimum cost flow problem to LP159604
Ref: convert minimum cost flow problem to lp159839
Ref: be159839
Ref: convert-minimum-cost-flow-problem-to-lp159839
Node: Solve minimum cost flow problem with out-of-kilter algorithm161403
Ref: solve minimum cost flow problem with out-of-kilter algorithm161621
Ref: bf161621
Ref: solve-minimum-cost-flow-problem-with-out-of-kilter-algorithm161621
Node: Klingman's network problem generator164377
Ref: klingman's network problem generator164591
Ref: c0164591
Ref: klingman-s-network-problem-generator164591
Node: Grid-like network problem generator166910
Ref: grid-like network problem generator167055
Ref: c1167055
Ref: grid-like-network-problem-generator167055
Node: Maximum flow problem169504
Ref: maximum flow problem169628
Ref: c2169628
Ref: maximum-flow-problem169628
Node: Read maximum cost flow problem data in DIMACS format169954
Ref: read maximum cost flow problem data in dimacs format170128
Ref: c3170128
Ref: read-maximum-cost-flow-problem-data-in-dimacs-format170128
Node: Write maximum cost flow problem data in DIMACS format170405
Ref: write maximum cost flow problem data in dimacs format170622
Ref: c4170622
Ref: write-maximum-cost-flow-problem-data-in-dimacs-format170622
Node: Convert maximum flow problem to LP170906
Ref: convert maximum flow problem to lp171127
Ref: c5171127
Ref: convert-maximum-flow-problem-to-lp171127
Node: Solve maximum flow problem with Ford-Fulkerson algorithm171370
Ref: solve maximum flow problem with ford-fulkerson algorithm171579
Ref: c6171579
Ref: solve-maximum-flow-problem-with-ford-fulkerson-algorithm171579
Node: Goldfarb's maximum flow problem generator171870
Ref: goldfarb's maximum flow problem generator172036
Ref: c7172036
Ref: goldfarb-s-maximum-flow-problem-generator172036
Node: Miscellaneous routines172287
Ref: miscellaneous routines172423
Ref: c8172423
Ref: miscellaneous-routines172423
Node: Library environment routines172521
Ref: library environment routines172611
Ref: c9172611
Ref: library-environment-routines172611
Node: Determine library version172896
Ref: determine library version173028
Ref: ca173028
Ref: determine-library-version173028
Node: Enable/disable terminal output173243
Ref: enable/disable terminal output173424
Ref: cb173424
Ref: enable-disable-terminal-output173424
Node: Enable/disable the terminal hook routine173811
Ref: enable/disable the terminal hook routine173995
Ref: cc173995
Ref: enable-disable-the-terminal-hook-routine173995
Node: Get memory usage information174545
Ref: get memory usage information174721
Ref: cd174721
Ref: get-memory-usage-information174721
Node: Set memory usage limit175460
Ref: set memory usage limit175625
Ref: ce175625
Ref: set-memory-usage-limit175625
Node: Free GLPK library environment175860
Ref: free glpk library environment175988
Ref: cf175988
Ref: free-glpk-library-environment175988
Node: Index176191
Ref: index176283

End Tag Table


Local Variables:
coding: utf-8
End:
