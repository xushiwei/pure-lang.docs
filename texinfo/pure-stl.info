This is pure-stl.info, produced by makeinfo version 4.13 from
pure-stl.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-stl: (pure-stl.info).    pure-stl
END-INFO-DIR-ENTRY


File: pure-stl.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-stl
********

  Version 0.1, September 14, 2011

    Peter Summerland <<p.summerland@gmail.com>> 
  Pure's interface to C++ vectors, specialized to hold pointers to
arbitrary Pure expressions, and the C++ Standard Template Library
algorithms that act on them.

* Menu:

* Copying::
* Installation::
* Overview::
* Error Handling::
* Basic Operations::
* STL Nonmodifying Algorithms::
* STL Modifying Algorithms::
* STL Sort Algorithms::
* STL Merge Algorithms::
* STL Heap Algorithms::
* Min/Max STL Algorithms::
* STL Numeric Algorithms::
* Trace Mode::
* Index::

 --- The Detailed Node Listing ---

Overview

* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Documentation::
* Parameter Names::

Error Handling

* Exception Symbols::
* Examples::

Basic Operations

* Imports::
* Data Structure::
* Support for Copy-On-Write Semantics::
* Operations::
* Convenience Functions::
* Examples: Examples<2>.

STL Nonmodifying Algorithms

* Imports: Imports<2>.
* Operations: Operations<2>.
* Examples: Examples<3>.

STL Modifying Algorithms

* Imports: Imports<3>.
* Operations: Operations<3>.
* Examples: Examples<4>.

STL Sort Algorithms

* Imports: Imports<4>.
* Operations: Operations<4>.
* Examples: Examples<5>.

STL Merge Algorithms

* Imports: Imports<5>.
* Operations: Operations<5>.
* Examples: Examples<6>.

STL Heap Algorithms

* Imports: Imports<6>.
* Operations: Operations<6>.
* Examples: Examples<7>.

Min/Max STL Algorithms

* Imports: Imports<7>.
* Operations: Operations<7>.
* Examples: Examples<8>.

STL Numeric Algorithms

* Imports: Imports<8>.
* Operations: Operations<8>.
* Examples: Examples<9>.


File: pure-stl.info,  Node: Copying,  Next: Installation,  Prev: Top,  Up: Top

1 Copying
*********

    Copyright (c) 2011 by Peter Summerland <<p.summerland@gmail.com>>. 
All rights reserved.

  pure-stlvec is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  pure-stlvec is distributed under a BSD-style license, see the COPYING
file for details.


File: pure-stl.info,  Node: Installation,  Next: Overview,  Prev: Copying,  Up: Top

2 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-stlvec-0.1.tar.gz>.

  To install pure-stlvec (on Linux), extract the source, cd to the
pure-stl directory, and run `make'. After this you can (and should)
also run `make test' to run a few unit tests to make sure that pure-stl
works properly on your system. If `make test' works, run `sudo make
install' to install pure-stlvec on your system.  `make' tries to guess
your Pure installation directory and platform-specific setup. If it
gets this wrong, you can set some variables manually. In particular,
`make install prefix=/usr' sets the installation prefix. Please see the
Makefile for details.


File: pure-stl.info,  Node: Overview,  Next: Error Handling,  Prev: Installation,  Up: Top

3 Overview
**********

The C++ Standard Template Library ("STL") is a library of generic
containers (data structures designed for storing other objects) and a
rich set of generic algorithms that operate on them. pure-stlvec
provides an interface to one of its most useful containers, "vector",
adopted to hold pointers to Pure expressions. The interface provides
Pure programmers with a mutable container "stlvec", that, like the
STL's vector, holds a sequence of objects that can be accessed in
constant time according to their position in the sequence.

* Menu:

* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Documentation::
* Parameter Names::


File: pure-stl.info,  Node: Modules,  Next: Simple Examples,  Up: Overview

3.1 Modules
===========

The usual operations for creating, accessing and modifying stlvecs are
provided by the stlvec module. The operations are similar in name and
function to those provided by the Pure Library for other containers. As
is the case for their Pure Library counterparts, these operations are
in the global namespace.

  In addition to the stlvec module, pure-stlvec provides a group of
modules, sv_modifying, sv_nonmodifying, sv_sort, sv_merge, sv_heap,
sv_minmax and sv_numeric, that are straight wrappers the STL algorithms
(specialized to work with STL vectors of pointers to Pure expressions).
This grouping of the STL algorithms follows that found at
<http://www.cplusplus.com/reference/algorithm/>. This web page contains
a table that summarizes of all of the algorithms in one place.

  pure-stlvec provides an "umbrella" module, stlvec_algorithms, that
pulls in all of the STL algorithm interface modules in one go. The STL
algorithm wrapper functions reside in the stl namespace and have the
same names as their counterparts in the STL.


File: pure-stl.info,  Node: Simple Examples,  Next: Members and Sequences of Members,  Prev: Modules,  Up: Overview

3.2 Simple Examples
===================

Here are some examples that use the basic operations provided by the
stlvec module.

    > using stlvec;

    > let sv1 = stlvec (0..4); members sv1;
    [0,1,2,3,4]

    > insert (sv1,stl::svend) (5..7); members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,3,4,5,6,7]

    > sv1!3;
    3

    > update sv1 3 33; members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,33,4,5,6,7]

    > erase (sv1,2,5); members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,5,6,7]

    > insert (sv1,2) [2,3,4];  members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,3,4,5,6,7]

     > map (+10) sv1;
    [10,11,12,13,14,15,16,17]

    > map (+10) (sv1,2,5);
    [12,13,14]

    > foldl (+) 0 sv1;
    28

    > [x+10 | x = sv1; x mod 2];
    [11,13,15,17]

    > {x+10 | x = (sv1,2,6); x mod 2};
    {13,15}

Here are some examples that use STL algorithms.

    > using stlvec_algorithms;

    > stl::reverse (sv1,2,6); members sv1;
    ()
    [0,1,5,4,3,2,6,7]

    > stl::stable_sort sv1 (>); members sv1;
    ()
    [7,6,5,4,3,2,1,0]

    > stl::random_shuffle sv1; members sv1;
    ()
    [1,3,5,4,0,7,6,2]

    > stl::partition sv1 (<3); members (sv1,0,ans); members sv1;
    3
    [1,2,0]
    [1,2,0,4,5,7,6,3]

    > stl::transform sv1 (sv1,0) (*2); members sv1;
    -1
    [2,4,0,8,10,14,12,6]

    > let sv2 = emptystlvec;

    > stl::transform sv1 (sv2,stl::svback) (div 2); members sv2;
    -1
    [1,2,0,4,5,7,6,3]

Many more examples can be found in the pure-stl/ut directory.


File: pure-stl.info,  Node: Members and Sequences of Members,  Next: STL Iterators and Value Semantics,  Prev: Simple Examples,  Up: Overview

3.3 Members and Sequences of Members
====================================

Throughout the documentation for pure-stlvec, the member of a stlvec
that is at the nth position in the sequence of expressions stored in
the stlvec is referred to as its nth member or nth element. The nth
member of a stlvec, sv, is sometimes denoted by sv!n.  The sequence of
members of sv starting at position i up to but not including j is
denoted by sv[i,j). There is a "past-the-end" symbol, svend, that
denotes the position after that occupied by the last member contained
by a stlvec.

  For example, if sv contains the sequence "a", "b", "c" "d" and "e",
sv!0 is "a", sv[1,3) is the sequence consisting of "b" followed by "c"
and v[3,stl::svend) denotes the sequence consisting of "d" followed by
"e".


File: pure-stl.info,  Node: STL Iterators and Value Semantics,  Next: Iterator Tuples,  Prev: Members and Sequences of Members,  Up: Overview

3.4 STL Iterators and Value Semantics
=====================================

In C++ programmers accesses a STL container's elements by means of
"iterators", which can be thought of as pointers to the containers
elements. A single iterators can be used to access a specific element,
and a pairs of iterators can be used to access a "range" of elements.
By convention, such a range includes the members in the slots pointed
to by the first iterator and all succeeding slots up to but not
including the slot pointed to by the second iterator. Each container
has a past-the-end iterator that can be used to specifiy ranges that
include the its last member.

  In the case of vectors there is an obvious correspondence between an
iterator that points to an element and the element's position (starting
at zero) in the vector.  pure-stlvec uses this correspondence to
designate a stlvec's members in a way that makes it relatively easy to
see how pure-stlvec's functions are acting on the stlvec's underlying
STL vector by referencing the STL's documentation. Thus, if sv is a
stlvec, and j is an int, "update sv j x" uses the STL to replace the
element pointed to by the iterator for position j of sv's underlying
STL vector. If, in addition, k is an int, stl::sort (sv,j,k) (<) uses
the STL to sort the elements in the range designated by the "jth" and
"kth" iterators for sv's underlying STL vector. This range, written as
sv[j,k), is the subsequence of sv that begins with the element at
position j and ends with the element at positon (k-1).

  Besides iterators, another cornerstone of the STL is its "value
semantics", i.e., all of the STL containers are mutable and if a
container is copied, all of its elements are copied. pure-stlvec deals
with the STL's value semantics by introducing mutable and nonmutable
stlvecs, and by storing smart pointers to objects (which have cheap
copies) rather than the actual objects.


File: pure-stl.info,  Node: Iterator Tuples,  Next: Predefined Iterator Tuple Indexes,  Prev: STL Iterators and Value Semantics,  Up: Overview

3.5 Iterator Tuples
===================

As mentioned in the previous section, in C++ ranges are specified by a
pair of STL iterators.

  In pure-stlvec ranges of elements in a stlvec are specified by
"iterator tuples" rather than, say, actual pointers to STL iterators.
Iterator tuples consist of the name of a stlvec followed by one of more
ints that indicate positions (starting from zero) of the stlvec's
elements.

  To illustrate how iterator tuples are used, consider the STL
stable_sort function, which sorts objects in the range [first, last) in
the order imposed by comp. Its C++ signature looks like this:

     void stable_sort ( RandomAccessIterator first,
     RandomAccessIterator last, Compare comp )

  The corresponding pure-stlvec function, from the sv_sort module,
looks like this:

     stable_sort (msv, first, last) comp

  where msv is a mutable stlvec, and first and last are integers. The
first thing that the Pure stable_sort does is create a pair of C++
iterators that point to the first and last positions in msv's
underlying STL vector.  Next it wraps the Pure comp function in a C++
function object that, along with the two iterators can be passed to the
C++ stable_sort function.

  For convenience, (sv,stl::svbeg, stl::svend) can be written simply as
sv. Thus, if first were stl::svbeg (or 0), and last were stl::svend (or
#msv, the number of elements in msv), the last Pure call could be
written:

     stable_sort msv comp

  It should be noted that often the STL library provides a default
version of functions, which like stable_sort, use a comparator or other
callback function provided by the caller. E.g., the C++ stable_sort has
a default version that assumes the "<" operator can be used on the
elements held by the container in question:

     void stable_sort ( RandomAccessIterator first,
     RandomAccessIterator last)

  The corresponding functions provided by the pure-stlvec modules
rarely, if ever, supply a default version. A typical example is
sv_sort's stable_sort which must be called with a comparator callback
function:

     stable_sort msv (<);

  Note also that the comparator (e.g., (<)), or other function being
passed to a pure-stlvec algorithm wrapper is almost always the last
parameter. This is the opposite of what is required for similar Pure
functions, but is consistent with the STL calling conventions.


File: pure-stl.info,  Node: Predefined Iterator Tuple Indexes,  Next: Back Insert Iterators,  Prev: Iterator Tuples,  Up: Overview

3.6 Predefined Iterator Tuple Indexes
=====================================

The following integer constants are defined in the stl namespace for use
in iterator tuples.

 -- constant: stl::svbeg = 0
 -- constant: stl::svend = -1
 -- constant: stl::svback = -2

  `svend' corresponds to STL's past-end iterator for STL vectors. It
makes it possible to specify ranges that include the last element of an
stlvec. I.e., the iterator tuple (sv,stl::svbeg,stl::svend) would
specify sv[0,n), where n is the number of elements in sv. In order to
understand the purpose of `svback', it is necessary to understand a bit
about STL's "back insert iterators."


File: pure-stl.info,  Node: Back Insert Iterators,  Next: Documentation,  Prev: Predefined Iterator Tuple Indexes,  Up: Overview

3.7 Back Insert Iterators
=========================

Many of the STL algorithms insert members into a target range
designated by an iterator that points to the first member of the target
range. Consistent with raw C usage, it is ok to copy over existing
elements the target stlvec. E.g.,:

    > using sv_modifying;

    > let v1 = stlvec (0..2);

    > let v2 = stlvec ("a".."g");

    > stl::copy v1 (v3,2) $$ members v3;
    ["a","b",0,1,2,"f","g"]

This is great for C++ programmers, but for Pure programmers it is almost
always preferable to append the copied items to the end of a new empty
target stlvec, rather than overwriting all or part or part of it. This
can be accomplished using stl::svback. E.g.,:

    > let v3 = emptystlvec;

    > stl::copy v1 (v3,stl::svback) $$ members v3;
    [0,1,2]

    > stl::copy v2 (v3,stl::svback) $$ members v3;
    [0,1,2,"a","b","c","d","e","f","g"]

In short, when a pure-stlvec function detects "stl::svback" in a target
iterator tuple, it constructs a STL "back inserter iterator" and passes
it on to the STL function.


File: pure-stl.info,  Node: Documentation,  Next: Parameter Names,  Prev: Back Insert Iterators,  Up: Overview

3.8 Documentation
=================

The documentation of the functions provided by the stlvec module are
reasonably complete.  In contrast, the descriptions of functions
provided by the STL algorithm modules are purposely simplified (and may
not, therefore, be technically accurate). This reflects that fact that
the functions provided by pure-stlvec have an obvious correspondence to
the functions provided by the STL, and the STL is extremely well
documented. Furthermore, using the Pure interpreter, it is very easy to
simply play around with with any of the pure-stlvec functions if there
are doubts, especially with respect to "corner cases."  Often this
leads to a deeper understanding compared to reading a precise technical
description.

  A good book on the STL is STL Tutorial and Reference Guide, Second
Edition, by David R. Musser, Gillmer J. Derge and Atul Saini. A
summmary of all of the STL algorithms can be found at
<http://www.cplusplus.com/reference/stl/>.


File: pure-stl.info,  Node: Parameter Names,  Prev: Documentation,  Up: Overview

3.9 Parameter Names
===================

In the descriptions of functions that follow, parameter names used in
function descriptions represent specific types of Pure objects:

sv
     stlvec (mutable or immutable)

imsv
     immutable stlvec

msv
     mutable stlvec

x
     an arbitrary Pure expression

xs
     a list of arbitrary Pure expressions

count, sz, n
     whole numbers to indicate a number of elements, size of a vector,
     etc

i,j
     whole numbers used to designate indexes into a stlvec

f,m,l
     whole numbers (or stl::beg or stl::svend) designating the "first",
     "middle" or "last" iterators in a stlvec iterator tuple

p
     a whole number (or other iterator constant such as stl::svend or
     stl::svback) used in a two element iterator tuple (e.g., (sv,p))

(sv,p)
     an iterator tuple that will be mapped to an iterator that points
     to the pth position of sv's underlying STL vector, v, (or to a
     back iterator on v if p is stl::svback

(sv,f,l)
     an iterator tuple that will be mapped to the pair of iterators
     that are designated by (sv,f) and (sv,l)

(sv,f,m,l)
     an iterator tuple that will be mapped to the iterators that are
     designated by (sv,f), (sv,m) and (sv,l)

sv[f,l)
     the range of members beginning with that at (sv,f) up to but not
     including that at (con,l)

comp
     a function that accepts two objects and returns true if the first
     argument is less than the second (in the strict weak ordering
     defined by comp), and false otherwise

unary_pred
     a function that accepts one object and returns true or false

bin_pred
     a function that accepts two objects and returns true or false

unary_fun
     a function that accepts one objects and returns another

bin_fun
     a function that accepts two objects and returns another

gen_fun
     a function of one parameter that produces a sequence of objects,
     one for each call (gen_fun 0). E.g., see test_generate in
     ut_sv_modifying.pure

  For readability, and to correspond with the STL documentation, the
words "first", "middle", and "last", or variants such as "first1" are
often used instead of f,m,l.


File: pure-stl.info,  Node: Error Handling,  Next: Basic Operations,  Prev: Overview,  Up: Top

4 Error Handling
****************

The functions provided this module handle errors by throwing exceptions.

* Menu:

* Exception Symbols::
* Examples::


File: pure-stl.info,  Node: Exception Symbols,  Next: Examples,  Up: Error Handling

4.1 Exception Symbols
=====================

 -- constructor: bad_argument
     This exception is thrown when a function is passed an unexpected
     value. A subtle error to watch for is a malformed iterator tuple
     (e.g., one with the wrong number of elements).

 -- constructor: bad_function
     This exception is thrown when a purported Pure call-back function
     is not even callable.

 -- constructor: failed_cond
     This exception is thrown when a Pure call-back predicate returns a
     value that is not an int.

 -- constructor: out_of_bounds
     This exception is thrown if the specified index is out of bounds.

 -- constructor: range_overflow
     This exception is thrown by functions that write over part of a
     target stlvec (e.g., copy) when the target range too small to
     accommodate the result.

 -- constructor: range_overlap
     This exception is thrown by algorithm functions that write over
     part of a target stlvec when the target and source ranges overlap
     in a way that is not allowed.

  In addition, any exception thrown by a Pure callback function passed
to a pure-stlvec function will be caught and be rethrown by the
pure-stlvec function.


File: pure-stl.info,  Node: Examples,  Prev: Exception Symbols,  Up: Error Handling

4.2 Examples
============

    > using stlvec, sv_modifying;

    > let sv1 = stlvec (0..4); members sv1;
    [0,1,2,3,4]

    > let sv2 = stlvec ("a".."e"); members sv2;
    ["a","b","c","d","e"]

    > sv1!10;
    <stdin>, line 25: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,10);
    <stdin>, line 26: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,2,3); // sb (sv2,pos)
    <stdin>, line 22: unhandled exception 'bad_argument' ...

    > stl::copy sv1 (sv2,2);
    <stdin>, line 23: unhandled exception 'range_overflow' ...

    > stl::copy sv2 (sv2,2);
    <stdin>, line 24: unhandled exception 'range_overlap' ...

    > stl::copy (sv1,1,3) (sv2,0); members sv2; // ok
    2
    [1,2,"c","d","e"]

    > stl::sort sv2 (>); // apples and oranges
    <stdin>, line 31: unhandled exception 'failed_cond'

    > listmap (\x->throw DOA) sv1; // callback function throws exception
    <stdin>, line 34: unhandled exception 'DOA' ...



File: pure-stl.info,  Node: Basic Operations,  Next: STL Nonmodifying Algorithms,  Prev: Error Handling,  Up: Top

5 Basic Operations
******************

The stlvec module provides functions for creating, accessing and
modifying stlvecs. They are all in the global namespace.

* Menu:

* Imports::
* Data Structure::
* Support for Copy-On-Write Semantics::
* Operations::
* Convenience Functions::
* Examples: Examples<2>.


File: pure-stl.info,  Node: Imports,  Next: Data Structure,  Up: Basic Operations

5.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec;



File: pure-stl.info,  Node: Data Structure,  Next: Support for Copy-On-Write Semantics,  Prev: Imports,  Up: Basic Operations

5.2 Data Structure
==================

Currently, stlvecs are of the form (STLVEC x) or (CONST_STLVEC x),
where x is a pointer to the underlying STL vector. E.g.,:

    > let v1 = stlvec (0..3); v1;
    STLVEC #<pointer 0x915c8e0>

    > members v1;
    [0,1,2,3]

    > let v2 = stlconst $ stlvec (0..3); v2;
    CONST_STLVEC #<pointer 0x8c1dbf0>

This representation may change in the future, and must not be relied
upon by client modules. In particular, one must never attempt to use the
embedded pointer directly.

  Three type tags are provided:

 -- type: mutable_stlvec
     The type for a mutable stlvec. The stlvec must have been
     constructed with STLVEC.

 -- type: const_stlvec
     The type for an immutable stlvec. The stlvec must have been
     constructed with CONST_STLVEC.

 -- type: stlvec
     The type for a stlvec, mutable or immutable. The stvec can be
     constructed with STLVEC or CONST_STLVEC.

  Functions that modify a stlvec will simply fail unless the stlvec is
mutable:

    > update v2 0 100;
    update (CONST_STLVEC #<pointer 0x9f07690>) 0 100



File: pure-stl.info,  Node: Support for Copy-On-Write Semantics,  Next: Operations,  Prev: Data Structure,  Up: Basic Operations

5.3 Support for Copy-On-Write Semantics
=======================================

The functions that create new stlvecs (emptystlvec, stlvec, and
mkstlvec) return a mutable stlvec. The new stlvecs can be converted to
immutable stlvecs (usually after they have been modified) by the
`stlconst' function. This function converts a mutable stlvec to an
immutable stlvec without changing the underlying STL vector.

  Using a copy-on-write strategy it is possible to use stlvecs in a
manner that is consistent with functional programming.  Typically, a
function that "updates" a stlvec passed to it as an argument will copy
the input stlvec to a new locally scoped mutable stlvec, modify the new
stlvec and use stlconst to make the new stlvec immutable before it is
returned. It should be noted that several of the STL algorithms have
"copy" versions which place their results directly into a new stlvec,
which can eliminate the need to copy the input stlvec. E.g.:

    > let sv1 = stlvec ("a".."e");

    > let sv2 = emptystlvec;

    > stl::reverse_copy sv1 (sv2,stl::svback) $$ members sv2;
    ["e","d","c","b","a"]

Without reverse_copy, one have to copy sv1 into sv2 and then reverse
sv2.


File: pure-stl.info,  Node: Operations,  Next: Convenience Functions,  Prev: Support for Copy-On-Write Semantics,  Up: Basic Operations

5.4 Operations
==============

When reading the function descriptions that follow, please bear in mind
that whenever a function is passed an iterator tuple of the form
(sv,first, last), first and last can be dropped, leaving (sv), or
simply sv. The function will treat the "unary" iterator tuple (sv) as
(sv, stl::svbeg, stl::svend).

 -- Function: emptystlvec
     return an empty stlvec

 -- Function: stlvec (sv,first,last)
     create a new stlvec consisting of the elements in sv[first,last)

 -- Function: stlvec xs
     create a new stlvec from a list of values

 -- Function: mkstlvec x count
     create a new stlvec consisting of count x's.

 -- Function: stlconst sv
     create an immutable stlvec that shares the same underlying STL
     vector with sv

 -- Function: # sv
     return the size of sv

 -- Function: reserve msv count
     modify the underlying STL vector have at least count slots,
     usually to speed up addition of new members

 -- Function: capacity sv
     return the total amount of slots held by the underlying STL vector

 -- Function: null sv
     test whether sv is empty

 -- Function: sv ! i
     return the ith member of sv

 -- Function: first sv
 -- Function: last sv
     first and last member of sv

 -- Function: members (sv, first, last)
     return a list of values stored in sv[first,last)

 -- Function: update msv i x
     replace the ith member of msv by x

 -- Function: append sv x
     append x to the end of sv

 -- Function: insert (msv,p) xs
 -- Function: insert (msv,p) (sv,first,last)
     insert members of the list xs or the range sv[first, last) into
     msv, all preceding the pth member of msv. Members are shifted to
     make room for the inserted members

 -- Function: rmfirst msv
 -- Function: rmlast msv
     remove first and last member from msv

 -- Function: erase (msv,first,last)
 -- Function: erase (msv,p)
 -- Function: erase msv
     remove msv[first,last), msv[p,p+1) or all of msv frommsv.

 -- Function: clear msv
     remove all of msv's members

 -- Function: all_equal comp (sv1, first1, last1) (sv2, first2, last2)
     returns true if comp returns true for all corresponding members of
     sv1[first1, last1) and sv1[first1, last1)

 -- Function: sv1 == sv2
 -- Function: sv1 ~= sv2
     (x == y) is the same as equal (==) x y. (x ~= y is simply ~(equal
     (==) x y)

  Note that `==' and `~==' are not defined for iterator tuples (the
rules would never be executed because == is defined on tuples in the
Prelude)


File: pure-stl.info,  Node: Convenience Functions,  Next: Examples<2>,  Prev: Operations,  Up: Basic Operations

5.5 Convenience Functions
=========================

The stlvec module provides convenience functions that apply map, catmap,
foldl, etc, to directly access Pure expressions stored in a stlvec.

 -- Function: map unary_fun (sv, first, last)
     one pass equivalent of map unary_fun $ members (sv, first, last)

 -- Function: listmap unary_fun (sv, first, last)
     same as map, used in list comprehensions

 -- Function: catmap unary_fun (sv, first, last)
     one pass equivalent of catmap unary_fun $ members (sv, first, last)

 -- Function: do unary_fun (sv, first, last)
     one pass equivalent of do unary_fun $ members (sv, first, last)

 -- Function: foldl bin_fun x (sv, first, last)
     one pass equivalent of foldl bin_fun x $ members (sv, first, last)

 -- Function: foldl1 bin_fun (sv, first, last)
     one pass equivalent of foldl1 bin_fun $ members (sv, first, last)

 -- Function: filter unary_pred (sv, first, last)
     one pass equivalent of filter unary_pred $ members (sv, first,
     last)

  The following four functions map (or catmap) stlvecs onto row and col
matrixes, primarily for use in matrix comprehensions.

 -- Function: rowmap unary_fun (sv, first, last)

 -- Function: rowcatmap unary_fun (sv, first, last)

 -- Function: colmap unary_fun (sv, first, last)

 -- Function: colcatmap unary_fun (sv, first, last)

  Please note that "stlvec to stlvec" functions are provided by the
pure-stl algorithm modules. Thus, for example, the stlvec module does
not provide a function that maps one stlvec onto a new stlvec. That
functionality, and more, is provided by stl::transform, which can be
found in the sv_modifying module.


File: pure-stl.info,  Node: Examples<2>,  Prev: Convenience Functions,  Up: Basic Operations

5.6 Examples
============

See ut_stvec in the ut subfolder.


File: pure-stl.info,  Node: STL Nonmodifying Algorithms,  Next: STL Modifying Algorithms,  Prev: Basic Operations,  Up: Top

6 STL Nonmodifying Algorithms
*****************************

The sv_nonmodifying.pure module provides an interface to the STL's
non-modifying sequence operations.

* Menu:

* Imports: Imports<2>.
* Operations: Operations<2>.
* Examples: Examples<3>.


File: pure-stl.info,  Node: Imports<2>,  Next: Operations<2>,  Up: STL Nonmodifying Algorithms

6.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using sv_nonmodifying;

All of the functions are in the stl namespace.


File: pure-stl.info,  Node: Operations<2>,  Next: Examples<3>,  Prev: Imports<2>,  Up: STL Nonmodifying Algorithms

6.2 Operations
==============

 -- Function: stl::for_each (sv, first, last) unary_fun
     applies unary_fun to each of the elements in sv[first,last)

 -- Function: stl::find (sv, first, last) x
     returns the position of the first element in sv[first,last) for
     which (==x) is true (or svend if not found)

 -- Function: stl::find_if (sv, first, last) unary_pred
     returns the position of the first element in sv[first,last) for
     which unary_pred is true (or svend if not found)

 -- Function: stl::find_first_of (sv1, first1, last1) (sv2, first2,
          last2) bin_pred
     Returns the position of the first element, x, in sv1[first1,last1)
     for which there exists y in sv2[first2,last2) and (bin_pred x y)
     is true (or svend if no such x exists).

 -- Function: stl::adjacent_find (sv, first, last) bin_pred
     search sv[first,last) for the first occurrence of two consecutive
     elements (x,y) for which (bin_pred x y) is true. Returns the
     position of x, if found, or svend if not found)

 -- Function: stl::count (sv, first, last) x
     returns the number of elements in the range sv[first,last) for
     which (x==) is true

 -- Function: stl::count_if (sv, first, last) unary_pred
     returns the number of elements in the range sv[first,last) for
     which unary_pred is true

 -- Function: stl::mismatch (sv1, first1, last1) (sv2, first2) bin_pred
     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1 until it
     finds i and j such that bin_pred (sv1!i) (sv2!j) is false and
     returns (i,j). If bin_pred is true for all of the pairs of
     elements, i will be svend and j will be first2 + n (or svend)

 -- Function: stl::equal (sv1, first1, last1) (sv2, first2) bin_pred
     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1, and returns
     true if bin_pred is true for each pair

 -- Function: stl::search (sv1, first1, last1) (sv2, first2) bin_pred
     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the first occurrence of the sequence defined
     by sv2[first2,last2), and returns the position in sv1 of its first
     element (or svend if not found)

 -- Function: stl::search_n (sv, first, last) count x bin_pred
     using bin_pred to determine equality of the elements, searches
     sv[first,last) for a sequence of count elements that equal x. If
     such a sequence is found, it returns the position of the first of
     its elements, otherwise it returns svend

 -- Function: stl::find_end (sv1, first1, last1) (sv2, first2, last2)
          bin_pred
     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the last occurrence of sv2[first2,last2).
     Returns the position of the first element in sv1 of the occurrence
     (or svend if not found).


File: pure-stl.info,  Node: Examples<3>,  Prev: Operations<2>,  Up: STL Nonmodifying Algorithms

6.3 Examples
============

See ut_sv_nonmodifying.pure


File: pure-stl.info,  Node: STL Modifying Algorithms,  Next: STL Sort Algorithms,  Prev: STL Nonmodifying Algorithms,  Up: Top

7 STL Modifying Algorithms
**************************

The sv_modifying module provides an interface to the STL's modifying
algorithms.

* Menu:

* Imports: Imports<3>.
* Operations: Operations<3>.
* Examples: Examples<4>.


File: pure-stl.info,  Node: Imports<3>,  Next: Operations<3>,  Up: STL Modifying Algorithms

7.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using sv_modifying;

All of the functions are in the stl namespace.


File: pure-stl.info,  Node: Operations<3>,  Next: Examples<4>,  Prev: Imports<3>,  Up: STL Modifying Algorithms

7.2 Operations
==============

 -- Function: stl::copy (sv, first1, last1) (msv, first2)
     copies the elements in sv[first1,last1) into a range whose first
     element is (msv,first2)

 -- Function: stl::copy_backward (sv,first1,last1) (msv,last2)
     copies the elements in sv[first1,last1), moving backward from
     (last1), into the range msv[first2,last2) where first2 is last2
     minus the number of elements in sv[first1,last1)

 -- Function: stl::swap_ranges (sv,first,last) (msv, p)
     exchanges the elements in sv[first, last) with those in msv[p,
     p+n) where n is last - first

 -- Function: stl::transform (sv,first,last) (msv, p) unary_fun
     applies unary_fun to the elements of sv[first,last) and places the
     resulting sequence in msv[p, p+n) where n is last - first. If sv
     is mutable, msv and sv can be the same stlvec. Returns (msv,p+n)

 -- Function: stl::transform_2 (sv1,first1,last1) (sv2,first2) (msv, p)
          bin_fun
     applies bin_fun to corresponding pairs of elements of
     sv1[first1,last1) sv2[first2,n) and and places the resulting
     sequence in msv[p, p+n) where n is last1 - first1. Returns
     (msv,p+n)

 -- Function: stl::replace (msv,first,last) x y
     same as *note replace_if: 5f. (msv,first,last) (x==) y

 -- Function: stl::replace_if (msv,first,last) unary_pred x
     replace the elements of msv[first,last) that satistfy unary_pred
     with x

 -- Function: stl::replace_copy (sv,first,last) (msv,p) x y
     same as *note replace: 5e. (msv,first,last) x y except that the
     modified sequence is placed in msv[p,p+last-first)

 -- Function: stl::replace_copy_if (sv,first,last) (msv,p) unary_pred x
     same as *note replace_if: 5f. except that the modified sequence is
     placed in msv[p,p+last-first)

 -- Function: stl::fill (msv,first,last) x
     replace all elements in msv[first,last) with x

 -- Function: stl::fill_n (msv,first) n x
     replace the elements of msv[first,first+n) with x

 -- Function: stl::generate (msv,first,last) gen_fun
     replace the elements in msv[first,last) with the sequence
     generated by successive calls to gen_fun

 -- Function: stl::generate_n (msv,first) n gen_fun
     replace all elements in msv[first,first+n) with the sequence
     generated by successive calls to gen_fen

 -- Function: stl::remove (msv,first,last) x
     same as *note remove_if: 67. (msv,first,last) (==x).

 -- Function: stl::remove_if (msv,first,last) unary_pred
     remove elements in msv[first,last) that do not satisfy unary_pred.
     If n elements satisfy unary_pred, they are moved to
     msv[first,first+n), preserving their relative order. The content
     of msv[first+n,svend) is undefined. Returns first+n, or svend if
     first+n is greater than the number of elements in msv

 -- Function: stl::remove_copy (sv,first,last) (msv,first) x
     same as *note remove: 66. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::remove_copy_if (sv,first,last) (msv,first) unary_pred
     Same as *note remove_if: 67. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::unique (msv,first,last) bin_pred
     eliminates consecutive duplicates from sv[first,last), using
     bin_pred to test for equality. The purged sequence is moved to
     sv[first,first+n) preserving their relative order, where n is the
     size of the purged sequence. Returns first+n or svend if first+n
     is greater than the number of elements in msv

 -- Function: stl::unique_copy (sv,first,last) (msv,first) bin_pred
     Same as *note unique: 6a. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::reverse (msv,first,last)
     Reverses the order of the elements in sv[first,last).

 -- Function: stl::reverse_copy (sv,first,last) (msv,first)
     same as *note reverse: 6c. except that the reversed sequence is
     copied to (msv,first) and sv[first,last) is not changed.

 -- Function: stl::rotate (msv,first,middle,last)
     rotates the elements of msv[first,middle,last] so that middle
     becomes the first element of msv[first,last].

 -- Function: stl::rotate_copy (msv,first,middle,last) (msv,first)
     same as rotate except that the rotated sequence is copied to
     (msv,first) and sv[first,last) is not changed.

 -- Function: stl::random_shuffle (msv,first,last)
     randomly reorders the elements in msv[first,last).

 -- Function: stl::partition (msv,first,last) unary_pred
     places the elements in msv[first,last) that satisfy unary_pred
     before those that don't. Returns middle, where msv [first,middle)
     contains all of the elements that satisfy unary_pre, and msv
     [middle, last) contains those that do not

 -- Function: stl::stable_partition (msv,first,last) unary_pred
     same as partition except that the relative positions of the
     elements in each group are preserved


File: pure-stl.info,  Node: Examples<4>,  Prev: Operations<3>,  Up: STL Modifying Algorithms

7.3 Examples
============

See ut_sv_modifying.pure


File: pure-stl.info,  Node: STL Sort Algorithms,  Next: STL Merge Algorithms,  Prev: STL Modifying Algorithms,  Up: Top

8 STL Sort Algorithms
*********************

The sv_sort.pure module provides an interface to the STL's sorting and
binary search algorithms.

* Menu:

* Imports: Imports<4>.
* Operations: Operations<4>.
* Examples: Examples<5>.


File: pure-stl.info,  Node: Imports<4>,  Next: Operations<4>,  Up: STL Sort Algorithms

8.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using sv_sort;

All of the functions are in the stl namespace.


File: pure-stl.info,  Node: Operations<4>,  Next: Examples<5>,  Prev: Imports<4>,  Up: STL Sort Algorithms

8.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering functions, comp (as for the Pure library sort function). The
functions (<) and (>) are commonly passed as comp.

 -- Function: stl::sort (msv, first, last) comp
     sorts msv[first, last)

 -- Function: stl::stable_sort (msv, first, last) comp
     sorts msv[first, last), preservint the relative order of equal
     members

 -- Function: stl::partial_sort (msv, first, middle, last) comp
     fills msv[first, middle) with the elements of msv[first,last) that
     would appear there if msv[first,last) were sorted using comp and
     fills msv[middle,last) with the remaining elements in unspecified
     order

 -- Function: stl::partial_sort_copy (sv, first1, last1) (msv, first2,
          last2) comp
     let n be the number of elements in sv[first1, last1) and r be the
     number of elements in msv[first2, last2). If r < n, *note
     partial_sort_copy: 7a. fills msv[first2, last2) with the first r
     elements of what sv[first1, last1) would be if it had been sorted.
     If r >= n, it fills msv[first2, first2+n) with the elements of
     sv[first1, last1) in sorted order. sv[first1,last1) is unchanged

 -- Function: stl::nth_element (msv, first, middle, last) comp
     rearranges the elements of msv[first, last) as follows. Let n be
     middle - first, an x nth smallest element of msv[first, last).
     Sfter the function is called, sv!middle will be x. All of the
     elements of msv[first, middle) will be less than x and all of the
     elements of msv[middle+1, last) will be greater than x

  The next four functions assume that sv[first, last) is ordered by
comp.

 -- Function: stl::lower_bound (sv, first, last) x comp
     returns an integer p that such that (sv,p) is the first position
     into which x can be inserted into sv[first, last) while
     maintaining the sorted ordering

 -- Function: stl::upper_bound (sv, first, last) x comp
     returns an integer p that such that (sv,p) is the last position
     into which x can be inserted into sv[first, last) while
     maintaining the sorted ordering

 -- Function: stl::equal_range (sv, first, last) x comp
     returns a tuple, (lower, upper) where lower and upper would have
     been returned by separate calls to lower_bound and upper_bound.

 -- Function: stl::binary_search (sv, first, last) x comp
     returns true if x is an element of sv[first, last)


File: pure-stl.info,  Node: Examples<5>,  Prev: Operations<4>,  Up: STL Sort Algorithms

8.3 Examples
============

See ut_sv_sort.pure in the pure-stl/ut directory.


File: pure-stl.info,  Node: STL Merge Algorithms,  Next: STL Heap Algorithms,  Prev: STL Sort Algorithms,  Up: Top

9 STL Merge Algorithms
**********************

The sv_merge module provides an interface to the STL's merge
algorithms. These algorithms operate on sorted ranges.

* Menu:

* Imports: Imports<5>.
* Operations: Operations<5>.
* Examples: Examples<6>.


File: pure-stl.info,  Node: Imports<5>,  Next: Operations<5>,  Up: STL Merge Algorithms

9.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using sv_merge;

All of the functions are in the stl namespace.


File: pure-stl.info,  Node: Operations<5>,  Next: Examples<6>,  Prev: Imports<5>,  Up: STL Merge Algorithms

9.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering functions, comp (as for the Pure library sort function). They
only work properly on input ranges that have been previously sorted
using comp.

  See parameter naming conventions at ..

 -- Function: stl::merge (sv1,first1,last1) (sv2,first2,last2) (msv,p)
          comp
     merges the two sorted ranges into the range msv[p,p+n) where n is
     the total length of the merged sequence


File: pure-stl.info,  Node: Examples<6>,  Prev: Operations<5>,  Up: STL Merge Algorithms

9.3 Examples
============

See ut_sv_merge.pure


File: pure-stl.info,  Node: STL Heap Algorithms,  Next: Min/Max STL Algorithms,  Prev: STL Merge Algorithms,  Up: Top

10 STL Heap Algorithms
**********************

The sv_heap.pure module provides an interface to the STL's heap
operations.

* Menu:

* Imports: Imports<6>.
* Operations: Operations<6>.
* Examples: Examples<7>.


File: pure-stl.info,  Node: Imports<6>,  Next: Operations<6>,  Up: STL Heap Algorithms

10.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using sv_heap;

All of the functions are in the stl namespace.


File: pure-stl.info,  Node: Operations<6>,  Next: Examples<7>,  Prev: Imports<6>,  Up: STL Heap Algorithms

10.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering functions, comp (as for the Pure library sort function). The
functions (<) and (>) are commonly passed as comp.

 -- Function: stl::make_heap (msv,first,last) comp
     rearranges the elements of msv[first,last) so that they are a
     heap, i.e., after this msv!first will be the largest element in
     msv[first,last), and push_heap and pop_heap will work properly

 -- Function: stl::push_heap (msv,first,last) comp
     makes msv[first,last) a heap (assuming that msv[first,last-1) was
     a heap)

 -- Function: stl::pop_heap (msv,first,last) comp
     swaps msv!first with msv!(last-1), and makes msv[first,last-1) a
     heap (assuming that msv[first,last) was a heap)

 -- Function: stl::sort_heap (msv,first,last) comp
     sorts the elements in msv[first,last)


File: pure-stl.info,  Node: Examples<7>,  Prev: Operations<6>,  Up: STL Heap Algorithms

10.3 Examples
=============

See ut_sv_heap.pure


File: pure-stl.info,  Node: Min/Max STL Algorithms,  Next: STL Numeric Algorithms,  Prev: STL Heap Algorithms,  Up: Top

11 Min/Max STL Algorithms
*************************

The sv_minmax.pure module provides an interface to a few additional STL
algorithms.

* Menu:

* Imports: Imports<7>.
* Operations: Operations<7>.
* Examples: Examples<8>.


File: pure-stl.info,  Node: Imports<7>,  Next: Operations<7>,  Up: Min/Max STL Algorithms

11.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using sv_minmax;

All of the functions are in the stl namespace.


File: pure-stl.info,  Node: Operations<7>,  Next: Examples<8>,  Prev: Imports<7>,  Up: Min/Max STL Algorithms

11.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering functions, comp (as for the Pure library sort function). The
functions (<) and (>) are commonly passed as comp.

 -- Function: stl::min_element (sv,first,last) comp
     returns the position of the minimal element of sv[first,last)
     under the ordering defined by comp

 -- Function: stl::max_element (sv,first,last) comp
     returns the position of the maximal element of sv[first,last)
     under the ordering defined by comp

 -- Function: stl::lexicographical_compare (sv1,first1,last1)
          (sv2,first2,last2) comp
     compares sv1[first1,last1) and sv2[first2,last2) element by
     element according to the ordering defined by comp, and returns
     true if the first sequence is less than the second

  Algorithms are provided for stepping through all the permutations the
elements of a stlvec. For these purposes, the first permutation has the
elements of msv[first,last) in ascending order and the last has the
elements in descending order.

 -- Function: stl::next_permutation (msv,first,last) comp
     rearranges msv[first,last) to produce the next permutation, in the
     ordering imposed by comp. If msv[first,last) is not the last
     permutation, change msv[first,last) to the next permutation and
     return true. Otherwise, change it to the first permutation and
     return true

 -- Function: stl::prev_permutation (msv,first,last) comp
     next_permutation in reverse


File: pure-stl.info,  Node: Examples<8>,  Prev: Operations<7>,  Up: Min/Max STL Algorithms

11.3 Examples
=============

See ut_sv_minmax.pure


File: pure-stl.info,  Node: STL Numeric Algorithms,  Next: Trace Mode,  Prev: Min/Max STL Algorithms,  Up: Top

12 STL Numeric Algorithms
*************************

The sv_numeric.pure module provides an interface to the STL's numeric
algorithms.

* Menu:

* Imports: Imports<8>.
* Operations: Operations<8>.
* Examples: Examples<9>.


File: pure-stl.info,  Node: Imports<8>,  Next: Operations<8>,  Up: STL Numeric Algorithms

12.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using sv_numeric;

All of the functions are in the stl namespace.


File: pure-stl.info,  Node: Operations<8>,  Next: Examples<9>,  Prev: Imports<8>,  Up: STL Numeric Algorithms

12.2 Operations
===============

 -- Function: stl::accumulate (sv,first,last) x bin_fun
     accumulate bin_fun over x and the members of sv[first,last)

 -- Function: stl::inner_product (sv1,first1,last1) (sv2,first2,last2)
          x bin_fun1 bin_fun2
     initialize ret with x. Traverse pairs of elements of
     sv1[first1,last1) and sv2[first2,last2), denoted by (e1, e2),
     replacing ret with (bin_fun1 ret $ bin_fun2 e1 e2). The number
     pairs traversed is equal to the size of sv1[first1,last1)

 -- Function: stl::partial_sum (sv,first,last) (msv, p) bin_fun
     accumulates bin_fun f over the elements of sv1[first1,last1), as
     with foldl1, places itermediate results in msv[p,p+N), where N is
     last - first, and returns q where M is q - N and msv[M,q) is the
     intermediate sequence

 -- Function: stl::adjacent_difference (sv,first,last) (msv, p) bin_fun
     produces a sequence of new elements by applying bin_fun to adjacent
     elements of sv[first,last), places the new elements in msv[p,p+N),
     where N is last - first, with the intermediate results, and
     returns q where M is q - N and msv[M,q) is the new sequence


File: pure-stl.info,  Node: Examples<9>,  Prev: Operations<8>,  Up: STL Numeric Algorithms

12.3 Examples
=============

See ut_sv_numeric.pure in the ut subfolder.


File: pure-stl.info,  Node: Trace Mode,  Next: Index,  Prev: STL Numeric Algorithms,  Up: Top

13 Trace Mode
*************

If the pure-stl dlls are built using 'make debug' (as opposed to 'make'
or 'make dlls'), the pure-stl tracing functions will be enabled. These
functions, all of which are defined in the stl namespace, can be used
to trace the creation and deletion of stlvecs as well as the changes in
ref counts that occur as Pure objects are moved and copied. In addition
to being useful for maintaining the pure-stl modules, these functions
can be used to observe the STL copy semantics.

 -- Function: stl::set_sv_trace on_off::int
     enables or disables tracing the creation and deletion of stlvecs

 -- Function: stl::sv_trace_enabled
     returns 1 if stlvec tracing is enabled, else 0

 -- Function: stl::set_px_trace on_off::int
     enables or disables tracing 'copying' of Pure expressions

 -- Function: stl::px_trace_enabled
     returns 1 if Pure expression tracing is enabled, else 0

  In addition, the following function, also in the stl namespace, is
available whether or not debug is passed to make.

 -- Function: stl::refc x
     returns the x's reference count (maintained by the Pure runtime for
     garbage collection purposes)


File: pure-stl.info,  Node: Index,  Prev: Trace Mode,  Up: Top

Index
*****

 [index ]
* Menu:

* # prefix function:                     Operations.          (line  28)
* == infix function:                     Operations.          (line  79)
* all_equal function:                    Operations.          (line  75)
* append function:                       Operations.          (line  54)
* bad_argument constructor:              Exception Symbols.   (line   6)
* bad_function constructor:              Exception Symbols.   (line  11)
* capacity function:                     Operations.          (line  35)
* catmap function:                       Convenience Functions.
                                                              (line  15)
* clear function:                        Operations.          (line  72)
* colcatmap function:                    Convenience Functions.
                                                              (line  40)
* colmap function:                       Convenience Functions.
                                                              (line  38)
* const_stlvec type:                     Data Structure.      (line  28)
* do function:                           Convenience Functions.
                                                              (line  18)
* emptystlvec function:                  Operations.          (line  12)
* erase function:                        Operations.          (line  67)
* failed_cond constructor:               Exception Symbols.   (line  15)
* filter function:                       Convenience Functions.
                                                              (line  27)
* first function:                        Operations.          (line  44)
* foldl function:                        Convenience Functions.
                                                              (line  21)
* foldl1 function:                       Convenience Functions.
                                                              (line  24)
* infix function:                        Operations.          (line  41)
* insert function:                       Operations.          (line  57)
* last function:                         Operations.          (line  44)
* listmap function:                      Convenience Functions.
                                                              (line  12)
* map function:                          Convenience Functions.
                                                              (line   9)
* members function:                      Operations.          (line  48)
* mkstlvec function:                     Operations.          (line  21)
* mutable_stlvec type:                   Data Structure.      (line  24)
* null function:                         Operations.          (line  38)
* out_of_bounds constructor:             Exception Symbols.   (line  19)
* range_overflow constructor:            Exception Symbols.   (line  22)
* range_overlap constructor:             Exception Symbols.   (line  27)
* reserve function:                      Operations.          (line  31)
* rmfirst function:                      Operations.          (line  63)
* rmlast function:                       Operations.          (line  63)
* rowcatmap function:                    Convenience Functions.
                                                              (line  36)
* rowmap function:                       Convenience Functions.
                                                              (line  34)
* stl accumulate function:               Operations<8>.       (line   6)
* stl adjacent_difference function:      Operations<8>.       (line  22)
* stl adjacent_find function:            Operations<2>.       (line  23)
* stl binary_search function:            Operations<4>.       (line  56)
* stl copy function:                     Operations<3>.       (line   6)
* stl copy_backward function:            Operations<3>.       (line  10)
* stl count function:                    Operations<2>.       (line  28)
* stl count_if function:                 Operations<2>.       (line  32)
* stl equal function:                    Operations<2>.       (line  43)
* stl equal_range function:              Operations<4>.       (line  52)
* stl fill function:                     Operations<3>.       (line  46)
* stl fill_n function:                   Operations<3>.       (line  49)
* stl find function:                     Operations<2>.       (line   9)
* stl find_end function:                 Operations<2>.       (line  60)
* stl find_first_of function:            Operations<2>.       (line  17)
* stl find_if function:                  Operations<2>.       (line  13)
* stl for_each function:                 Operations<2>.       (line   6)
* stl generate function:                 Operations<3>.       (line  52)
* stl generate_n function:               Operations<3>.       (line  56)
* stl inner_product function:            Operations<8>.       (line   9)
* stl lexicographical_compare function:  Operations<7>.       (line  18)
* stl lower_bound function:              Operations<4>.       (line  42)
* stl make_heap function:                Operations<6>.       (line  10)
* stl max_element function:              Operations<7>.       (line  14)
* stl merge function:                    Operations<5>.       (line  13)
* stl min_element function:              Operations<7>.       (line  10)
* stl mismatch function:                 Operations<2>.       (line  36)
* stl next_permutation function:         Operations<7>.       (line  29)
* stl nth_element function:              Operations<4>.       (line  32)
* stl partial_sort function:             Operations<4>.       (line  17)
* stl partial_sort_copy function:        Operations<4>.       (line  23)
* stl partial_sum function:              Operations<8>.       (line  16)
* stl partition function:                Operations<3>.       (line 107)
* stl pop_heap function:                 Operations<6>.       (line  19)
* stl prev_permutation function:         Operations<7>.       (line  36)
* stl push_heap function:                Operations<6>.       (line  15)
* stl px_trace_enabled function:         Trace Mode.          (line  23)
* stl random_shuffle function:           Operations<3>.       (line 104)
* stl refc function:                     Trace Mode.          (line  29)
* stl remove function:                   Operations<3>.       (line  60)
* stl remove_copy function:              Operations<3>.       (line  70)
* stl remove_copy_if function:           Operations<3>.       (line  74)
* stl remove_if function:                Operations<3>.       (line  63)
* stl replace function:                  Operations<3>.       (line  31)
* stl replace_copy function:             Operations<3>.       (line  38)
* stl replace_copy_if function:          Operations<3>.       (line  42)
* stl replace_if function:               Operations<3>.       (line  34)
* stl reverse function:                  Operations<3>.       (line  89)
* stl reverse_copy function:             Operations<3>.       (line  92)
* stl rotate function:                   Operations<3>.       (line  96)
* stl rotate_copy function:              Operations<3>.       (line 100)
* stl search function:                   Operations<2>.       (line  48)
* stl search_n function:                 Operations<2>.       (line  54)
* stl set_px_trace function:             Trace Mode.          (line  20)
* stl set_sv_trace function:             Trace Mode.          (line  14)
* stl sort function:                     Operations<4>.       (line  10)
* stl sort_heap function:                Operations<6>.       (line  23)
* stl stable_partition function:         Operations<3>.       (line 113)
* stl stable_sort function:              Operations<4>.       (line  13)
* stl sv_trace_enabled function:         Trace Mode.          (line  17)
* stl svback constant:                   Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl svbeg constant:                    Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl svend constant:                    Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl swap_ranges function:              Operations<3>.       (line  15)
* stl transform function:                Operations<3>.       (line  19)
* stl transform_2 function:              Operations<3>.       (line  24)
* stl unique function:                   Operations<3>.       (line  78)
* stl unique_copy function:              Operations<3>.       (line  85)
* stl upper_bound function:              Operations<4>.       (line  47)
* stlconst function:                     Operations.          (line  24)
* stlvec function:                       Operations.          (line  15)
* stlvec module:                         Top.                 (line   6)
* stlvec type:                           Data Structure.      (line  32)
* update function:                       Operations.          (line  51)
* ~= infix function:                     Operations.          (line  79)



Tag Table:
Node: Top238
Ref: 0567
Ref: pure567
Node: Copying2069
Ref: copying2151
Ref: 12151
Ref: module-stlvec2151
Ref: 22151
Ref: 32151
Node: Installation2539
Ref: installation2626
Ref: 42626
Node: Overview3327
Ref: overview3421
Ref: 53421
Node: Modules4216
Ref: modules4294
Ref: 64294
Node: Simple Examples5357
Ref: simple examples5476
Ref: 75476
Ref: simple-examples5476
Node: Members and Sequences of Members6999
Ref: members and sequences of members7144
Ref: 87144
Ref: members-and-sequences-of-members7144
Node: STL Iterators and Value Semantics7930
Ref: stl iterators and value semantics8075
Ref: 98075
Ref: stl-iterators-and-value-semantics8075
Node: Iterator Tuples9997
Ref: iterator tuples10143
Ref: a10143
Ref: iterator-tuples10143
Node: Predefined Iterator Tuple Indexes12519
Ref: predefined iterator tuple indexes12653
Ref: b12653
Ref: predefined-iterator-tuple-indexes12653
Ref: c12824
Ref: stl svbeg12824
Ref: d12853
Ref: stl svend12853
Ref: e12883
Ref: stl svback12883
Node: Back Insert Iterators13302
Ref: back insert iterators13434
Ref: f13434
Ref: back-insert-iterators13434
Node: Documentation14506
Ref: documentation14620
Ref: 1014620
Node: Parameter Names15598
Ref: parameter names15682
Ref: 1115682
Ref: parameter-names15682
Node: Error Handling17845
Ref: error handling17943
Ref: 1217943
Ref: error-handling17943
Node: Exception Symbols18097
Ref: exception symbols18184
Ref: 1318184
Ref: exception-symbols18184
Ref: 1418229
Ref: bad_argument18229
Ref: 1518452
Ref: bad_function18452
Ref: 1618581
Ref: failed_cond18581
Ref: 1718714
Ref: out_of_bounds18714
Ref: 1818817
Ref: range_overflow18817
Ref: 1919015
Ref: range_overlap19015
Node: Examples19380
Ref: examples19467
Ref: 1a19467
Node: Basic Operations20443
Ref: basic operations20560
Ref: 1b20560
Ref: basic-operations20560
Node: Imports20869
Ref: imports20954
Ref: 1c20954
Node: Data Structure21092
Ref: data structure21221
Ref: 1d21221
Ref: data-structure21221
Ref: 1e21773
Ref: mutable_stlvec/type21773
Ref: 1f21891
Ref: const_stlvec/type21891
Ref: 2022016
Ref: stlvec/type22016
Node: Support for Copy-On-Write Semantics22306
Ref: support for copy-on-write semantics22438
Ref: 2122438
Ref: support-for-copy-on-write-semantics22438
Node: Operations23629
Ref: operations23768
Ref: 2223768
Ref: 2324103
Ref: emptystlvec24103
Ref: 2424158
Ref: stlvec24158
Ref: 2524338
Ref: mkstlvec24338
Ref: 2624420
Ref: stlconst24420
Ref: 2724535
Ref: #24535
Ref: 2824582
Ref: reserve24582
Ref: 2924729
Ref: capacity24729
Ref: 2a24828
Ref: null24828
Ref: 2b24881
Ref: !24881
Ref: 2c24936
Ref: first24936
Ref: 2d24959
Ref: last24959
Ref: 2e25015
Ref: members25015
Ref: 2f25110
Ref: update25110
Ref: 3025180
Ref: append25180
Ref: 3125238
Ref: insert25238
Ref: 3225495
Ref: rmfirst25495
Ref: 3325521
Ref: rmlast25521
Ref: 3425590
Ref: erase25590
Ref: 3525743
Ref: clear25743
Ref: 3625801
Ref: all_equal25801
Ref: 3725992
Ref: ==25992
Ref: 3826017
Ref: ~=26017
Node: Convenience Functions26276
Ref: convenience functions26391
Ref: 3926391
Ref: convenience-functions26391
Ref: 3a26586
Ref: map/stlvec26586
Ref: 3b26703
Ref: listmap/stlvec26703
Ref: 3c26800
Ref: catmap/stlvec26800
Ref: 3d26923
Ref: do/stlvec26923
Ref: 3e27038
Ref: foldl/stlvec27038
Ref: 3f27159
Ref: foldl1/stlvec27159
Ref: 4027278
Ref: filter/stlvec27278
Ref: 4127535
Ref: rowmap/stlvec27535
Ref: 4227585
Ref: rowcatmap/stlvec27585
Ref: 4327638
Ref: colmap/stlvec27638
Ref: 4427688
Ref: colcatmap/stlvec27688
Node: Examples<2>28051
Ref: examples<2>28147
Ref: 4528147
Ref: id128147
Node: STL Nonmodifying Algorithms28209
Ref: stl nonmodifying algorithms28336
Ref: 4628336
Ref: stl-nonmodifying-algorithms28336
Node: Imports<2>28587
Ref: imports<2>28685
Ref: 4728685
Ref: id228685
Node: Operations<2>28879
Ref: operations<2>28997
Ref: 4828997
Ref: id328997
Ref: 4929028
Ref: stl for_each29028
Ref: 4a29150
Ref: stl find29150
Ref: 4b29313
Ref: stl find_if29313
Ref: 4c29493
Ref: stl find_first_of29493
Ref: 4d29775
Ref: stl adjacent_find29775
Ref: 4e30026
Ref: stl count30026
Ref: 4f30165
Ref: stl count_if30165
Ref: 5030321
Ref: stl mismatch30321
Ref: 5130732
Ref: stl equal30732
Ref: 5230990
Ref: stl search30990
Ref: 5331310
Ref: stl search_n31310
Ref: 5431629
Ref: stl find_end31629
Node: Examples<3>31958
Ref: examples<3>32057
Ref: 5532057
Ref: id432057
Node: STL Modifying Algorithms32113
Ref: stl modifying algorithms32243
Ref: 5632243
Ref: stl-modifying-algorithms32243
Node: Imports<3>32467
Ref: imports<3>32562
Ref: 5732562
Ref: id532562
Node: Operations<3>32753
Ref: operations<3>32868
Ref: 5832868
Ref: id632868
Ref: 5932899
Ref: stl copy32899
Ref: 5a33057
Ref: stl copy_backward33057
Ref: 5b33311
Ref: stl swap_ranges33311
Ref: 5c33470
Ref: stl transform33470
Ref: 5d33747
Ref: stl transform_233747
Ref: 5e34042
Ref: stl replace34042
Ref: 5f34151
Ref: stl replace_if34151
Ref: 6034294
Ref: stl replace_copy34294
Ref: 6134480
Ref: stl replace_copy_if34480
Ref: 6234660
Ref: stl fill34660
Ref: 6334756
Ref: stl fill_n34756
Ref: 6434854
Ref: stl generate34854
Ref: 6535017
Ref: stl generate_n35017
Ref: 6635182
Ref: stl remove35182
Ref: 6735286
Ref: stl remove_if35286
Ref: 6835672
Ref: stl remove_copy35672
Ref: 6935861
Ref: stl remove_copy_if35861
Ref: 6a36065
Ref: stl unique36065
Ref: 6b36444
Ref: stl unique_copy36444
Ref: 6c36640
Ref: stl reverse36640
Ref: 6d36744
Ref: stl reverse_copy36744
Ref: 6e36936
Ref: stl rotate36936
Ref: 6f37105
Ref: stl rotate_copy37105
Ref: 7037291
Ref: stl random_shuffle37291
Ref: 7137399
Ref: stl partition37399
Ref: 7237709
Ref: stl stable_partition37709
Node: Examples<4>37881
Ref: examples<4>37977
Ref: 7337977
Ref: id737977
Node: STL Sort Algorithms38030
Ref: stl sort algorithms38153
Ref: 7438153
Ref: stl-sort-algorithms38153
Node: Imports<4>38383
Ref: imports<4>38473
Ref: 7538473
Ref: id838473
Node: Operations<4>38659
Ref: operations<4>38769
Ref: 7638769
Ref: id938769
Ref: 7738990
Ref: stl sort38990
Ref: 7839067
Ref: stl stable_sort39067
Ref: 7939204
Ref: stl partial_sort39204
Ref: 7a39493
Ref: stl partial_sort_copy39493
Ref: 7b40001
Ref: stl nth_element40001
Ref: 7c40476
Ref: stl lower_bound40476
Ref: 7d40701
Ref: stl upper_bound40701
Ref: 7e40925
Ref: stl equal_range40925
Ref: 7f41121
Ref: stl binary_search41121
Node: Examples<5>41236
Ref: examples<5>41327
Ref: 8041327
Ref: id1041327
Node: STL Merge Algorithms41405
Ref: stl merge algorithms41523
Ref: 8141523
Ref: stl-merge-algorithms41523
Node: Imports<5>41774
Ref: imports<5>41865
Ref: 8241865
Ref: id1141865
Node: Operations<5>42052
Ref: operations<5>42163
Ref: 8342163
Ref: id1242163
Ref: 8442456
Ref: stl merge42456
Node: Examples<6>42659
Ref: examples<6>42751
Ref: 8542751
Ref: id1342751
Node: STL Heap Algorithms42800
Ref: stl heap algorithms42921
Ref: 8642921
Ref: stl-heap-algorithms42921
Node: Imports<6>43132
Ref: imports<6>43222
Ref: 8743222
Ref: id1443222
Node: Operations<6>43410
Ref: operations<6>43520
Ref: 8843520
Ref: id1543520
Ref: 8943743
Ref: stl make_heap43743
Ref: 8a43999
Ref: stl push_heap43999
Ref: 8b44135
Ref: stl pop_heap44135
Ref: 8c44309
Ref: stl sort_heap44309
Node: Examples<7>44404
Ref: examples<7>44495
Ref: 8d44495
Ref: id1644495
Node: Min/Max STL Algorithms44545
Ref: min/max stl algorithms44668
Ref: 8e44668
Ref: min-max-stl-algorithms44668
Node: Imports<7>44893
Ref: imports<7>44986
Ref: 8f44986
Ref: id1744986
Node: Operations<7>45176
Ref: operations<7>45289
Ref: 9045289
Ref: id1845289
Ref: 9145512
Ref: stl min_element45512
Ref: 9245672
Ref: stl max_element45672
Ref: 9345832
Ref: stl lexicographical_compare45832
Ref: 9446361
Ref: stl next_permutation46361
Ref: 9546712
Ref: stl prev_permutation46712
Node: Examples<8>46804
Ref: examples<8>46898
Ref: 9646898
Ref: id1946898
Node: STL Numeric Algorithms46950
Ref: stl numeric algorithms47064
Ref: 9747064
Ref: stl-numeric-algorithms47064
Node: Imports<8>47287
Ref: imports<8>47380
Ref: 9847380
Ref: id2047380
Node: Operations<8>47571
Ref: operations<8>47684
Ref: 9947684
Ref: id2147684
Ref: 9a47717
Ref: stl accumulate47717
Ref: 9b47839
Ref: stl inner_product47839
Ref: 9c48197
Ref: stl partial_sum48197
Ref: 9d48500
Ref: stl adjacent_difference48500
Node: Examples<9>48848
Ref: examples<9>48942
Ref: 9e48942
Ref: id2248942
Node: Trace Mode49016
Ref: trace mode49113
Ref: 9f49113
Ref: trace-mode49113
Ref: a049617
Ref: stl set_sv_trace49617
Ref: a149732
Ref: stl sv_trace_enabled49732
Ref: a249821
Ref: stl set_px_trace49821
Ref: a349929
Ref: stl px_trace_enabled49929
Ref: a450147
Ref: stl refc50147
Node: Index50281
Ref: index50347

End Tag Table


Local Variables:
coding: utf-8
End:
