\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-stlmap.info
@documentencoding UTF-8
@copying
Generated by Sphinx
@end copying
@settitle pure-stlmap
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-stlmap: (pure-stlmap.info).    pure-stlmap
@end direntry

@c %**end of header

@titlepage
@title pure-stlmap
@author Albert Gr√§f (Editor)
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-stlmap
@end ifnottex

@c %**start of body
Version 0.0, October 29, 2011

Albert Graef <@email{Dr.Graef@@t-online.de}>

This package provides a light-weight, no frills interface to the C++ @code{map}
and @code{unordered_map} containers, see the @uref{http://en.cppreference.com/w/cpp,C++ standard library documentation} for details. (The C++ containers were originally based on the
@uref{http://www.sgi.com/tech/stl/,Standard Template Library}, so they are also sometimes referred to as "STL
containers"; hence the name of this package.)

The package includes the @code{hashmap} and @code{ordmap} modules which make these
data structures available in Pure land and equip them with a (more or less)
idiomatic Pure container interface.

@anchor{0}@anchor{c-standard-library-documentation}@anchor{1}@anchor{standard-template-library}
@menu
* Copying::
* Installation::
* Usage::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Usage

* Examples::
@end detailmenu
@end menu


@node Copying,Installation,Top,Top
@anchor{copying}@anchor{2}@anchor{3}
@chapter Copying
Copyright (c) 2011 by Albert Graef.

pure-stlmap is free software: you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

pure-stlmap is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
details.

You should have received a copy of the GNU Lesser General Public License along
with this program.  If not, see <@indicateurl{http://www.gnu.org/licenses/}>.


@node Installation,Usage,Copying,Top
@anchor{installation}@anchor{4}
@chapter Installation
Get the latest source from
@indicateurl{http://pure-lang.googlecode.com/files/pure-stlmap-0.0.tar.gz}.

Run @code{make} to compile the modules and @code{make install} (as root) to install
them in the Pure library directory. This requires GNU make, and of course you
need to have Pure (and a C++ library which includes the STL) installed.

@code{make} tries to guess your Pure installation directory and platform-specific
setup. If it gets this wrong, you can set some variables manually, please
check the Makefile for details.


@cartouche
@quotation Note
This module requires Pure 0.49 or later and a recent version of the
C++ library (GNU libstdc++ v3 has been tested). All proper C++11 libraries
should work out of the box, while (recent) C++0x implementations may
require some fiddling with the sources and/or the compilation options. Pre
C++0x library versions surely require considerably more work, especially in
the hashmap module.
@end quotation
@end cartouche


@node Usage,Index,Installation,Top
@anchor{usage}@anchor{5}
@chapter Usage
After installation, you can use the operations of this package by placing one
or both of the following import declarations in your Pure programs:

@example
using hashmap;
using ordmap;
@end example

@noindent
In Pure land, the C++ @code{map} and @code{unordered_map} containers and their
@code{multimap} variants are made available as a collection of four data
structures:

@itemize *
@item
@code{hashmap}, @code{hashmmap}: Hashed (unordered) map and multimap data
structures. These work with arbitrary key (and value) types, like the hashed
dictionary and set data structures in the standard library, and can be found
in the @code{hashmap.pure} module.
@item
@code{ordmap}, @code{ordmmap}: Ordered map and multimap data structures. These
require the keys to be ordered by the standard @code{<} predicate, like the
ordered dictionary and set data structures in the standard library, and can
be found in the @code{ordmap.pure} module.
@end itemize

All data structures offer most of the usual Pure container interface and can
be used either as dictionaries (holding key => value pairs) or sets (holding
only keys, without associated values). The data structures are very thin
wrappers around the C++ container types; in fact, they are just pointers to
the C++ containers. Memory management of these objects is automatic, and
customizable pretty-printing is provided as well.

The most important difference to the dictionary and set types in the standard
library is that the hashmap and ordmap containers are @emph{mutable} data
structures; inserting and deleting members really modifies the underlying C++
containers. (However, it is possible to take copies of the containers in
situations where it's necessary to preserve value semantics.)

Also note that not the full standard dictionary and set interface is provided;
in particular, submap comparisons and set union/difference/intersection
operations are missing right now (the C++ library doesn't have these either),
but it's easy to define them yourself if needed (please see the included
examples).

Documentation of the types and functions provided by the modules is still to
be written, so for the time being please refer to the module sources and the
included examples instead.


@menu
* Examples::
@end menu


@node Examples,,,Usage
@anchor{examples}@anchor{6}
@section Examples
Some basic examples showing hashmaps in action:

@example
> using hashmap;
> let m = hashmap [foo=>99, bar=>bar 4711L, baz=>1..5]; m;
hashmap [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
> m!bar;
bar 4711L
> keys m;
[foo,bar,baz]
> vals m;
[99,bar 4711L,[1,2,3,4,5]]
> list m;
[foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
> member m foo, member m bar;
1,1
> [x,y | x=>y = m];
[(foo,99),(bar,bar 4711L),(baz,[1,2,3,4,5])]
@end example

@noindent
Hashed multimaps (@code{hashmmap}):

@example
> let m = hashmmap [foo=>99,baz=>1..5,baz=>bar 4711L]; m;
hashmmap [foo=>99,baz=>[1,2,3,4,5],baz=>bar 4711L]
> m!baz;
[[1,2,3,4,5],bar 4711L]
> m!foo;
[99]
@end example

@noindent
All map containers can be used as generators in list and matrix
comprehensions:

@example
> [x y | x=>y = m];
[foo 99,baz [1,2,3,4,5],baz (bar 4711L)]
> @{@{x;y@} | x=>y = m@};
@{foo,baz,baz;99,[1,2,3,4,5],bar 4711L@}
@end example

@noindent
This example illustrates how to employ ordered maps as a set data structure:

@example
> using ordmap;
> type ordxmap x::ordmap | ordxmap x::ordmmap;
> x::ordxmap + y::ordxmap = foldl insert (copy x) (list y);
> x::ordxmap - y::ordxmap = foldl delete (copy x) (list y);
> x::ordxmap * y::ordxmap = x-(x-y);
> let m1 = ordmap [5,1,3,11,3];
> let m2 = ordmap (3..6);
> m1;m2;
ordmap [1,3,5,11]
ordmap [3,4,5,6]
> m1+m2;
ordmap [1,3,4,5,6,11]
> m1-m2;
ordmap [1,11]
> m1*m2;
ordmap [3,5]
@end example

@noindent
Using @code{ordmmap} instead of @code{ordmap}, we also get ordered multisets
("bags"):

@example
> let m1 = ordmmap [5,1,3,11,3];
> let m2 = ordmmap (3..6);
> m1;m2;
ordmmap [1,3,3,5,11]
ordmmap [3,4,5,6]
> m1+m2;
ordmmap [1,3,3,3,4,5,5,6,11]
> m1-m2;
ordmmap [1,3,11]
> m1*m2;
ordmmap [3,5]
@end example

@noindent

@node Index,,Usage,Top
@anchor{index}
@unnumbered Index
@printindex ge

@c %**end of body
@bye
