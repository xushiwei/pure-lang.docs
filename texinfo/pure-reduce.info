This is pure-reduce.info, produced by makeinfo version 4.13 from
pure-reduce.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-reduce: (pure-reduce.info).    A REDUCE Interface for the Pure Programming Language
END-INFO-DIR-ENTRY


File: pure-reduce.info,  Node: Top,  Next: Installation,  Up: (dir)

pure-reduce
***********

  Version 0.1, October 07, 2012

    Albert Graef <<Dr.Graef@t-online.de>> 
    Kurt Pagani <<kp@scios.ch>> 
  This is a module providing access to the Reduce
(http://www.reduce-algebra.com/) computer algebra system from Pure. It
uses an "embedded" version of Reduce which can be provided in the form
of a shared library. The *note Installation: 0. section below describes
how to build this library from the Reduce sources. More background
information and a discussion of the interface can be found in the
Embedding REDUCE
(http://groups.google.com/group/pure-lang/browse_thread/thread/c11e82ca2e9e8cbb)
thread on the Pure mailing list.

  The interface can be found in the reduce.pure module. It actually
consists of two parts, a *note low-level interface: 3. which consists
of a number of C entry points provided by the Reduce library, and a
*note high-level interface: 4. which provides everything that the Pure
programmer needs to use Reduce from Pure.  Some basic examples are in
reduce_examp.pure. Please note that at present this module is still
experimental and under development. But the basic functionality works,
and you're welcome to discuss the new interface on the mailing list
and/or submit bug reports and patches.

* Menu:

* Installation::
* Low-Level Interface::
* High-Level Interface::
* Basic Examples::
* Index::


File: pure-reduce.info,  Node: Installation,  Next: Low-Level Interface,  Prev: Top,  Up: Top

1 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-reduce-0.1.tar.gz>.

  You'll need both the Reduce library (named reduce.so, reduce.dylib or
reduce.dll, depending on the system you have) and a Reduce image file
(reduce.img) to make this module work. A Makefile is included with this
package so that you can build these yourself from the Reduce sources.
(In principle, this only needs to be done once for the initial
installation of this module, but you may want to repeat this procedure
every once in a while to get the latest Reduce version.)

  You can check out the latest Reduce version from its svn repository
with the following command:

    svn co https://reduce-algebra.svn.sourceforge.net/svnroot/reduce-algebra/trunk/ reduce-algebra

This may take a while; Reduce is a _big_ package. Once it's finished,
just drop the resulting reduce-algebra directory into the pure-reduce
source directory. Run `make' and then (if needed) `make install' in the
pure-reduce directory (_not_ in the reduce-algebra directory!). You
should also run `make check' which runs a few tests in order to verify
that the interface works ok (this can be done without installing the
package, but needs the Reduce image and library).

  In case the above procedure doesn't work for you, there are more
detailed instructions on how to compile the relevant parts of Reduce in
the pure_reduce.txt file included in the distribution. Also note that
the pure-reduce module requires neither a full Reduce installation nor
a full build of the Reduce package; just the Reduce library and image.
Thus the additional items discussed below are all completely optional.

  For convenience, the Makefile also has a `make reduce' target which
builds a minimal Reduce executable. If you use that option, `make
install' installs this executable along with the library and image
files, so that you can then run Reduce directly from the command line
by just typing `reduce'. Please note that this is a rather minimalistic
Reduce frontend; it's small, builds with minimal fuss and doesn't need
any support files other than the image file, but doesn't have all the
bells and whistles of the full Reduce version.

  If you want to install the full Reduce version, the easiest way to go
is to download one of the binary packages available on SourceForge
(http://sourceforge.net/projects/reduce-algebra/). You can also build
Reduce yourself from the sources; please check the build instructions in
the reduce-algebra folder for details. (Basically, you'll need to run
`./configure --with-csl' or `./configure --with-psl' and then `make'
there. Be patient, this takes a while.)


File: pure-reduce.info,  Node: Low-Level Interface,  Next: High-Level Interface,  Prev: Installation,  Up: Top

2 Low-Level Interface
*********************

The low-level interface is a straight wrapper of the C entry points
provided by the Reduce library, also known as the "procedural" or PROC
(http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup)
interface, for short. It uses an embedded version of Reduce which runs
on a free and open-source Lisp flavour known as CSL
(http://lisp.codemist.co.uk/) (Codemist Standard Lisp). The external C
routines are all declared in the `reduce' namespace. Normally you
shouldn't have to call these functions directly, since we provide a
high-level, idiomatic Pure interface which makes calling Reduce from
Pure much more convenient, see below.


File: pure-reduce.info,  Node: High-Level Interface,  Next: Basic Examples,  Prev: Low-Level Interface,  Up: Top

3 High-Level Interface
**********************

The goal here is to make it easy to run Reduce from Pure; to these ends,
the most important features of the low-level PROC interface are wrapped
in a convenient way. Currently the following variables and functions are
provided:

 -- variable: REDUCE_PATH
     This variable holds a colon-delimited search path used to locate
     the Reduce image file (see *note reduce start: b. below). By
     default this includes the current directory and the Pure library
     directory.

 -- Function: reduce::start image::string args::smatrix
     Initializes the Reduce system. This is done automatically when
     loading this module, so normally you shouldn't have to call this
     manually, unless the default image file wasn't found or you want
     to restart the Reduce system with your own image file or your own
     set of options. When calling this operation manually, you need to
     specify the name of the Reduce image file and any desired extra
     arguments as a string vector.  Unless the filename contains a
     slash, *note reduce start: b. searches the directories in *note
     REDUCE_PATH: a. for the image file. An exception is raised if the
     image file isn't found.

 -- Function: reduce::finish
     Finalizes the Reduce system. You can call this to release the
     resources of the Reduce system. (*note reduce start: b. also
     invokes this automatically if a Reduce instance is already
     running, so it isn't necessary to call *note reduce finish: c. in
     this case.)

 -- Function: reduce::verbosity n
     Sets the verbosity level; 0 means no messages at all (which is the
     default when using this module), and the following values may be
     or'ed together to pick what you need:

          1: messages whenever garbage collection happens

          2: messages whenever a module of code is loaded

          4: extra details in the garbage collector messages

 -- Function: reduce::load name::string
     Loads Reduce packages. This works like Reduce's `load_package'
     command; please check the Reduce documentation for details.

 -- Function: reduce::switch name:string val::int
     Lets you change global Reduce options. This works like Reduce's
     `on' and `off' declarations; please check the Reduce documentation
     for details.

  For convenience, the following operations are in the default
namespace:

 -- Function: simplify x
     This is the main entry point. It takes an algebraic expression in
     Pure format and tries to simplify it using Reduce. The result is
     then converted back to Pure format. Note that you need to quote
     `x' if you want to prevent it from being evaluated on the Pure
     side.

 -- Function: lisp x
     This can be used to execute arbitrary Lisp code, which is sometimes
     necessary to perform special functions in the Reduce system. The
     result is always a Pure list or an atomic value. Note that you
     need to quote `x' if you want to prevent it from being evaluated
     on the Pure side. This is to be used with care. At present, the
     PROC interface isn't very forgiving if you try to execute invalid
     Lisp code; it will most likely crash in such cases.

 -- Function: declare declsym [foo,bar,...]
     Declare symbols and their properties; please see the Declarations
     section in the Reduce manual for details. The second argument can
     also be a singleton symbol. In the present implementation,
     `declsym' must be one of:

        * `operator' (declares an operator symbol);

        * `antisymmetric', `symmetric', `even', `odd', `linear',
          `noncom' and `nonzero' (declares properties of already
          declared operator symbols);

        * `depend', `nodepend', `factor', `remfac', `order', `korder'
          (declares kernel dependencies and orders). These take both
          symbols and "kernels" as arguments (the latter are simple
          prefix expressions which denote irreducible subterms such as
          `cos x'; Reduce treats these more or less like variables in
          algebraic simplifications).

 -- Function: precision prec::int
     Sets the internal Reduce precision in decimal digits for floating
     point calculations, and returns the previously set precision. This
     takes effect when rounded mode is enabled (`reduce::switch
     "rounded" 1').  Note that at present this only affects Reduce's
     internal precision, floating point values are still returned as
     double precision numbers in Pure land.

 -- Function: plotreset
     This is identical to the `plotreset' command provided by Reduce's
     gnuplot (http://www.gnuplot.info/) interface, and is sometimes
     needed to reset the plot subsystem.

  At present, this module makes no attempt to capture terminal output
such as error messages produced by Reduce, so you should be prepared to
read these in the terminal in which Pure is running, or capture them
yourself using the output redirection facilities of the shell if needed.

  In Pure land, Reduce and Lisp expressions are represented using Pure's
standard curried notation. Some special conversions are applied to
algebraic expressions to make arithmetic operations such as `+', `*'
etc. work as expected. In addition, the `==', `..' and `:=' infix
operators can be used to denote equations, ranges and assignments in
Reduce, respectively. (Note that you may have to quote these in some
cases so that they don't get evaluated on the Pure side.) Also, Reduce's
`arbconst n', `arbint n' and `arbcomplex n' terms are mapped to Greek
symbols `αn', `βn' and `ζn' on the Pure side. (All these automatic
conversions can also be turned off on the output side with the `#!
--disable mapped' compilation pragma; this may be useful for debugging
purposes.)


File: pure-reduce.info,  Node: Basic Examples,  Next: Index,  Prev: High-Level Interface,  Up: Top

4 Basic Examples
****************

Here is a simple example showing how to start up Reduce and do some
calculations:

    > using reduce;
    Reduce (Free CSL version), 27-Sep-12 ...
    > simplify $ df ((x+5)^3) x;
    3*x^2+30*x+75
    > simplify $ solve (x^2+7) x;
    [x==sqrt 7*i,x==-sqrt 7*i]

Note that the result returned by *note simplify: 10. is always a quoted
expression. If the expression can be further reduced on the Pure side,
you'll have to use Pure's `eval' function to force its evaluation:

    > using math;
    > eval ans;
    [x==0.0+:2.64575131106459,x==0.0+:-2.64575131106459]

You can also execute Lisp code in the CSL interpreter hosting the Reduce
system. This is sometimes necessary to access special functionality, but
should be done with care (at present invalid Lisp code can easily crash
the interpreter). For instance:

    > lisp ('list a b c d e);
    [a,b,c,d,e]
    > lisp ('cdr [a,b,[c,d],e]);
    [b,[c,d],e]

Free symbols are quoted automatically, and Pure lists are mapped to
corresponding Lisp lists. If the result is a Lisp list, it will be
converted back to a Pure list. Most simple kinds of Lisp calls should be
doable that way, but don't expect any miracles; the *note lisp: 11.
function is provided to access special functionality in the "symbolic
mode" of the Reduce system, not to turn Pure into a full-featured Lisp
frontend.

  The following example illustrates how you can use the *note lisp: 11.
function to declare an operator symbol and change or query its
properties:

    > lisp ('operator [myop]);
    []
    > lisp ('flag [myop] odd);
    []
    > lisp ('prop myop);
    [odd:t,simpfn:simpiden]
    > simplify (myop (-x));
    -myop x

If you find it awkward to evaluate Lisp forms in Pure, you can also
achieve the same with the *note declare: 12. function which covers most
of the common Reduce declarations that might be needed:

    > declare operator myop;
    []
    > declare odd myop;
    []
    > simplify (myop (-x));
    -myop x

This example shows how you can do a simple plot using Reduce's gnuplot
(http://www.gnuplot.info/) module:

    > simplify $ plot [sin x/x, x=='(-20..20), terminal=="wxt", title=="sinc"];
    0

Many more examples can be found in the reduce_examp.pure and tests.pure
scripts included in the distribution.


File: pure-reduce.info,  Node: Index,  Prev: Basic Examples,  Up: Top

Index
*****

 [index ]
* Menu:

* declare function:                      High-Level Interface.
                                                              (line  75)
* lisp function:                         High-Level Interface.
                                                              (line  66)
* plotreset function:                    High-Level Interface.
                                                              (line 102)
* precision function:                    High-Level Interface.
                                                              (line  94)
* reduce finish function:                High-Level Interface.
                                                              (line  29)
* reduce load function:                  High-Level Interface.
                                                              (line  47)
* reduce module:                         Top.                 (line   6)
* reduce start function:                 High-Level Interface.
                                                              (line  17)
* reduce switch function:                High-Level Interface.
                                                              (line  51)
* reduce verbosity function:             High-Level Interface.
                                                              (line  36)
* REDUCE_PATH variable:                  High-Level Interface.
                                                              (line  11)
* simplify function:                     High-Level Interface.
                                                              (line  59)



Tag Table:
Node: Top294
Ref: 11028
Ref: reduce1028
Ref: 21028
Ref: embedding-reduce1028
Node: Installation1727
Ref: installation1824
Ref: 51824
Ref: module-reduce1824
Ref: 61824
Ref: a-reduce-interface-for-the-pure-programming-language1824
Ref: 01824
Ref: 74512
Ref: sourceforge4512
Node: Low-Level Interface4512
Ref: low-level interface4626
Ref: 34626
Ref: low-level-interface4626
Ref: 85349
Ref: proc5349
Ref: 95349
Ref: csl5349
Node: High-Level Interface5349
Ref: high-level interface5465
Ref: 45465
Ref: high-level-interface5465
Ref: a5741
Ref: reduce_path5741
Ref: b5990
Ref: reduce start5990
Ref: c6702
Ref: reduce finish6702
Ref: d7017
Ref: reduce verbosity7017
Ref: e7417
Ref: reduce load7417
Ref: f7591
Ref: reduce switch7591
Ref: 107876
Ref: simplify7876
Ref: 118191
Ref: lisp8191
Ref: 128691
Ref: declare8691
Ref: 139582
Ref: precision9582
Ref: 1410006
Ref: plotreset10006
Ref: 1510211
Ref: gnuplot10211
Node: Basic Examples11272
Ref: basic examples11374
Ref: 1611374
Ref: basic-examples11374
Node: Index13680
Ref: index13753

End Tag Table


Local Variables:
coding: utf-8
End:
