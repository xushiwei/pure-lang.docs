This is purelib.info, produced by makeinfo version 4.13 from
purelib.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* purelib: (purelib.info).    Pure Library Manual
END-INFO-DIR-ENTRY


File: purelib.info,  Node: Top,  Next: Prelude,  Up: (dir)

Pure Library Manual
*******************

  Version 0.55, June 03, 2012

  Albert Gräf <<Dr.Graef@t-online.de>>

  Copyright (c) 2009-2012 by Albert Gräf. This document is available
under the GNU Free Documentation License
(http://www.gnu.org/copyleft/fdl.html).

  This manual describes the operations in the standard Pure library,
including the prelude and the other library modules which come bundled
with the interpreter.

  There is a companion to this manual, `pure' which describes the Pure
language and the operation of the Pure interpreter.

* Menu:

* Prelude::
* Mathematical Functions::
* Container Types::
* System Interface::
* Index::

 --- The Detailed Node Listing ---

Prelude

* Constants and Operators::
* Prelude Types::
* Basic Combinators::
* Lists and Tuples::
* Slicing::
* Hash Pairs::
* List Functions::
* String Functions::
* Matrix Functions::
* Record Functions::
* Primitives::

Mathematical Functions

* Imports::
* Basic Math Functions::
* Complex Numbers::
* Rational Numbers::
* Semantic Number Predicates and Types::

Container Types

* Arrays::
* Heaps::
* Dictionaries::
* Sets and Bags::

System Interface

* Imports: Imports<6>.
* Errno and Friends::
* POSIX Locale::
* Signal Handling::
* Time Functions::
* Process Functions::
* Basic I/O Interface::
* Stat and Friends::
* Reading Directories::
* Shell Globbing::
* Regex Matching::
* Additional POSIX Functions::
* Option Parsing::


File: purelib.info,  Node: Prelude,  Next: Mathematical Functions,  Prev: Top,  Up: Top

1 Prelude
*********

The prelude defines the basic operations of the Pure language. This
includes the basic arithmetic and logical operations, string, list and
matrix functions, as well as the support operations required to
implement list and matrix comprehensions. The string, matrix and record
operations are in separate modules strings.pure, matrices.pure and
records.pure, the primitive arithmetic and logical operations can be
found in primitives.pure. Note that since the prelude module gets
imported automatically (unless the interpreter is invoked with the
`--no-prelude' option), all operations discussed in this section are
normally available in Pure programs without requiring any explicit
import declarations, unless explicitly noted otherwise.

* Menu:

* Constants and Operators::
* Prelude Types::
* Basic Combinators::
* Lists and Tuples::
* Slicing::
* Hash Pairs::
* List Functions::
* String Functions::
* Matrix Functions::
* Record Functions::
* Primitives::


File: purelib.info,  Node: Constants and Operators,  Next: Prelude Types,  Up: Prelude

1.1 Constants and Operators
===========================

The prelude also declares a signature of commonly used constant and
operator symbols. This includes the truth values `true' and `false'.

 -- constant: true = 1
 -- constant: false = 0
     These are actually just integers in Pure, but sometimes it's
     convenient to refer to them using these symbolic constants. Note
     that if you also want to use these on the left-hand side of
     equations, you still have to declare them as `nonfix' symbols
     yourself, using a declaration like:

         nonfix false true;



  In addition, the following special exception symbols are provided:

 -- constructor: failed_cond
 -- constructor: failed_match
 -- constructor: stack_fault
 -- constructor: malloc_error
     These are the built-in exception values. `failed_cond' denotes a
     failed conditional in guard or if-then-else; `failed_match'
     signals a failed pattern match in lambda, `case' expression, etc.;
     `stack_fault' means not enough stack space (`PURE_STACK' limit
     exceeded); and `malloc_error' indicates a memory allocation error.

 -- constructor: bad_list_value x
 -- constructor: bad_tuple_value x
 -- constructor: bad_string_value x
 -- constructor: bad_matrix_value x
     These denote value mismatches a.k.a. dynamic typing errors. They
     are thrown by some operations when they fail to find an expected
     value of the corresponding type.

 -- constructor: out_of_bounds
     This exception is thrown by the index operator `!' if a list,
     tuple or matrix index is out of bounds.

  Here's the list of predefined operator symbols. Note that the parser
will automagically give unary minus the same precedence level as the
corresponding binary operator.

    infixl  1000   $$ ;                // sequence operator
    infixr  1100   $ ;                 // right-associative application
    infixr  1200   , ;                 // pair (tuple)
    infix   1300   => ;                // key=>value pairs ("hash rocket")
    infix   1400   .. ;                // arithmetic sequences
    infixr  1500   || ;                // logical or (short-circuit)
    infixr  1600   && ;                // logical and (short-circuit)
    prefix  1700   ~ ;                 // logical negation
    infix   1800   < > <= >= == ~= ;   // relations
    infix   1800   === ~== ;           // syntactic equality
    infixr  1900   : ;                 // list cons
    infix   2000   +: <: ;             // complex numbers (cf. math.pure)
    infixl  2100   << >> ;             // bit shifts
    infixl  2200   + - or ;            // addition, bitwise or
    infixl  2300   * / div mod and ;   // multiplication, bitwise and
    infixl  2300   % ;                 // exact division (cf. math.pure)
    prefix  2400   not ;               // bitwise not
    infixr  2500   ^ ;                 // exponentiation
    prefix  2600   # ;                 // size operator
    infixl  2700   ! !! ;              // indexing, slicing
    infixr  2800   . ;                 // function composition
    prefix  2900   ' ;                 // quote
    postfix 3000   & ;                 // thunk



File: purelib.info,  Node: Prelude Types,  Next: Basic Combinators,  Prev: Constants and Operators,  Up: Prelude

1.2 Prelude Types
=================

Some additional type symbols are provided which can be used as type
tags on the left-hand side of equations, see _Type Tags_ in the Pure
Manual.

 -- type: number
 -- type: complex
 -- type: real
 -- type: rational
 -- type: integer
     Additional number types.

  These types are defined in a purely syntactic way, by checking the
builtin-type or the constructor symbol of a number. Some semantic number
types can be found in the *note math: 1a. module, see *note Semantic
Number Predicates and Types: 1b.

  *note integer: 19. is the union of Pure's built-in integer types,
i.e., it comprises all `int' and `bigint' values. *note rational: 18.
and *note complex: 16. are the rational and complex types, while *note
real: 17. is the union of the `double', *note integer: 19. and *note
rational: 18. types (i.e., anything that can represent a real number
and be used for the real and imaginary parts of a *note complex: 16.
number). Finally, *note number: 15. is the union of all numeric types,
i.e., this type can be used to match any kind of number.

  Note that the operations of the *note rational: 18. and *note
complex: 16. types are actually defined in the *note math: 1a. module
which isn't part of the prelude, so you have to import this module in
order to do computations with these types of values. However, the type
tags and constructors for these types are defined in the prelude so
that these kinds of values can be parsed and recognized without having
the *note math: 1a.  module loaded.

  The prelude also provides a subtype of the built-in `string' type
which represents single-character strings:

 -- type: char
     A single character string. This matches any string value of length
     1.

  *note Lists and tuples: 1d. can be matched with the following types:

 -- type: list
 -- type: rlist
     The list and "proper" (or "recursive") list types. Note that the
     former comprises both the empty list `[]' and all list nodes of
     the form `x:xs' (no matter whether the tail `xs' is a proper list
     value or not), whereas the latter only matches proper list values
     of the form `x1:...:xn:[]'. Thus the *note list: 1e. type can be
     checked in O(1) time, while the *note rlist: 1f. type is defined
     recursively and requires linear time (with respect to the size of
     the list) to be checked. This should be considered when deciding
     whether to use one or the other in a given situation; see _Type
     Rules_ for further explanation.

 -- type: tuple
     The type of all tuples, comprises the empty tuple `()' and all
     tuples `(x,xs)' with at least two members. This is analogous to the
     *note list: 1e. type above, but no "proper" tuple type is needed
     here since any tuple of this form is always a proper tuple.

  There are some other, more specialized types representing various
kinds of applications, function objects and other named entities. These
are useful, in particular, for the definition of higher-order functions
and for performing symbolic manipulations on unevaluated symbolic terms.

 -- type: appl
     This type represents all unevaluated function or constructor
     applications of the form `x y'. This comprises constructor terms
     and quoted or partial function applications.

 -- type: function
     This type represents any term which may be called as a function.
     This may be a closure (global or local function, or a lambda
     function) which takes at least one argument, or a partial
     application of a closure to some arguments which is still
     "unsaturated", i.e., expects some further arguments to be "ready
     to go".

 -- type: fun
     A named function object (global or local function, but not a
     partial application).

 -- type: lambda
     An anonymous (lambda) function.

 -- type: closure
     Any kind of function object (named function or lambda). This is the
     union of the *note fun: 23. and *note lambda: 24. types.

 -- type: thunk
     This is a special kind of unevaluated parameterless function
     object used in lazy evaluation. See _Lazy Evaluation and Streams_
     in the Pure Manual.

 -- type: var
     A free variable. This can be any kind of symbol that could in
     principle be bound to a value (excluding operator and nonfix
     symbols).

 -- type: symbol
     Any kind of symbol (this also includes operator and nonfix
     symbols).

  Corresponding type predicates are provided for all of the above, see
*note Predicates: 29. Some further types and predicates for matrices
and records can be found under *note Matrix Inspection and
Manipulation: 2a. and *note Record Functions: 2b.


File: purelib.info,  Node: Basic Combinators,  Next: Lists and Tuples,  Prev: Prelude Types,  Up: Prelude

1.3 Basic Combinators
=====================

The prelude implements the following important function combinators.

 -- Function: f $ g
 -- Function: f . g
     Like in Haskell, these denote right-associative application and
     function composition. They are also defined as macros so that
     saturated calls of them are eliminated automatically. Examples:

         > foo $ bar 99;
         foo (bar 99)
         > (foo.bar) 99;
         foo (bar 99)



 -- Function: id x
 -- Function: cst x y
     These are the customary identity and constant combinators from the
     combinatorial calculus:

         > map id (1..5);
         [1,2,3,4,5]
         > map (cst 0) (1..5);
         [0,0,0,0,0]



 -- Function: void x
     This combinator is basically equivalent to `cst ()', but with the
     special twist that it is also defined as a macro optimizing the
     case of "throwaway" list and matrix comprehensions. This is useful
     if a comprehension is evaluated solely for its side effects. E.g.:

         > using system;
         > extern int rand();
         > foo = void [printf "%d\n" rand | _ = 1..3];
         > show foo
         foo = do (\_ -> printf "%d\n" rand) (1..3);
         > foo;
         1714636915
         1957747793
         424238335
         ()

     Note that the above list comprehension is actually implemented
     using *note do: 33. (instead of *note map: 34, which would
     normally be the case), so that the intermediate list value of the
     comprehension is never constructed. This is described in more
     detail in section _Optimization Rules_ of the Pure Manual.

  In addition, the prelude also provides the following combinators
adopted from Haskell:

 -- Function: flip f
     Swaps arguments of a binary function `f', e.g.:

         > map (flip (/) 2) (1..3);
         [0.5,1.0,1.5]

     This combinator is also used by the compiler to implement right
     operator sections, which allows you to write the above simply as:

         > map (/2) (1..3);
         [0.5,1.0,1.5]



 -- Function: curry f
     Turns a function `f' expecting a pair of values into a curried
     function of two arguments:

         > using system;
         > dowith (curry (printf "%d: %g\n")) (0..2) [0.0,2.718,3.14];
         0: 0
         1: 2.718
         2: 3.14
         ()



 -- Function: uncurry f
     The inverse of *note curry: 36. Turns a curried function `f'
     expecting two arguments into a function processing a single pair
     argument:

         > map (uncurry (*)) [(2,3),(4,5),(6,7)];
         [6,20,42]



 -- Function: curry3 f
 -- Function: uncurry3 f
     These work analogously, but are used to convert between ternary
     curried functions and functions operating on triples.

 -- Function: fix f
     This is the (normal order) fixed point combinator which allows you
     to create recursive anonymous functions. It takes another function
     `f' as its argument and applies `f' to `fix f' itself:

         > let fact = fix (\f n -> if n<=0 then 1 else n*f (n-1));
         > map fact (1..5);
         [1,2,6,24,120]

     See Fixed point combinator
     (http://en.wikipedia.org/wiki/Fixed_point_combinator) at Wikipedia
     for an explanation of how this magic works.  Just like in Haskell,
     *note fix: 3a. can be used to produce least fixed points of
     arbitrary functions. For instance:

         > fix (cst bar);
         bar
         > let xs = fix (1:);
         > xs;
         1:#<thunk 0x7fe537fe2f90>
         > xs!!(0..10);
         [1,1,1,1,1,1,1,1,1,1,1]




File: purelib.info,  Node: Lists and Tuples,  Next: Slicing,  Prev: Basic Combinators,  Up: Prelude

1.4 Lists and Tuples
====================

The prelude defines the list and tuple constructors, as well as equality
and inequality on these structures. It also provides a number of other
useful basic operations on lists and tuples. These are all described
below.

 -- constructor: []
 -- constructor: ()
     Empty list and tuple.

 -- constructor: x : y
 -- constructor: x , y
     List and tuple constructors. These are right-associative in Pure.

  Lists are the usual right-recursive aggregates of the form `x:xs',
where `x' denotes the *head* and `xs' the *tail* of the list, pretty
much the same as in Lisp or Prolog except that they use a Haskell-like
syntax. In contrast to Haskell, list concatenation is denoted '*note +:
3f.'  (see below), and lists may contain an arbitrary mixture of
arguments, i.e., they are fully polymorphic:

    > 1:2:3:[];
    [1,2,3]
    > [1,2,3]+[u,v,w]+[3.14];
    [1,2,3,u,v,w,3.14]

Lists are *eager* in Pure by default, but they can also be made *lazy*
(in the latter case they are also called *streams*). This is
accomplished by turning the tail of a list into a "thunk" (a.k.a.
"future") which defers evaluation until the list tail is actually
needed, see section _Lazy Evaluation and Streams_ in the Pure Manual.
For instance, an infinite arithmetic sequence (see below) will always
produce a list with a thunked tail:

    > 1:3..inf;
    1:#<thunk 0x7f696cd2dbd8>

Pure also distinguishes *proper* and *improper* lists. The former are
always terminated by an empty list in the final tail and can thus be
written using the conventional `[x1,x2,...,xn]' syntax:

    > 1:2:3:[];
    [1,2,3]

In contrast, improper lists are terminated with a non-list value and
can only be represented using the '*note 2f::' operator:

    > 1:2:3;
    1:2:3

These aren't of much use as ordinary list values, but are frequently
encountered as patterns on the left-hand side of an equation, where the
final tail is usually a variable. Also note that technically, a lazy
list is also an improper list (although it may expand to a proper list
value as it is traversed).

  Tuples work in a similar fashion, but with the special twist that the
pairing constructor '*note 2f::' is associative (it always produces
right-recursive pairs) and '*note 2f::' acts as a neutral element on
these constructs, so that '*note 2f::' and '*note 2f::' define a
complete monoid structure. Note that this means that '*note 2f::' is
actually a "constructor with equations" since it obeys the laws
`(x,y),z == x,(y,z)' and `(),x == x,() == x'. Also note that there
isn't a separate operation for concatenating tuples, since the pairing
operator already does this:

    > (1,2,3),(10,9,8);
    1,2,3,10,9,8
    > (),(a,b,c);
    a,b,c
    > (a,b,c),();
    a,b,c

This also implies that tuples are always flat in Pure and can't be
nested; if you need this, you should use lists instead. Also, tuples
are always eager in Pure.

  Some important basic operations on lists and tuples are listed below.

 -- Function: x + y
     List concatenation. This non-destructively appends the elements of
     `y' to `x'.

         > [1,2,3]+[u,v,w];
         [1,2,3,u,v,w]

     Note that this operation in fact just recurses into `x' and
     replaces the empty list marking the "end" of `x' with `y', as if
     defined by the following equations (however, the prelude actually
     defines this operation in a tail-recursive fashion):

         [] + ys = ys;
         (x:xs) + ys = x : xs+ys;

     To make this work, both operands should be proper lists, otherwise
     you may get somewhat surprising (but correct) improper list
     results like the following:

         > [1,2,3]+99;
         1:2:3:99
         > (1:2:3)+33;
         1:2:36

     This happens because Pure is dynamically typed and places no
     limits on ad hoc polymorphism. Note that the latter result is due
     to the fact that '*note +: 41.' also denotes the addition of
     numbers, and the improper tail of the first operand is a number in
     this case, as is the second operand. Otherwise you might have got
     an unreduced instance of the '*note +: 41.' operator instead.

 -- Function: x == y
 -- Function: x ~= y
     Equality and inequality of lists and tuples. These compare two
     lists or tuples by recursively comparing their members, so '*note
     ==: 46.' must be defined on the list or tuple members if you want
     to use these operations. Also note that these operations are
     inherently eager, so applying them to two infinite lists may take
     an infinite amount of time.

         > reverse [a,b,c] == [c,b,a];
         1
         > (a,b,c) == ();
         0



 -- Function: # x
     List and tuple size. This operation counts the number of elements
     in a list or tuple:

         > #[a,b,c];
         3
         > #(a,b,c);
         3

     Please note that for obvious reasons this operation is inherently
     eager, so trying to compute the size of an infinite list will take
     forever.

 -- Function: x ! i
     Indexing of lists and tuples is always zero-based (i.e., indices
     run from `0' to `#x-1'), and an exception will be raised if the
     index is out of bounds:

         > [1,2,3]!2;
         3
         > [1,2,3]!4;
         <stdin>, line 34: unhandled exception 'out_of_bounds' while evaluating
         '[1,2,3]!4'



 -- Function: x !! is
     The slicing operation takes a list or tuple and a list of indices
     and returns the list or tuple of the corresponding elements,
     respectively.  Indices which are out of the valid range are
     silently ignored:

         > (1..5)!!(3..10);
         [4,5]
         > (1,2,3,4,5)!!(3..10);
         4,5

     The case of contiguous index ranges, as shown above, is optimized
     so that it always works in linear time, see *note Slicing: 50.
     below for details. But indices can actually be specified in any
     order, so that you can retrieve any permutation of the members,
     also with duplicates. E.g.:

         > (1..5)!![2,4,4,1];
         [3,5,5,2]

     This is less efficient than the case of contiguous index ranges,
     because it requires repeated traversals of the list for each
     index. For larger lists you should hence use vectors or matrices
     instead, to avoid the quadratic complexity.

 -- Function: x .. y
     Arithmetic sequences. Note that the Pure syntax differs from
     Haskell in that there are no brackets around the construct and a
     step width is indicated by specifying the first two elements as
     `x:y' instead of `x,y'.

         > 1..5;
         [1,2,3,4,5]
         > 1:3..11;
         [1,3,5,7,9,11]

     To prevent unwanted artifacts due to rounding errors, the upper
     bound in a floating point sequence is always rounded to the
     nearest grid point:

         > 0.0:0.1..0.29;
         [0.0,0.1,0.2,0.3]
         > 0.0:0.1..0.31;
         [0.0,0.1,0.2,0.3]

     Last but not least, you can specify infinite sequences with an
     infinite upper bound (`inf' or `-inf'):

         > 1:3..inf;
         1:#<thunk 0x7f696cd2dbd8>
         > -1:-3..-inf;
         -1:#<thunk 0x7f696cd2fde8>

     The lower bounds of an arithmetic sequence must always be finite.

 -- Function: null x
     Test for the empty list and tuple.

         > null [];
         1
         > null (a,b,c);
         0



 -- Function: reverse x
     Reverse a list or tuple.

         > reverse (1..5);
         [5,4,3,2,1]
         > reverse (a,b,c);
         (c,b,a)



  In addition, the prelude provides the following conversion operations.

 -- Function: list x
 -- Function: tuple x
     Convert between (finite) lists and tuples.

         > tuple (1..5);
         1,2,3,4,5
         > list (a,b,c);
         [a,b,c]

     The `list' function can be used to turn a finite lazy list into an
     eager one:

         > list $ take 10 (-1:-3..-inf);
         [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

     You can also achieve the same effect somewhat more conveniently by
     slicing a finite part from a stream:

         > (-1:-3..-inf)!!(0..9);
         [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]



  Conversely, it is also possible to convert an (eager) list to a lazy
one (a stream).

 -- Function: stream x
     Convert a list to a stream.

         > stream (1..10);
         1:#<thunk 0x7fe537fe2b58>



  This might appear a bit useless at first sight, since all elements of
the stream are in fact already known. However, this operation then
allows you to apply other functions to the list and have them evaluated
in a lazy fashion.


File: purelib.info,  Node: Slicing,  Next: Hash Pairs,  Prev: Lists and Tuples,  Up: Prelude

1.5 Slicing
===========

Indexing and slicing are actually fairly general operations in Pure
which are used not only in the context of lists and tuples, but for any
type of container data structure which can be "indexed" in some way.
Other examples in the standard library are the *note array: 57. and
*note dict: 58. containers.

  The prelude therefore implements slicing in a generic way, so that it
works with any kind of container data structure which defines '*note !:
4c.' in such a manner that it throws an exception when the index is out
of bounds.  It also works with any kind of index container that
implements the *note catmap: 59. operation.

  The prelude also optimizes the case of contiguous integer ranges so
that slices like `xs!!(i..j)' are computed in linear time if possible.
This works, in particular, with lists, strings and matrices.

  Moreover, the prelude includes some optimization rules and
corresponding helper functions to optimize the most common cases at
compile time, so that the index range is never actually constructed. To
these ends, the slicing expression `xs!!(i..j)' is translated to a call
`subseq xs i j' of the special *note subseq: 5a. function:

 -- Function: subseq x i j
     If `x' is a list, matrix or string, and `i' and `j' are int
     values, compute the slice `xs!!(i..j)' in the most efficient manner
     possible. This generally avoids constructing the index list `i..j'.
     Otherwise `i..j' is computed and *note subseq: 5a. falls back to
     the *note slice: 5b. function below to compute the slice in the
     usual way.

 -- Function: slice x ys
     Compute the slice `x!!ys' using the standard slicing operation,
     without any special compile time tricks. (Runtime optimizations are
     still applied if possible.)

  You can readily see the effects of this optimization by running the
slicing operator against *note slice: 5b.:

    > let xs = 1..1000000;
    > stats -m
    > #slice xs (100000..299990);
    199991
    0.34s, 999957 cells
    > #xs!!(100000..299990);
    199991
    0.14s, 399984 cells

Even more drastic improvements in both running time and memory usage
can be seen in the case of matrix slices:

    > let x = rowvector xs;
    > #slice x (100000..299990);
    199991
    0.19s, 599990 cells
    > #x!!(100000..299990);
    199991
    0s, 10 cells



File: purelib.info,  Node: Hash Pairs,  Next: List Functions,  Prev: Slicing,  Up: Prelude

1.6 Hash Pairs
==============

The prelude provides another special kind of pairs called "hash pairs",
which take the form `key=>value'. These are used in various contexts to
denote key-value associations. The only operations on hash pairs
provided by the prelude are equality testing (which recursively
compares the components) and the functions *note key: 5e. and *note
val: 5f.:

 -- constructor: x => y
     The hash pair constructor, also known as the "hash rocket".

 -- Function: x == y
 -- Function: x ~= y
     Equality and inequality of hash pairs.

         > ("foo"=>99) == ("bar"=>99);
         0



 -- Function: key (x=>y)
 -- Function: val (x=>y)
     Extract the components of a hash pair.

         > key ("foo"=>99), val ("foo"=>99);
         "foo",99



  Note that in difference to the tuple operator '*note 2f::', the hash
rocket '*note =>: 60.' is non-associative, so nested applications _must_
be parenthesized, and `(x=>y)=>z' is generally _not_ the same as
`x=>(y=>z)'. Also note that '*note 2f::' has lower precedence than
'*note =>: 60.', so to include a tuple as key or value in a hash pair,
the tuple must be parenthesized, as in `"foo"=>(1,2)' (whereas
`"foo"=>1,2' denotes a tuple whose first element happens to be a hash
pair).


File: purelib.info,  Node: List Functions,  Next: String Functions,  Prev: Hash Pairs,  Up: Prelude

1.7 List Functions
==================

This mostly comes straight from the Q prelude which in turn was based on
the first edition of the Bird/Wadler book, and is very similar to what
you can find in the Haskell prelude. Some functions have slightly
different names, though, and of course everything is typed dynamically.

* Menu:

* Common List Functions::
* List Generators::
* Zip and Friends::


File: purelib.info,  Node: Common List Functions,  Next: List Generators,  Up: List Functions

1.7.1 Common List Functions
---------------------------

 -- Function: any p xs
     test whether the predicate `p' holds for any of the members of `xs'

 -- Function: all p xs
     test whether the predicate `p' holds for all of the members of `xs'

 -- Function: cat xs
     concatenate a list of lists

 -- Function: catmap f xs
     convenience function which combines *note cat: 67. and *note map:
     34.; this is also used to implement list comprehensions

 -- Function: do f xs
     apply `f' to all members of `xs', like *note map: 34, but throw
     away all intermediate results and return `()'

 -- Function: drop n xs
     remove `n' elements from the front of `xs'

 -- Function: dropwhile p xs
     remove elements from the front of `xs' while the predicate `p' is
     satisfied

 -- Function: filter p xs
     return the list of all members of `xs' satisfying the predicate `p'

 -- Function: foldl f a xs
     accumulate the binary function `f' over all members of `xs',
     starting from the initial value `a' and working from the front of
     the list towards its end

 -- Function: foldl1 f xs
     accumulate the binary function `f' over all members of `xs',
     starting from the value `head xs' and working from the front of the
     list towards its end; `xs' must be nonempty

 -- Function: foldr f a xs
     accumulate the binary function `f' over all members of `xs',
     starting from the initial value `a' and working from the end of the
     list towards its front

 -- Function: foldr1 f xs
     accumulate the binary function `f' over all members of `xs',
     starting from the value `last xs' and working from the end of the
     list towards its front; `xs' must be nonempty

 -- Function: head xs
     return the first element of `xs'; `xs' must be nonempty

 -- Function: index xs x
     search for an occurrence of `x' in `xs' and return the index of the
     first occurrence, if any, `-1' otherwise

     Note: This uses equality *note ==: 46. to decide whether a member
     of `xs' is an occurrence of `x', so *note ==: 46. must have an
     appropriate definition on the list members.

 -- Function: init xs
     return all but the last element of `xs'; `xs' must be nonempty

 -- Function: last xs
     return the last element of `xs'; `xs' must be nonempty

 -- Function: listmap f xs
     convenience function which works like *note map: 34, but also
     deals with matrix and string arguments while ensuring that the
     result is always a list; this is primarily used to implement list
     comprehensions

 -- Function: map f xs
     apply `f' to each member of `xs'

 -- Function: scanl f a xs
     accumulate the binary function `f' over all members of `xs', as
     with *note foldl: 6b, but return all intermediate results as a list

 -- Function: scanl1 f xs
     accumulate the binary function `f' over all members of `xs', as
     with *note foldl1: 6c, but return all intermediate results as a
     list

 -- Function: scanr f a xs
     accumulate the binary function `f' over all members of `xs', as
     with *note foldr: 6d, but return all intermediate results as a list

 -- Function: scanr1 f xs
     accumulate the binary function `f' over all members of `xs', as
     with *note foldr1: 6e, but return all intermediate results as a
     list

 -- Function: sort p xs
     Sorts the elements of the list `xs' in ascending order according to
     the given predicate `p', using the C `qsort' function. The
     predicate `p' is invoked with two arguments and should return a
     truth value indicating whether the first argument is "less than"
     the second. (An exception is raised if the result of a comparison
     is not a machine integer.)

         > sort (>) (1..10);
         [10,9,8,7,6,5,4,3,2,1]
         > sort (<) ans;
         [1,2,3,4,5,6,7,8,9,10]



 -- Function: tail xs
     return all but the first element of `xs'; `xs' must be nonempty

 -- Function: take n xs
     take `n' elements from the front of `xs'

 -- Function: takewhile p xs
     take elements from the front of `xs' while the predicate `p' is
     satisfied


File: purelib.info,  Node: List Generators,  Next: Zip and Friends,  Prev: Common List Functions,  Up: List Functions

1.7.2 List Generators
---------------------

Some useful (infinite) list generators, as well as some finite (and
eager) variations of these. The latter work like a combination of *note
take: 7a. or *note takewhile: 7b. and the former, but are implemented
directly for better efficiency.

 -- Function: cycle xs
     cycles through the elements of the nonempty list `xs', ad infinitum

 -- Function: cyclen n xs
     eager version of *note cycle: 7d, returns the first `n' elements of
     `cycle xs'

 -- Function: iterate f x
     returns the stream containing `x', `f x', `f (f x)', etc., ad
     infinitum

 -- Function: iteraten n f x
     eager version of *note iterate: 7f, returns the first `n' elements
     of `iterate f x'

 -- Function: iterwhile p f x
     another eager version of *note iterate: 7f, returns the list of all
     elements from the front of `iterate f x' for which the predicate
     `p' holds

 -- Function: repeat x
     returns an infinite stream of `x's

 -- Function: repeatn n x
     eager version of *note repeat: 82, returns a list with `n' `x's


File: purelib.info,  Node: Zip and Friends,  Prev: List Generators,  Up: List Functions

1.7.3 Zip and Friends
---------------------

 -- Function: unzip xys
     takes a list of pairs to a pair of lists of corresponding elements

 -- Function: unzip3 xyzs
     *note unzip: 85. with triples

 -- Function: zip xs ys
     return the list of corresponding pairs `(x,y)' where `x' runs
     through the elements of `xs' and `y' runs through the elements of
     `ys'

 -- Function: zip3 xs ys zs
     *note zip: 87. with three lists, returns a list of triples

 -- Function: zipwith f xs ys
     apply the binary function `f' to corresponding elements of `xs'
     and `ys'

 -- Function: zipwith3 f xs ys zs
     apply the ternary function `f' to corresponding elements of `xs',
     `ys' and `zs'

  Pure also has the following variations of *note zipwith: 89. and
*note zipwith3: 8a. which throw away all intermediate results and
return the empty tuple `()'. That is, these work like *note do: 33. but
pull arguments from two or three lists, respectively:

 -- Function: dowith f xs ys
     apply the binary function `f' to corresponding elements of `xs'
     and `ys', return `()'

 -- Function: dowith3 f xs ys zs
     apply the ternary function `f' to corresponding elements of `xs',
     `ys' and `zs', return `()'


File: purelib.info,  Node: String Functions,  Next: Matrix Functions,  Prev: List Functions,  Up: Prelude

1.8 String Functions
====================

Pure strings are null-terminated character strings encoded in UTF-8, see
the Pure Manual for details. The prelude provides various operations on
strings, including a complete set of list-like operations, so that
strings can be used mostly as if they were lists, although they are
really implemented as C character arrays for reasons of efficiency.
Pure also has some powerful operations to convert between Pure
expressions and their string representation, see *note Eval and
Friends: 90. for those.

* Menu:

* Basic String Functions::
* Low-Level Operations::


File: purelib.info,  Node: Basic String Functions,  Next: Low-Level Operations,  Up: String Functions

1.8.1 Basic String Functions
----------------------------

 -- Function: s + t
 -- Function: s ! i
 -- Function: s !! is
     String concatenation, indexing and slicing works just like with
     lists:

         > "abc"+"xyz";
         "abcxyz"
         > let s = "The quick brown fox jumps over the lazy dog.";
         > s!5;
         "u"
         > s!!(20..24);
         "jumps"



 -- Function: null s
 -- Function: # s
     Checking for empty strings and determining the size of a string
     also works as expected:

         > null "";
         1
         > null s;
         0
         > #s;
         44



 -- Function: s == t
 -- Function: s ~= t
 -- Function: s <= t
 -- Function: s >= t
 -- Function: s < t
 -- Function: s > t
     String equality and comparisons. This employs the usual
     lexicographic order based on the (UTF-8) character codes.

         > "awe">"awesome";
         0
         > "foo">="bar";
         1
         > "foo"=="bar";
         0



  You can search for the location of a substring in a string, and
extract a substring of a given length:

 -- Function: index s u
     Returns the (zero-based) index of the first occurrence of the
     substring `u' in `s', or -1 if `u' is not found in `s'.

 -- Function: substr s i n
     Extracts a substring of (at most) `n' characters at position `i' in
     `s'. This takes care of all corner cases, adjusting index and
     number of characters so that the index range stays confined to the
     source string.

  Example:

    > index s "jumps";
    20
    > substr s 20 10;
    "jumps over"

Note that Pure doesn't have a separate type for individual characters.
Instead, these are represented as strings `c' containing exactly one
(UTF-8) character (i.e., `#c==1'). It is possible to convert such single
character strings to the corresponding integer character codes, and vice
versa:

 -- Function: ord c
     Ordinal number of a single character string `c'. This is the
     character's code point in the Unicode character set.

 -- Function: chr n
     Converts an integer back to the character with the corresponding
     code point.

  In addition, the usual character arithmetic works, including
arithmetic sequences of characters, so that you can write stuff like
the following:

    > "a"-"A";
    32
    > "u"-32;
    "U"
    > "a".."k";
    ["a","b","c","d","e","f","g","h","i","j","k"]

For convenience, the prelude provides the following functions to convert
between strings and lists (or other aggregates) of characters.

 -- Function: chars s
 -- Function: list s
     Convert a string `s' to a list of characters.

 -- Function: tuple s
 -- Function: matrix s
     Convert a string `s' to a tuple or (symbolic) matrix of characters,
     respectively.

 -- Function: strcat xs
     Concatenate a list `xs' of strings (in particular, this converts a
     list of characters back to a string).

 -- Function: string xs
     Convert a list, tuple or (symbolic) matrix of strings to a string.
     In the case of a list, this is synonymous with *note strcat: ab,
     but it also works with the other types of aggregates.

  For instance:

    > list "abc";
    ["a","b","c"]
    > string ("a".."z");
    "abcdefghijklmnopqrstuvwxyz"

The following functions are provided to deal with strings of "tokens"
separated by a given delimiter string.

 -- Function: split delim s
     Splits `s' into a list of substrings delimited by `delim'.

 -- Function: join delim xs
     Joins the list of strings `xs' to a single string, interpolating
     the given `delim' string.

  Example:

    > let xs = split " " s; xs;
    ["The","quick","brown","fox","jumps","over","the","lazy","dog."]
    > join ":" xs;
    "The:quick:brown:fox:jumps:over:the:lazy:dog."

We mention in passing here that more elaborate string matching,
splitting and replacement operations based on regular expressions are
provided by the system module, see *note Regex Matching: af.

  If that isn't enough already, most generic list operations carry over
to strings in the obvious way, treating the string like a list of
characters.  (Polymorphic operations such as *note map: 34, which
aren't guaranteed to yield string results under all circumstances, will
actually return lists in that case, so you might have to apply *note
string: ac. explicitly to convert these back to a string.) For instance:

    > filter (>="k") s;
    "qukrownoxumpsovrtlzyo"
    > string $ map pred "ibm";
    "hal"

List comprehensions can draw values from strings, too:

    > string [x+1 | x="HAL"];
    "IBM"



File: purelib.info,  Node: Low-Level Operations,  Prev: Basic String Functions,  Up: String Functions

1.8.2 Low-Level Operations
--------------------------

The following routines are provided by the runtime to turn raw C `char*'
pointers (also called *byte strings* in Pure parlance, to distinguish
them from Pure's "cooked" UTF-8 string values) into corresponding Pure
strings. Normally you don't have to worry about this, because the C
interface already takes care of the necessary marshalling, but in some
low-level code these operations are useful. Also note that here and in
the following, the *note cstring: b1. routines also convert the string
between the system encoding and Pure's internal UTF-8 representation.

 -- Function: string s
 -- Function: cstring s
     Convert a pointer `s' to a Pure string. `s' must point to a
     null-terminated C string. These routines take ownership of the
     original string value, assuming it to be malloced, so you should
     only use these for C strings which are specifically intended to be
     freed by the user.

 -- Function: string_dup s
 -- Function: cstring_dup s
     Convert a pointer `s' to a Pure string. Like above, but these
     functions take a copy of the string, leaving the original C string
     untouched.

  The reverse transformations are also provided. These take a Pure
string to a byte string (raw `char*').

 -- Function: byte_string s
 -- Function: byte_cstring s
     Construct a byte string from a Pure string `s'. The result is a raw
     pointer object pointing to the converted string. The original Pure
     string is always copied (and, in the case of *note byte_cstring:
     b6, converted to the system encoding). The resulting byte string
     is a malloced pointer which can be used like a C `char*', and has
     to be freed explicitly by the caller when no longer needed.

  It is also possible to convert Pure string lists or symbolic vectors
of strings to byte string vectors and vice versa. These are useful if
you need to pass an `argv'-like string vector (i.e., a `char**' or
`char*[]') to C routines. The computed C vectors are malloced pointers
which have an extra *note NULL: 52. pointer as the last entry, and
should thus be usable for almost any purpose which requires such a
string vector in C. They also take care of garbage-collecting
themselves. The original string data is always copied. As usual, the
*note cstring: b1. variants do automatic conversions to the system
encoding.

 -- Function: byte_string_pointer xs
 -- Function: byte_cstring_pointer xs
     Convert a list or vector of Pure strings to a C `char**'.

 -- Function: string_list n p
 -- Function: cstring_list n p
     Convert a C `char**' to a list of Pure strings.

 -- Function: string_vector n p
 -- Function: cstring_vector n p
     Convert a C `char**' to a symbolic vector of Pure strings.

  Note that the back conversions take an additional first argument which
denotes the number of strings to retrieve. If you know that the vector
is *note NULL: 52.-terminated then this can also be an infinite value
(`inf') in which case the number of elements will be figured out
automatically.  Processing always stops at the first *note NULL: 52.
pointer encountered.

  Also note that, as of version 0.45, Pure has built-in support for
passing `argv'-style vectors as arguments by means of the `char**' and
`void**' pointer types. However, the operations provided here are more
general in that they allow you to both encode and decode such values in
an explicit fashion. This is useful, e.g., for operations like `getopt'
which may mutate the given `char**' vector.

  If you have `getopt' in your C library, you can try the following
example. First enter these definitions:

    extern int getopt(int argc, char **argv, char *optstring);
    optind = get_int $ addr "optind";
    optarg = cstring_dup $ get_pointer $ addr "optarg";

Now let's run `getopt' on a byte string vector constructed from an
argument vector (which includes the "program name" in the first
element):

    > let args = byte_cstring_pointer {"progname","boo","-n","-tfoo","bar"};
    > getopt 5 args "nt:", optarg;
    110,#<pointer 0>
    > getopt 5 args "nt:", optarg;
    116,"foo"
    > getopt 5 args "nt:", optarg;
    -1,#<pointer 0>

Note that 110 and 116 are the character codes of the option characters
`n' and `t', where the latter option takes an argument, as returned by
`optarg'. Finally, `getopt' returns -1 to indicate that there are no
more options, and we can retrieve the current `optindex' value and the
mutated argument vector to see which non-option arguments remain to be
processed, as follows:

    > optind, cstring_vector 5 args;
    3,{"progname","-n","-tfoo","boo","bar"}

It is now an easy exercise to design your own high-level wrapper around
`getopt' to process command line arguments in Pure. However, this isn't
really necessary since the Pure library already offers such an operation
which doesn't rely on any special system functions, see *note Option
Parsing: bd.  in the *note System Interface: be. section.


File: purelib.info,  Node: Matrix Functions,  Next: Record Functions,  Prev: String Functions,  Up: Prelude

1.9 Matrix Functions
====================

 -- Function: # x
 -- Function: dim x
     Determine the size of a matrix (number of elements) and its
     dimensions (number of rows and columns).

         > let x = {1,2,3;4,5,6}; #x;
         6
         > dim x;
         2,3



 -- Function: null
     Check for empty matrices. Note that there are various kinds of
     these, as a matrix may have zero rows or columns, or both.

 -- Function: x ! i
 -- Function: x !! is
     Indexing and slicing works pretty much like in MATLAB and Octave,
     except that the Pure operators '*note !: 4c.' and '*note !!: 4f.'
     are used and indices are zero-based. It is possible to access
     elements with a one-dimensional index (in row-major oder):

         > x!3;
         4

     Or you can specify a pair of row and column index:

         > x!(1,0);
         4

     Slicing works accordingly. You can either specify a list of (one-
     or two-dimensional) indices, in which case the result is always a
     row vector:

         > x!!(2..5);
         {3,4,5,6}

     Or you can specify a pair of row and column index lists:

         > x!!(0..1,1..2);
         {2,3;5,6}

     The following abbreviations are provided to grab a slice from a
     row or column:

         > x!!(1,1..2);
         {5,6}
         > x!!(0..1,1);
         {2;5}

     As in the case of lists, matrix slices are optimized to handle
     cases with contiguous index ranges in an efficient manner, see
     *note Slicing: 50. for details. To these ends, the helper
     functions *note subseq: c8. and *note subseq2: c9. are defined to
     handle the necessary compile time optimizations.

 -- Function: x == y
 -- Function: x ~= y
     Matrix equality and inequality. These check the dimensions and the
     matrix elements for equality:

         > x == transpose x;
         0



  Most of the generic list operations are implemented on matrices, see
*note Common List Functions: 64. Hence operations like *note map: 34.
and *note zipwith: 89. work as expected:

    > map succ {1,2,3;4,5,6};
    {2,3,4;5,6,7}
    > zipwith (+) {1,2,3;4,5,6} {1,0,1;0,2,0};
    {2,2,4;4,7,6}

The matrix module also provides a bunch of other specialized matrix
operations, including all the necessary operations for matrix
comprehensions. We briefly summarize the most important operations
below; please refer to matrices.pure for all the gory details. Also
make sure you check _Matrix Computations_ in the Pure Manual for some
more examples, and the *note Record Functions: 2b. section for an
implementation of records using symbolic vectors.

* Menu:

* Matrix Construction and Conversions::
* Matrix Inspection and Manipulation::
* Pointers and Matrices::


File: purelib.info,  Node: Matrix Construction and Conversions,  Next: Matrix Inspection and Manipulation,  Up: Matrix Functions

1.9.1 Matrix Construction and Conversions
-----------------------------------------

 -- Function: matrix xs
     This function converts a list or tuple to a corresponding matrix.
     *note matrix: cd. also turns a list of lists or matrices
     specifying the rows of the matrix to the corresponding rectangular
     matrix; otherwise, the result is a row vector. (In the former
     case, *note matrix: cd. may throw a *note bad_matrix_value: f.
     exception in case of dimension mismatch, with the offending
     submatrix as argument.)

         > matrix [1,2,3];
         {1,2,3}
         > matrix [[1,2,3],[4,5,6]];
         {1,2,3;4,5,6}



 -- Function: rowvector xs
 -- Function: colvector xs
 -- Function: vector xs
     The *note rowvector: ce. and *note colvector: cf. functions work
     in a similar fashion, but expect a list, tuple or matrix of
     elements and always return a row or column vector, respectively
     (i.e., a 1\times n or n\times 1 matrix, where n is the size of the
     converted aggregate). Also, the *note vector: d0. function is a
     synonym for *note rowvector: ce. These functions can also be used
     to create recursive (symbolic) matrix structures of arbitrary
     depth, which provide a nested array data structure with efficient
     (constant time) element access.

         > rowvector [1,2,3];
         {1,2,3}
         > colvector [1,2,3];
         {1;2;3}
         > vector [rowvector [1,2,3],colvector [4,5,6]];
         {{1,2,3},{4;5;6}}



 -- Function: rowvectorseq x y step
 -- Function: colvectorseq x y step
 -- Function: vectorseq x y step
     With these functions you can create a row or column vector from an
     arithmetic sequence. Again, *note vectorseq: d3. is provided as a
     synonym for *note rowvectorseq: d1. These operations are optimized
     for the case of int and double ranges.

         > rowvectorseq 0 10 1;
         {0,1,2,3,4,5,6,7,8,9,10}
         > colvectorseq 0 10 1;
         {0;1;2;3;4;5;6;7;8;9;10}
         > vectorseq 0.0 0.9 0.1;
         {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9}

     The prelude also contains some optimization rules which translate
     calls to *note vector: d0. et al on arithmetic sequences to the
     corresponding calls to *note vectorseq: d3. et al, such as:

         def vector (n1:n2..m) = vectorseq n1 m (n2-n1);
         def vector (n..m) = vectorseq n m 1;

     Example:

         > foo = vector (1..10);
         > bar = vector (0.0:0.1..0.9);
         > show foo bar
         bar = vectorseq 0.0 0.9 0.1;
         foo = vectorseq 1 10 1;
         > foo; bar;
         {1,2,3,4,5,6,7,8,9,10}
         {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9}

     Please note that these optimization rules assume that basic
     arithmetic works with the involved elements, which may give you
     trouble if you try to use *note vector: d0. et al with exotic
     kinds of user-defined arithmetic sequences. To disable them,
     simply run the interpreter with the option `--disable
     vectorseq-opt'.

 -- Function: dmatrix xs
 -- Function: cmatrix xs
 -- Function: imatrix xs
 -- Function: smatrix xs
     These functions convert a list or matrix to a matrix of the
     corresponding type (integer, double, complex or symbolic). If the
     input is a list, the result is always a row vector; this is
     usually faster than the *note matrix: cd. and *note vector: d0.
     operations, but requires that the elements already are of the
     appropriate type.

         > imatrix [1,2,3];
         {1,2,3}
         > dmatrix {1,2,3;4,5,6};
         {1.0,2.0,3.0;4.0,5.0,6.0}

     The *note dmatrix: d4, *note cmatrix: d5. and *note imatrix: d6.
     functions can also be invoked with either an int `n' or a pair
     `(n,m)' of ints as argument, in which case they construct a zero
     rowvector or matrix with the corresponding dimensions.

         > imatrix 3;
         {0,0,0}
         > imatrix (2,3);
         {0,0,0;0,0,0}



 -- Function: list x
 -- Function: list2 x
 -- Function: tuple x
     These convert a matrix back to a flat list or tuple. The `list2'
     function converts a matrix to a list of lists (one sublist for
     each row of the matrix).

         > tuple {1,2,3;4,5,6};
         1,2,3,4,5,6
         > list {1,2,3;4,5,6};
         [1,2,3,4,5,6]
         > list2 {1,2,3;4,5,6};
         [[1,2,3],[4,5,6]]
         > list2 {1,2,3};
         [[1,2,3]]




File: purelib.info,  Node: Matrix Inspection and Manipulation,  Next: Pointers and Matrices,  Prev: Matrix Construction and Conversions,  Up: Matrix Functions

1.9.2 Matrix Inspection and Manipulation
----------------------------------------

 -- type: dmatrix
 -- type: cmatrix
 -- type: imatrix
 -- type: smatrix
 -- type: nmatrix
     Convenience types for the different subtypes of matrices (double,
     complex, int, symbolic and numeric, i.e., non-symbolic). These can
     be used as type tags on the left-hand side of equations to match
     specific types of matrices.

 -- Function: dmatrixp x
 -- Function: cmatrixp x
 -- Function: imatrixp x
 -- Function: smatrixp x
 -- Function: nmatrixp x
     Corresponding predicates to check for different kinds of matrices.

 -- Function: vectorp x
 -- Function: rowvectorp x
 -- Function: colvectorp x
     Check for different kinds of vectors (these are just matrices with
     one row or column).

 -- Function: stride x
     The stride of a matrix denotes the real row size of the underlying
     C array, see the description of the *note pack: e5. function below
     for further details. There's little use for this value in Pure,
     but it may be needed when interfacing to C.

 -- Function: subseq x i j
 -- Function: subseq2 x i j k l
     Helper functions to optimize matrix slices, see *note Slicing: 50.
     for details.  *note subseq2: c9. is a special version of *note
     subseq: c8.  which is used to optimize the case of 2-dimensional
     matrix slices `xs!!(i..j,k..l)'.

 -- Function: row x i
 -- Function: col x i
     Extract the `i'th row or column of a matrix.

 -- Function: rows x
 -- Function: cols x
     Return the list of all rows or columns of a matrix.

 -- Function: diag x
 -- Function: subdiag x k
 -- Function: supdiag x k
     Extract (sub-,super-) diagonals from a matrix. Sub- and
     super-diagonals for `k=0' return the main diagonal. Indices for
     sub- and super-diagonals can also be negative, in which case the
     corresponding super- or sub-diagonal is returned instead. In each
     case the result is a row vector.

 -- Function: submat x (i,j) (n,m)
     Extract a submatrix of a given size at a given offset. The result
     shares the underlying storage with the input matrix (i.e., matrix
     elements are _not_ copied) and so this is a comparatively cheap
     operation.

 -- Function: rowcat xs
 -- Function: colcat xs
     Construct matrices from lists of rows and columns. These take
     either scalars or submatrices as inputs; corresponding dimensions
     must match.  *note rowcat: ee. combines submatrices vertically,
     like `{x;y}'; *note colcat: ef. combines them horizontally, like
     `{x,y}'. Note: Like the built-in matrix constructs, these
     operations may throw a *note bad_matrix_value: f. exception in
     case of dimension mismatch.

 -- Function: matcat xs
     Construct a matrix from a (symbolic) matrix of other matrices
     and/or scalars. This works like a combination of *note rowcat: ee.
     and *note colcat: ef, but draws its input from a matrix instead of
     a list of matrices, and preserves the overall layout of the "host"
     matrix. The net effect is that the host matrix is flattened out.
     If all elements of the input matrix are scalars already, the input
     matrix is returned unchanged.

 -- Function: rowcatmap f xs
 -- Function: colcatmap f xs
 -- Function: rowmap f xs
 -- Function: colmap f xs
     Various combinations of *note rowcat: ee, *note colcat: ef. and
     *note map: 34.  These are used, in particular, for implementing
     matrix comprehensions.

 -- Function: diagmat x
 -- Function: subdiagmat x k
 -- Function: supdiagmat x k
     Create a (sub-,super-) diagonal matrix from a row vector `x' of
     size `n'. The result is always a square matrix with dimension
     `(n+k,n+k)', which is of the same matrix type (double, complex,
     int, symbolic) as the input and has the elements of the vector on
     its `k'th sub- or super-diagonal, with all other elements zero. A
     negative value for `k' turns a sub- into a super-diagonal matrix
     and vice versa.

 -- Function: re x
 -- Function: im x
 -- Function: conj x
     Extract the real and imaginary parts and compute the conjugate of a
     numeric matrix.

 -- Function: pack x
 -- Function: packed x
     Pack a matrix. This creates a copy of the matrix which has the
     data in contiguous storage. It also frees up extra memory if the
     matrix was created as a slice from a bigger matrix (see *note
     submat: ed. above) which has since gone the way of the dodo. The
     *note packed: fb. predicate can be used to verify whether a matrix
     is already packed. Note that even if a matrix is already packed,
     *note pack: e5. will make a copy of it anyway, so *note pack: e5.
     also provides a quick way to copy a matrix, e.g., if you want to
     pass it as an input/output parameter to a GSL routine.

 -- Function: redim (n,m) x
 -- Function: redim n x
     Change the dimensions of a matrix without changing its size. The
     total number of elements must match that of the input matrix.
     Reuses the underlying storage of the input matrix if possible
     (i.e., if the matrix is *note packed: fb.). You can also redim a
     matrix to a given row size `n'. In this case the row size must
     divide the total size of the matrix.

 -- Function: sort p x
     Sorts the elements of a matrix (non-destructively, i.e., without
     changing the original matrix) according to the given predicate,
     using the C `qsort' function. This works exactly the same as with
     lists (see *note Common List Functions: 64.), except that it takes
     and returns a matrix instead of a list. Note that the function
     sorts _all_ elements of the matrix in one go (regardless of the
     dimensions), as if the matrix was a single big vector. The result
     matrix has the same dimensions as the input matrix. Example:

         > sort (<) {10,9;8,7;6,5};
         {5,6;7,8;9,10}

     If you'd like to sort the individual rows instead, you can do that
     as follows:

         > sort_rows p = rowcat . map (sort p) . rows;
         > sort_rows (<) {10,9;8,7;6,5};
         {9,10;7,8;5,6}

     Likewise, to sort the columns of a matrix:

         > sort_cols p = colcat . map (sort p) . cols;
         > sort_cols (<) {10,9;8,7;6,5};
         {6,5;8,7;10,9}

     Also note that the pure-gsl module provides an interface to the GSL
     routines for sorting numeric (int and double) vectors using the
     standard order. These will usually be much faster than *note sort:
     fd, whereas *note sort: fd. is more flexible in that it also
     allows you to sort symbolic matrices and to choose the order
     predicate.

 -- Function: transpose x
     Transpose a matrix. Example:

         > transpose {1,2,3;4,5,6};
         {1,4;2,5;3,6}



 -- Function: rowrev x
 -- Function: colrev x
 -- Function: reverse x
     Reverse a matrix. *note rowrev: ff. reverses the rows, *note
     colrev: 100. the columns, *note reverse: 53. both dimensions.


File: purelib.info,  Node: Pointers and Matrices,  Prev: Matrix Inspection and Manipulation,  Up: Matrix Functions

1.9.3 Pointers and Matrices
---------------------------

Last but not least, the matrix module also offers a bunch of low-level
operations for converting between matrices and raw pointers. These are
typically used to shovel around massive amounts of numeric data between
Pure and external C routines, when performance and throughput is an
important consideration (e.g., graphics, video and audio applications).
The usual caveats concerning direct pointer manipulations apply.

 -- Function: pointer x
     Get a pointer to the underlying C array of a matrix. The data is
     _not_ copied. Hence you have to be careful when passing such a
     pointer to C functions if the underlying data is non-contiguous;
     when in doubt, first use the *note pack: e5. function to place the
     data in contiguous storage, or use one of the matrix-pointer
     conversion routines below.

 -- Function: double_pointer p x
 -- Function: float_pointer p x
 -- Function: complex_pointer p x
 -- Function: complex_float_pointer p x
 -- Function: int_pointer p x
 -- Function: short_pointer p x
 -- Function: byte_pointer p x
     These operations copy the contents of a matrix to a given pointer
     and return that pointer, converting to the target data type on the
     fly if necessary. The given pointer may also be *note NULL: 52, in
     which case suitable memory is malloced and returned; otherwise the
     caller must ensure that the memory pointed to by `p' is big enough
     for the contents of the given matrix.

 -- Function: double_matrix (n,m) p
 -- Function: float_matrix (n,m) p
 -- Function: complex_matrix (n,m) p
 -- Function: complex_float_matrix (n,m) p
 -- Function: int_matrix (n,m) p
 -- Function: short_matrix (n,m) p
 -- Function: byte_matrix (n,m) p
     These functions allow you to create a numeric matrix from a
     pointer, copying the data and converting it from the source type
     on the fly if necessary. The source pointer `p' may also be *note
     NULL: 52, in which case the new matrix is filled with zeros
     instead.  Otherwise the caller must ensure that the pointer points
     to properly initialized memory big enough for the requested
     dimensions. The given dimension may also be just an integer `n' if
     a row vector is to be created.

 -- Function: double_matrix_view (n,m) p
 -- Function: complex_matrix_view (n,m) p
 -- Function: int_matrix_view (n,m) p
     These operations can be used to create a numeric matrix view of
     existing data, without copying the data. The data must be double,
     complex or int, the pointer must not be *note NULL: 52. and the
     caller must also ensure that the memory persists for the entire
     lifetime of the matrix object.  The given dimension may also be
     just an integer `n' if a row vector view is to be created.


File: purelib.info,  Node: Record Functions,  Next: Primitives,  Prev: Matrix Functions,  Up: Prelude

1.10 Record Functions
=====================

As of Pure 0.41, the prelude also provides a basic record data
structure, implemented as symbolic vectors of `key=>value' pairs which
support a few dictionary-like operations such as *note member: 116,
*note insert: 117. and indexing.  Records may be represented as row,
column or empty vectors (i.e., the number of rows or columns must be
zero or one). They must be symbolic matrices consisting only of "hash
pairs" `key=>value', where the keys can be either symbols or strings.
The values can be any kind of Pure data; in particular, they may
themselves be records, so records can be nested.

  The following operations are provided. Please note that all updates of
record members are non-destructive and thus involve copying, which takes
linear time (and space) and thus might be slow for large record values;
if this is a problem then you should use dictionaries instead (cf.
*note Dictionaries: 118.). Or you can create mutable records by using
expression references (cf. *note Expression References: 119.) as
values, which allow you to modify the data in-place. Element lookup
(indexing) uses binary search on an internal index data structure and
thus takes logarithmic time once the index has been constructed (which
is done automatically when needed, or when calling `recordp' on a fresh
record value).

  Also note that records with duplicate keys are permitted; in such a
case the following operations will always operate on the _last_ entry
for a given key.

 -- type: record
     The record type. This is functionally equivalent to *note recordp:
     11b, but can be used as a type tag on the left-hand side of
     equations.

 -- Function: recordp x
     Check for record values.

 -- Function: record x
     Normalizes a record. This removes duplicate keys and orders the
     record by keys (using an apparently random but well-defined order
     of the key values), so that normalized records are syntactically
     equal (*note ===: 11d.) if and only if they contain the same hash
     pairs. For convenience, this function can also be used directly on
     lists and tuples of hash pairs to convert them to a normalized
     record value.

 -- Function: # x
     The size of a record (number of entries it contains). Duplicate
     entries are counted. (This is in fact just the standard matrix
     size operation.)

 -- Function: member x y
     Check whether `x' contains the key `y'.

 -- Function: x ! y
     Retrieves the (last) value associated with the key `y' in `x', if
     any, otherwise throws an `out_of_bound' exception.

 -- Function: x !! ys
     Slicing also works as expected, by virtue of the generic
     definition of slicing provided by the matrix data structure.

 -- Function: insert x (y=>z)
 -- Function: update x y z
     Associate the key `y' with the value `z' in `x'. If `x' already
     contains the key `y' then the corresponding value is updated (the
     last such value if `x' contains more than one association for `y'),
     otherwise a new member is inserted at the end of the record.

 -- Function: delete x y
     Delete the key `y' (and its associated value) from `x'. If `x'
     contains more than one entry for `y' then the last such entry is
     removed.

 -- Function: keys x
 -- Function: vals x
     List the keys and associated values of `x'. If the record contains
     duplicate keys, they are all listed in the order in which they are
     stored in the record.

  Here are a few basic examples:

    > let r = {x=>5, y=>12};
    > r!y; r!![y,x];              // indexing and slicing
    12
    {12,5}
    > keys r; vals r;             // keys and values of a record
    {x,y}
    {5,12}
    > insert r (x=>99);           // update an existing entry
    {x=>99,y=>12}
    > insert ans (z=>77);         // add a new entry
    {x=>99,y=>12,z=>77}
    > delete ans z;               // delete an existing entry
    {x=>99,y=>12}
    > let r = {r,x=>7,z=>3}; r;   // duplicate key x
    {x=>5,y=>12,x=>7,z=>3}
    > r!x, r!z;                   // indexing returns the last value of x
    7,3
    > delete r x;                 // delete removes the last entry for x
    {x=>5,y=>12,z=>3}
    > record r;                   // normalize (remove dups and sort)
    {x=>7,y=>12,z=>3}
    > record [x=>5, x=>7, y=>12]; // construct a normalized record from a list
    {x=>7,y=>12}
    > record (x=>5, x=>7, y=>12); // ... or a tuple
    {x=>7,y=>12}

More examples can be found in the _Record Data_ section in the Pure
Manual.


File: purelib.info,  Node: Primitives,  Prev: Record Functions,  Up: Prelude

1.11 Primitives
===============

This prelude module is a collection of various lowlevel operations,
which are implemented either directly by machine instructions or by C
functions provided in the runtime. In particular, this module defines
the basic arithmetic and logic operations on machine integers, bigints
and floating point numbers, as well as various type checking predicates
and conversions between different types. Some basic pointer operations
are also provided, as well as "sentries" (Pure's flavour of object
finalizers) and "references" (mutable expression pointers).

* Menu:

* Special Constants::
* Arithmetic::
* Conversions::
* Predicates::
* Inspection::
* Eval and Friends::
* Expression Serialization::
* Other Special Primitives::
* Pointer Operations::
* Sentries::
* Tagged Pointers::
* Expression References::
* Pointer Arithmetic::


File: purelib.info,  Node: Special Constants,  Next: Arithmetic,  Up: Primitives

1.11.1 Special Constants
------------------------

 -- constant: inf
 -- constant: nan
     IEEE floating point infinities and NaNs. You can test for these
     using the *note infp: 129. and *note nanp: 12a. predicates, see
     *note Predicates: 29. below.

 -- constant: NULL = pointer 0
     Generic null pointer. (This is actually a built-in constant.) You
     can also check for null pointers with the *note null: 12b.
     predicate, see *note Predicates: 29.


File: purelib.info,  Node: Arithmetic,  Next: Conversions,  Prev: Special Constants,  Up: Primitives

1.11.2 Arithmetic
-----------------

The basic arithmetic and logic operations provided by this module are
summarized in the following table:

Kind            Operator            Meaning
---------------------------------------------------------------------------------- 
Arithmetic      `+' `-'             addition, subtraction (also unary minus)
                `*' `/'             multiplication, division (inexact)
                `div' `mod'         exact int/bigint division/modulus
                `^'                 exponentiation (inexact)
Comparisons     `==' `~='           equality, inequality
                `<' `>'             less than, greater than
                `<=' `>='           less than or equal, greater than or equal
Logic           `~'                 logical not
                `&&' `||'           and, or (short-circuit)
Bitwise         `not'               bitwise not
                `and' `or'          and, or
                `<<' `>>'           bit shifts

  Precedence and and associativity of the operators can be found in the
*note operators: 12. table at the beginning of this section.

  The names of some operations are at odds with C. Note, in particular,
that logical negation is denoted `~' instead of `!' (and, consequently,
`~=' denotes inequality, rather than `!='), and the bitwise operations
are named differently. This is necessary because Pure uses `!', `&' and
`|' for other purposes. Also, `/' always denotes inexact (double)
division in Pure, whereas the integer division operators are called
`div' and `mod'. (`%', which is not defined by this module, also has a
different meaning in Pure; it's the exact division operator, see *note
Rational Numbers: 12d.)

  The above operations are implemented for int, bigint and, where
appropriate, double operands. (Pointer arithmetic and comparisons are
provided in a separate module, see *note Pointer Arithmetic: 12e.) The
math module (see *note Mathematical Functions: 12f.) also provides
implementations of the arithmetic and comparison operators for
rational, complex and complex rational numbers.

  Note that the logical operations are actually implemented as special
forms in order to provide for short-circuit evaluation. This needs
special support from the compiler to work. The primitives module still
provides definitions for these, as well as other special forms like
`quote' and the thunking operator `&' so that they may be used as
function values and in partial applications, but when used in this
manner they lose all their special call-by-name properties; see
_Special Forms_ in the Pure Manual for details.

  A detailed listing of the basic arithmetic and logical operations
follows below.

 -- Function: x + y
 -- Function: x - y
 -- Function: x * y
 -- Function: x / y
 -- Function: x ^ y
     Addition, subtraction, multiplication, division and
     exponentiation. The latter two are inexact and will yield double
     results.

 -- Function: - x
     Unary minus. This has the same precedence as binary '*note -: 130.'
     above.

 -- Function: x div y
 -- Function: x mod y
     Exact int and bigint division and modulus.

 -- Function: x == y
 -- Function: x ~= y
     Equality and inequality.

 -- Function: x <= y
 -- Function: x >= y
 -- Function: x > y
 -- Function: x < y
     Comparisons.

 -- Function: ~ x
 -- Function: x && y
 -- Function: x || y
     Logical negation, conjunction and disjunction. These work with
     machine ints only and are evaluated in short-circuit mode.

 -- Function: not x
 -- Function: x and y
 -- Function: x or y
     Bitwise negation, conjunction and disjunction. These work with both
     machine ints and bigints.

 -- Function: x << k
 -- Function: x >> k
     Arithmetic bit shifts. The left operand `x' may be a machine int
     or a bigint. The right operand `k' must be a machine int and
     denotes the (nonnegative) number of bits to shift.

          Note: This operation may expand to a single machine
          instruction in the right circumstances, thus the condition
          that `k' be nonnegative isn't always checked. This may lead
          to surprising results if you do specify a negative value for
          `k'. However, in the current implementation bigint shifts do
          check the sign of `k' and handle it in the appropriate way,
          by turning a left shift into a corresponding right shift and
          vice versa.

  In addition, the following arithmetic and numeric functions are
provided:

 -- Function: abs x
 -- Function: sgn x
     Absolute value and sign of a number.

 -- Function: min x y
 -- Function: max x y
     Minimum and maximum of two values. This works with any kind of
     values which have the ordering relations defined on them.

 -- Function: succ x
 -- Function: pred x
     Successor (`+1') and predecessor (`-1') functions.

 -- Function: gcd x y
 -- Function: lcd x y
     The greatest common divisor and least common multiple functions
     from the GMP library. These return a bigint if at least one of the
     arguments is a bigint, a machine int otherwise.

 -- Function: pow x y
     Computes exact powers of ints and bigints. The result is always a
     bigint. Note that `y' must always be nonnegative here, but see the
     math module (*note Mathematical Functions: 12f.) which deals with
     the case `y<0' using rational numbers.


File: purelib.info,  Node: Conversions,  Next: Predicates,  Prev: Arithmetic,  Up: Primitives

1.11.3 Conversions
------------------

These operations convert between various types of Pure values.

 -- Function: hash x
     Compute a 32 bit hash code of a Pure expression.

 -- Function: int x
 -- Function: bigint x
 -- Function: double x
     Conversions between the different numeric types.

 -- Function: pointer x
     Convert a string, int or bigint to a pointer value. Converting a
     string returns a pointer to the underlying UTF8-encoded C string
     so that it can be passed to the appropriate C functions.
     Converting an integer gives a pointer with the given numeric
     address. This may be used to construct special pointer values such
     as the null pointer (`pointer 0').

 -- Function: ubyte x
 -- Function: ushort x
 -- Function: uint x
 -- Function: uint64 x
 -- Function: ulong x
     Convert signed (8/16/32/64) bit integers to the corresponding
     unsigned quantities. These functions behave as if the value was
     "cast" to the corresponding unsigned C type, and are most useful
     for dealing with unsigned integers returned by external C
     routines. The routines always use the smallest Pure int type
     capable of holding the result: `int' for *note ubyte: 153. and
     *note ushort: 154, `bigint' for *note uint: 155, *note uint64:
     156. and *note ulong: 157. All routines take int parameters. In
     the case of *note uint64: 156, a bigint parameter is also
     permitted (which is what the C interface returns for 64 bit
     values). Also note that *note ulong: 157. reduces to either *note
     uint: 155. or *note uint64: 156, depending on the size of `long'
     for the host architecture.

  The following rounding functions work with all kinds of numbers:

 -- Function: floor x
 -- Function: ceil x
     Floor and ceil.

 -- Function: round x
 -- Function: trunc x
     Round or truncate to an integer.

 -- Function: frac x
     Fractional part (`x-trunc x').

  Note that all these functions return double values for double
arguments, so if you need an integer result then you'll have to apply a
suitable conversion, as in `int (floor x)'.


File: purelib.info,  Node: Predicates,  Next: Inspection,  Prev: Conversions,  Up: Primitives

1.11.4 Predicates
-----------------

A syntactic equality test is provided, as well as various type checking
predicates. Note that type definitions are provided for most of the type
checking predicates which don't denote built-in types; see *note
Prelude Types: 13.  for details.

 -- Function: same x y
 -- Function: x === y
 -- Function: x ~== y
     Syntactic equality. In contrast to *note ==: 46. and *note ~=:
     137, this is defined on all Pure expressions. Basically, two
     expressions are syntactically equal if they print out the same in
     the interpreter. In the special case of pointer objects and
     closures, which do not have a syntactic representation in Pure,
     `x' and `y' must be the same object (same pointer value or
     function).

 -- Function: typep ty x
     Generic type checking predicate. This checks whether `x' is of type
     `ty', where `ty' is a symbol denoting any of the built-in types
     (`int', `bigint' etc.) or any type defined in a `type' definition.
     (Note that you may have to quote `ty' if it happens to be defined
     as a variable or parameterless function.)

 -- Function: intp x
 -- Function: bigintp x
 -- Function: doublep x
 -- Function: stringp x
 -- Function: pointerp x
 -- Function: matrixp x
     Predicates to check for the built-in types.

 -- Function: charp x
     Single character string predicate.

 -- Function: numberp x
 -- Function: complexp x
 -- Function: realp x
 -- Function: rationalp x
 -- Function: integerp x
     Additional number predicates. Note some further "semantic" number
     predicates are defined in the *note math: 1a. module, see *note
     Semantic Number Predicates and Types: 1b.

 -- Function: exactp x
 -- Function: inexactp x
     Check whether a number is exact (i.e., doesn't contain any double
     components).

 -- Function: infp x
 -- Function: nanp x
     Check for *note inf: 127. and *note nan: 128. values.

 -- Function: null p
     Check for null pointers.

 -- Function: applp x
 -- Function: listp x
 -- Function: rlistp x
 -- Function: tuplep x
     Predicates to check for function applications, lists, proper lists
     and tuples. Note that *note listp: 170. only checks for a toplevel
     list constructor, whereas *note rlistp: 171. also recursively
     checks the tails of the list; the latter may need time
     proportional to the list size. The *note applp: 16f. and *note
     tuplep: 172. predicates look for an application or tuple
     constructor at the toplevel only, which can always be done in
     constant time.

 -- Function: funp x
 -- Function: lambdap x
 -- Function: thunkp x
 -- Function: closurep x
     Predicates to check for various kinds of function objects (named,
     anonymous or thunk). *note closurep: 176. checks for any kind of
     "normal" closure (i.e., named functions and lambdas, but not
     thunks).

 -- Function: functionp x
     Convenience function to check for "callable" functions. This
     includes any kind of closure with a nonzero argument count as well
     as partial (unsaturated) applications of these.

 -- Function: symbolp x
 -- Function: varp x
     Predicates to check for any kind of symbol (this also includes
     operator and nonfix symbols) and for free variable symbols,
     respectively. Note that varp returns true for any symbol which is
     not an operator or nonfix symbol (i.e., for any symbol that could
     in principle be bound to a value, either globally or locally).
     This holds even if the symbol is currently bound to a function,
     macro or constant.


File: purelib.info,  Node: Inspection,  Next: Eval and Friends,  Prev: Predicates,  Up: Primitives

1.11.5 Inspection
-----------------

The following operations let you peek at various internal information
that the interpreter provides to Pure programs either for convenience
or for metaprogramming purposes. They are complemented by the evaluation
primitives discussed below, see *note Eval and Friends: 90.

 -- Function: ans
     Retrieve the most recently printed result of a toplevel expression
     evaluated in the read-eval-print loop. This is just a convenience
     for interactive usage. Note that the *note ans: 17b. value will
     stick around until a new expression is computed. (It is possible
     to clear the *note ans: 17b. value with the interactive command
     `clear ans', however.)  Example:

         > 1/3;
         0.333333333333333
         > ans/2;
         0.166666666666667



 -- Function: __func__
     Returns the (lexically) innermost function at the point of the
     call.  This can be either a global function, a local (named)
     function introduced in a `with' clause or an anonymous function (a
     lambda). Fails (returning just the literal symbol *note __func__:
     17c. by default) if there is no such function (i.e., if the call
     is at the toplevel). Note that in contrast to the C99 variable of
     the same name, this really returns the function value itself in
     Pure; the *note str: 17d.  function can be used if you need the
     print name of the function.  Examples:

         > foo x = if x>0 then x else throw __func__;
         > foo (-99);
         <stdin>, line 2: unhandled exception 'foo' while evaluating 'foo (-99)'
         > (\x->x+": "+str __func__) "test";
         "test: #<closure 0x7f4a2411db30>"

     If you want, you can add a default rule for *note __func__: 17c.
     which specifies the behaviour when *note __func__: 17c. gets
     called at the global level. E.g.:

         > __func__ = throw "__func__ called at global level";
         > __func__;
         <stdin>, line 5: unhandled exception '"__func__ called at global level"' while
         evaluating '__func__'



 -- macro: __namespace__
     Returns the current namespace at the point of the call. This is
     implemented as a built-in macro which expands to a string. The
     empty string is returned in the default namespace. Example:

         > namespace foo;
         > foo = __namespace__;
         > namespace;
         > show foo::foo
         foo::foo = "foo";
         > foo::foo;
         "foo"



 -- macro: __list__
     This expands a (literal) tuple to a list, preserving embedded
     tuples in the same way that list values are parsed in the Pure
     language, cf. _Primary Expressions_. This is provided for the
     benefit of custom aggregate notations (usually implemented as
     outfix operators) which are supposed to be parsed like the
     built-in list and matrix brackets. Example:

         > outfix (: :);
         > def (:x:) = __list__ x;
         > (:(1,2),(3,4):);
         [(1,2),(3,4)]

     Note that this macro uses internal information from the parser not
     available to Pure programs. Thus there's no way to actually define
     this macro in Pure, which is why it is provided as a builtin
     instead.

 -- macro: __locals__
     Built-in macro which expands to a list with the local function
     bindings (`with' clauses) visible at this point in the program. The
     return value is a list of hash pairs `x=>f' where `x' is the global
     symbol denoting the function (the symbol is always quoted) and `f'
     is the function value itself. Example:

         > __locals__ with foo x = x+1; x = a+b end;
         [x=>a+b,foo=>foo]
         > f 99 when _=>f = ans!1 end;
         100

     The *note __locals__: 180. function is useful for debugging
     purposes, as well as to implement dynamic environments. It is also
     used internally to implement the *note reduce: 181. macro, see
     *note Eval and Friends: 90.

     Note that *note __locals__: 180. always evaluates parameterless
     functions and returns the resulting value instead of a closure (as
     can be seen in the binding `x=>a+b' in the example above).
     Normally this is what you want, but it can be a problem with
     parameterless functions involving side effects. In such a case, if
     you want to evaluate the function at a later time, you'll either
     have to use a thunk or massage the local function so that it takes
     a dummy argument such as `()'.

     Also note that *note __locals__: 180. will use as keys in the
     resulting list whatever global symbols are in scope at the point
     of the call. By default, i.e., if no global symbol with the same
     print name as the local is visible at the point of the call, a
     symbol in the default namespace is used, as we've seen above.
     Otherwise the result may be also be a qualified symbol if such a
     symbol has already been declared or defined at the point of the
     call. For instance:

         > namespace foo;
         > public foo;
         > __locals__ with foo x = x+1 end;
         [foo::foo=>foo]

     This behaviour may be a bit surprising at first sight, but is
     consistent with the way the interpreter performs its symbol
     lookup, see _Symbol Lookup and Creation_ for details.

  The following functions allow you to inspect or modify the function,
type, macro, constant and variable definitions of the running program.
This uses a special meta representation for rewriting rules and
definitions. Please see the _Macros_ section in the Pure manual for
details. Also note that these operations are subject to some
limitations, please check the remarks concerning *note eval: 182. and
*note evalcmd: 183. in the following subsection for details.

 -- Function: get_fundef sym
 -- Function: get_typedef sym
 -- Function: get_macdef sym
     If the given symbol is defined as a function, type or macro,
     return the corresponding list of rewriting rules. Otherwise return
     the empty list.

 -- Function: get_interface sym
 -- Function: get_interface_typedef sym
     If the given symbol is defined as an interface type, return its
     definition; otherwise return the empty list. *note get_interface:
     187.  returns the list of patterns used to declare the type, while
     *note get_interface_typedef: 188. returns the actual list of type
     rules, in the same format as with *note get_typedef: 185. Note
     that the latter may be empty even if the type is defined, meaning
     that the type hasn't been instantiated yet, see _Interface Types_
     for details. Also note that Pure allows you to have _both_ an
     interface and a regular (concrete) definition of a type, in which
     case *note get_typedef: 185. and *note get_interface_typedef: 188.
     may both return nonempty (and usually different) results.

 -- Function: get_vardef sym
 -- Function: get_constdef sym
     If the given symbol is defined as a variable or constant, return
     the corresponding definition as a singleton list of the form `[sym
     --> value]'. Otherwise return the empty list.

  The following functions may fail in case of error, in which case
*note lasterr: 18b. is set accordingly (see *note Eval and Friends: 90.
below).

 -- Function: add_fundef rules
 -- Function: add_typedef rules
 -- Function: add_macdef rules
     Add the given rewriting rules (given in the same format as
     returned by the *note get_fundef: 184, *note get_typedef: 185. and
     *note get_macdef: 186.  functions above) to the running program.

 -- Function: add_fundef_at r rules
 -- Function: add_typedef_at r rules
 -- Function: add_macdef_at r rules
     Same as above, but add the given rewriting rules at (i.e., before)
     the given rule `r' (which must already exist, otherwise the call
     fails).  Note that all added rules must have the same head symbol
     on the left-hand side, which matches the head symbol on the
     left-hand side of `r'.

 -- Function: add_interface sym patterns
     Add the given patterns to the interface type `sym' (given as a
     symbol). If the interface type doesn't exist yet, it will be
     created.

 -- Function: add_interface_at sym p patterns
     Same as above, but add the given patterns at (i.e., before) the
     given pattern `p' (the given interface type must already exist and
     contain the given pattern, otherwise the call fails).

 -- Function: add_vardef rules
 -- Function: add_constdef rules
     Define variables and constants. Each rule must take the form `sym
     --> value' with a symbol on the left-hand side (no pattern
     matching is performed by these functions).

  The following functions may be used to delete individual rewriting
rules, interface type patterns or variable and constant symbols.

 -- Function: del_fundef rule
 -- Function: del_typedef rule
 -- Function: del_macdef rule
     Delete the given rewriting rule (given in the same format as
     returned by the *note get_fundef: 184, *note get_typedef: 185. and
     *note get_macdef: 186.  functions) from the running program.
     Returns `()' if successful, fails otherwise.

 -- Function: del_interface sym pattern
     Delete the given pattern from the given interface type. Returns
     `()' if successful, fails otherwise.

 -- Function: del_vardef sym
 -- Function: del_constdef sym
     Delete variables and constants, given by their (quoted) symbols.
     Returns `()' if successful, or fails if the symbol isn't defined
     (or defined as a different kind of symbol).

  The prelude also provides some functions to retrieve various
attributes of a function symbol which determine how the operation is
applied to its operands or arguments. These functions all take a single
argument, the symbol or function object to be inspected, and return an
integer value.

 -- Function: nargs x
     Get the argument count of a function object, i.e., the number of
     arguments it expects. Returns 0 for thunks and saturated
     applications, -1 for over-saturated applications and non-functions.

 -- Function: arity x
     Determine the arity of an operator symbol. The returned value is
     0, 1 or 2 for nullary, unary and binary symbols, respectively, -1
     for symbols without a fixity declaration or other kinds of objects.

 -- Function: fixity f
     Determine the fixity of an operator symbol. The fixity is encoded
     as an integer `10*n+m' where `n' is the precedence level (ranging
     from `0' to `PREC_MAX', where `PREC_MAX' denotes the precedence of
     primary expressions, 16777216 in the current implementation) and
     `m' indicates the actual fixity at each level, in the order of
     increasing precedence (0 = infix, 1 = infixl, 2 = infixr, 3 =
     prefix, 4 = postfix). The fixity value of nonfix and outfix
     symbols, as well as symbols without a fixity declaration, is
     always given as `10*PREC_MAX', and the same value is also reported
     for non-symbol objects. Infix, prefix and postfix symbols always
     have a *note fixity: 19e.  value less than `10*PREC_MAX'.
     (`PREC_MAX' isn't actually defined as a constant anywhere, but you
     can easily do that yourself by setting `PREC_MAX' to the fixity
     value of any nonfix symbol or non-symbol value, e.g.: `const
     PREC_MAX = fixity [];')

  Note that only closures (i.e., named and anonymous functions and
thunks) have a defined argument count in Pure, otherwise *note nargs:
19c. returns -1 indicating an unknown argument count. Partial
applications of closures return the number of remaining arguments,
which may be zero to indicate a *saturated* (but unevaluated)
application, or -1 for *over-saturated* and constructor applications.
(Note that in Pure a saturated application may also remain unevaluated
because there is no definition for the given combination of arguments
and thus the expression is in normal form, or because the application
was quoted. If such a normal form application is then applied to some
"extra" arguments it becomes over-saturated.)

  The value returned by *note nargs: 19c. always denotes the actual
argument count of the given function, regardless of the declared arity
if the function also happens to be an operator symbol. Often these will
coincide (as, e.g., in the case of *note +: 41. which is a binary
operator and also expects two arguments). But this is not necessarily
the case, as shown in the following example of a binary operator which
actually takes _three_ arguments:

    > infix 0 oops;
    > (oops) x y z = x*z+y;
    > arity (oops);
    2
    > nargs (oops);
    3
    > nargs (5 oops 8);
    1
    > map (5 oops 8) (1..5);
    [13,18,23,28,33]



File: purelib.info,  Node: Eval and Friends,  Next: Expression Serialization,  Prev: Inspection,  Up: Primitives

1.11.6 Eval and Friends
-----------------------

Pure provides some rather powerful operations to convert between Pure
expressions and their string representation, and to evaluate quoted
expressions (`'x'). The string conversions *note str: 17d, *note val:
5f. and *note eval: 182. also provide a convenient means to serialize
Pure expressions, e.g., when terms are to be transferred to/from
persistent storage. (Note, however, that this has its limitations.
Specifically, some objects like pointers and anonymous functions do not
have a parsable string representation. Also see the *note Expression
Serialization: 19f. section for some dedicated serialization operations
which provide a more compact binary serialization format.)

 -- Function: str x
     Yields the print representation of an expression in Pure syntax,
     as a string.

 -- Function: val s
     Parses a single simple expression, specified as a string in Pure
     syntax, and returns the result as is, without evaluating it. Note
     that this is much more limited than the *note eval: 182. operation
     below, as the expression must not contain any of the special
     constructs (conditional expressions, `when', `with', etc.), unless
     they are quoted.

 -- Function: eval x
     Parses any expression, specified as a string in Pure syntax, and
     returns its value. In fact, *note eval: 182. can also parse and
     execute arbitrary Pure code. In that case it will return the last
     computed expression, if any.  Alternatively, *note eval: 182. can
     also be invoked on a (quoted) Pure expression, which is recompiled
     and then evaluated. Exceptions during evaluation are reported back
     to the caller.

          Note: The use of *note eval: 182. and *note evalcmd: 183. (as
          well as *note add_fundef: 18c, *note add_typedef: 18d. etc.
          from the preceding subsection) to modify a running program
          breaks referential transparency and hence these functions
          should be used with care. Also, none of the inspection and
          mutation capabilities provided by these operations will work
          in batch-compiled programs, please check the _Batch
          Compilation_ section in the Pure manual for details.
          Moreover, using these operations to modify or delete a
          function which is currently being executed results in
          undefined behaviour.

 -- Function: evalcmd x
     Like *note eval: 182, but allows execution of interactive commands
     and returns their captured output as a string. No other results are
     returned, so this operation is most useful for executing Pure
     definitions and interactive commands for their side-effects. (At
     this time, only the regular output of a few commands can be
     captured, most notably `bt', `clear', `mem', `save' and `show';
     otherwise the result string will be empty.)

 -- Function: lasterr
     Reports errors in *note val: 5f, *note eval: 182. and *note
     evalcmd: 183. (as well as in *note add_fundef: 18c. et al,
     described in the previous subsection).  This string value will be
     nonempty iff a compilation or execution error was encountered
     during the most recent invocation of these functions. In that case
     each reported error message is terminated with a newline character.

 -- Function: lasterrpos
     Gives more detailed error information. This returns a list of the
     individual error messages in *note lasterr: 18b, along with the
     position of each error (if available). Each list item is either
     just a string (the error message, with any trailing newline
     stripped off) if no error position is available, or a tuple of the
     form `msg,file,l1,c1,l2,c2' where `msg' is the error message,
     `file' the name of the file containing the error (which will
     usually be `"<stdin>"' indicating that the error is in the source
     string, but may also be a proper filename of a module imported in
     the evaluated code), `l1,c1' denotes the beginning of the range
     with the errorneous construct (given as line and column indices)
     and `l2,c2' its end (or rather the character position following
     it). For convenience, both line and column indices are zero-based,
     in order to facilitate extraction of the text from the actual
     source string.

          Note: The indicated error positions are only approximate, and
          may in many cases span an entire syntactic construct (such as
          a subexpression or even an entire function definition)
          containing the error. Also, the end of the range may
          sometimes point one token past the actual end of the
          construct. (These limitations are due to technical
          restrictions in the parser; don't expect them to go away
          anytime soon.)

  Examples:

    > str (1/3);
    "0.333333333333333"
    > val "1/3";
    1/3
    > eval "1/3";
    0.333333333333333
    > eval ('(1/3));
    0.333333333333333
    > evalcmd "show evalcmd";
    "extern expr* evalcmd(expr*);\n"
    > eval "1/3)";
    eval "1/3)"
    > lasterr;
    "<stdin>, line 1: syntax error, unexpected ')', expecting '=' or '|'\n"
    > lasterrpos;
    [("<stdin>, line 1: syntax error, unexpected ')', expecting '=' or '|'",
    "<stdin>",0,3,0,4)]

In addition to *note str: 17d, the prelude also provides the following
function for pretty-printing the internal representation used to denote
quoted specials. This is commonly used in conjunction with the
`__show__' function, please see the _Macros_ section in the Pure manual
for details.

 -- Function: __str__ x
     Pretty-prints special expressions.

  Example:

    > __str__ ('__lambda__ [x __type__ int] (x+1));
    "\\x::int -> x+1"

The *note evalcmd: 183. function is commonly used to invoke the `show'
and `clear' commands for metaprogramming purposes. The prelude provides
the following two convenience functions to make this easy:

 -- Function: globsym pat level
     This uses *note evalcmd: 183. with the `show' command to list all
     defined symbols matching the given glob pattern. A definition
     level may be specified to restrict the context in which the symbol
     is defined; a level of 0 indicates that all symbols are eligible
     (see the description of the `show' command in the Pure manual for
     details). The result is the list of all matching (quoted) symbols.

 -- Function: clearsym sym level
     This uses *note evalcmd: 183. with the `clear' command to delete
     the definition of the given symbol at the given definition level.
     No glob patterns are permitted here.  The `sym' argument may
     either be a string or a literal (quoted) symbol.

  Example:

    > let x,y = 77,99;
    > let syms = globsym "[a-z]" 0; syms;
    [x,y]
    > map eval syms;
    [77,99]
    > do (flip clearsym 0) syms;
    ()
    > globsym "[a-z]" 0;
    []
    > x,y;
    x,y

The following functions are useful for doing symbolic expression
simplification.

 -- macro: reduce x
     Reevaluates an expression in a local environment. This dynamically
     rebinds function symbols in the given expression to whatever local
     function definitions are in effect at the point of the *note
     reduce: 181.  call. Note that *note reduce: 181. is actually
     implemented as a macro which expands to the *note reduce_with:
     1a5. primitive (see below), using the *note __locals__: 180.
     builtin to enumerate the bindings which are in effect at the call
     site.

 -- Function: reduce_with env x
     Like *note reduce: 181. above, but takes a list of replacements
     (given as hash pairs `u=>v') as the first argument. The *note
     reduce: 181. macro expands to `reduce_with __locals__'.

  The *note reduce: 181. macro provides a restricted form of dynamic
binding which is useful to implement local rewriting rules. It is
invoked without parameters and expands to the curried call `reduce_with
__locals__' of the *note reduce_with: 1a5. primitive, which takes one
additional argument, the expression to be rewritten. The following
example shows how to expand or factorize an expression using local
rules for the laws of distributivity:

    expand = reduce with
      (a+b)*c = a*c+b*c;
      a*(b+c) = a*b+a*c;
    end;

    factor = reduce with
      a*c+b*c = (a+b)*c;
      a*b+a*c = a*(b+c);
    end;

    expand ((a+b)*2); // yields a*2+b*2
    factor (a*2+b*2); // yields (a+b)*2

Note that instances of locally bound functions are substituted back in
the computed result, thus the instances of `*' and `+' in the results
`a*2+b*2' and `(a+b)*2' shown above denote the corresponding globals,
not the local incarnations of `*' and `+' defined in `expand' and
`factor', respectively.

  *note reduce: 181. also adjusts to quoted arguments. In this case,
the local rules are applied as usual, but back-substituted globals are
_not_ evaluated in the result:

    > expand ((a+1)*2);
    a*2+2
    > expand ('((a+1)*2));
    a*2+1*2

Note that *note reduce: 181. only takes into account local _function_
bindings from `with' clauses, local _variable_ bindings do not affect
its operation in any way:

    > let y = [x,x^2,x^3];
    > reduce y when x = u+v end;
    [x,x^2,x^3]

However, in such cases you can perform the desired substitution by
turning the `when' into a `with' clause:

    > reduce y with x = u+v end;
    [u+v,(u+v)^2,(u+v)^3]

Or you can just invoke the underlying *note reduce_with: 1a5. builtin
directly, with the desired substitutions given as hash pairs in the
first argument:

    > reduce_with [x=>u+v] y;
    [u+v,(u+v)^2,(u+v)^3]



File: purelib.info,  Node: Expression Serialization,  Next: Other Special Primitives,  Prev: Eval and Friends,  Up: Primitives

1.11.7 Expression Serialization
-------------------------------

Like *note str: 17d. and *note eval: 182, the following *note blob:
1a6. and *note val: 5f. operations can be used to safely transfer
expression data to/from persistent storage and between different
processes (using, e.g., POSIX shared memory, pipes or sockets).
However, *note blob: 1a6. and *note val: 5f. use a binary format which
is usually much more compact and gets processed much faster than the
string representations used by *note str: 17d.  and *note eval: 182.
Also, *note val: 5f. offers some additional protection against
transmission errors through a crc check. (The advantage of the string
representation, however, is that it's readable plain text in Pure
syntax.)

 -- Function: blob x
     Stores the contents of the given expression as a binary object. The
     return value is a cooked pointer which frees itself when
     garbage-collected.

 -- Function: val p
     Reconstructs a serialized expression from the result of a previous
     invocation of the *note blob: 1a6. function.

 -- Function: blobp p
     Checks for a valid *note blob: 1a6. object. (Note that *note val:
     5f. may fail even if *note blobp: 1a8. returns `true', because for
     performance reasons *note blobp: 1a8. only does a quick
     plausibility check on the header information of the blob, whereas
     *note val: 5f. also performs a crc check and verifies data
     integrity.)

 -- Function: # p
 -- Function: blob_size p
 -- Function: blob_crc p
     Determines the size (in bytes) and crc checksum of a blob,
     respectively.  *note blob_size: 1aa. always returns a bigint,
     *note blob_crc: 1ab. a machine int (use *note uint: 155. on the
     latter to get a proper unsigned 32 bit value). For convenience,
     `#p' is defined as an alias for `blob_size p' on *note blob: 1a6.
     pointers.

  Example:

    > let b = blob {"Hello, world!", 1/3, 4711, NULL};
    > b; #b; uint $ blob_crc b;
    #<pointer 0x141dca0>
    148L
    3249898239L
    > val b;
    {"Hello, world!",0.333333333333333,4711,#<pointer 0>}

Please note that the current implementation has some limitations:

   * Just as with *note str: 17d. and *note eval: 182, runtime data
     (local closures and pointers other than the *note NULL: 52.
     pointer) can't be serialized, causing *note blob: 1a6. to fail.
     However, it _is_ possible to transfer a global function, provided
     that the function exists (and is the same) in both the sending and
     the receiving process. (This condition can't be verified by *note
     val: 5f. and thus is at the programmer's responsibilty.)

   * Sharing of subexpressions will in general be preserved, but
     sharing of list and tuple _tails_ will be lost (unless the entire
     list or tuple is shared).

   * The *note val: 5f. function may fail to reconstruct the serialized
     expression even for valid blobs, if there is a conflict in symbol
     fixities between the symbol tables of the sending and the receiving
     process. To avoid this, make sure that symbol declarations in the
     sending and the receiving script match up.


File: purelib.info,  Node: Other Special Primitives,  Next: Pointer Operations,  Prev: Expression Serialization,  Up: Primitives

1.11.8 Other Special Primitives
-------------------------------

 -- Function: exit status
     Terminate the program with the given status code.

 -- Function: throw x
     Throw an exception, cf. _Exception Handling_.

 -- Function: force x
     Force a thunk (`x&'), cf. _Special Forms_. This usually happens
     automagically when the value of a thunk is needed.


File: purelib.info,  Node: Pointer Operations,  Next: Sentries,  Prev: Other Special Primitives,  Up: Primitives

1.11.9 Pointer Operations
-------------------------

The prelude provides a few basic operations on pointers which make it
easy to interface to external C functions. For more advanced uses, the
library also includes the *note pointers: 1b1. module which can be
imported explicitly if needed, see *note Pointer Arithmetic: 12e. below.

 -- Function: addr symbol
     Get the address of a C symbol (given as a string) at runtime. The
     library containing the symbol must already be loaded. Note that
     this can in fact be any kind of externally visible C symbol, so
     it's also possible to get the addresses of global variables. The
     result is returned as a pointer. The function fails if the symbol
     was not found.

 -- Function: calloc nmembers size
 -- Function: malloc size
 -- Function: realloc ptr size
 -- Function: free ptr
     Interface to `malloc', `free' and friends. These let you allocate
     dynamic buffers (represented as Pure pointer values) for various
     purposes.

  The following functions perform direct memory accesses through
pointers.  Their primary use is to interface to certain C library
functions which take or return data through pointers. It goes without
saying that these operations should be used with utmost care. No
checking is done on the pointer types, so it is the programmer's
responsibility to ensure that the pointers actually refer to the
corresponding type of data.

 -- Function: get_byte ptr
 -- Function: get_short ptr
 -- Function: get_int ptr
 -- Function: get_int64 ptr
 -- Function: get_long ptr
 -- Function: get_float ptr
 -- Function: get_double ptr
 -- Function: get_string ptr
 -- Function: get_pointer ptr
     Return the integer, floating point, string or generic pointer
     value at the memory location indicated by `ptr'.

 -- Function: put_byte ptr x
 -- Function: put_short ptr x
 -- Function: put_int ptr x
 -- Function: put_int64 ptr x
 -- Function: put_long ptr x
 -- Function: put_float ptr x
 -- Function: put_double ptr x
 -- Function: put_string ptr x
 -- Function: put_pointer ptr x
     Change the integer, floating point, string or generic pointer
     value at the memory location indicated by `ptr' to the given value
     `x'.


File: purelib.info,  Node: Sentries,  Next: Tagged Pointers,  Prev: Pointer Operations,  Up: Primitives

1.11.10 Sentries
----------------

Sentries are Pure's flavour of object *finalizers*. A sentry is simply
an object (usually a function) which gets applied to the target
expression when it is garbage-collected. This is useful to perform
automatic cleanup actions on objects with internal state, such as
files. Pure's sentries are _much_ more useful than finalizers in other
garbage-collected languages, since it is guaranteed that they are
called as soon as an object "goes out of scope", i.e., becomes
inaccessible.

 -- Function: sentry f x
     Places a sentry `f' at an expression `x' and returns the modified
     expression.

 -- Function: clear_sentry x
     Removes the sentry from an expression `x'.

 -- Function: get_sentry x
     Returns the sentry of an expression `x' (if any, fails otherwise).

  As of Pure 0.45, sentries can be placed on any Pure expression. The
sentry itself can also be any type of object (but usually it's a
function).  Example:

    > using system;
    > sentry (\_->puts "I'm done for!") (1..3);
    [1,2,3]
    > clear ans
    I'm done for!

Note that setting a finalizer on a global symbol won't usually be of
much use since such values are cached by the interpreter. (However, the
sentry _will_ be invoked if the symbol gets recompiled because its
definition has changed. This may be useful for some purposes.)

  In Pure parlance, we call an expression *cooked* if a sentry has been
attached to it. The following predicate can be used to check for this
condition. Also, there is a convenience function to create cooked
pointers which take care of freeing themselves when they are no longer
needed.

 -- Function: cookedp x
     Check whether a given object has a sentry set on it.

 -- Function: cooked ptr
     Create a pointer which disposes itself after use. This is just a
     shorthand for `sentry free'. The given pointer `ptr' must be *note
     malloc: 1b4.ed to make this work.

  Example:

    > using system;
    > let p = cooked (malloc 1024);
    > cookedp p;
    1
    > get_sentry p;
    free
    > clear p

Besides their use as finalizers, sentries can also be handy in other
circumstances, when you need to associate an expression with another,
"invisible" value. In this case the sentry is usually some kind of data
structure instead of a function to be executed at finalization time. For
instance, here's how we can employ sentries to implement hashing of
function values:

    using dict;
    hashed f x = case get_sentry f of
                   h::hdict = h!x if member h x;
                   _ = y when y = f x; sentry (update h x y) f
                           when h = case get_sentry f of
                                      h::hdict = h; _ = emptyhdict
                                    end;
                           end;
                         end;
                 end;

E.g., consider the naive recursive definition of the Fibonacci function:

    fib n::int = if n<=1 then 1 else fib (n-1)+fib (n-2);

A hashed version of the Fibonacci function can be defined as follows:

    let hfib = hashed f with
      f n::int = if n<=1 then 1 else hfib (n-1)+hfib (n-2)
    end;

This turns the naive definition of the Fibonacci function (which has
exponential time complexity) into a linear time operation:

    > stats
    > fib 35;
    14930352
    4.53s
    > hfib 35;
    14930352
    0.25s

Finally, note that there can be only one sentry per expression but,
building on the operations provided here, it's easy to design a scheme
where sentries are chained. For instance:

    chain_sentry f x = sentry (h (get_sentry x)) x with
      h g x = g x $$ f x;
    end;

This invokes the original sentry before the chained one:

    > using system;
    > f _ = puts "sentry#1"; g _ = puts "sentry#2";
    > let p = chain_sentry g $ sentry f $ malloc 10;
    > clear p
    sentry#1
    sentry#2

You can chain any number of sentries that way. This scheme should work
in most cases in which sentries are used just as finalizers. However,
there are other uses, like the "hashed function" example above, where
you'd like the original sentry to stay intact. This can be achieved by
placing the new sentry as a sentry on the _original sentry_ rather than
the expression itself:

    attach_sentry f x = sentry (sentry f (get_sentry x)) x;

This requires that the sentry will actually be garbage-collected when
its hosting expression gets freed, so it will _not_ work if the
original sentry is a global:

    > let p = attach_sentry g $ sentry f $ malloc 10;
    > clear p
    sentry#1

However, the attached sentry will work ok if you can ensure that the
original sentry is a (partial or constructor) application. E.g.:

    > let p = attach_sentry g $ sentry (f$) $ malloc 10;
    > clear p
    sentry#1
    sentry#2



File: purelib.info,  Node: Tagged Pointers,  Next: Expression References,  Prev: Sentries,  Up: Primitives

1.11.11 Tagged Pointers
-----------------------

As of Pure 0.45, the C interface now fully checks pointer parameter
types at runtime (see the _C Types_ section in the Pure Manual for
details).  To these ends, pointer values are internally tagged to keep
track of the pointer types. The operations described in this section
give you access to these tags in Pure programs. At the lowest level, a
pointer tag is simply a machine int associated with a pointer value.
The default tag is 0, which denotes a generic pointer value, i.e.,
`void*' in C. The following operations are provided to create such
tags, and set, get or verify the tag of a pointer value.

 -- Function: ptrtag t x
     Places an integer tag `t' at an expression `x' and returns the
     modified expression. `x' must be a pointer value.

 -- Function: get_ptrtag x
     Retrieves the tag associated with `x'.

 -- Function: check_ptrtag t x
     Compares the tag associated with `x' against `t' and returns true
     iff the tags match. If `x' is a pointer value, this is equivalent
     to `get_ptrtag x==t || null x && get_ptrtag x==0'.

 -- Function: make_ptrtag
     Returns a new, unique tag each time it is invoked.

  Examples:

    > let p = malloc 10;
    > get_ptrtag p; // zero by default
    0
    > let t = make_ptrtag; t;
    12
    > ptrtag t p;
    #<pointer 0xc42da0>
    > get_ptrtag p;
    12
    > check_ptrtag t p;
    1
    > check_ptrtag 0 p;
    0

Note that in the case of a non-*note NULL: 52. pointer, *note
check_ptrtag: 1d3.  just tests the tags for equality. On the other
hand, a generic *note NULL: 52. pointer, like in C, is considered
compatible with all pointer types:

    > let t1 = make_ptrtag; t1;
    13
    > check_ptrtag t1 p;
    0
    > check_ptrtag t1 NULL;
    1
    > get_ptrtag NULL;
    0

The operations above are provided so that you can design your own, more
elaborate type systems for pointer values if the need arises. However,
you'll rarely have to deal with pointer tags at this level yourself. For
most applications, it's enough to inspect the type of a Pure pointer and
maybe modify it by "casting" it to a new target type. The following
high-level operations provide these capabilities.

 -- Function: pointer_tag ty
 -- Function: pointer_tag x
     Returns the pointer tag for the given type `ty', denoted as a
     string, or the given pointer value `x'. In the former case, the
     type should be specified in the C-like syntax used in `extern'
     declarations; a new tag will be created using *note make_ptrtag:
     1d4. if needed. In the latter case, *note pointer_tag: 1d5. simply
     acts as a frontend for *note get_ptrtag: 1d2. above.

 -- Function: pointer_type tag
 -- Function: pointer_type x
     Returns the type name associated with the given int value `tag' or
     pointer value `x'. Please note that this may be *note NULL: 52. in
     the case of an "anonymous" tag, which may have been created with
     *note make_ptrtag: 1d4. above, or if the tag is simply unknown
     because it hasn't been created yet.

 -- Function: pointer_cast tag x
 -- Function: pointer_cast ty x
     Casts `x' (which must be a pointer value) to the given pointer
     type, which may be specified either as a tag or a string denoting
     the type name. This returns a new pointer value with the
     appropriate type tag on it (the tag on the original pointer value
     `x' isn't affected by this operation).

  Example:

    > let p = malloc 10;
    > let q = pointer_cast "char*" p;
    > map pointer_type [p,q];
    ["void*","char*"]
    > map pointer_tag [p,q];
    [0,1]
    > map pointer_type (0..make_ptrtag-1);
    ["void*","char*","void**","char**","short*","short**","int*","int**",
    "float*","float**","double*","double**"]

(The last command shows a quick and dirty way to retrieve the currently
defined type tags in the interpreter. This won't work in batch-compiled
scripts, however, since in this case the range of type tags is in
general non-contiguous.)

  If you have to do many casts to a given type, you can avoid the
overhead of repeatedly looking up the type name by assigning the tag to
a variable, which can then be passed to *note pointer_cast: 1d7.
instead:

    > let ty = pointer_tag "long*";
    > pointer_cast ty p, pointer_cast ty q;

Note that you have to be careful when casting a cooked pointer, because
*note pointer_cast: 1d7. may have to create a copy of the original
pointer value in order not to clobber the original type tag. The sentry
will then still be with the original cooked pointer value, thus you
have to ensure that this value survives its type-cast duplicate. It's
usually best to apply the cast right at the spot where the pointer gets
passed to an external function, e.g.:

    > extern char *gets(char*);
    > let p = cooked $ malloc 1000;
    > gets (pointer_cast "char*" p);

Such usage is always safe. If this approach isn't possible, you might
want to use the lowlevel *note ptrtag: 1d1. operation instead. (This
will clobber the type tag of the pointer, but you can always change it
back afterwards.)


File: purelib.info,  Node: Expression References,  Next: Pointer Arithmetic,  Prev: Tagged Pointers,  Up: Primitives

1.11.12 Expression References
-----------------------------

Expression references provide a kind of mutable data cells which can
hold any Pure expression. If you need these, then you're doomed. ;-)
However, they can be useful as a last resort when you need to keep
track of some local state or interface to the messy imperative world.
Pure's references are actually implemented as expression pointers so
that you can readily pass them as pointers to a C function which
expects a `pure_expr**' parameter. This may even be useful at times.

 -- Function: ref x
     Create a reference pointing to `x' initially.

 -- Function: put r x
     Set a new value `x', and return that value.

 -- Function: get r
     Retrieve the current value `r' points to.

 -- Function: unref r
     Purge the referenced object and turn the reference into a dangling
     pointer. (This is used as a sentry on reference objects and
     shouldn't normally be called directly.)

 -- Function: refp x
     Predicate to check for reference values.

  Note that manually removing the *note unref: 1dc. sentry of a
reference turns the reference into just a normal pointer object and
renders it unusable as a reference. Doing this will also leak memory,
so don't!


File: purelib.info,  Node: Pointer Arithmetic,  Prev: Expression References,  Up: Primitives

1.11.13 Pointer Arithmetic
--------------------------

The pointers.pure module provides the usual C-style pointer arithmetic
and comparisons of pointer values. This module normally is not included
in the prelude, so to use these operations, you have to add the
following import declaration to your program:

    using pointers;

The module overloads the comparison and some of the arithmetic operators
(cf. *note Arithmetic: 12c.) so that they can be used to compare
pointers and to perform C-style pointer arithmetic. To these ends, some
conversions between pointers and numeric types are also provided.

 -- Function: int p
 -- Function: bigint p
     Convert a pointer to an int or bigint, giving its numeric address
     value, which usually denotes a byte offset relative to the
     beginning of the memory of the executing process. This value can
     then be used in arithmetic operations and converted back to a
     pointer using the *note pointer: 152. function from the prelude.
     (Note that to make this work on 64 bit systems, you'll have to
     convert the pointer values to bigints.)

 -- Function: p + n
 -- Function: p - n
 -- Function: p - q
     Pointer arithmetic. `p+n' and `p-n' offsets a pointer `p' by the
     given integer `n' denoting the amount of bytes. In addition, `p-q'
     returns the byte offset between two pointers `p' and `q'. Note
     that, in contrast to C pointer arithmetic which also takes into
     account the base type of the pointer, the Pure operations always
     use byte offsets, no matter what type of pointer (as given by the
     pointer tag) is passed to these operations.

 -- Function: p == q
 -- Function: p ~= q
     Pointer equality and inequality. This is exactly the same as
     syntactic equality on pointers.

 -- Function: p <= q
 -- Function: p >= q
 -- Function: p > q
 -- Function: p < q
     Pointer comparisons. One pointer `p' is considered to be "less"
     than another pointer `q' if it represents a "lower" address in
     memory, i.e., if the byte offset `p-q' is negative.


File: purelib.info,  Node: Mathematical Functions,  Next: Container Types,  Prev: Prelude,  Up: Top

2 Mathematical Functions
************************

The math.pure module provides Pure's basic math routines. It also
defines complex and rational numbers.

* Menu:

* Imports::
* Basic Math Functions::
* Complex Numbers::
* Rational Numbers::
* Semantic Number Predicates and Types::


File: purelib.info,  Node: Imports,  Next: Basic Math Functions,  Up: Mathematical Functions

2.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using math;



File: purelib.info,  Node: Basic Math Functions,  Next: Complex Numbers,  Prev: Imports,  Up: Mathematical Functions

2.2 Basic Math Functions
========================

The module defines the following real-valued constants:

 -- constant: e = 2.71828...
     Euler's number.

 -- constant: pi = 3.1415...
     Ludolph's number.

  It also provides a reasonably comprehensive (pseudo) random number
generator which uses the Mersenne twister
(http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html) to avoid bad
generators present in some C libraries.

  Please note that as of Pure 0.41, the runtime library includes a newer
release of the Mersenne twister which fixes issues with some kinds of
seed values, and will yield different values for given seeds. Also, the
*note random31: 1ed. and *note random53: 1ee. functions have been added
as a convenience to compute unsigned 31 bit integers and 53 bit double
values, and the *note srandom: 1ef. function now also accepts an int
matrix as seed value.

 -- Function: random
     Return 32 bit pseudo random ints in the range
     `-0x80000000..0x7fffffff'.

 -- Function: random31
     Return 31 bit pseudo random ints in the range `0..0x7fffffff'.

 -- Function: random53
     Return pseudo random doubles in the range `[0,1)' with 53 bits
     resolution.

 -- Function: srandom seed
     Sets the seed of the generator to the given 32 bit integer. You
     can also specify longer seeds using a nonempty row vector, e.g.:
     `srandom {0x123, 0x234, 0x345, 0x456}'.

  The following functions work with both double and int/bigint
arguments. The result is always a double. For further explanations
please see the descriptions of the corresponding functions from the C
math library.

 -- Function: sqrt x
     The square root function.

 -- Function: exp x
 -- Function: ln x
 -- Function: log x
     Exponential function, natural and decadic logarithms.

 -- Function: sin x
 -- Function: cos x
 -- Function: tan x
     Trigonometric functions.

 -- Function: asin x
 -- Function: acos x
 -- Function: atan x
     Inverse trigonometric functions.

 -- Function: atan2 y x
     Computes the arcus tangent of `y/x', using the signs of the two
     arguments to determine the quadrant of the result.

 -- Function: sinh x
 -- Function: cosh x
 -- Function: tanh x
     Hyperbolic trigonometric functions.

 -- Function: asinh x
 -- Function: acosh x
 -- Function: atanh x
     Inverse hyperbolic trigonometric functions.


File: purelib.info,  Node: Complex Numbers,  Next: Rational Numbers,  Prev: Basic Math Functions,  Up: Mathematical Functions

2.3 Complex Numbers
===================

 -- Function: x +: y
 -- Function: r <: t
     Complex number constructors.

 -- constant: i = 0+:1
     Imaginary unit.

  We provide both rectangular (`x+:y') and polar (`r<:a')
representations, where `(x,y)' are the Cartesian coordinates and
`(r,t)' the radius (absolute value) and angle (in radians) of a complex
number, respectively. The *note +: 41. and *note <: 13b. constructors
(declared in the prelude) bind weaker than all other arithmetic
operators and are non-associative.

  The polar representation `r<:t' is normalized so that `r' is always
nonnegative and `t' falls in the range `-pi<t<=pi'.

  The constant *note i: 204. is provided to denote the imaginary unit
`0+:1'.

  The arithmetic operations *note +: 41, *note *: 131. etc. and the
equality relations *note ==: 46. and *note ~=: 137. work as expected,
and the square root, exponential, logarithms, trigonometric and
hyperbolic trigonometric functions (see *note Basic Math Functions:
1ea.) are extended to complex numbers accordingly. These do _not_ rely
on complex number support in the C library, but should still conform to
IEEE 754 and POSIX, provided that the C library provides a
standards-compliant implementation of the basic math functions.

  The following operations all work with both the rectangular and the
polar representation, promoting real (double, int/bigint) inputs to
complex where appropriate. When the result of an operation is again a
complex number, it generally uses the same representation as the input
(except for explicit conversions). Mixed rect/polar and polar/rect
arithmetic always returns a rect result, and mixed complex/real and
real/complex arithmetic yields a rect or polar result, depending on
what the complex input was.

 -- Function: complex x
     Convert any kind of number to a complex value.

 -- Function: polar z
 -- Function: rect z
     Convert between polar and rectangular representations.

 -- Function: cis t
     Create complex values on the unit circle. Note: To quickly compute
     `exp (x+:y)' in polar form, use `exp x <: y'.

 -- Function: abs z
 -- Function: arg z
     Modulus (absolute value) and argument (angle, a.k.a. phase). Note
     that you can also find both of these in one go by converting to
     polar form.

 -- Function: re z
 -- Function: im z
     Real and imaginary part.

 -- Function: conj z
     Complex conjugate.

  Examples:

    > using math;
    > let z = 2^(1/i); z;
    0.769238901363972+:-0.638961276313635
    > let z = ln z/ln 2; z;
    0.0+:-1.0
    > abs z, arg z;
    1.0,-1.5707963267949
    > polar z;
    1.0<:-1.5707963267949

Please note that, as the *note +: 41. and *note <: 13b. constructors
bind weaker than the other arithmetic operators, complex numbers _must_
be parenthesized accordingly, e.g.:

    > (1+:2)*(3+:4);
    -5+:10



File: purelib.info,  Node: Rational Numbers,  Next: Semantic Number Predicates and Types,  Prev: Complex Numbers,  Up: Mathematical Functions

2.4 Rational Numbers
====================

 -- Function: x % y
     Exact division operator and rational number constructor.

  Pure's rational numbers are constructed with the *exact division*
operator *note %: 20e. (declared in the prelude) which has the same
precedence and fixity as the other division operators.

  The *note %: 20e. operator returns a rational or complex rational for
any combination of integer, rational and complex integer/rational
arguments, provided that the denominator is nonzero (otherwise it
behaves like `x div 0', which will raise an exception). Machine int
operands are always promoted to bigints, thus normalized rationals
always take the form `x%y' where both the numerator `x' and the
denominator `y' are bigints. For other numeric operands *note %: 20e.
works just like *note /: 132. Rational results are normalized so that
the sign is always in the numerator and numerator and denominator are
relatively prime. In particular, a rational zero is always represented
as `0L%1L'.

  The usual arithmetic operations and equality/order relations are
extended accordingly, as well as the *note basic math functions: 1ea.
and the *note rounding functions: 158, and will return exact (rational
or complex rational) results where appropriate. Rational operations are
implemented using the GMP bigint functions where possible, and thus are
reasonably fast.

  In addition, the module also provides following operations:

 -- Function: rational x
     Converts a real or complex value `x' to a rational or complex
     rational. Note that the conversion from double values doesn't do
     any rounding, so it is guaranteed that converting the resulting
     rational back to a double reconstructs the original value.

     Conversely, the *note int: 14f, *note bigint: 150, *note double:
     151, *note complex: 205, *note rect: 207, *note polar: 206. and
     *note cis: 208. conversion functions are overloaded so that they
     convert a rational to one of the other number types.

 -- Function: num x
 -- Function: den x
     Numerator and denominator of a rational `x'.

  Examples:

    > using math;
    > 5%7 + 2%3;
    29L%21L
    > 3%8 - 1%3;
    1L%24L
    > pow (11%10) 3;
    1331L%1000L
    > let x = pow 3 (-3); x;
    1L%27L
    > num x, den x;
    1L,27L
    > rational (3/4);
    3L%4L

Note that doubles can't represent most rationals exactly, so conversion
from double to rational _will_ yield funny results in many cases (which
are still accurate up to rounding errors). For instance:

    > let x = rational (1/17); x;
    4238682002231055L%72057594037927936L
    > num x/den x;
    0.0588235294117647
    > double (1%17);
    0.0588235294117647



File: purelib.info,  Node: Semantic Number Predicates and Types,  Prev: Rational Numbers,  Up: Mathematical Functions

2.5 Semantic Number Predicates and Types
========================================

In difference to the syntactic predicates in *note Primitives: 125,
these check whether the given value can be represented as an object of
the given target type (up to rounding errors). Note that if `x' is of
syntactic type `X', then it is also of semantic type `X'. Moreover,
`intvalp x => bigintvalp x => ratvalp x => realvalp x => compvalp x <=>
numberp x'.

 -- Function: compvalp x
     Check for complex values (this is the same as *note numberp: 168.).

 -- Function: realvalp x
     Check for real values (`im x==0').

 -- Function: ratvalp x
     Check for rational values (same as *note realvalp: 213, except
     that IEEE 754 infinities and NaNs are excluded).

 -- Function: bigintvalp x
     Check for "big" integer values which can be represented as a
     bigint.

 -- Function: intvalp x
     Check for "small" integer values which can be represented as a
     machine int.

 -- type: compval
 -- type: realval
 -- type: ratval
 -- type: bigintval
 -- type: intval
     Convenience types for the above predicates. These can be used as
     type tags on the left-hand side of an equation to match numeric
     values for which the corresponding predicate yields *note true: 6.


File: purelib.info,  Node: Container Types,  Next: System Interface,  Prev: Mathematical Functions,  Up: Top

3 Container Types
*****************

The standard library provides a variety of efficient container data
structures for different purposes. These are all purely functional,
i.e., immutable data structures implemented using different flavours of
binary trees. This means that instead of modifying a data structure
in-place, operations like insertion and deletion return a new instance
of the container, keeping the previous instance intact. Nevertheless,
all operations are performed efficiently, in logarithmic time where
possible.

  The container types are all implemented as abstract data structures,
so client modules shouldn't rely on the internal representation. Each
type provides a corresponding type tag (cf. _Type Tags_ in the Pure
Manual), as given in the description of each type, which can be used to
match values of the type, e.g.:

    shift a::array = rmfirst a;

All container types implement the equality predicates *note ==: 46. and
*note ~=: 137. by recursively comparing their members. In addition, the
dictionary, set and bag data structures also provide the other
comparison predicates (*note <: 13b, *note <=: 138. etc.) which check
whether one dictionary, set or bag is contained in another.

* Menu:

* Arrays::
* Heaps::
* Dictionaries::
* Sets and Bags::


File: purelib.info,  Node: Arrays,  Next: Heaps,  Up: Container Types

3.1 Arrays
==========

The array.pure module implements an efficient functional array data
structure which allows to access and update individual array members, as
well as to add and remove elements at the beginning and end of an
array. All these operations are carried out in logarithmic time.

 -- type: array
     The array data type.

* Menu:

* Imports: Imports<2>.
* Operations::
* Examples::


File: purelib.info,  Node: Imports<2>,  Next: Operations,  Up: Arrays

3.1.1 Imports
-------------

To use the operations of this module, add the following import
declaration to your program:

    using array;



File: purelib.info,  Node: Operations,  Next: Examples,  Prev: Imports<2>,  Up: Arrays

3.1.2 Operations
----------------

 -- Function: emptyarray
     return the empty array

 -- Function: array xs
     create an array from a list `xs'

 -- Function: array2 xs
     create a two-dimensional array from a list of lists

 -- Function: mkarray x n
     create an array consisting of `n' `x''s

 -- Function: mkarray2 x (n,m)
     create a two-dimensional array of `n*m' `x''s

 -- Function: arrayp x
     check whether `x' is an array

 -- Function: # a
     size of `a'

 -- Function: a ! i
     return the `i'th member of `a'

 -- Function: a ! (i,j)
     two-dimensional subscript

 -- Function: null a
     test whether `a' is the empty array

 -- Function: members a
 -- Function: list a
     list of values stored in `a'

 -- Function: members2 a
 -- Function: list2 a
     list of members in a two-dimensional array

 -- Function: first a
 -- Function: last a
     first and last member of `a'

 -- Function: rmfirst a
 -- Function: rmlast a
     remove first and last member from `a'

 -- Function: insert a x
     insert `x' at the beginning of `a'

 -- Function: append a x
     append `x' to the end of `a'

 -- Function: update a i x
     replace the `i'th member of `a' by `x'

 -- Function: update2 a (i,j) x
     update two-dimensional array


File: purelib.info,  Node: Examples,  Prev: Operations,  Up: Arrays

3.1.3 Examples
--------------

Import the module:

    > using array;

A one-dimensional array:

    > let a::array = array (0.0:0.1..1.0);
    > #a; members a;
    11
    [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]

Indexing an array works in the usual way, using Pure's *note !: 4c.
operator. By virtue of the prelude, slicing an array with *note !!: 4f.
also works as expected:

    > a!5;
    0.5
    > a!!(3..7);
    [0.3,0.4,0.5,0.6,0.7]

Updating a member of an array produces a new array:

    > let b::array = update a 1 2.0;
    > members b;
    [0.0,2.0,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]

Two-dimensional arrays can be created with *note array2: 223. from a
list of lists:

    > let a2::array = array2 [[i,x | x = [u,v,w]] | i = 1..2];
    > members2 a2;
    [[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]
    > a2!(1,2);
    2,w
    > a2!![(0,1),(1,2)];
    [(1,v),(2,w)]
    > a2!!(0..1,1..2);
    [[(1,v),(1,w)],[(2,v),(2,w)]]

Here's how to convert an array to a Pure matrix:

    > matrix $ members a;
    {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0}
    > matrix $ members2 a2;
    {(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)}

Converting back from a matrix to an array:

    > let b2::array = array2 $ list2 {(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)};
    > members2 b2;
    [[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]



File: purelib.info,  Node: Heaps,  Next: Dictionaries,  Prev: Arrays,  Up: Container Types

3.2 Heaps
=========

Heaps are a kind of priority queue data structure which allows quick
(constant time) access to the smallest member, and to remove the
smallest member and insert new elements in logarithmic time. Our
implementation does not allow quick update of arbitrary heap members;
if such functionality is required, bags can be used instead (see *note
Sets and Bags: 239.).

  Heap members _must_ be ordered by the *note <=: 138. predicate.
Multiple instances of the same element may be stored in a heap;
however, the order in which equal elements are retrieved is not
specified.

 -- type: heap
     The heap data type.

* Menu:

* Imports: Imports<3>.
* Operations: Operations<2>.
* Examples: Examples<2>.


File: purelib.info,  Node: Imports<3>,  Next: Operations<2>,  Up: Heaps

3.2.1 Imports
-------------

To use the operations of this module, add the following import
declaration to your program:

    using heap;



File: purelib.info,  Node: Operations<2>,  Next: Examples<2>,  Prev: Imports<3>,  Up: Heaps

3.2.2 Operations
----------------

 -- Function: emptyheap
     return the empty heap

 -- Function: heap xs
     create a heap from a list `xs'

 -- Function: heapp x
     check whether `x' is a heap

 -- Function: # h
     size of a heap

 -- Function: null h
     test whether `h' is the empty heap

 -- Function: members h
 -- Function: list h
     list the members of `h' in ascending order

 -- Function: first h
     the first (i.e., smallest) member of `h'

 -- Function: rmfirst h
     remove the first (i.e., smallest) member from `h'

 -- Function: insert h x
     insert `x' into `h'


File: purelib.info,  Node: Examples<2>,  Prev: Operations<2>,  Up: Heaps

3.2.3 Examples
--------------

    > let h::heap = heap [5,1,3,11,3];
    > members h;
    [1,3,3,5,11]
    > first h;
    1
    > members $ rmfirst h;
    [3,3,5,11]



File: purelib.info,  Node: Dictionaries,  Next: Sets and Bags,  Prev: Heaps,  Up: Container Types

3.3 Dictionaries
================

The dict.pure module provides Pure's dictionary data types based on AVL
trees. There are actually four different types to choose from,
depending on whether you need ordered or hashed dictionaries and
whether multiple values for the same key should be allowed or not.

 -- type: dict
     An ordered dictionary. This assumes an ordered key type, i.e., the
     predicate *note <: 13b. must be defined on the keys.

 -- type: hdict
     A hashed dictionary which works with any (mixture of) key types but
     stores members in an apparently random order.

 -- type: mdict
     An ordered dictionary, like *note dict: 248, which allows multiple
     values to be associated with the same key.

 -- type: hmdict
     A multi-valued dictionary, like *note mdict: 24a, but uses hashed
     keys like *note hdict: 249.

 -- type: xdict
     This is just an abstract supertype for matching any kind of
     dictionary provided by this module.

  *note mdict: 24a. and *note hmdict: 24b. are also colloquially
referred to as (ordered or hashed) _multidicts_. This implementation
guarantees that different members for the same key are always kept in
the order in which they were inserted, and this is also the order in
which they will be retrieved by the *note members: 24d, *note keys:
24e, *note vals: 24f.  and indexing operations.

  The usual comparison predicates (*note ==: 46, *note ~=: 137, *note
<=: 138, *note <: 13b. etc.) are defined on all dictionary types, where
two dictionaries are considered "equal" (`d1==d2') if they both contain
the same `key=>value' pairs, and `d1<=d2' means that `d1' is a
sub-dictionary of `d2', i.e., all `key=>value' pairs of `d1' are also
contained in `d2' (taking into account multiplicities in the multidict
case). Ordered dictionaries compare keys using equality (assuming two
keys `a' and `b' to be equal if neither `a<b' nor `b<a' holds), while
hashed dictionaries check for syntactical equality (using *note ===:
11d.). The associated values are compared using the *note ==: 46.
predicate if it is defined, falling back to syntactic equality
otherwise.

  The underlying AVL tree data structure can be found in the
avltrees.pure module which is included in the library, but not to be
invoked directly.

  The AVL tree algorithm has its origin in the SWI-Prolog
implementation of association lists. The original implementation was
created by R. A. O'Keefe and updated for SWI-Prolog by Jan Wielemaker.
For the original source see <http://www.swi-prolog.org>.

  The port from SWI-Prolog and the deletion stuff (*note rmfirst: 250,
*note rmlast: 251, *note delete: 252.) missing in the Prolog
implementation was provided by Jiri Spitz. The generalization of the
code to arbitrary combinations of ordered/hashed and
single-/multi-valued keys was done by Albert Graef.

* Menu:

* Imports: Imports<4>.
* Operations: Operations<3>.
* Examples: Examples<3>.


File: purelib.info,  Node: Imports<4>,  Next: Operations<3>,  Up: Dictionaries

3.3.1 Imports
-------------

To use the operations of this module, add the following import
declaration to your program:

    using dict;



File: purelib.info,  Node: Operations<3>,  Next: Examples<3>,  Prev: Imports<4>,  Up: Dictionaries

3.3.2 Operations
----------------

 -- Function: emptydict
 -- Function: emptyhdict
 -- Function: emptymdict
 -- Function: emptyhmdict
     return an empty dictionary

 -- Function: dict xs
 -- Function: hdict xs
 -- Function: mdict xs
 -- Function: hmdict xs
     create a dictionary of the corresponding type either from a list
     `xs' of key-value pairs in the form `key=>value', or from another
     dictionary; in the latter case the argument is converted to a
     dictionary of the desired target type

 -- Function: dictp d
 -- Function: hdictp d
 -- Function: mdictp d
 -- Function: hmdictp d
     check whether `x' is a dictionary of the corresponding type

 -- Function: mkdict y xs
 -- Function: mkhdict y xs
 -- Function: mkmdict y xs
 -- Function: mkhmdict y xs
     create a dictionary from a list of keys and a constant value

 -- Function: d1 + d2
     sum: `d1+d2' adds the members of `d2' to `d1'

 -- Function: d1 - d2
     difference: `d1-d2' removes the members of `d2' from `d1'

 -- Function: d1 * d2
     intersection: `d1*d2' removes the members _not_ in `d2' from `d1'

 -- Function: # d
     size of a dictionary (the number of members it contains)

 -- Function: d ! x
     get the value from `d' by key `x'; in the case of a multidict this
     actually returns a list of values (which may be empty if `d'
     doesn't contain `x')

 -- Function: null d
     test whether `d' is an empty dictionary

 -- Function: member d x
     test whether `d' contains a member with key `x'

 -- Function: members d
 -- Function: list d
     list the members of `d' (in ascending order for ordered
     dictionaries)

 -- Function: keys d
     list the keys of `d' (in ascending order for ordered dictionaries)

 -- Function: vals d
     list the values of `d'

 -- Function: first d
 -- Function: last d
     return the first and the last member of `d', respectively

 -- Function: rmfirst d
 -- Function: rmlast d
     remove the first and the last member from `d', respectively

 -- Function: insert d (x=>y)
 -- Function: update d x y
     insert `x=>y' into `d' (this always adds a new member in a
     multidict, otherwise it replaces an existing value if there is
     one); note that *note update: 270. is just a fully curried version
     of *note insert: 26f, so `update d x y' behaves exactly like
     `insert d (x=>y)'

 -- Function: delete d x
     remove `x' from `d' if present (in the multidict case, only the
     first member with the given key `x' is removed)

 -- Function: delete_val d (x=>y)
     remove a specific key-value pair `x=>y' from `d' if present (in the
     multidict case, only the first instance of `x=>y' is removed);
     please also see the notes below regarding this operation

 -- Function: delete_all d x
     remove all instances of `x' from `d' (in the non-multidict case,
     this is just the same as *note delete: 252.)

     Note:
        * The infix operators *note +: 265, *note -: 266. and *note *:
          267.  work like the corresponding set and bag operations (see
          *note Sets and Bags: 239.), treating dictionaries as
          collections of `key=>val' pairs. You can mix arbitrary
          operand types with these operations, as well as with the
          comparison operations; the necessary conversions from less
          general dictionary types (ordered, single-valued) to more
          general types (hashed, multi-valued) are handled
          automatically.

        * The *note delete_val: 271. function compares values using
          equality (*note ==: 46.) if it is defined, falling back to
          syntactic equality (*note ===: 11d.) otherwise. If there is
          more than one instance of the given value under the given
          key, the first such instance will be removed (which, if *note
          ==: 46. is defined on the values, may be any instance that
          compares equal, not necessarily an exact match).

        * In the multidict case, *note delete_val: 271. may require
          linear time with respect to the number of different values
          stored under the given key. Since this operation is also
          needed to implement some other multidict operations like
          comparisons, difference and intersection, these may end up
          requiring quadratic running times in degenerate cases (i.e.,
          if the majority of members happens to be associated with only
          very few keys).


File: purelib.info,  Node: Examples<3>,  Prev: Operations<3>,  Up: Dictionaries

3.3.3 Examples
--------------

A normal (ordered) dictionary:

    > using dict;
    > let d::dict = dict ["foo"=>77,"bar"=>99.1];
    > keys d; vals d; members d;
    ["bar","foo"]
    [99.1,77]
    ["bar"=>99.1,"foo"=>77]

Indexing a dictionary works in the usual way, using Pure's *note !: 4c.
operator. An *note out_of_bounds: 10. exception is thrown if the key is
not in the dictionary:

    > d!"foo";
    77
    > d!"baz";
    <stdin>, line 5: unhandled exception 'out_of_bounds' while evaluating
    'd!"baz"'

By virtue of the prelude, slicing a dictionary with *note !!: 4f. also
works as expected:

    > d!!["foo","bar","baz"];
    [77,99.1]

A hashed dictionary can be used with any key values, which are stored
in a seemingly random order:

    > let h::hdict = hdict [foo=>77,42=>99.1];
    > keys h; vals h; members h;
    [42,foo]
    [99.1,77]
    [42=>99.1,foo=>77]
    > h!foo;
    77
    > h!!keys h;
    [99.1,77]

Multidicts work in pretty much the same fashion, but allow more than one
value for a given key to be stored in the dictionary. In this case, the
indexing operation returns a list of all values for the given key, which
may be empty if the key is not in the dictionary (rather than throwing
an *note out_of_bounds: 10. exception):

    > let d::mdict = mdict ["foo"=>77,"bar"=>99.1,"foo"=>99];
    > d!"foo"; d!"baz";
    [77,99]
    []

Slicing thus returns a list of lists of values here:

    > d!!["foo","bar","baz"];
    [[77,99],[99.1],[]]

To obtain a flat list you can just concatenate the results:

    > cat $ d!!["foo","bar","baz"];
    [77,99,99.1]

Hashed multidicts provide both key hashing and multiple values per key:

    > let h::hmdict = hmdict [foo=>77,42=>99.1,42=>77];
    > keys h; vals h; members h;
    [42,42,foo]
    [99.1,77,77]
    [42=>99.1,42=>77,foo=>77]
    > h!42;
    [99.1,77]

There are also some set-like operations which allow you to add/remove
the members (`key=>val' pairs) of one dictionary to/from another
dictionary, and to compute the intersection of two dictionaries. For
instance:

    > let h1 = hmdict [a=>1,b=>2];
    > let h2 = hmdict [b=>2,c=>3];
    > members (h1+h2);
    [a=>1,c=>3,b=>2,b=>2]
    > members (h1-h2);
    [a=>1]
    > members (h1*h2);
    [b=>2]

It's possible to mix dictionaries of different types in these
operations.  The necessary conversions are handled automatically:

    > let h1 = hmdict [a=>1,b=>2];
    > let h2 = hdict  [b=>3,c=>4];
    > members (h1+h2);
    [a=>1,c=>4,b=>2,b=>3]

Note that the result will always be promoted to the most general operand
type in such cases (a hashed multidict in the above example). If this is
not what you want, you'll have to apply the necessary conversions
manually:

    > members (hdict h1+h2);
    [a=>1,c=>4,b=>3]



File: purelib.info,  Node: Sets and Bags,  Prev: Dictionaries,  Up: Container Types

3.4 Sets and Bags
=================

The set.pure module implements Pure's set data types based on AVL trees.
These work pretty much like dictionaries (cf. *note Dictionaries: 118.)
but only store keys (called "elements" or "members" here) without any
associated data values. Hence sets provide membership tests like
dictionaries, but no indexing operations.

  There are four variations of this data structure to choose from,
depending on whether the set members are ordered or hashed, and whether
multiple instances of the same element are allowed (in this case the
set is actually called a _multiset_ or a _bag_).

 -- type: set
 -- type: bag
     These implement the ordered set types. They require that members be
     ordered, i.e., the predicate `<' must be defined on them.

 -- type: hset
 -- type: hbag
     These implement the hashed set types which don't require an order
     of the members. Distinct members are stored in an apparently
     random order.

 -- type: xset
     This is just an abstract supertype for matching any kind of set or
     bag provided by this module.

  The usual comparison predicates (*note ==: 46, *note ~=: 137, *note
<=: 138, *note <: 13b. etc.) are defined on all set and bag types,
where two sets or bags are considered "equal" (`m1==m2') if they both
contain the same elements, and `m1<=m2' means that `m1' is a subset or
subbag of `m2', i.e., all elements of `m1' are also contained in `m2'
(taking into account multiplicities in the multiset case). Ordered sets
and bags compare elements using equality (considering two elements `a'
and `b' to be equal if neither `a<b' nor `b<a' holds), while hashed
sets and bags check for syntactical equality (using *note ===: 11d.).

  The underlying AVL tree data structure can be found in the
avltrees.pure module which is included in the library, but not to be
invoked directly.  The AVL tree algorithm has its origin in the
SWI-Prolog implementation of association lists and was ported to Pure
by Jiri Spitz, see *note Dictionaries: 118.  for details.

* Menu:

* Imports: Imports<5>.
* Operations: Operations<4>.
* Examples: Examples<4>.


File: purelib.info,  Node: Imports<5>,  Next: Operations<4>,  Up: Sets and Bags

3.4.1 Imports
-------------

To use the operations of this module, add the following import
declaration to your program:

    using set;



File: purelib.info,  Node: Operations<4>,  Next: Examples<4>,  Prev: Imports<5>,  Up: Sets and Bags

3.4.2 Operations
----------------

 -- Function: emptyset
 -- Function: emptybag
 -- Function: emptyhset
 -- Function: emptyhbag
     return an empty set or bag

 -- Function: set xs
 -- Function: bag xs
 -- Function: hset xs
 -- Function: hbag xs
     create a set or bag of the corresponding type from a list or
     another set or bag `xs'; in the latter case the argument is
     converted to a set or bag of the desired target type

 -- Function: setp x
 -- Function: bagp x
 -- Function: hsetp x
 -- Function: hbagp x
     check whether `x' is a set or bag of the corresponding type

 -- Function: m1 + m2
     union/sum: `m1+m2' adds the members of `m2' to `m1'

 -- Function: m1 - m2
     difference: `m1-m2' removes the members of `m2' from `m1'

 -- Function: m1 * m2
     intersection: `m1*m2' removes the members _not_ in `m2' from `m1'

 -- Function: # m
     size of a set or bag `m'

 -- Function: null m
     test whether `m' is an empty set or bag

 -- Function: member m x
     test whether `m' contains `x'

 -- Function: members m
 -- Function: list m
     list the members of `m' (in ascending order for ordered sets and
     bags)

 -- Function: first m
 -- Function: last m
     return the first and the last member of `m', respectively

 -- Function: rmfirst m
 -- Function: rmlast m
     remove the first and the last member from `m', respectively

 -- Function: insert m x
     insert `x' into `m' (replaces an existing element in the case of a
     set)

 -- Function: delete m x
     remove `x' from `m' (in the bag case, only the first instance of
     `x' is removed)

 -- Function: delete_all m x
     remove all instances of `x' from `m' (in the set case, this is just
     the same as *note delete: 295.)

     Note: The infix operators (*note +: 288, *note -: 289, *note *:
     28a, as well as the comparison operations) allow you to mix
     arbitrary operand types; the necessary conversions from less
     general set types (ordered, set) to more general types (hashed,
     multiset) are handled automatically.

     Also note that in the case of sets, *note +: 288. is just the
     ordinary set union. There are basically two generalizations of
     this operation to bags, *multiset union* and *multiset sum*; *note
     +: 288. implements the _latter_. Thus, if a bag `m1' contains `k1'
     instances of an element `x' and a bag `m2' contains `k2' instances
     of `x', then `m1+m2' contains `k1+k2' instances of `x' (rather
     than `max k1 k2' instances, which would be the case for multiset
     union). Multiset sum is probably more common in practical
     applications, and also generalizes easily to multidicts (see *note
     Dictionaries: 118.). However, if multiset union is needed, it can
     easily be defined in terms of multiset sum as follows:

         union m1 m2 = m1+(m2-m1);




File: purelib.info,  Node: Examples<4>,  Prev: Operations<4>,  Up: Sets and Bags

3.4.3 Examples
--------------

Some basic set operations:

    > let m::set = set [5,1,3,11,3];
    > members m;
    [1,3,5,11]
    > map (member m) (1..5);
    [1,0,1,0,1]
    > members $ m+set (3..6);
    [1,3,4,5,6,11]
    > members $ m-set (3..6);
    [1,11]
    > members $ m*set (3..6);
    [3,5]

The bag operations work in a similar fashion, but multiple instances are
permitted in this case, and each instance counts as a separate member:

    > let m::bag = bag [5,1,3,11,3];
    > members m;
    [1,3,3,5,11]
    > members $ delete m 3;
    [1,3,5,11]
    > members $ insert m 1;
    [1,1,3,3,5,11]
    > members $ m+bag (3..6);
    [1,3,3,3,4,5,5,6,11]
    > members $ m-bag (3..6);
    [1,3,11]
    > members $ m*bag (3..6);
    [3,5]

As already mentioned, operands of different types can be mixed with the
infix operators; the necessary conversions are handled automatically.
E.g., here's how you add a set to a bag:

    > let m1::bag = bag [5,1,3,11,3];
    > let m2::set = set (3..6);
    > members (m1+m2);
    [1,3,3,3,4,5,5,6,11]

Note that the result will always be promoted to the most general operand
type in such cases (a bag in the above example). If this is not what you
want, you'll have to apply the necessary conversions manually:

    > members (set m1+m2);
    [1,3,4,5,6,11]

If set members aren't ordered then you'll get an exception when trying
to create an ordered set or bag from them:

    > set [a,b,c];
    <stdin>, line 5: unhandled exception 'failed_cond' while evaluating
    'set [a,b,c]'

In such a case hashed sets and bags must be used instead. These work
analogously to the ordered sets and bags, but distinct members are
stored in an apparently random order:

    > members $ hset [a,b,c] * hset [c,d,e];
    [c]
    > members $ hbag [a,b,c] + hbag [c,d,e];
    [a,c,c,b,d,e]



File: purelib.info,  Node: System Interface,  Next: Index,  Prev: Container Types,  Up: Top

4 System Interface
******************

This module offers some useful system routines, straight from the C
library, as well as some convenience functions for wrapping these up in
Pure. Even the "purest" program needs to do some basic I/O every once
in a while, and this module provides the necessary stuff to do just
that. The operations provided in this module should work (if necessary
by a suitable emulation) on all supported systems. Most of the
following functions are extensively documented in the C library manual
pages, so we concentrate on the Pure-specific aspects here.

* Menu:

* Imports: Imports<6>.
* Errno and Friends::
* POSIX Locale::
* Signal Handling::
* Time Functions::
* Process Functions::
* Basic I/O Interface::
* Stat and Friends::
* Reading Directories::
* Shell Globbing::
* Regex Matching::
* Additional POSIX Functions::
* Option Parsing::


File: purelib.info,  Node: Imports<6>,  Next: Errno and Friends,  Up: System Interface

4.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using system;

Some functions of the system interface are provided in separate modules;
see *note Regex Matching: af, *note Additional POSIX Functions: 29a.
and *note Option Parsing: bd.


File: purelib.info,  Node: Errno and Friends,  Next: POSIX Locale,  Prev: Imports<6>,  Up: System Interface

4.2 Errno and Friends
=====================

 -- Function: errno
 -- Function: set_errno n
 -- Function: perror msg
 -- Function: strerror n
     This value and the related routines are indispensable to give
     proper diagnostics when system calls fail for some reason. Note
     that, by its very nature, *note errno: 29c. is a fairly volatile
     value, don't expect it to survive a return to the command line in
     interactive sessions.

  Example:

    > using system;
    > fopen "junk" "r", perror "junk";
    junk: No such file or directory
    fopen "junk" "r"



File: purelib.info,  Node: POSIX Locale,  Next: Signal Handling,  Prev: Errno and Friends,  Up: System Interface

4.3 POSIX Locale
================

 -- Function: setlocale category locale
     Set or retrieve the current locale.

  Details are platform-specific, but you can expect that at least the
categories `LC_ALL', `LC_COLLATE', `LC_CTYPE', `LC_MONETARY',
`LC_NUMERIC' and `LC_TIME' are defined, as well as the following values
for the locale parameter: `"C"' or `"POSIX"' (the default POSIX
locale), `""' (the system default locale), and *note NULL: 52, to just
query the current locale.

  Other string values which can be passed as the locale argument depend
on the implementation, please check your local setlocale(3)
documentation for details. If locale is not *note NULL: 52, the current
locale is changed accordingly. The return value is the new locale, or
the current locale when passing *note NULL: 52. for the locale
parameter. In either case, the string returned by *note setlocale: 2a1.
is such that it can be passed to *note setlocale: 2a1. to restore the
same locale again. In case of an error, *note setlocale: 2a1. fails
(rather than returning a null pointer).

  Please note that calling this function alters the Pure interpreter's
idea of what the current locale is. When the interpreter starts up, it
always sets the default system locale. Unless your scripts rely on a
specific encoding, setting the locale to either `"C"' or `""' should
always be safe.

  Example:

    > setlocale LC_ALL NULL;
    "en_US.UTF-8"



File: purelib.info,  Node: Signal Handling,  Next: Time Functions,  Prev: POSIX Locale,  Up: System Interface

4.4 Signal Handling
===================

 -- Function: trap action sig
     Establish or remove Pure signal handlers.

  The action parameter of *note trap: 2a3. can be one of the predefined
integer values `SIG_TRAP', `SIG_IGN' and `SIG_DFL'.  `SIG_TRAP' causes
the given signal to be handled by mapping it to a Pure exception of the
form `signal sig'. `SIG_IGN' ignores the signal, `SIG_DFL' reverts to
the system's default handling. See `show -g SIG*' for a list of known
signal values on your system.

  Note: When the interpreter runs interactively, most standard
termination signals (`SIGINT', `SIGTERM', etc.) are already set up to
report corresponding Pure exceptions; if this is not desired, you can
use *note trap: 2a3. to either ignore these or revert to the default
handlers instead.

  See _Exception Handling_ in the Pure Manual for details and examples.


File: purelib.info,  Node: Time Functions,  Next: Process Functions,  Prev: Signal Handling,  Up: System Interface

4.5 Time Functions
==================

The usual date/time functions from the C library are all provided. This
includes some functions to retrieve wallclock and cpu time which usually
offer much better resolution than the venerable *note time: 2a5.
function.

 -- Function: time
     Reports the current time in seconds since the *epoch*, 00:00:00
     UTC, Jan 1 1970. The result is always a bigint (in fact, the *note
     time: 2a5. value is already 64 bit on many OSes nowadays).

 -- Function: gettimeofday
     Returns wallclock time as seconds since the epoch, like *note
     time: 2a5, but theoretically offers resolutions in the microsec
     range (actual resolutions vary, but are usually in the msec range
     for contemporary systems). The result is returned as a double
     value (which also limits precision). This function may actually be
     implemented through different system calls, depending on what's
     available on the host OS.

 -- Function: clock
     Returns the current CPU (not wallclock) time since an arbitrary
     point in the past, as a machine int. The number of "ticks" per
     second is given by the `CLOCKS_PER_SEC' constant. Note that this
     value will wrap around approximately every 72 minutes.

 -- Function: sleep t
 -- Function: nanosleep t
     Suspend execution for a given time interval in seconds. *note
     sleep: 2a8.  takes integer (int/bigint) arguments only and uses
     the `sleep()' system function. *note nanosleep: 2a9. also accepts
     double arguments and theoretically supports resolutions down to 1
     nanosecond (again, actual resolutions vary). This function may
     actually be implemented through different system calls, depending
     on what's available on the host OS. Both functions usually return
     zero, unless the sleep was interrupted by a signal, in which case
     the time remaining to be slept is returned.

  Examples:

    > time,sleep 1,time;
    1270241703L,0,1270241704L
    > gettimeofday,nanosleep 0.1,gettimeofday;
    1270241709.06338,0.0,1270241709.16341

Here's a little macro which lets you time evaluations:

    def timex x = y,(t2-t1)/CLOCKS_PER_SEC when
      t1 = clock; y = x; t2 = clock;
    end;

Example:

    > timex (foldl (+) 0 (1..100000));
    705082704,0.07


 -- Function: tzset
     Initialize timezone information.

 -- variable: tzname
 -- variable: timezone
 -- variable: daylight
     The timezone information.

  The *note tzset: 2aa. function calls the corresponding routine from
the C library and initializes the (Pure) variables *note tzname: 2ab,
*note timezone: 2ac.  and *note daylight: 2ad. accordingly. See the
tzset(3) manual page for details. This routine is also called
automatically when the system module is loaded, so you only have to
invoke it to get up-to-date information after changes to the locale or
the timezone. Example:

    > tzset;
    ()
    > tzname, timezone, daylight;
    ["CET","CEST"],-3600,1
    > tzname!daylight;
    "CEST"

The following functions deal with date/time values in string and
"broken-down" time format. See the ctime(3), gmtime(3), localtime(3),
mktime(3), asctime(3), strftime(3) and strptime(3) manual pages for
details.

 -- Function: ctime t
     Convert a time value as returned by the *note time: 2a5. function
     to a string in local time.

 -- Function: gmtime t
 -- Function: localtime t
     Convert a time value to UTC or local time in "broken-down" form (a
     static pointer to a `tm' struct containing a bunch of `int' fields)
     which can then be passed to the *note asctime: 2b1. and *note
     strftime: 2b2.  functions, or to *note int_matrix: 10f. if you
     want to convert the data to a matrix; see the example below.

 -- Function: mktime tm
     Converts broken-down time to a time value (seconds since the
     epoch). As with *note time: 2a5, the result is always a bigint.

 -- Function: asctime tm
 -- Function: strftime format tm
     Format broken-down time as a string. *note strftime: 2b2. also
     uses a format string supplied by the user, see below for a list of
     the most important conversion specifiers.

 -- Function: strptime s format tm
     Parse a date/time string `s' according to the given format (using
     more or less the same format specifiers as the *note strftime:
     2b2. function) and store the broken-down time result in the given
     `tm' struct. This function may fail, e.g., if *note strptime: 2b4.
     finds an error in the format string. Otherwise it returns the part
     of the string which wasn't processed, see the example below.

  Examples:

    > let t = time; t;
    1270239790L
    > let tm = localtime t; tm;
    #<pointer 0x7ff97ecbdde0>
    > mktime tm;
    1270239790L
    > asctime tm;
    "Fri Apr  2 22:23:10 2010\n"
    > int_matrix 9 tm;
    {10,23,22,2,3,110,5,91,1}
    > strftime "%c" tm;
    "Fri 02 Apr 2010 10:23:10 PM CEST"
    > strptime ans "%c" tm, int_matrix 9 tm;
    "CEST",{10,23,22,2,3,110,5,91,1}

In the above example, *note strptime: 2b4. was given a static pointer
to a `tm' struct returned by *note localtime: 2b0. This always works,
but in some situations it may be preferable to allocate dynamic storage
instead. This storage should be properly initialized (zeroed out)
before passing it to *note strptime: 2b4, since *note strptime: 2b4.
only stores the values specified (at least in principle; please consult
your local C library documentation for details). Also note that while
POSIX only specifies nine `int' fields in a `tm' struct, depending on
the host operating system the struct may contain additional public and
private fields. The actual size of a `tm' struct is given by the
`SIZEOF_TM' constant, so a safe way to allocate suitable dynamic
storage for the *note strptime: 2b4. function is as follows:

    > let tm = pointer_cast "int*" $ calloc 1 SIZEOF_TM;
    > strptime "4/2/10" "%D" tm, int_matrix 9 tm;
    "",{0,0,0,2,3,110,5,91,0}

Instead of explicitly allocating dynamic storage and converting it to a
Pure matrix later, you can also invoke *note strptime: 2b4. directly
with an int matrix of sufficient size:

    > let tm = imatrix (SIZEOF_TM div SIZEOF_INT + 1);
    > strptime "4/2/10" "%D" tm, take 9 tm;
    "",{0,0,0,2,3,110,5,91,0}

Last but not least, to make calling *note strptime: 2b4. more
convenient, you can supply your own little wrapper function which takes
care of allocating the storage, e.g.:

    mystrptime s format = s,take 9 tm when
      tm = imatrix (SIZEOF_TM div SIZEOF_INT + 1);
      s = strptime s format tm;
    end;

    > mystrptime "4/2/10" "%D";
    "",{0,0,0,2,3,110,5,91,0}

Here is a list of some common format specifiers which can be used with
the *note strftime: 2b2. and *note strptime: 2b4. routines. These are
all specified by POSIX and should thus be available on most platforms.
Note that many more formats are usually supported than what is listed
here, so please consult your local manual pages for the complete list.

   * `%d', `%m', `%y': Day of the month, month and year as decimal
     two-digit numbers.

   * `%Y': The year as a four-digit number which includes the century.

   * `%H', `%M', `%S': Hours (range `00' to `23'), minutes and seconds
     as decimal two-digit numbers.

   * `%I': The hours on a 12-hour clock (range `01' to `12').

  The following formats are locale-dependent:

   * `%a', `%A': Abbreviated and full weekday name.

   * `%b', `%B': Abbreviated and full month name.

   * `%p': AM or PM. `%P' is the same in lowercase (`strftime' only).

  There are also some useful meta-formats which specify various
combinations of the above:

   * `%c': The preferred date and time representation for the current
     locale.

   * `%D': The American date format (`%m/%d/%y').

   * `%F': The ISO 8601 date format (`%Y-%m-%d'). (This is generally
     supported by *note strftime: 2b2. only, but *note strptime: 2b4.
     from GNU libc has it.)

   * `%r': The time in AM/PM notation (`%I:%M:%S %p').

   * `%R': The time in 24-hour notation (`%H:%M').

   * `%T': The time in 24-hour notation, including seconds (`%H:%M:%S').

  In addition, `%%' denotes a literal `%' character, `%n' newlines and
`%t' tabs. (For *note strptime: 2b4. the latter two are synonymous and
match arbitrary whitespace.)

  Windows users should note that *note strptime: 2b4. isn't natively
supported there. A basic emulation is provided by the Pure runtime, but
at present this only supports the C locale.


File: purelib.info,  Node: Process Functions,  Next: Basic I/O Interface,  Prev: Time Functions,  Up: System Interface

4.6 Process Functions
=====================

The following process functions are available on all systems. (Some
additional process-related functions such as *note fork: 2b6, *note
kill: 2b7, *note wait: 2b8. and *note waitpid: 2b9. are available in
the *note posix: 2ba. module, see *note Additional POSIX Functions:
29a.)

 -- Function: system cmd
     Execute a shell command.

 -- Function: execv prog argv
 -- Function: execvp prog argv
 -- Function: execve prog argv envp
     Execute a new process. `prog' denotes the name of the executable
     to be run, `argv' the argument vector (which repeats the program
     name in the first component), and `envp' a vector of environment
     strings of the form `"var=value"'. The *note execv: 2bc. function
     executes the program `prog' exactly as given, while *note execvp:
     2bd. also performs a path search. The *note execve: 2be. function
     is like *note execv: 2bc, but also specifies an environment to be
     passed to the process. In either case, the new process replaces
     the current process. For convenience, both `argv' and `envp' can
     be specified as a Pure string vector or a list, which is
     automatically translated to the raw, *note NULL: 52.-terminated C
     string vectors (i.e., `char**') required by the underlying C
     functions.

 -- Function: spawnv mode prog argv
 -- Function: spawnvp mode prog argv
 -- Function: spawnve mode prog argv envp
     Spawn a new child process. These work like the corresponding MS
     Windows functions; on Un*x systems this functionality is
     implemented using a combination of *note fork: 2b6. and *note
     execv: 2bc. The arguments are the same as for the *note execv:
     2bc. functions, except that there's an additional `mode' argument
     which specifies how the process is to be executed: `P_WAIT' waits
     for the process to finish, after which *note spawnv: 2bf. returns
     with the exit status of the terminated child process; `P_NOWAIT'
     makes *note spawnv: 2bf. return immediately, returning the process
     id; and `P_OVERLAY' causes the child process to replace its
     parent, just like with *note execv: 2bc. (On Windows, there's an
     additional `P_DETACH' flag which works like `P_NOWAIT' but also
     turns the child process into a background task.)

  Note that, in addition, the prelude provides the *note exit: 1ad.
function which terminates the program with a given exit code, cf. *note
Other Special Primitives: 1ac.

  Examples:

    > system "pwd";
    /home/ag/svn/pure-lang/trunk/pure/lib
    0
    > spawnvp P_WAIT "pwd" ["pwd"];
    /home/ag/svn/pure-lang/trunk/pure/lib
    0
    > spawnv P_WAIT "/bin/sh" ["/bin/sh","-c","pwd"];
    /home/ag/svn/pure-lang/trunk/pure/lib
    0



File: purelib.info,  Node: Basic I/O Interface,  Next: Stat and Friends,  Prev: Process Functions,  Up: System Interface

4.7 Basic I/O Interface
=======================

Note that this module also defines the standard I/O streams *note
stdin: 2c3, *note stdout: 2c4. and *note stderr: 2c5. as variables on
startup. These are ready to be used with the operations described
below. Also note that for convenience some of the following routines
are actually Pure wrappers, rather than just providing the raw C
library routines.

 -- variable: stdin
 -- variable: stdout
 -- variable: stderr
     The standard I/O streams.

 -- Function: fopen name mode
 -- Function: popen cmd mode
     Open a file or a pipe. These take care of closing a file object
     automagically when it's garbage-collected, and fail (instead of
     returning a null pointer) in case of error, so that you can
     provide any desired error handling simply by adding suitable
     equations.

 -- Function: fdopen fd mode
     Associates a file object with a given existing file descriptor.
     Otherwise works like *note fopen: 2c6, so the resulting file is
     closed automatically when it's garbage-collected.

 -- Function: freopen path mode fp
     Reopens a file object. The existing file object is closed.
     Otherwise works like *note fopen: 2c6, so the resulting file is
     closed automatically when it's garbage-collected.

 -- Function: fclose fp
 -- Function: pclose fp
     Close a file or a pipe.

 -- Function: tmpfile
     Creates a unique temporary file (opened in `"w+b"' mode) which gets
     deleted automatically when it is closed or the file object gets
     garbage-collected.

 -- Function: feof fp
 -- Function: ferror fp
 -- Function: clearerr fp
     Check the end-of-file and error bits. *note clearerr: 2cf. clears
     the error bit.

 -- Function: fileno fp
     Returns the file descriptor associated with the given file.

 -- Function: fflush fp
     Flushes the given file (or all open files if `fp' is *note NULL:
     52.).

 -- Function: fgets fp
 -- Function: gets
     Pure wrappers for the C `fgets' and `gets' functions which handle
     the necessary buffering automatically.

 -- Function: fget fp
     A variation of *note fgets: 2d2. which slurps in an entire text
     file at once.

 -- Function: fputs s fp
 -- Function: puts s
     Output a string to the given file or *note stdout: 2c4,
     respectively. These are just the plain C functions. Note that
     *note puts: 2d6. automatically adds a newline, while *note fputs:
     2d5. doesn't. Hmm.

 -- Function: fread ptr size nmemb fp
 -- Function: fwrite ptr size nmemb fp
     Binary read/writes. Here you'll have to manage the buffers
     yourself.  See the corresponding manual pages for details.

 -- Function: fseek fp offset whence
 -- Function: ftell fp
 -- Function: rewind fp
     Reposition the file pointer and retrieve its current value. The
     constants `SEEK_SET', `SEEK_CUR' and `SEEK_END' can be used for
     the `whence' argument of *note fseek: 2d9. The call `rewind fp' is
     equivalent to `fseek fp 0 SEEK_SET' (except that the latter also
     returns a result code). See the corresponding manual pages for
     details.

 -- Function: setbuf fp buf
 -- Function: setvbuf fp buf mode size
     Set the buffering of a file object, given as the first argument.
     The second argument specifies the buffer, which must be a pointer
     to suitably allocated memory or *note NULL: 52. The `mode'
     argument of *note setvbuf: 2dd. specifies the buffering mode,
     which may be one of the predefined constants `_IONBF', `_IOLBF' and
     `_IOFBF' denoting no buffering, line buffering and full (a.k.a.
     block) buffering, respectively; the `size' argument denotes the
     buffer size.

     For *note setbuf: 2dc, the given buffer must be able to hold
     `BUFSIZ' characters, where `BUFSIZ' is a constant defined by this
     module.  `setbuf fp buf' is actually equivalent to the following
     call (except that *note setvbuf: 2dd. also returns an integer
     return value):

         setvbuf fp buf (if null buf then _IONBF else _IOFBF) BUFSIZ

     Please see the setbuf(3) manual page for details.

  Examples:

    > puts "Hello, world!";
    Hello, world!
    14

    > map fileno [stdin,stdout,stderr];
    [0,1,2]

    > let fp = fopen "/etc/passwd" "r";
    > fgets fp;
    "at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash\n"
    > fgets fp;
    "avahi:x:103:104:User for Avahi:/var/run/avahi-daemon:/bin/false\n"
    > ftell fp;
    121L
    > rewind fp;
    ()
    > fgets fp;
    "at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash\n"

    > split "\n" $ fget $ popen "ls *.pure" "r";
    ["array.pure","dict.pure","getopt.pure","heap.pure","math.pure",
    "matrices.pure","prelude.pure","primitives.pure","quasiquote2.pure",
    "quasiquote.pure","set.pure","strings.pure","system.pure",""]

C-style formatted I/O is provided through the following wrappers for
the C `printf' and `scanf' functions. These wrapper functions take or
return a tuple of values and are fully type-safe, so they should never
segfault.  All basic formats derived from `%cdioux', `%efg', `%s' and
`%p' are supported, albeit without the standard length modifiers such
as `h' and `l', which aren't of much use in Pure. (However, in addition
to C `printf' and `scanf', the Pure versions also support the modifiers
`Z' and `R' of the GMP (http://gmplib.org) and MPFR
(http://www.mpfr.org) libraries, which are used for converting
multiprecision integer and floating point values, as shown in the
examples below.)

 -- Function: printf format args
 -- Function: fprintf fp format args
     Print a formatted string to *note stdout: 2c4. or the given file,
     respectively. Normally, these functions return the result of the
     underlying C routines (number of characters written, or negative on
     error). However, in case of an abnormal condition in the wrapper
     function, such as argument mismatch, they will throw an exception.
     (In particular, an *note out_of_bounds: 10. exception will be
     thrown if there are not enough arguments for the given format
     string.)

 -- Function: sprintf format args
     Print a formatted string to a buffer and return the result as a
     string.  Note that, unlike the C routine, the Pure version just
     returns the string result in the case of success; otherwise, the
     error handling is the same as with *note printf: 2e0. and *note
     fprintf: 2e1. The implementation actually uses the C routine
     `snprintf' for safety, and a suitable output buffer is provided
     automatically.

 -- Function: scanf format
 -- Function: fscanf fp format
     Read formatted input from *note stdin: 2c3. or the given file,
     respectively.  These normally return a tuple (or singleton) with
     the converted values. An exception of the form `scanf_error ret',
     where `ret' is the tuple of successfully converted values (which
     may be less than the number of requested input items), is thrown
     if end-of-file was met or another error occurred while still
     reading. The handling of other abnormal conditions is analogous to
     *note printf: 2e0. et al. Also note that this implementation
     doesn't accept any of the standard length modifiers; in
     particular, floating point values will _always_ be read in double
     precision and you just specify `e', `g' etc. for these. The
     "assignment suppression" flag `*' is understood, however; the
     corresponding items will not be returned.

 -- Function: sscanf s format
     This works exactly like *note fscanf: 2e4, but input comes from a
     string (first argument) rather than a file.

  Examples:

    > do (printf "%s%d\n") [("foo",5),("catch",22)];
    foo5
    catch22
    ()
    > sscanf "foo 5 22" "%s %d %g";
    "foo",5,22.0

As mentioned above, special argument formats are provided for bigints
and multiprecision floats:

    > sscanf "a(5) = 1234" "a(%d) = %Zd";
    5,1234L
    > sprintf "a(%d) = %Zd" ans;
    "a(5) = 1234"

    > using mpfr;
    > mpfr_set_default_prec 113;
    ()
    > printf "pi = %0.30Rg\n" (4*atan (mpfr 1));
    pi = 3.14159265358979323846264338328
    37

There are a number of other options for these conversions, please check
the GMP (http://gmplib.org) and MPFR (http://www.mpfr.org)
documentation for details.

     Note: In contrast to bigints, multiprecision floats aren't directly
     supported by the Pure language. If you would like to use these
     numbers, you'll have to install the `mpfr' addon module which is
     not included in the standard library yet. Also note that, at the
     time of this writing, MPFR (http://www.mpfr.org) only provides
     formatted output, so multiprecision floats are not supported by
     the `scanf' functions. To work around this limitation, it is
     possible to read the number as a string and then convert it using
     the `mpfr' function.


File: purelib.info,  Node: Stat and Friends,  Next: Reading Directories,  Prev: Basic I/O Interface,  Up: System Interface

4.8 Stat and Friends
====================

 -- Function: stat path
     Return information about the given file. This is a simple wrapper
     around the corresponding system call, see the stat(2) manual page
     for details. The function returns a tuple with the most important
     fields from the `stat' structure, in this order: `st_dev',
     `st_ino', `st_mode', `st_nlink', `st_uid', `st_gid', `st_rdev',
     `st_size', `st_atime', `st_mtime', `st_ctime'. Among these,
     `st_mode', `st_nlink', `st_uid' and `st_gid' are simple machine
     integers, the rest is encoded as bigints (even on 32 bit
     platforms).

 -- Function: lstat path
     Return information about the given symbolic link (rather than the
     file it points to). On systems where this function isn't supported
     (e.g., Windows), *note lstat: 2e8. is identical to *note stat: 2e7.

 -- Function: fstat fp
     Return information about the given file object. Same as *note
     stat: 2e7, but here the file is given as a file pointer created
     with *note fopen: 2c6.  (see *note Basic I/O Interface: 2c2.
     above). Note that the corresponding system function actually takes
     a file descriptor, so the Pure implementation is equivalent to the
     C call `fstat(fileno(fp))'. This function might not be supported
     on all platforms.

  For average applications, the most interesting fields are `st_mode'
and `st_size', which can be retrieved with `stat filename!![2,7]'. Note
that to facilitate access to the `st_mode' field, the usual masks and
bits for file types (`S_IFMT', `S_IFREG', etc.) and permissions
(`S_ISUID', `S_ISGID', `S_IRWXU', etc.)  are defined as constants by
this module.  Use the command `show -g S_*' in the interpreter to get a
full list of these. Other interesting fields are `st_atime', `st_mtime'
and `st_ctime', which can be accessed using `stat filename!!(8..10)'.
The values of these fields are the times of last access, last
modification and creation, respectively, which can be decoded using the
appropriate time functions like *note ctime: 2ae. or *note strftime:
2b2, see *note Time Functions: 2a4.

  Examples:

    > stat "/etc/passwd";
    64773L,9726294L,33188,1,0,0,0L,1623L,1250373163L,1242692339L,1242692339L
    > stat "/etc/passwd"!7;                                // file size
    1623L
    > strftime "%c" $ localtime $ stat "/etc/passwd"!10;   // creation time
    "Tue 19 May 2009 02:18:59 AM CEST"
    > sprintf "0%o" $ stat "/etc/passwd"!2 and not S_IFMT; // permissions
    "0644"
    > stat "/etc/passwd"!2 and S_IFMT == S_IFREG; // this is a regular file
    1
    > stat "/etc"!2 and S_IFMT == S_IFDIR;        // this is a directory
    1



File: purelib.info,  Node: Reading Directories,  Next: Shell Globbing,  Prev: Stat and Friends,  Up: System Interface

4.9 Reading Directories
=======================

 -- Function: readdir name
     Read the contents of the given directory and return the names of
     all its entries as a list.

  Example:

    > readdir "/home";
    ["ag",".",".."]



File: purelib.info,  Node: Shell Globbing,  Next: Regex Matching,  Prev: Reading Directories,  Up: System Interface

4.10 Shell Globbing
===================

 -- Function: fnmatch pat s flags
     Returns a simple truth value (1 if `pat' matches `s', 0 if it
     doesn't), instead of an error code like the C function.

 -- Function: glob pat flags
     Returns a Pure list with the matches (unless there is an error in
     which case the integer result code of the underlying C routine is
     returned).

  The available flag values and glob error codes are available as
symbolic `FNM_*' and `GLOB_*' constants defined as variables in the
global environment. See the fnmatch(3) and glob(3) manpages for the
meaning of these.

  Example:

    > glob "*.pure" 0;
    ["array.pure","dict.pure","getopt.pure","heap.pure","math.pure",
    "matrices.pure","prelude.pure","primitives.pure","set.pure",
    "strings.pure","system.pure"]



File: purelib.info,  Node: Regex Matching,  Next: Additional POSIX Functions,  Prev: Shell Globbing,  Up: System Interface

4.11 Regex Matching
===================

Please note that, as of Pure 0.48, this part of the system interface is
not included in the system module any more, but is provided as a
separate regex module which can be used independently of the system
module. To use the operations of this module, add the following import
declaration to your program:

    using regex;

Since the POSIX regex functions (`regcomp' and `regexec') have a
somewhat difficult calling sequence, this module provides a couple of
rather elaborate high-level wrapper functions for use in Pure programs.
These are implemented in terms of a low-level interface provided in the
runtime. (The low-level interface isn't documented here, but these
functions are also callable if you want to create your own regular
expression engines in Pure.  You might wish to take a look at the
implementation of the high-level functions in regex.pure to see how this
can be done.)

 -- Function: regex pat cflags s eflags
     Compiles and matches a regex in one go, and returns the list of
     submatches (if any).

          Parameters:

             * *pat* (*note string: ac.) -- the regular expression
               pattern

             * *cflags* (*note int: 14f.) -- the compilation flags
               (bitwise or of any of the flags accepted by regcomp(3))

             * *s* (*note string: ac.) -- the subject string to be
               matched

             * *eflags* (*note int: 14f.) -- the matching execution
               flags (bitwise or of any of the flags accepted by
               regexec(3))

  Symbolic `REG_*' constants are provided for the different flag
values, see the regcomp(3) manpage for an explanation of these. Two
particularly important compilation flags (to be included in the `cflags'
argument) are `REG_NOSUB', which prevents submatches to be computed,
and `REG_EXTENDED', which switches *note regex: 2f0. from "basic" to
"extended" regular expressions so that it understands all the regular
expression elements of egrep(1) in the pattern argument.

  Depending on the flags and the outcome of the operation, the result
of this function can take one of the following forms:

   - `regerr code msg': This indicates an error during compilation of
     the pattern (e.g., if there was a syntax error in the pattern).
     `code' is the nonzero integer code returned by `regcomp', and
     `msg' is the corresponding error message string, as returned by
     `regerror'. You can redefine the `regerr' function as appropriate
     for your application (e.g., if you'd like to print an error
     message or throw an exception).

   - `0' or `1': Just a truth value indicates whether the pattern
     matched or not. This will be the form of the result if the
     `REG_NOSUB' flag was specified for compilation, indicating that no
     submatch information is to be computed.

   - `0' (indicating no match), or `1' (indicating a successful match),
     where the latter value is followed by a tuple of `(pos,substr)'
     pairs for each submatch. This will be the form of the result only
     if the `REG_NOSUB' flag was _not_ specified for compilation, so
     that submatch information is available.

  Note that, according to POSIX semantics, a return value of 1 does
_not_ generally mean that the entire subject string was matched, unless
you explicitly tie the pattern to the beginning (`^') and end (`$') of
the string.

  If the result takes the latter form, each `(pos,substr)' pair
indicates a portion of the subject string which was matched; `pos' is
the position at which the match starts, and `substr' is the substring
(starting at position `pos') which was matched. The first
`(pos,substr)' pair always indicates which portion of the string was
matched by the entire pattern, the remaining pairs represent submatches
for the parenthesized subpatterns of the pattern, as described on the
regcomp(3) manual page. Note that some submatches may be empty (if they
matched the empty string), in which case a pair `(pos,"")' indicates
the (nonnegative) position `pos' where the subpattern matched the empty
string. Other submatches may not participate in the match at all, in
which case the pair `(-1,"")' is returned.

  The following helper functions are provided to analyze the result
returned by *note regex: 2f0.

 -- Function: reg_result res
     Returns the result of a *note regex: 2f0. call, i.e., a `regerr'
     term if compilation failed, and a flag indicating whether the
     match was successful otherwise.

 -- Function: reg_info res
     Returns the submatch info if any, otherwise it returns `()'.

 -- Function: reg n info
     Returns the `n'th submatch of the given submatch info, where `info'
     is the result of a *note reg_info: 2f2. call.

 -- Function: regs info
     Returns all valid submatches, i.e., the list of all triples
     `(n,p,s)' for which `reg n == (p,s)' with `p>=0'.

  In addition, the following convenience functions are provided to
perform global regex searches, to perform substitutions, and to
tokenize a string according to a given delimiter regex.

 -- Function: regexg f pat cflags s eflags
     Perform a global regular expression search. This routine will scan
     the entire string for (non-overlapping) instances of the pattern,
     applies the given function `f' to the `reg_info' for each match,
     and collects all results in a list. Note: Never specify the
     `REG_NOSUB' flag with this function, it needs the submatch info.

 -- Function: regexgg f pat cflags s eflags
     This works like *note regexg: 2f5, but allows overlapping matches.

 -- Function: regsub f pat cflags s eflags
     Replaces all non-overlapping instances of a pattern with a computed
     substitution string. To these ends, the given function `f' is
     applied to the *note reg_info: 2f2. for each match. The result
     string is then obtained by concatenating `f info' for all matches,
     with the unmatched portions of the string in between. To make this
     work, `f' must always return a string value; otherwise, *note
     regsub: 2f7. throws a *note bad_string_value: e. exception.

 -- Function: regsplit pat cflags s eflags
     Splits a string into constituents delimited by substrings matching
     the given pattern.

  Please note that these operations all operate in an eager fashion,
i.e., they process the entire input string in one go. This may be
unwieldy or at least inefficient for huge amounts of text. As a remedy,
the following lazy alternatives are available:

 -- Function: regexgs f pat cflags s eflags
 -- Function: regexggs f pat cflags s eflags
 -- Function: regsplits pat cflags s eflags
     These work like *note regexg: 2f5, *note regexgg: 2f6. and *note
     regsplit: 2f8.  above, but return a stream result which enables
     you to process the matches one by one, using "call by need"
     evaluation.

* Menu:

* Basic Examples::
* Regex Substitutions and Splitting::
* Empty Matches::
* Submatches::


File: purelib.info,  Node: Basic Examples,  Next: Regex Substitutions and Splitting,  Up: Regex Matching

4.11.1 Basic Examples
---------------------

Let's have a look at some simple examples:

    > let pat = "[[:alpha:]][[:alnum:]]*";
    > let s = "1var foo 99 BAR $%&";

Simple match:

    > regex pat 0 s 0;
    1,1,"var"

Same without match info:

    > regex pat REG_NOSUB s 0;
    1

Global match, return the list of all matches:

    > regexg id pat 0 s 0;
    [(1,"var"),(5,"foo"),(12,"BAR")]

Same with overlapping matches:

    > regexgg id pat 0 s 0;
    [(1,"var"),(2,"ar"),(3,"r"),(5,"foo"),(6,"oo"),(7,"o"),(12,"BAR"),
    (13,"AR"),(14,"R")]

Note that *note id: 30. (the identity function) in the examples above
can be replaced with an arbitrary function which processes the matches.
For instance, if we only want the matched strings instead of the full
match info:

    > regexg (!1) pat 0 s 0;
    ["var","foo","BAR"]

Lazy versions of both *note regexg: 2f5. and *note regexgg: 2f6. are
provided which return the result as a stream instead. These can be
processed in a "call by need" fashion:

    > regexgs id pat 0 s 0;
    (1,"var"):#<thunk 0x7fb1b7976750>
    > last ans;
    12,"BAR"

Let's verify that the processing is really done lazily:

    > using system;
    > test x = printf "got: %s\n" (str x) $$ x;
    > let xs = regexgs test pat 0 s 0;
    got: 1,"var"
    > xs!1;
    got: 5,"foo"
    5,"foo"
    > last xs;
    got: 12,"BAR"
    12,"BAR"

As you can see, the first match is produced immediately, while the
remaining matches are processed as the result stream is traversed. This
is most useful if you have to deal with bigger amounts of text. By
processing the result stream in a piecemeal fashion, you can avoid
keeping the entire result list in memory. For instance, compare the
following:

    > let s2 = fget $ fopen "system.pure" "r";
    > stats -m
    > #regexg id pat 0 s2 0;
    7977
    0.18s, 55847 cells
    > #regexgs id pat 0 s2 0;
    7977
    0.12s, 20 cells



File: purelib.info,  Node: Regex Substitutions and Splitting,  Next: Empty Matches,  Prev: Basic Examples,  Up: Regex Matching

4.11.2 Regex Substitutions and Splitting
----------------------------------------

We can also perform substitutions on matches:

    > regsub (sprintf "<%d:%s>") pat 0 s 0;
    "1<1:var> <5:foo> 99 <12:BAR> $%&"

Or split a string using a delimiter pattern (this uses an egrep
pattern):

    > let delim = "[[:space:]]+";
    > regsplit delim REG_EXTENDED s 0;
    ["1var","foo","99","BAR","$%&"]
    > regsplit delim REG_EXTENDED "The   quick brown    fox" 0;
    ["The","quick","brown","fox"]

The *note regsplit: 2f8. operation also has a lazy variation:

    > regsplits "[[:space:]]+" REG_EXTENDED "The   quick brown    fox" 0;
    "The":#<thunk 0x7fb1b79775b0>
    > last ans;
    "fox"



File: purelib.info,  Node: Empty Matches,  Next: Submatches,  Prev: Regex Substitutions and Splitting,  Up: Regex Matching

4.11.3 Empty Matches
--------------------

Empty matches are permitted, too, subject to the constraint that at most
one match is reported for each position (which also prevents looping).
And of course an empty match will only be reported if nothing else
matches. For instance:

    > regexg id "" REG_EXTENDED "foo" 0;
    [(0,""),(1,""),(2,""),(3,"")]
    > regexg id "o*" REG_EXTENDED "foo" 0;
    [(0,""),(1,"oo"),(3,"")]
    > regexgg id "o*" REG_EXTENDED "foo" 0;
    [(0,""),(1,"oo"),(2,"o"),(3,"")]

This also works when substituting or splitting:

    > regsub (cst " ") "" REG_EXTENDED "some text" 0;
    " s o m e   t e x t "
    > regsub (cst " ") " ?" REG_EXTENDED "some text" 0;
    " s o m e  t e x t "
    > regsplit "" REG_EXTENDED "some text" 0;
    ["","s","o","m","e"," ","t","e","x","t",""]
    > regsplit " ?" REG_EXTENDED "some text" 0;
    ["","s","o","m","e","","t","e","x","t",""]



File: purelib.info,  Node: Submatches,  Prev: Empty Matches,  Up: Regex Matching

4.11.4 Submatches
-----------------

Parenthesized subexpressions in a pattern yield corresponding submatch
information, which is useful if we need to retrieve the text matched by
a given subexpression. For instance, suppose we want to parse
environment lines, such as those returned by the shell's `set' command.
These can be dissected using the following regex:

    > const env_pat = "^([^=]+)=(.*)$";
    > const env_flags = REG_EXTENDED or REG_NEWLINE;
    > regex env_pat env_flags "SHELL=/bin/sh" 0;
    1,0,"SHELL=/bin/sh",0,"SHELL",6,"/bin/sh"

Note that we again used an extended regex here, and we also added the
`REG_NEWLINE' flag so that we properly deal with multiline input.  The
desired information is in the 4th and 6th element of the submatch info,
we can retrieve that as follows:

    > parse_env s = regexg (\info -> info!3 => info!5) env_pat env_flags s 0;
    > parse_env "SHELL=/bin/sh\nHOME=/home/bar\n";
    ["SHELL"=>"/bin/sh","HOME"=>"/home/bar"]

We can get hold of the real process environment as follows:

    > using system;
    > let env = parse_env $ fget $ popen "set" "r";
    > #env;
    109
    > head env;
    "BASH"=>"/usr/bin/sh"

Just for the fun of it, let's convert this to a record, providing easy
random access to the environment variables:

    > let env = record env;
    > env!!["SHELL","HOME"];
    {"/bin/bash","/home/ag"}



File: purelib.info,  Node: Additional POSIX Functions,  Next: Option Parsing,  Prev: Regex Matching,  Up: System Interface

4.12 Additional POSIX Functions
===============================

_Platforms: _Mac, Unix

  The posix module provides some additional POSIX functions not
available on all supported systems. (In particular, none of these
functions are provided on MS Windows.) You can load this module in
addition to the system module if you need the additional functionality.
To use the operations of this module, add the following import
declaration to your program:

    using posix;

The following operations are provided. Please see the appropriate POSIX
manual pages for a closer description of these functions.

 -- Function: fork
     Fork a new process.

 -- Function: getpid
 -- Function: getppid
     Get the process id of the current process and its parent process,
     respectively.

 -- Function: wait status
 -- Function: waitpid pid status options
     Wait for any child process, or the given one. The `status' argument
     must be a pointer to an `int' value, which is used to return the
     status of the child process.

 -- Function: kill pid sig
     Send the given signal to the given process.

 -- Function: raise sig
     Raise the given signal in the current process.

 -- Function: pause
     Sleep until a signal is caught.


File: purelib.info,  Node: Option Parsing,  Prev: Additional POSIX Functions,  Up: System Interface

4.13 Option Parsing
===================

This is a quick-and-dirty replacement for the GNU getopt functions,
ported from the Q library. To use the operations of this module, add
the following import declaration to your program:

    using getopt;

The following operation is provided:

 -- Function: getopt opts args
     Parse options as given by `opts' in the command line arguments
     `args', return the parsed options along with a list of the
     remaining (non-option) command line arguments.

  The *note getopt: 305. function takes two arguments: `opts', a list
of option descriptions in the format described below, and `args', a
list of strings containing the command line parameters to be parsed for
options. The result is a pair `(opts_return,args_return)' where
`opts_return' is a list of options and their values, and `args_return'
is the list of remaining (non-option) arguments. Options are parsed
using the rules of GNU getopt(1). If an invalid option is encountered
(unrecognized option, missing or extra argument, etc.), *note getopt:
305. throws the offending option string as an exception.

  The `opts_return' value is a list of "hash pairs" `opt=>val' where
`opt' is the (long) option name (as given by the `long_opt' field given
in the `opts' argument, see below) and `val' is the corresponding value
(`()' if none). Note that this format is ready to be passed to the
*note dict: 259. or *note hdict: 25a. function, cf. *note Dictionaries:
118, which makes it easy to retrieve option values or check for the
presence of options. (As of Pure 0.41, you can also just convert the
list to a record and employ the record functions to access the option
data, cf. *note Record Functions: 2b.)

  The `opts' argument of `getopt' must be a list of triples `(long_opt,
short_opt, flag)', where `long_opt' denotes the long option,
`short_opt' the equivalent short option, and `flag' is one of the
symbolic integer values `NOARG', `OPTARG' and `REQARG' which specifies
whether the option has no argument, an optional argument or a required
argument, respectively. Either `long_opt' or `short_opt' should be a
string value of the form `"--abc"' or `"-x"', respectively. Note that
since the `long_opt' value is always used to denote the corresponding
option in the `opts_return' list, you always have to specify a sensible
value for that field. If no separate long option name is needed, you
can specify the same value as in the `short_opt' field, or some other
convenient value (e.g., an integer) which designates the option.
Conversely, to indicate that an option has no short option equivalent,
simply specify an empty option string for the `short_opt' field.

  Examples:

    > let opts = [("--help", "-h", NOARG),       // no argument
    >             ("--version", "", NOARG),      // no short option
    >             ("--filename", "-f", REQARG),  // required argument
    >             ("--count", "-n", OPTARG)];    // optional argument
    > getopt opts ["foo", "-h", "--filename", "bar", "-n0", "baz"];
    ["--help"=>(),"--filename"=>"bar","--count"=>"0"],["foo","baz"]
    > catch invalid_option $ getopt opts ["-h","-v"];
    invalid_option "-v"
    > getopt opts [foo, "-h", bar];
    ["--help"=>()],[foo,bar]

As the last example shows, non-option arguments (as well as option
values specified as separate arguments) can actually be any values
which are just copied to the result lists as is.


File: purelib.info,  Node: Index,  Prev: System Interface,  Up: Top

Index
*****

 [index ]
* Menu:

* # prefix function <1>:                 Operations<4>.       (line  35)
* # prefix function <2>:                 Operations<3>.       (line  42)
* # prefix function <3>:                 Operations<2>.       (line  15)
* # prefix function <4>:                 Operations.          (line  24)
* # prefix function <5>:                 Expression Serialization.
                                                              (line  35)
* # prefix function <6>:                 Record Functions.    (line  49)
* # prefix function <7>:                 Matrix Functions.    (line   6)
* # prefix function <8>:                 Basic String Functions.
                                                              (line  22)
* # prefix function:                     Lists and Tuples.    (line 131)
* $ infix function:                      Basic Combinators.   (line   8)
* % infix function:                      Rational Numbers.    (line   6)
* && infix function:                     Arithmetic.          (line  83)
* * infix function <1>:                  Operations<4>.       (line  32)
* * infix function <2>:                  Operations<3>.       (line  39)
* * infix function:                      Arithmetic.          (line  56)
* + infix function <1>:                  Operations<4>.       (line  26)
* + infix function <2>:                  Operations<3>.       (line  33)
* + infix function <3>:                  Complex Numbers.     (line   6)
* + infix function <4>:                  Pointer Arithmetic.  (line  28)
* + infix function <5>:                  Arithmetic.          (line  56)
* + infix function <6>:                  Basic String Functions.
                                                              (line   6)
* + infix function:                      Lists and Tuples.    (line  84)
* - infix function <1>:                  Operations<4>.       (line  29)
* - infix function <2>:                  Operations<3>.       (line  36)
* - infix function <3>:                  Pointer Arithmetic.  (line  28)
* - infix function:                      Arithmetic.          (line  56)
* - prefix function:                     Arithmetic.          (line  65)
* / infix function:                      Arithmetic.          (line  56)
* < infix function <1>:                  Complex Numbers.     (line   6)
* < infix function <2>:                  Pointer Arithmetic.  (line  44)
* < infix function <3>:                  Arithmetic.          (line  77)
* < infix function:                      Basic String Functions.
                                                              (line  36)
* << infix function:                     Arithmetic.          (line  95)
* <= infix function <1>:                 Pointer Arithmetic.  (line  44)
* <= infix function <2>:                 Arithmetic.          (line  77)
* <= infix function:                     Basic String Functions.
                                                              (line  36)
* == infix function <1>:                 Pointer Arithmetic.  (line  39)
* == infix function <2>:                 Arithmetic.          (line  73)
* == infix function <3>:                 Matrix Functions.    (line  63)
* == infix function <4>:                 Basic String Functions.
                                                              (line  36)
* == infix function <5>:                 Hash Pairs.          (line  16)
* == infix function:                     Lists and Tuples.    (line 115)
* === infix function:                    Predicates.          (line  11)
* => infix constructor:                  Hash Pairs.          (line  13)
* > infix function <1>:                  Pointer Arithmetic.  (line  44)
* > infix function <2>:                  Arithmetic.          (line  77)
* > infix function:                      Basic String Functions.
                                                              (line  36)
* >= infix function <1>:                 Pointer Arithmetic.  (line  44)
* >= infix function <2>:                 Arithmetic.          (line  77)
* >= infix function:                     Basic String Functions.
                                                              (line  36)
* >> infix function:                     Arithmetic.          (line  95)
* [] constructor:                        Lists and Tuples.    (line  11)
* ^ infix function:                      Arithmetic.          (line  56)
* __func__ function:                     Inspection.          (line  26)
* __list__ macro:                        Inspection.          (line  69)
* __locals__ macro:                      Inspection.          (line  87)
* __namespace__ macro:                   Inspection.          (line  54)
* __str__ function:                      Eval and Friends.    (line 119)
* abs function <1>:                      Complex Numbers.     (line  55)
* abs function:                          Arithmetic.          (line 113)
* acos function:                         Basic Math Functions.
                                                              (line  61)
* acosh function:                        Basic Math Functions.
                                                              (line  75)
* add_constdef function:                 Inspection.          (line 196)
* add_fundef function:                   Inspection.          (line 170)
* add_fundef_at function:                Inspection.          (line 177)
* add_interface function:                Inspection.          (line 186)
* add_interface_at function:             Inspection.          (line 191)
* add_macdef function:                   Inspection.          (line 170)
* add_macdef_at function:                Inspection.          (line 177)
* add_typedef function:                  Inspection.          (line 170)
* add_typedef_at function:               Inspection.          (line 177)
* add_vardef function:                   Inspection.          (line 196)
* addr function:                         Pointer Operations.  (line  11)
* all function:                          Common List Functions.
                                                              (line   9)
* and infix function:                    Arithmetic.          (line  89)
* ans function:                          Inspection.          (line  11)
* any function:                          Common List Functions.
                                                              (line   6)
* append function:                       Operations.          (line  55)
* appl type:                             Prelude Types.       (line  72)
* applp function:                        Predicates.          (line  61)
* arg function:                          Complex Numbers.     (line  55)
* arity function:                        Inspection.          (line 234)
* array function:                        Operations.          (line   9)
* array module:                          Container Types.     (line  29)
* array type:                            Arrays.              (line  11)
* array2 function:                       Operations.          (line  12)
* arrayp function:                       Operations.          (line  21)
* asctime function:                      Time Functions.      (line 106)
* asin function:                         Basic Math Functions.
                                                              (line  61)
* asinh function:                        Basic Math Functions.
                                                              (line  75)
* atan function:                         Basic Math Functions.
                                                              (line  61)
* atan2 function:                        Basic Math Functions.
                                                              (line  66)
* atanh function:                        Basic Math Functions.
                                                              (line  75)
* bad_list_value constructor:            Constants and Operators.
                                                              (line  33)
* bad_matrix_value constructor:          Constants and Operators.
                                                              (line  33)
* bad_string_value constructor:          Constants and Operators.
                                                              (line  33)
* bad_tuple_value constructor:           Constants and Operators.
                                                              (line  33)
* bag function:                          Operations<4>.       (line  12)
* bag type:                              Sets and Bags.       (line  17)
* bagp function:                         Operations<4>.       (line  20)
* bigint function <1>:                   Pointer Arithmetic.  (line  18)
* bigint function:                       Conversions.         (line  11)
* bigintp function:                      Predicates.          (line  29)
* bigintval type:                        Semantic Number Predicates and Types.
                                                              (line  31)
* bigintvalp function:                   Semantic Number Predicates and Types.
                                                              (line  23)
* blob function:                         Expression Serialization.
                                                              (line  18)
* blob_crc function:                     Expression Serialization.
                                                              (line  35)
* blob_size function:                    Expression Serialization.
                                                              (line  35)
* blobp function:                        Expression Serialization.
                                                              (line  27)
* byte_cstring function:                 Low-Level Operations.
                                                              (line  32)
* byte_cstring_pointer function:         Low-Level Operations.
                                                              (line  52)
* byte_matrix function:                  Pointers and Matrices.
                                                              (line  35)
* byte_pointer function:                 Pointers and Matrices.
                                                              (line  21)
* byte_string function:                  Low-Level Operations.
                                                              (line  32)
* byte_string_pointer function:          Low-Level Operations.
                                                              (line  52)
* calloc function:                       Pointer Operations.  (line  19)
* cat function:                          Common List Functions.
                                                              (line  12)
* catmap function:                       Common List Functions.
                                                              (line  15)
* ceil function:                         Conversions.         (line  45)
* char type:                             Prelude Types.       (line  42)
* character arithmetic:                  Basic String Functions.
                                                              (line  88)
* charp function:                        Predicates.          (line  37)
* chars function:                        Basic String Functions.
                                                              (line 102)
* check_ptrtag function:                 Tagged Pointers.     (line  23)
* chr function:                          Basic String Functions.
                                                              (line  84)
* cis function:                          Complex Numbers.     (line  51)
* clear_sentry function:                 Sentries.            (line  19)
* clearerr function:                     Basic I/O Interface. (line  45)
* clearsym function:                     Eval and Friends.    (line 139)
* clock function:                        Time Functions.      (line  25)
* closure type:                          Prelude Types.       (line  92)
* closurep function:                     Predicates.          (line  74)
* cmatrix function:                      Matrix Construction and Conversions.
                                                              (line  84)
* cmatrix type:                          Matrix Inspection and Manipulation.
                                                              (line   6)
* cmatrixp function:                     Matrix Inspection and Manipulation.
                                                              (line  16)
* col function:                          Matrix Inspection and Manipulation.
                                                              (line  42)
* colcat function:                       Matrix Inspection and Manipulation.
                                                              (line  65)
* colcatmap function:                    Matrix Inspection and Manipulation.
                                                              (line  84)
* colmap function:                       Matrix Inspection and Manipulation.
                                                              (line  84)
* colrev function:                       Matrix Inspection and Manipulation.
                                                              (line 171)
* cols function:                         Matrix Inspection and Manipulation.
                                                              (line  46)
* colvector function:                    Matrix Construction and Conversions.
                                                              (line  22)
* colvectorp function:                   Matrix Inspection and Manipulation.
                                                              (line  23)
* colvectorseq function:                 Matrix Construction and Conversions.
                                                              (line  44)
* combinators:                           Basic Combinators.   (line   6)
* complex function:                      Complex Numbers.     (line  44)
* complex type:                          Prelude Types.       (line  10)
* complex_float_matrix function:         Pointers and Matrices.
                                                              (line  35)
* complex_float_pointer function:        Pointers and Matrices.
                                                              (line  21)
* complex_matrix function:               Pointers and Matrices.
                                                              (line  35)
* complex_matrix_view function:          Pointers and Matrices.
                                                              (line  51)
* complex_pointer function:              Pointers and Matrices.
                                                              (line  21)
* complexp function:                     Predicates.          (line  40)
* compval type:                          Semantic Number Predicates and Types.
                                                              (line  31)
* compvalp function:                     Semantic Number Predicates and Types.
                                                              (line  13)
* conj function <1>:                     Complex Numbers.     (line  65)
* conj function:                         Matrix Inspection and Manipulation.
                                                              (line 103)
* constructor:                           Lists and Tuples.    (line  11)
* cooked function:                       Sentries.            (line  49)
* cookedp function:                      Sentries.            (line  46)
* cos function:                          Basic Math Functions.
                                                              (line  56)
* cosh function:                         Basic Math Functions.
                                                              (line  70)
* cst function:                          Basic Combinators.   (line  21)
* cstring function:                      Low-Level Operations.
                                                              (line  15)
* cstring_dup function:                  Low-Level Operations.
                                                              (line  23)
* cstring_list function:                 Low-Level Operations.
                                                              (line  56)
* cstring_vector function:               Low-Level Operations.
                                                              (line  60)
* ctime function:                        Time Functions.      (line  90)
* curry function:                        Basic Combinators.   (line  73)
* curry3 function:                       Basic Combinators.   (line  96)
* cycle function:                        List Generators.     (line  11)
* cyclen function:                       List Generators.     (line  14)
* daylight variable:                     Time Functions.      (line  65)
* del_constdef function:                 Inspection.          (line 217)
* del_fundef function:                   Inspection.          (line 205)
* del_interface function:                Inspection.          (line 213)
* del_macdef function:                   Inspection.          (line 205)
* del_typedef function:                  Inspection.          (line 205)
* del_vardef function:                   Inspection.          (line 217)
* delete function <1>:                   Operations<4>.       (line  61)
* delete function <2>:                   Operations<3>.       (line  83)
* delete function:                       Record Functions.    (line  72)
* delete_all function <1>:               Operations<4>.       (line  65)
* delete_all function:                   Operations<3>.       (line  92)
* delete_val function:                   Operations<3>.       (line  87)
* den function:                          Rational Numbers.    (line  45)
* diag function:                         Matrix Inspection and Manipulation.
                                                              (line  50)
* diagmat function:                      Matrix Inspection and Manipulation.
                                                              (line  92)
* dict function:                         Operations<3>.       (line  12)
* dict module:                           Examples<2>.         (line  14)
* dict type:                             Dictionaries.        (line  11)
* dictp function:                        Operations<3>.       (line  21)
* dim function:                          Matrix Functions.    (line   6)
* div infix function:                    Arithmetic.          (line  69)
* dmatrix function:                      Matrix Construction and Conversions.
                                                              (line  84)
* dmatrix type:                          Matrix Inspection and Manipulation.
                                                              (line   6)
* dmatrixp function:                     Matrix Inspection and Manipulation.
                                                              (line  16)
* do function:                           Common List Functions.
                                                              (line  19)
* double function:                       Conversions.         (line  11)
* double_matrix function:                Pointers and Matrices.
                                                              (line  35)
* double_matrix_view function:           Pointers and Matrices.
                                                              (line  51)
* double_pointer function:               Pointers and Matrices.
                                                              (line  21)
* doublep function:                      Predicates.          (line  29)
* dowith function:                       Zip and Friends.     (line  33)
* dowith3 function:                      Zip and Friends.     (line  37)
* drop function:                         Common List Functions.
                                                              (line  23)
* dropwhile function:                    Common List Functions.
                                                              (line  26)
* e constant:                            Basic Math Functions.
                                                              (line   8)
* emptyarray function:                   Operations.          (line   6)
* emptybag function:                     Operations<4>.       (line   6)
* emptydict function:                    Operations<3>.       (line   6)
* emptyhbag function:                    Operations<4>.       (line   6)
* emptyhdict function:                   Operations<3>.       (line   6)
* emptyheap function:                    Operations<2>.       (line   6)
* emptyhmdict function:                  Operations<3>.       (line   6)
* emptyhset function:                    Operations<4>.       (line   6)
* emptymdict function:                   Operations<3>.       (line   6)
* emptyset function:                     Operations<4>.       (line   6)
* errno function:                        Errno and Friends.   (line   6)
* eval function:                         Eval and Friends.    (line  29)
* evalcmd function:                      Eval and Friends.    (line  50)
* exactp function:                       Predicates.          (line  49)
* execv function:                        Process Functions.   (line  15)
* execve function:                       Process Functions.   (line  15)
* execvp function:                       Process Functions.   (line  15)
* exit function:                         Other Special Primitives.
                                                              (line   6)
* exp function:                          Basic Math Functions.
                                                              (line  51)
* failed_cond constructor:               Constants and Operators.
                                                              (line  23)
* failed_match constructor:              Constants and Operators.
                                                              (line  23)
* false constant:                        Constants and Operators.
                                                              (line   9)
* fclose function:                       Basic I/O Interface. (line  36)
* fdopen function:                       Basic I/O Interface. (line  26)
* feof function:                         Basic I/O Interface. (line  45)
* ferror function:                       Basic I/O Interface. (line  45)
* fflush function:                       Basic I/O Interface. (line  54)
* fget function:                         Basic I/O Interface. (line  63)
* fgets function:                        Basic I/O Interface. (line  58)
* fileno function:                       Basic I/O Interface. (line  51)
* filter function:                       Common List Functions.
                                                              (line  30)
* first function <1>:                    Operations<4>.       (line  49)
* first function <2>:                    Operations<3>.       (line  67)
* first function <3>:                    Operations<2>.       (line  25)
* first function:                        Operations.          (line  44)
* fix function:                          Basic Combinators.   (line 101)
* fixity function:                       Inspection.          (line 239)
* flip function:                         Basic Combinators.   (line  59)
* float_matrix function:                 Pointers and Matrices.
                                                              (line  35)
* float_pointer function:                Pointers and Matrices.
                                                              (line  21)
* floor function:                        Conversions.         (line  45)
* fnmatch function:                      Shell Globbing.      (line   6)
* foldl function:                        Common List Functions.
                                                              (line  33)
* foldl1 function:                       Common List Functions.
                                                              (line  38)
* foldr function:                        Common List Functions.
                                                              (line  43)
* foldr1 function:                       Common List Functions.
                                                              (line  48)
* fopen function:                        Basic I/O Interface. (line  18)
* force function:                        Other Special Primitives.
                                                              (line  12)
* fork function:                         Additional POSIX Functions.
                                                              (line  20)
* fprintf function:                      Basic I/O Interface. (line 148)
* fputs function:                        Basic I/O Interface. (line  67)
* frac function:                         Conversions.         (line  53)
* fread function:                        Basic I/O Interface. (line  74)
* free function:                         Pointer Operations.  (line  19)
* freopen function:                      Basic I/O Interface. (line  31)
* fscanf function:                       Basic I/O Interface. (line 168)
* fseek function:                        Basic I/O Interface. (line  79)
* fstat function:                        Stat and Friends.    (line  22)
* ftell function:                        Basic I/O Interface. (line  79)
* fun type:                              Prelude Types.       (line  85)
* function type:                         Prelude Types.       (line  77)
* functionp function:                    Predicates.          (line  83)
* funp function:                         Predicates.          (line  74)
* fwrite function:                       Basic I/O Interface. (line  74)
* gcd function:                          Arithmetic.          (line 126)
* get function:                          Expression References.
                                                              (line  20)
* get_byte function:                     Pointer Operations.  (line  35)
* get_constdef function:                 Inspection.          (line 160)
* get_double function:                   Pointer Operations.  (line  35)
* get_float function:                    Pointer Operations.  (line  35)
* get_fundef function:                   Inspection.          (line 139)
* get_int function:                      Pointer Operations.  (line  35)
* get_int64 function:                    Pointer Operations.  (line  35)
* get_interface function:                Inspection.          (line 146)
* get_interface_typedef function:        Inspection.          (line 146)
* get_long function:                     Pointer Operations.  (line  35)
* get_macdef function:                   Inspection.          (line 139)
* get_pointer function:                  Pointer Operations.  (line  35)
* get_ptrtag function:                   Tagged Pointers.     (line  20)
* get_sentry function:                   Sentries.            (line  22)
* get_short function:                    Pointer Operations.  (line  35)
* get_string function:                   Pointer Operations.  (line  35)
* get_typedef function:                  Inspection.          (line 139)
* get_vardef function:                   Inspection.          (line 160)
* getopt function:                       Option Parsing.      (line  14)
* getopt module:                         Additional POSIX Functions.
                                                              (line  43)
* getpid function:                       Additional POSIX Functions.
                                                              (line  23)
* getppid function:                      Additional POSIX Functions.
                                                              (line  23)
* gets function:                         Basic I/O Interface. (line  58)
* gettimeofday function:                 Time Functions.      (line  16)
* glob function:                         Shell Globbing.      (line  10)
* globsym function:                      Eval and Friends.    (line 131)
* gmtime function:                       Time Functions.      (line  94)
* hash function:                         Conversions.         (line   8)
* hash pair:                             Hash Pairs.          (line   6)
* hash rocket:                           Hash Pairs.          (line   6)
* hbag function:                         Operations<4>.       (line  12)
* hbag type:                             Sets and Bags.       (line  22)
* hbagp function:                        Operations<4>.       (line  20)
* hdict function:                        Operations<3>.       (line  12)
* hdict type:                            Dictionaries.        (line  15)
* hdictp function:                       Operations<3>.       (line  21)
* head function:                         Common List Functions.
                                                              (line  53)
* heap function:                         Operations<2>.       (line   9)
* heap module:                           Examples.            (line  58)
* heap type:                             Heaps.               (line  18)
* heapp function:                        Operations<2>.       (line  12)
* hmdict function:                       Operations<3>.       (line  12)
* hmdict type:                           Dictionaries.        (line  23)
* hmdictp function:                      Operations<3>.       (line  21)
* hset function:                         Operations<4>.       (line  12)
* hset type:                             Sets and Bags.       (line  22)
* hsetp function:                        Operations<4>.       (line  20)
* i constant:                            Complex Numbers.     (line  10)
* id function:                           Basic Combinators.   (line  21)
* im function <1>:                       Complex Numbers.     (line  61)
* im function:                           Matrix Inspection and Manipulation.
                                                              (line 103)
* imatrix function:                      Matrix Construction and Conversions.
                                                              (line  84)
* imatrix type:                          Matrix Inspection and Manipulation.
                                                              (line   6)
* imatrixp function:                     Matrix Inspection and Manipulation.
                                                              (line  16)
* index function <1>:                    Basic String Functions.
                                                              (line  57)
* index function:                        Common List Functions.
                                                              (line  56)
* inexactp function:                     Predicates.          (line  49)
* inf constant:                          Special Constants.   (line   6)
* infix constructor:                     Lists and Tuples.    (line  15)
* infix function <1>:                    Operations<3>.       (line  45)
* infix function <2>:                    Operations.          (line  27)
* infix function <3>:                    Record Functions.    (line  57)
* infix function <4>:                    Matrix Functions.    (line  22)
* infix function <5>:                    Basic String Functions.
                                                              (line   6)
* infix function <6>:                    Lists and Tuples.    (line 144)
* infix function:                        Basic Combinators.   (line   8)
* infp function:                         Predicates.          (line  54)
* init function:                         Common List Functions.
                                                              (line  64)
* insert function <1>:                   Operations<4>.       (line  57)
* insert function <2>:                   Operations<3>.       (line  75)
* insert function <3>:                   Operations<2>.       (line  31)
* insert function <4>:                   Operations.          (line  52)
* insert function:                       Record Functions.    (line  65)
* int function <1>:                      Pointer Arithmetic.  (line  18)
* int function:                          Conversions.         (line  11)
* int_matrix function:                   Pointers and Matrices.
                                                              (line  35)
* int_matrix_view function:              Pointers and Matrices.
                                                              (line  51)
* int_pointer function:                  Pointers and Matrices.
                                                              (line  21)
* integer type:                          Prelude Types.       (line  10)
* integerp function:                     Predicates.          (line  40)
* intp function:                         Predicates.          (line  29)
* intval type:                           Semantic Number Predicates and Types.
                                                              (line  31)
* intvalp function:                      Semantic Number Predicates and Types.
                                                              (line  27)
* iterate function:                      List Generators.     (line  18)
* iteraten function:                     List Generators.     (line  22)
* iterwhile function:                    List Generators.     (line  26)
* join function:                         Basic String Functions.
                                                              (line 133)
* key function:                          Hash Pairs.          (line  25)
* keys function <1>:                     Operations<3>.       (line  61)
* keys function:                         Record Functions.    (line  77)
* kill function:                         Additional POSIX Functions.
                                                              (line  34)
* lambda type:                           Prelude Types.       (line  89)
* lambdap function:                      Predicates.          (line  74)
* last function <1>:                     Operations<4>.       (line  49)
* last function <2>:                     Operations<3>.       (line  67)
* last function <3>:                     Operations.          (line  44)
* last function:                         Common List Functions.
                                                              (line  67)
* lasterr function:                      Eval and Friends.    (line  59)
* lasterrpos function:                   Eval and Friends.    (line  67)
* lcd function:                          Arithmetic.          (line 126)
* list arithmetic sequence:              Lists and Tuples.    (line 182)
* list concatenation:                    Lists and Tuples.    (line  84)
* list equality:                         Lists and Tuples.    (line 115)
* list function <1>:                     Operations<4>.       (line  44)
* list function <2>:                     Operations<3>.       (line  56)
* list function <3>:                     Operations<2>.       (line  21)
* list function <4>:                     Operations.          (line  36)
* list function <5>:                     Matrix Construction and Conversions.
                                                              (line 112)
* list function <6>:                     Basic String Functions.
                                                              (line 102)
* list function:                         Lists and Tuples.    (line 234)
* list indexing:                         Lists and Tuples.    (line 144)
* list size:                             Lists and Tuples.    (line 131)
* list slicing:                          Lists and Tuples.    (line 157)
* list type:                             Prelude Types.       (line  48)
* list2 function <1>:                    Operations.          (line  40)
* list2 function:                        Matrix Construction and Conversions.
                                                              (line 112)
* listmap function:                      Common List Functions.
                                                              (line  70)
* listp function:                        Predicates.          (line  61)
* lists:                                 Lists and Tuples.    (line   6)
* ln function:                           Basic Math Functions.
                                                              (line  51)
* localtime function:                    Time Functions.      (line  94)
* log function:                          Basic Math Functions.
                                                              (line  51)
* lstat function:                        Stat and Friends.    (line  17)
* make_ptrtag function:                  Tagged Pointers.     (line  28)
* malloc function:                       Pointer Operations.  (line  19)
* malloc_error constructor:              Constants and Operators.
                                                              (line  23)
* map function:                          Common List Functions.
                                                              (line  76)
* matcat function:                       Matrix Inspection and Manipulation.
                                                              (line  75)
* math module:                           Mathematical Functions.
                                                              (line   6)
* matrix dimensions:                     Matrix Functions.    (line   6)
* matrix function <1>:                   Matrix Construction and Conversions.
                                                              (line   6)
* matrix function:                       Basic String Functions.
                                                              (line 106)
* matrix size:                           Matrix Functions.    (line   6)
* matrixp function:                      Predicates.          (line  29)
* max function:                          Arithmetic.          (line 117)
* mdict function:                        Operations<3>.       (line  12)
* mdict type:                            Dictionaries.        (line  19)
* mdictp function:                       Operations<3>.       (line  21)
* member function <1>:                   Operations<4>.       (line  41)
* member function <2>:                   Operations<3>.       (line  53)
* member function:                       Record Functions.    (line  54)
* members function <1>:                  Operations<4>.       (line  44)
* members function <2>:                  Operations<3>.       (line  56)
* members function <3>:                  Operations<2>.       (line  21)
* members function:                      Operations.          (line  36)
* members2 function:                     Operations.          (line  40)
* min function:                          Arithmetic.          (line 117)
* mkarray function:                      Operations.          (line  15)
* mkarray2 function:                     Operations.          (line  18)
* mkdict function:                       Operations<3>.       (line  27)
* mkhdict function:                      Operations<3>.       (line  27)
* mkhmdict function:                     Operations<3>.       (line  27)
* mkmdict function:                      Operations<3>.       (line  27)
* mktime function:                       Time Functions.      (line 102)
* mod infix function:                    Arithmetic.          (line  69)
* nan constant:                          Special Constants.   (line   6)
* nanosleep function:                    Time Functions.      (line  31)
* nanp function:                         Predicates.          (line  54)
* nargs function:                        Inspection.          (line 229)
* nmatrix type:                          Matrix Inspection and Manipulation.
                                                              (line   6)
* nmatrixp function:                     Matrix Inspection and Manipulation.
                                                              (line  16)
* not prefix function:                   Arithmetic.          (line  89)
* NULL constant:                         Special Constants.   (line  12)
* null function <1>:                     Operations<4>.       (line  38)
* null function <2>:                     Operations<3>.       (line  50)
* null function <3>:                     Operations<2>.       (line  18)
* null function <4>:                     Operations.          (line  33)
* null function <5>:                     Predicates.          (line  58)
* null function <6>:                     Matrix Functions.    (line  18)
* null function <7>:                     Basic String Functions.
                                                              (line  22)
* null function:                         Lists and Tuples.    (line 212)
* num function:                          Rational Numbers.    (line  45)
* number type:                           Prelude Types.       (line  10)
* numberp function:                      Predicates.          (line  40)
* operators:                             Constants and Operators.
                                                              (line  45)
* or infix function:                     Arithmetic.          (line  89)
* ord function:                          Basic String Functions.
                                                              (line  80)
* out_of_bounds constructor:             Constants and Operators.
                                                              (line  41)
* pack function:                         Matrix Inspection and Manipulation.
                                                              (line 109)
* packed function:                       Matrix Inspection and Manipulation.
                                                              (line 109)
* pause function:                        Additional POSIX Functions.
                                                              (line  40)
* pclose function:                       Basic I/O Interface. (line  36)
* perror function:                       Errno and Friends.   (line   6)
* pi constant:                           Basic Math Functions.
                                                              (line  11)
* pointer function <1>:                  Conversions.         (line  16)
* pointer function:                      Pointers and Matrices.
                                                              (line  13)
* pointer_cast function:                 Tagged Pointers.     (line  85)
* pointer_tag function:                  Tagged Pointers.     (line  68)
* pointer_type function:                 Tagged Pointers.     (line  77)
* pointerp function:                     Predicates.          (line  29)
* pointers module:                       Expression References.
                                                              (line  36)
* polar function:                        Complex Numbers.     (line  47)
* popen function:                        Basic I/O Interface. (line  18)
* posix module:                          Additional POSIX Functions.
                                                              (line   8)
* pow function:                          Arithmetic.          (line 132)
* pred function:                         Arithmetic.          (line 122)
* printf function:                       Basic I/O Interface. (line 148)
* ptrtag function:                       Tagged Pointers.     (line  16)
* put function:                          Expression References.
                                                              (line  17)
* put_byte function:                     Pointer Operations.  (line  47)
* put_double function:                   Pointer Operations.  (line  47)
* put_float function:                    Pointer Operations.  (line  47)
* put_int function:                      Pointer Operations.  (line  47)
* put_int64 function:                    Pointer Operations.  (line  47)
* put_long function:                     Pointer Operations.  (line  47)
* put_pointer function:                  Pointer Operations.  (line  47)
* put_short function:                    Pointer Operations.  (line  47)
* put_string function:                   Pointer Operations.  (line  47)
* puts function:                         Basic I/O Interface. (line  67)
* raise function:                        Additional POSIX Functions.
                                                              (line  37)
* random function:                       Basic Math Functions.
                                                              (line  27)
* random31 function:                     Basic Math Functions.
                                                              (line  31)
* random53 function:                     Basic Math Functions.
                                                              (line  34)
* rational function:                     Rational Numbers.    (line  34)
* rational type:                         Prelude Types.       (line  10)
* rationalp function:                    Predicates.          (line  40)
* ratval type:                           Semantic Number Predicates and Types.
                                                              (line  31)
* ratvalp function:                      Semantic Number Predicates and Types.
                                                              (line  19)
* re function <1>:                       Complex Numbers.     (line  61)
* re function:                           Matrix Inspection and Manipulation.
                                                              (line 103)
* readdir function:                      Reading Directories. (line   6)
* real type:                             Prelude Types.       (line  10)
* realloc function:                      Pointer Operations.  (line  19)
* realp function:                        Predicates.          (line  40)
* realval type:                          Semantic Number Predicates and Types.
                                                              (line  31)
* realvalp function:                     Semantic Number Predicates and Types.
                                                              (line  16)
* record function:                       Record Functions.    (line  40)
* record type:                           Record Functions.    (line  32)
* recordp function:                      Record Functions.    (line  37)
* rect function:                         Complex Numbers.     (line  47)
* redim function:                        Matrix Inspection and Manipulation.
                                                              (line 121)
* reduce macro:                          Eval and Friends.    (line 162)
* reduce_with function:                  Eval and Friends.    (line 172)
* ref function:                          Expression References.
                                                              (line  14)
* refp function:                         Expression References.
                                                              (line  28)
* reg function:                          Regex Matching.      (line 102)
* reg_info function:                     Regex Matching.      (line  99)
* reg_result function:                   Regex Matching.      (line  94)
* regex function:                        Regex Matching.      (line  24)
* regex module:                          Regex Matching.      (line   6)
* regexg function:                       Regex Matching.      (line 114)
* regexgg function:                      Regex Matching.      (line 121)
* regexggs function:                     Regex Matching.      (line 142)
* regexgs function:                      Regex Matching.      (line 142)
* regs function:                         Regex Matching.      (line 106)
* regsplit function:                     Regex Matching.      (line 133)
* regsplits function:                    Regex Matching.      (line 142)
* regsub function:                       Regex Matching.      (line 124)
* repeat function:                       List Generators.     (line  31)
* repeatn function:                      List Generators.     (line  34)
* reverse function <1>:                  Matrix Inspection and Manipulation.
                                                              (line 171)
* reverse function:                      Lists and Tuples.    (line 222)
* rewind function:                       Basic I/O Interface. (line  79)
* rlist type:                            Prelude Types.       (line  48)
* rlistp function:                       Predicates.          (line  61)
* rmfirst function <1>:                  Operations<4>.       (line  53)
* rmfirst function <2>:                  Operations<3>.       (line  71)
* rmfirst function <3>:                  Operations<2>.       (line  28)
* rmfirst function:                      Operations.          (line  48)
* rmlast function <1>:                   Operations<4>.       (line  53)
* rmlast function <2>:                   Operations<3>.       (line  71)
* rmlast function:                       Operations.          (line  48)
* round function:                        Conversions.         (line  49)
* row function:                          Matrix Inspection and Manipulation.
                                                              (line  42)
* rowcat function:                       Matrix Inspection and Manipulation.
                                                              (line  65)
* rowcatmap function:                    Matrix Inspection and Manipulation.
                                                              (line  84)
* rowmap function:                       Matrix Inspection and Manipulation.
                                                              (line  84)
* rowrev function:                       Matrix Inspection and Manipulation.
                                                              (line 171)
* rows function:                         Matrix Inspection and Manipulation.
                                                              (line  46)
* rowvector function:                    Matrix Construction and Conversions.
                                                              (line  22)
* rowvectorp function:                   Matrix Inspection and Manipulation.
                                                              (line  23)
* rowvectorseq function:                 Matrix Construction and Conversions.
                                                              (line  44)
* same function:                         Predicates.          (line  11)
* scanf function:                        Basic I/O Interface. (line 168)
* scanl function:                        Common List Functions.
                                                              (line  79)
* scanl1 function:                       Common List Functions.
                                                              (line  83)
* scanr function:                        Common List Functions.
                                                              (line  88)
* scanr1 function:                       Common List Functions.
                                                              (line  92)
* sentry function:                       Sentries.            (line  15)
* set function:                          Operations<4>.       (line  12)
* set module:                            Examples<3>.         (line 105)
* set type:                              Sets and Bags.       (line  17)
* set_errno function:                    Errno and Friends.   (line   6)
* setbuf function:                       Basic I/O Interface. (line  89)
* setlocale function:                    POSIX Locale.        (line   6)
* setp function:                         Operations<4>.       (line  20)
* setvbuf function:                      Basic I/O Interface. (line  89)
* sgn function:                          Arithmetic.          (line 113)
* short_matrix function:                 Pointers and Matrices.
                                                              (line  35)
* short_pointer function:                Pointers and Matrices.
                                                              (line  21)
* sin function:                          Basic Math Functions.
                                                              (line  56)
* sinh function:                         Basic Math Functions.
                                                              (line  70)
* sleep function:                        Time Functions.      (line  31)
* slice function:                        Slicing.             (line  36)
* smatrix function:                      Matrix Construction and Conversions.
                                                              (line  84)
* smatrix type:                          Matrix Inspection and Manipulation.
                                                              (line   6)
* smatrixp function:                     Matrix Inspection and Manipulation.
                                                              (line  16)
* sort function <1>:                     Matrix Inspection and Manipulation.
                                                              (line 130)
* sort function:                         Common List Functions.
                                                              (line  97)
* spawnv function:                       Process Functions.   (line  32)
* spawnve function:                      Process Functions.   (line  32)
* spawnvp function:                      Process Functions.   (line  32)
* split function:                        Basic String Functions.
                                                              (line 130)
* sprintf function:                      Basic I/O Interface. (line 159)
* sqrt function:                         Basic Math Functions.
                                                              (line  48)
* srandom function:                      Basic Math Functions.
                                                              (line  38)
* sscanf function:                       Basic I/O Interface. (line 184)
* stack_fault constructor:               Constants and Operators.
                                                              (line  23)
* stat function:                         Stat and Friends.    (line   6)
* stderr variable:                       Basic I/O Interface. (line  13)
* stdin variable:                        Basic I/O Interface. (line  13)
* stdout variable:                       Basic I/O Interface. (line  13)
* str function:                          Eval and Friends.    (line  17)
* strcat function:                       Basic String Functions.
                                                              (line 111)
* stream function:                       Lists and Tuples.    (line 260)
* strerror function:                     Errno and Friends.   (line   6)
* strftime function:                     Time Functions.      (line 106)
* stride function:                       Matrix Inspection and Manipulation.
                                                              (line  29)
* string comparisons:                    Basic String Functions.
                                                              (line  36)
* string concatenation:                  Basic String Functions.
                                                              (line   6)
* string function <1>:                   Low-Level Operations.
                                                              (line  15)
* string function:                       Basic String Functions.
                                                              (line 115)
* string indexing:                       Basic String Functions.
                                                              (line   6)
* string size:                           Basic String Functions.
                                                              (line  22)
* string slicing:                        Basic String Functions.
                                                              (line   6)
* string_dup function:                   Low-Level Operations.
                                                              (line  23)
* string_list function:                  Low-Level Operations.
                                                              (line  56)
* string_vector function:                Low-Level Operations.
                                                              (line  60)
* stringp function:                      Predicates.          (line  29)
* strings:                               String Functions.    (line   6)
* strptime function:                     Time Functions.      (line 112)
* subdiag function:                      Matrix Inspection and Manipulation.
                                                              (line  50)
* subdiagmat function:                   Matrix Inspection and Manipulation.
                                                              (line  92)
* submat function:                       Matrix Inspection and Manipulation.
                                                              (line  59)
* subseq function <1>:                   Matrix Inspection and Manipulation.
                                                              (line  35)
* subseq function:                       Slicing.             (line  28)
* subseq2 function:                      Matrix Inspection and Manipulation.
                                                              (line  35)
* substr function:                       Basic String Functions.
                                                              (line  61)
* succ function:                         Arithmetic.          (line 122)
* supdiag function:                      Matrix Inspection and Manipulation.
                                                              (line  50)
* supdiagmat function:                   Matrix Inspection and Manipulation.
                                                              (line  92)
* symbol type:                           Prelude Types.       (line 106)
* symbolp function:                      Predicates.          (line  88)
* system function:                       Process Functions.   (line  12)
* system module:                         Examples<4>.         (line  69)
* tail function:                         Common List Functions.
                                                              (line 112)
* take function:                         Common List Functions.
                                                              (line 115)
* takewhile function:                    Common List Functions.
                                                              (line 118)
* tan function:                          Basic Math Functions.
                                                              (line  56)
* tanh function:                         Basic Math Functions.
                                                              (line  70)
* throw function:                        Other Special Primitives.
                                                              (line   9)
* thunk type:                            Prelude Types.       (line  96)
* thunkp function:                       Predicates.          (line  74)
* time function:                         Time Functions.      (line  11)
* timezone variable:                     Time Functions.      (line  65)
* tmpfile function:                      Basic I/O Interface. (line  40)
* transpose function:                    Matrix Inspection and Manipulation.
                                                              (line 163)
* trap function:                         Signal Handling.     (line   6)
* true constant:                         Constants and Operators.
                                                              (line   9)
* trunc function:                        Conversions.         (line  49)
* tuple equality:                        Lists and Tuples.    (line 115)
* tuple function <1>:                    Matrix Construction and Conversions.
                                                              (line 112)
* tuple function <2>:                    Basic String Functions.
                                                              (line 106)
* tuple function:                        Lists and Tuples.    (line 234)
* tuple indexing:                        Lists and Tuples.    (line 144)
* tuple size:                            Lists and Tuples.    (line 131)
* tuple slicing:                         Lists and Tuples.    (line 157)
* tuple type:                            Prelude Types.       (line  61)
* tuplep function:                       Predicates.          (line  61)
* tuples:                                Lists and Tuples.    (line   6)
* typep function:                        Predicates.          (line  22)
* tzname variable:                       Time Functions.      (line  65)
* tzset function:                        Time Functions.      (line  61)
* ubyte function:                        Conversions.         (line  24)
* uint function:                         Conversions.         (line  24)
* uint64 function:                       Conversions.         (line  24)
* ulong function:                        Conversions.         (line  24)
* uncurry function:                      Basic Combinators.   (line  86)
* uncurry3 function:                     Basic Combinators.   (line  96)
* unref function:                        Expression References.
                                                              (line  23)
* unzip function:                        Zip and Friends.     (line   6)
* unzip3 function:                       Zip and Friends.     (line   9)
* update function <1>:                   Operations<3>.       (line  75)
* update function <2>:                   Operations.          (line  58)
* update function:                       Record Functions.    (line  65)
* update2 function:                      Operations.          (line  61)
* ushort function:                       Conversions.         (line  24)
* val function <1>:                      Expression Serialization.
                                                              (line  23)
* val function <2>:                      Eval and Friends.    (line  21)
* val function:                          Hash Pairs.          (line  25)
* vals function <1>:                     Operations<3>.       (line  64)
* vals function:                         Record Functions.    (line  77)
* var type:                              Prelude Types.       (line 101)
* varp function:                         Predicates.          (line  88)
* vector function:                       Matrix Construction and Conversions.
                                                              (line  22)
* vectorp function:                      Matrix Inspection and Manipulation.
                                                              (line  23)
* vectorseq function:                    Matrix Construction and Conversions.
                                                              (line  44)
* void function:                         Basic Combinators.   (line  33)
* wait function:                         Additional POSIX Functions.
                                                              (line  28)
* waitpid function:                      Additional POSIX Functions.
                                                              (line  28)
* xdict type:                            Dictionaries.        (line  27)
* xset type:                             Sets and Bags.       (line  28)
* zip function:                          Zip and Friends.     (line  12)
* zip3 function:                         Zip and Friends.     (line  17)
* zipwith function:                      Zip and Friends.     (line  20)
* zipwith3 function:                     Zip and Friends.     (line  24)
* || infix function:                     Arithmetic.          (line  83)
* ~ prefix function:                     Arithmetic.          (line  83)
* ~= infix function <1>:                 Pointer Arithmetic.  (line  39)
* ~= infix function <2>:                 Arithmetic.          (line  73)
* ~= infix function <3>:                 Matrix Functions.    (line  63)
* ~= infix function <4>:                 Basic String Functions.
                                                              (line  36)
* ~= infix function <5>:                 Hash Pairs.          (line  16)
* ~= infix function:                     Lists and Tuples.    (line 115)
* ~== infix function:                    Predicates.          (line  11)



Tag Table:
Node: Top245
Ref: 0348
Ref: fdl348
Ref: 1348
Ref: gpl348
Node: Prelude1735
Ref: prelude1826
Ref: 21826
Ref: pure-library-manual1826
Ref: 31826
Ref: 41826
Ref: id11826
Node: Constants and Operators2807
Ref: constants and operators2897
Ref: 52897
Ref: constants-and-operators2897
Ref: 63092
Ref: true3092
Ref: 73115
Ref: false3115
Ref: 83550
Ref: failed_cond3550
Ref: 93579
Ref: failed_match3579
Ref: a3609
Ref: stack_fault3609
Ref: b3638
Ref: malloc_error3638
Ref: c4016
Ref: bad_list_value4016
Ref: d4050
Ref: bad_tuple_value4050
Ref: e4085
Ref: bad_string_value4085
Ref: f4121
Ref: bad_matrix_value4121
Ref: 104336
Ref: out_of_bounds4336
Ref: 114480
Ref: index-04480
Ref: 124480
Ref: operators4480
Node: Prelude Types6061
Ref: prelude types6177
Ref: 136177
Ref: prelude-types6177
Ref: 146177
Ref: id26177
Ref: 156360
Ref: number/type6360
Ref: 166377
Ref: complex/type6377
Ref: 176395
Ref: real/type6395
Ref: 186410
Ref: rational/type6410
Ref: 196429
Ref: integer/type6429
Ref: 1c7831
Ref: char/type7831
Ref: 1e7999
Ref: list/type7999
Ref: 1f8014
Ref: rlist/type8014
Ref: 208699
Ref: tuple/type8699
Ref: 219278
Ref: appl/type9278
Ref: 229480
Ref: function/type9480
Ref: 239845
Ref: fun/type9845
Ref: 249953
Ref: lambda/type9953
Ref: 2510008
Ref: closure/type10008
Ref: 2610162
Ref: thunk/type10162
Ref: 2710341
Ref: var/type10341
Ref: 2810504
Ref: symbol/type10504
Node: Basic Combinators10851
Ref: basic combinators10960
Ref: 2c10960
Ref: basic-combinators10960
Ref: 2d11005
Ref: index-111005
Ref: 2e11075
Ref: $11075
Ref: 2f11095
Ref: 11095
Ref: 3011418
Ref: id11418
Ref: 3111437
Ref: cst11437
Ref: 3211663
Ref: void11663
Ref: 3512665
Ref: flip12665
Ref: 3612995
Ref: curry12995
Ref: 3713278
Ref: uncurry13278
Ref: 3813526
Ref: curry313526
Ref: 3913549
Ref: uncurry313549
Ref: 3a13703
Ref: fix13703
Ref: 3b14509
Ref: fixpoint14509
Node: Lists and Tuples14509
Ref: lists and tuples14612
Ref: 1d14612
Ref: lists-and-tuples14612
Ref: 3c14655
Ref: index-214655
Ref: 3d14655
Ref: index-314655
Ref: 3e14876
Ref: []14876
Ref: 4017617
Ref: index-417617
Ref: 3f17617
Ref: +/list17617
Ref: 4218768
Ref: index-518768
Ref: 4318768
Ref: index-618768
Ref: 4418768
Ref: ==/list18768
Ref: 4518789
Ref: ~=/list18789
Ref: 4719281
Ref: index-719281
Ref: 4819281
Ref: index-819281
Ref: 4919281
Ref: #19281
Ref: 4a19619
Ref: index-919619
Ref: 4b19619
Ref: index-1019619
Ref: 4c19619
Ref: !19619
Ref: 4d19967
Ref: index-1119967
Ref: 4e19967
Ref: index-1219967
Ref: 4f19967
Ref: !!19967
Ref: 5120922
Ref: index-1320922
Ref: 5221831
Ref: null21831
Ref: 5321963
Ref: reverse21963
Ref: 5422188
Ref: list22188
Ref: 5522209
Ref: tuple22209
Ref: 5622830
Ref: stream22830
Node: Slicing23183
Ref: slicing23279
Ref: 5023279
Ref: 5a24471
Ref: subseq24471
Ref: 5b24865
Ref: slice24865
Node: Hash Pairs25622
Ref: hash pairs25716
Ref: 5c25716
Ref: hash-pairs25716
Ref: 5d25747
Ref: index-1425747
Ref: 6026099
Ref: =>26099
Ref: 6126189
Ref: ==/hashpair26189
Ref: 6226210
Ref: ~=/hashpair26210
Ref: 5e26329
Ref: key26329
Ref: 5f26354
Ref: val26354
Node: List Functions26978
Ref: list functions27081
Ref: 6327081
Ref: list-functions27081
Node: Common List Functions27479
Ref: common list functions27576
Ref: 6427576
Ref: common-list-functions27576
Ref: 6527633
Ref: any27633
Ref: 6627730
Ref: all27730
Ref: 6727827
Ref: cat27827
Ref: 5927882
Ref: catmap27882
Ref: 3328041
Ref: do28041
Ref: 6828184
Ref: drop28184
Ref: 6928257
Ref: dropwhile28257
Ref: 6a28373
Ref: filter28373
Ref: 6b28473
Ref: foldl28473
Ref: 6c28668
Ref: foldl128668
Ref: 6d28883
Ref: foldr28883
Ref: 6e29078
Ref: foldr129078
Ref: 6f29293
Ref: head29293
Ref: 7029377
Ref: 7129711
Ref: init29711
Ref: 7229802
Ref: last29802
Ref: 7329885
Ref: listmap29885
Ref: 3430139
Ref: map30139
Ref: 7430201
Ref: scanl30201
Ref: 7530371
Ref: scanl130371
Ref: 7630546
Ref: scanr30546
Ref: 7730716
Ref: scanr130716
Ref: 7830891
Ref: sort30891
Ref: 7931416
Ref: tail31416
Ref: 7a31508
Ref: take31508
Ref: 7b31579
Ref: takewhile31579
Node: List Generators31693
Ref: list generators31814
Ref: 7c31814
Ref: list-generators31814
Ref: 7d32102
Ref: cycle32102
Ref: 7e32199
Ref: cyclen32199
Ref: 7f32315
Ref: iterate32315
Ref: 8032424
Ref: iteraten32424
Ref: 8132548
Ref: iterwhile32548
Ref: 8232737
Ref: repeat32737
Ref: 8332801
Ref: repeatn32801
Node: Zip and Friends32897
Ref: zip and friends32988
Ref: 8432988
Ref: zip-and-friends32988
Ref: 8533033
Ref: unzip33033
Ref: 8633130
Ref: unzip333130
Ref: 8733192
Ref: zip33192
Ref: 8833365
Ref: zip333365
Ref: 8933458
Ref: zipwith33458
Ref: 8a33572
Ref: zipwith333572
Ref: 8b33957
Ref: dowith33957
Ref: 8c34083
Ref: dowith334083
Node: String Functions34220
Ref: string functions34329
Ref: 8d34329
Ref: string-functions34329
Ref: 8e34329
Ref: id334329
Ref: 8f34372
Ref: index-1534372
Node: Basic String Functions34934
Ref: basic string functions35039
Ref: 9135039
Ref: basic-string-functions35039
Ref: 9235098
Ref: index-1635098
Ref: 9335098
Ref: index-1735098
Ref: 9435098
Ref: index-1835098
Ref: 9535098
Ref: +/string35098
Ref: 9635118
Ref: !/string35118
Ref: 9735138
Ref: !!/string35138
Ref: 9835424
Ref: index-1935424
Ref: 9935424
Ref: null/string35424
Ref: 9a35445
Ref: #/string35445
Ref: 9b35653
Ref: index-2035653
Ref: 9c35653
Ref: ==/string35653
Ref: 9d35674
Ref: ~=/string35674
Ref: 9e35695
Ref: <=/string35695
Ref: 9f35716
Ref: >=/string35716
Ref: a035737
Ref: </string35737
Ref: a135757
Ref: >/string35757
Ref: a236122
Ref: index/string36122
Ref: a336275
Ref: substr36275
Ref: a436911
Ref: ord36911
Ref: a537056
Ref: chr37056
Ref: a637164
Ref: index-2137164
Ref: a737560
Ref: chars37560
Ref: a837582
Ref: list/string37582
Ref: a937655
Ref: tuple/string37655
Ref: aa37677
Ref: matrix/string37677
Ref: ab37793
Ref: strcat37793
Ref: ac37933
Ref: string37933
Ref: ad38381
Ref: split38381
Ref: ae38474
Ref: join38474
Node: Low-Level Operations39595
Ref: low-level operations39700
Ref: b039700
Ref: low-level-operations39700
Ref: b240321
Ref: string/pointer40321
Ref: b140344
Ref: cstring40344
Ref: b340668
Ref: string_dup40668
Ref: b440695
Ref: cstring_dup40695
Ref: b540986
Ref: byte_string40986
Ref: b641014
Ref: byte_cstring41014
Ref: b742087
Ref: byte_string_pointer42087
Ref: b842124
Ref: byte_cstring_pointer42124
Ref: b942226
Ref: string_list42226
Ref: ba42256
Ref: cstring_list42256
Ref: bb42341
Ref: string_vector42341
Ref: bc42373
Ref: cstring_vector42373
Node: Matrix Functions44691
Ref: matrix functions44802
Ref: bf44802
Ref: matrix-functions44802
Ref: c044802
Ref: id444802
Ref: c144845
Ref: index-2244845
Ref: c244845
Ref: index-2344845
Ref: c344845
Ref: #/matrix44845
Ref: c444863
Ref: dim44863
Ref: c545078
Ref: null/matrix45078
Ref: c645230
Ref: !/matrix45230
Ref: c745250
Ref: !!/matrix45250
Ref: ca46469
Ref: ==/matrix46469
Ref: cb46490
Ref: ~=/matrix46490
Node: Matrix Construction and Conversions47526
Ref: matrix construction and conversions47658
Ref: cc47658
Ref: matrix-construction-and-conversions47658
Ref: cd47743
Ref: matrix47743
Ref: ce48309
Ref: rowvector48309
Ref: cf48336
Ref: colvector48336
Ref: d048363
Ref: vector48363
Ref: d149160
Ref: rowvectorseq49160
Ref: d249196
Ref: colvectorseq49196
Ref: d349232
Ref: vectorseq49232
Ref: d450689
Ref: dmatrix50689
Ref: d550714
Ref: cmatrix50714
Ref: d650739
Ref: imatrix50739
Ref: d750764
Ref: smatrix50764
Ref: d851625
Ref: list/matrix51625
Ref: d951646
Ref: list2/matrix51646
Ref: da51668
Ref: tuple/matrix51668
Node: Matrix Inspection and Manipulation52073
Ref: matrix inspection and manipulation52235
Ref: 2a52235
Ref: matrix-inspection-and-manipulation52235
Ref: db52390
Ref: nmatrix52390
Ref: dc52655
Ref: dmatrixp52655
Ref: dd52680
Ref: cmatrixp52680
Ref: de52705
Ref: imatrixp52705
Ref: df52730
Ref: smatrixp52730
Ref: e052755
Ref: nmatrixp52755
Ref: e152853
Ref: vectorp52853
Ref: e252877
Ref: rowvectorp52877
Ref: e352904
Ref: colvectorp52904
Ref: e453029
Ref: stride53029
Ref: c853315
Ref: subseq/matrix53315
Ref: c953342
Ref: subseq2/matrix53342
Ref: e653623
Ref: row53623
Ref: e753645
Ref: col53645
Ref: e853718
Ref: rows53718
Ref: e953739
Ref: cols53739
Ref: ea53818
Ref: diag53818
Ref: eb53839
Ref: subdiag53839
Ref: ec53865
Ref: supdiag53865
Ref: ed54201
Ref: submat54201
Ref: ee54464
Ref: rowcat54464
Ref: ef54488
Ref: colcat54488
Ref: f054954
Ref: matcat54954
Ref: f155439
Ref: rowcatmap55439
Ref: f255468
Ref: colcatmap55468
Ref: f355497
Ref: rowmap55497
Ref: f455523
Ref: colmap55523
Ref: f555716
Ref: diagmat55716
Ref: f655740
Ref: subdiagmat55740
Ref: f755769
Ref: supdiagmat55769
Ref: f856237
Ref: re/matrix56237
Ref: f956256
Ref: im/matrix56256
Ref: fa56275
Ref: conj/matrix56275
Ref: e556391
Ref: pack56391
Ref: fb56412
Ref: packed56412
Ref: fc57054
Ref: redim57054
Ref: fd57491
Ref: sort/matrix57491
Ref: fe58876
Ref: transpose/matrix58876
Ref: ff58999
Ref: rowrev58999
Ref: 10059022
Ref: colrev59022
Ref: 10159045
Ref: reverse/matrix59045
Node: Pointers and Matrices59203
Ref: pointers and matrices59321
Ref: 10259321
Ref: pointers-and-matrices59321
Ref: 10359798
Ref: pointer/matrix59798
Ref: 10460201
Ref: double_pointer60201
Ref: 10560234
Ref: float_pointer60234
Ref: 10660266
Ref: complex_pointer60266
Ref: 10760300
Ref: complex_float_pointer60300
Ref: 10860340
Ref: int_pointer60340
Ref: 10960370
Ref: short_pointer60370
Ref: 10a60402
Ref: byte_pointer60402
Ref: 10b60836
Ref: double_matrix60836
Ref: 10c60872
Ref: float_matrix60872
Ref: 10d60907
Ref: complex_matrix60907
Ref: 10e60944
Ref: complex_float_matrix60944
Ref: 10f60987
Ref: int_matrix60987
Ref: 11061020
Ref: short_matrix61020
Ref: 11161055
Ref: byte_matrix61055
Ref: 11261606
Ref: double_matrix_view61606
Ref: 11361647
Ref: complex_matrix_view61647
Ref: 11461689
Ref: int_matrix_view61689
Node: Record Functions62139
Ref: record functions62244
Ref: 2b62244
Ref: record-functions62244
Ref: 11562244
Ref: id562244
Ref: 11a63759
Ref: record/type63759
Ref: 11b63930
Ref: recordp63930
Ref: 11c63985
Ref: record63985
Ref: 11e64449
Ref: #/record64449
Ref: 11664627
Ref: member/record64627
Ref: 11f64698
Ref: !/record64698
Ref: 12064846
Ref: !!/record64846
Ref: 11764997
Ref: insert/record64997
Ref: 12165027
Ref: update/record65027
Ref: 12265334
Ref: delete/record65334
Ref: 12365512
Ref: keys/record65512
Ref: 12465533
Ref: vals/record65533
Node: Primitives66780
Ref: primitives66860
Ref: 12566860
Node: Special Constants67720
Ref: special constants67804
Ref: 12667804
Ref: special-constants67804
Ref: 12767855
Ref: inf67855
Ref: 12867873
Ref: nan67873
Node: Arithmetic68273
Ref: arithmetic68377
Ref: 12c68377
Ref: 4171085
Ref: +71085
Ref: 13071105
Ref: -71105
Ref: 13171125
Ref: *71125
Ref: 13271145
Ref: /71145
Ref: 13371165
Ref: ^71165
Ref: 13471327
Ref: -/unary71327
Ref: 13571431
Ref: div71431
Ref: 13671453
Ref: mod71453
Ref: 4671524
Ref: ==71524
Ref: 13771545
Ref: ~=71545
Ref: 13871597
Ref: <=71597
Ref: 13971618
Ref: >=71618
Ref: 13a71639
Ref: >71639
Ref: 13b71659
Ref: <71659
Ref: 13c71698
Ref: ~71698
Ref: 13d71716
Ref: &&71716
Ref: 13e71737
Ref: ||71737
Ref: 13f71891
Ref: not71891
Ref: 14071911
Ref: and71911
Ref: 14171933
Ref: or71933
Ref: 14272059
Ref: <<72059
Ref: 14372080
Ref: >>72080
Ref: 14472878
Ref: abs72878
Ref: 14572898
Ref: sgn72898
Ref: 14672961
Ref: min72961
Ref: 14772983
Ref: max72983
Ref: 14873137
Ref: succ73137
Ref: 14973158
Ref: pred73158
Ref: 14a73236
Ref: gcd73236
Ref: 14b73258
Ref: lcd73258
Ref: 14c73475
Ref: pow73475
Node: Conversions73756
Ref: conversions73853
Ref: 14d73853
Ref: 14e73956
Ref: hash73956
Ref: 14f74032
Ref: int74032
Ref: 15074052
Ref: bigint74052
Ref: 15174075
Ref: double74075
Ref: 15274153
Ref: pointer74153
Ref: 15374558
Ref: ubyte74558
Ref: 15474580
Ref: ushort74580
Ref: 15574603
Ref: uint74603
Ref: 15674624
Ref: uint6474624
Ref: 15774647
Ref: ulong74647
Ref: 15875527
Ref: rounding-functions75527
Ref: 15975579
Ref: floor75579
Ref: 15a75601
Ref: ceil75601
Ref: 15b75644
Ref: round75644
Ref: 15c75666
Ref: trunc75666
Ref: 15d75727
Ref: frac75727
Node: Predicates75966
Ref: predicates76063
Ref: 2976063
Ref: 15e76344
Ref: same76344
Ref: 11d76367
Ref: ===76367
Ref: 15f76389
Ref: ~==76389
Ref: 16076831
Ref: typep76831
Ref: 16177189
Ref: intp77189
Ref: 16277210
Ref: bigintp77210
Ref: 16377234
Ref: doublep77234
Ref: 16477258
Ref: stringp77258
Ref: 16577282
Ref: pointerp77282
Ref: 16677307
Ref: matrixp77307
Ref: 16777381
Ref: charp77381
Ref: 16877444
Ref: numberp77444
Ref: 16977468
Ref: complexp77468
Ref: 16a77493
Ref: realp77493
Ref: 16b77515
Ref: rationalp77515
Ref: 16c77541
Ref: integerp77541
Ref: 16d77754
Ref: exactp77754
Ref: 16e77777
Ref: inexactp77777
Ref: 12977892
Ref: infp77892
Ref: 12a77913
Ref: nanp77913
Ref: 12b77994
Ref: null/pointer77994
Ref: 16f78046
Ref: applp78046
Ref: 17078068
Ref: listp78068
Ref: 17178090
Ref: rlistp78090
Ref: 17278113
Ref: tuplep78113
Ref: 17378625
Ref: funp78625
Ref: 17478646
Ref: lambdap78646
Ref: 17578670
Ref: thunkp78670
Ref: 17678693
Ref: closurep78693
Ref: 17778940
Ref: functionp78940
Ref: 17879158
Ref: symbolp79158
Ref: 17979182
Ref: varp79182
Node: Inspection79640
Ref: inspection79742
Ref: 17a79742
Ref: 17b80053
Ref: ans80053
Ref: 17c80552
Ref: __func__80552
Ref: 17e81804
Ref: __namespace__81804
Ref: 17f82203
Ref: __list__82203
Ref: 18082943
Ref: __locals__82943
Ref: 18485475
Ref: get_fundef85475
Ref: 18585504
Ref: get_typedef85504
Ref: 18685534
Ref: get_macdef85534
Ref: 18785723
Ref: get_interface85723
Ref: 18885755
Ref: get_interface_typedef85755
Ref: 18986562
Ref: get_vardef86562
Ref: 18a86591
Ref: get_constdef86591
Ref: 18c86964
Ref: add_fundef86964
Ref: 18d86995
Ref: add_typedef86995
Ref: 18e87027
Ref: add_macdef87027
Ref: 18f87265
Ref: add_fundef_at87265
Ref: 19087301
Ref: add_typedef_at87301
Ref: 19187338
Ref: add_macdef_at87338
Ref: 19287681
Ref: add_interface87681
Ref: 19387871
Ref: add_interface_at87871
Ref: 19488118
Ref: add_vardef88118
Ref: 19588149
Ref: add_constdef88149
Ref: 19688501
Ref: del_fundef88501
Ref: 19788531
Ref: del_typedef88531
Ref: 19888562
Ref: del_macdef88562
Ref: 19988847
Ref: del_interface88847
Ref: 19a88999
Ref: del_vardef88999
Ref: 19b89028
Ref: del_constdef89028
Ref: 19c89540
Ref: nargs89540
Ref: 19d89768
Ref: arity89768
Ref: 19e90005
Ref: fixity90005
Node: Eval and Friends92381
Ref: eval and friends92497
Ref: 9092497
Ref: eval-and-friends92497
Ref: 17d93229
Ref: str93229
Ref: 1a093338
Ref: val/string93338
Ref: 18293732
Ref: eval93732
Ref: 18394904
Ref: evalcmd94904
Ref: 18b95394
Ref: lasterr95394
Ref: 1a195829
Ref: lasterrpos95829
Ref: 1a298099
Ref: __str__98099
Ref: 1a398454
Ref: globsym98454
Ref: 1a498910
Ref: clearsym98910
Ref: 18199499
Ref: reduce99499
Ref: 1a5100012
Ref: reduce_with100012
Node: Expression Serialization102117
Ref: expression serialization102247
Ref: 19f102247
Ref: expression-serialization102247
Ref: 1a6102993
Ref: blob102993
Ref: 1a7103174
Ref: val/blob103174
Ref: 1a8103317
Ref: blobp103317
Ref: 1a9103696
Ref: #/blob103696
Ref: 1aa103714
Ref: blob_size103714
Ref: 1ab103740
Ref: blob_crc103740
Node: Other Special Primitives105392
Ref: other special primitives105524
Ref: 1ac105524
Ref: other-special-primitives105524
Ref: 1ad105589
Ref: exit105589
Ref: 1ae105671
Ref: throw105671
Ref: 1af105745
Ref: force105745
Node: Pointer Operations105893
Ref: pointer operations106009
Ref: 1b0106009
Ref: pointer-operations106009
Ref: 1b2106344
Ref: addr106344
Ref: 1b3106741
Ref: calloc106741
Ref: 1b4106776
Ref: malloc106776
Ref: 1b5106802
Ref: realloc106802
Ref: 1b6106833
Ref: free106833
Ref: 1b7107438
Ref: get_byte107438
Ref: 1b8107465
Ref: get_short107465
Ref: 1b9107493
Ref: get_int107493
Ref: 1ba107519
Ref: get_int64107519
Ref: 1bb107547
Ref: get_long107547
Ref: 1bc107574
Ref: get_float107574
Ref: 1bd107602
Ref: get_double107602
Ref: 1be107631
Ref: get_string107631
Ref: 1bf107660
Ref: get_pointer107660
Ref: 1c0107812
Ref: put_byte107812
Ref: 1c1107841
Ref: put_short107841
Ref: 1c2107871
Ref: put_int107871
Ref: 1c3107899
Ref: put_int64107899
Ref: 1c4107929
Ref: put_long107929
Ref: 1c5107958
Ref: put_float107958
Ref: 1c6107988
Ref: put_double107988
Ref: 1c7108019
Ref: put_string108019
Ref: 1c8108050
Ref: put_pointer108050
Node: Sentries108232
Ref: sentries108339
Ref: 1c9108339
Ref: 1ca108857
Ref: sentry108857
Ref: 1cb108971
Ref: clear_sentry108971
Ref: 1cc109049
Ref: get_sentry109049
Ref: 1cd109981
Ref: cookedp109981
Ref: 1ce110064
Ref: cooked110064
Node: Tagged Pointers113128
Ref: tagged pointers113238
Ref: 1cf113238
Ref: tagged-pointers113238
Ref: 1d0113238
Ref: id6113238
Ref: 1d1113894
Ref: ptrtag113894
Ref: 1d2114043
Ref: get_ptrtag114043
Ref: 1d3114115
Ref: check_ptrtag114115
Ref: 1d4114345
Ref: make_ptrtag114345
Ref: 1d5115451
Ref: pointer_tag115451
Ref: 1d6115913
Ref: pointer_type115913
Ref: 1d7116297
Ref: pointer_cast116297
Node: Expression References118333
Ref: expression references118453
Ref: 119118453
Ref: expression-references118453
Ref: 1d8118453
Ref: id7118453
Ref: 1d9118993
Ref: ref118993
Ref: 1da119065
Ref: put119065
Ref: 1db119137
Ref: get119137
Ref: 1dc119205
Ref: unref119205
Ref: 1dd119410
Ref: refp119410
Ref: 1b1119691
Ref: module-pointers119691
Node: Pointer Arithmetic119691
Ref: pointer arithmetic119787
Ref: 12e119787
Ref: pointer-arithmetic119787
Ref: 1de120394
Ref: int/pointer120394
Ref: 1df120414
Ref: bigint/pointer120414
Ref: 1e0120893
Ref: +/pointer120893
Ref: 1e1120913
Ref: -/pointer120913
Ref: 1e2120933
Ref: -/pointerdiff120933
Ref: 1e3121423
Ref: ==/pointer121423
Ref: 1e4121444
Ref: ~=/pointer121444
Ref: 1e5121569
Ref: <=/pointer121569
Ref: 1e6121590
Ref: >=/pointer121590
Ref: 1e7121611
Ref: >/pointer121611
Ref: 1e8121631
Ref: </pointer121631
Node: Mathematical Functions121846
Ref: mathematical functions121949
Ref: 1a121949
Ref: module-math121949
Ref: 12f121949
Ref: mathematical-functions121949
Node: Imports122234
Ref: imports122330
Ref: 1e9122330
Node: Basic Math Functions122466
Ref: basic math functions122586
Ref: 1ea122586
Ref: basic-math-functions122586
Ref: 1eb122694
Ref: 1ec122745
Ref: pi122745
Ref: 1f0123472
Ref: mersenne-twister123472
Ref: 1f1123472
Ref: random123472
Ref: 1ed123577
Ref: random31123577
Ref: 1ee123669
Ref: random53123669
Ref: 1ef123778
Ref: srandom123778
Ref: 1f2124205
Ref: sqrt124205
Ref: 1f3124258
Ref: exp124258
Ref: 1f4124278
Ref: ln124278
Ref: 1f5124297
Ref: log124297
Ref: 1f6124377
Ref: sin124377
Ref: 1f7124397
Ref: cos124397
Ref: 1f8124417
Ref: tan124417
Ref: 1f9124468
Ref: asin124468
Ref: 1fa124489
Ref: acos124489
Ref: 1fb124510
Ref: atan124510
Ref: 1fc124570
Ref: atan2124570
Ref: 1fd124720
Ref: sinh124720
Ref: 1fe124741
Ref: cosh124741
Ref: 1ff124762
Ref: tanh124762
Ref: 200124825
Ref: asinh124825
Ref: 201124847
Ref: acosh124847
Ref: 202124869
Ref: atanh124869
Node: Complex Numbers124941
Ref: complex numbers125070
Ref: 203125070
Ref: complex-numbers125070
Ref: 204125188
Ref: i125188
Ref: 205126848
Ref: complex126848
Ref: 206126925
Ref: polar126925
Ref: 207126947
Ref: rect126947
Ref: 208127029
Ref: cis127029
Ref: 209127173
Ref: abs/complex127173
Ref: 20a127193
Ref: arg127193
Ref: 20b127371
Ref: re127371
Ref: 20c127390
Ref: im127390
Ref: 20d127440
Ref: conj127440
Node: Rational Numbers127926
Ref: rational numbers128071
Ref: 12d128071
Ref: rational-numbers128071
Ref: 20e128114
Ref: %128114
Ref: 20f129519
Ref: rational129519
Ref: 210130083
Ref: num130083
Ref: 211130103
Ref: den130103
Node: Semantic Number Predicates and Types130768
Ref: semantic number predicates and types130889
Ref: 1b130889
Ref: semantic-number-predicates-and-types130889
Ref: 212131334
Ref: compvalp131334
Ref: 213131433
Ref: realvalp131433
Ref: 214131499
Ref: ratvalp131499
Ref: 215131646
Ref: bigintvalp131646
Ref: 216131753
Ref: intvalp131753
Ref: 217131864
Ref: compval131864
Ref: 218131882
Ref: realval131882
Ref: 219131900
Ref: ratval131900
Ref: 21a131917
Ref: bigintval131917
Ref: 21b131937
Ref: intval131937
Node: Container Types132166
Ref: container types132278
Ref: 21c132278
Ref: container-types132278
Ref: 57133496
Ref: module-array133496
Node: Arrays133562
Ref: arrays133635
Ref: 21d133635
Ref: 21e133931
Ref: array/type133931
Node: Imports<2>134035
Ref: imports<2>134108
Ref: 21f134108
Ref: id8134108
Node: Operations134249
Ref: operations134339
Ref: 220134339
Ref: 221134374
Ref: emptyarray134374
Ref: 222134428
Ref: array134428
Ref: 223134490
Ref: array2134490
Ref: 224134572
Ref: mkarray134572
Ref: 225134644
Ref: mkarray2134644
Ref: 226134727
Ref: arrayp134727
Ref: 227134786
Ref: #/array134786
Ref: 228134822
Ref: !/array134822
Ref: 229134935
Ref: null/array134935
Ref: 22a134998
Ref: members/array134998
Ref: 22b135022
Ref: list/array135022
Ref: 22c135078
Ref: members2/array135078
Ref: 22d135103
Ref: list2/array135103
Ref: 22e135174
Ref: first/array135174
Ref: 22f135196
Ref: last/array135196
Ref: 230135252
Ref: rmfirst/array135252
Ref: 231135276
Ref: rmlast/array135276
Ref: 232135343
Ref: insert/array135343
Ref: 233135409
Ref: append/array135409
Ref: 234135469
Ref: update/array135469
Ref: 235135541
Ref: update2/array135541
Node: Examples135608
Ref: examples135679
Ref: 236135679
Ref: 237137005
Ref: module-heap137005
Node: Heaps137006
Ref: heaps137100
Ref: 238137100
Ref: 23a137690
Ref: heap/type137690
Node: Imports<3>137818
Ref: imports<3>137893
Ref: 23b137893
Ref: id9137893
Node: Operations<2>138033
Ref: operations<2>138128
Ref: 23c138128
Ref: id10138128
Ref: 23d138163
Ref: emptyheap138163
Ref: 23e138215
Ref: heap138215
Ref: 23f138274
Ref: heapp138274
Ref: 240138330
Ref: #/heap138330
Ref: 241138369
Ref: null/heap138369
Ref: 242138431
Ref: members/heap138431
Ref: 243138455
Ref: list/heap138455
Ref: 244138525
Ref: first/heap138525
Ref: 245138594
Ref: rmfirst/heap138594
Ref: 246138674
Ref: insert/heap138674
Node: Examples<2>138725
Ref: examples<2>138801
Ref: 247138801
Ref: id11138801
Ref: 58138969
Ref: module-dict138969
Node: Dictionaries138970
Ref: dictionaries139071
Ref: 118139071
Ref: 248139374
Ref: dict/type139374
Ref: 249139520
Ref: hdict/type139520
Ref: 24a139661
Ref: mdict/type139661
Ref: 24b139798
Ref: hmdict/type139798
Ref: 24c139920
Ref: xdict/type139920
Node: Imports<4>142000
Ref: imports<4>142082
Ref: 253142082
Ref: id12142082
Node: Operations<3>142222
Ref: operations<3>142324
Ref: 254142324
Ref: id13142324
Ref: 255142359
Ref: emptydict142359
Ref: 256142383
Ref: emptyhdict142383
Ref: 257142408
Ref: emptymdict142408
Ref: 258142433
Ref: emptyhmdict142433
Ref: 259142492
Ref: dict142492
Ref: 25a142514
Ref: hdict142514
Ref: 25b142537
Ref: mdict142537
Ref: 25c142560
Ref: hmdict142560
Ref: 25d142836
Ref: dictp142836
Ref: 25e142858
Ref: hdictp142858
Ref: 25f142881
Ref: mdictp142881
Ref: 260142904
Ref: hmdictp142904
Ref: 261142994
Ref: mkdict142994
Ref: 262143020
Ref: mkhdict143020
Ref: 263143047
Ref: mkmdict143047
Ref: 264143074
Ref: mkhmdict143074
Ref: 265143169
Ref: +/dict143169
Ref: 266143243
Ref: -/dict143243
Ref: 267143329
Ref: */dict143329
Ref: 268143423
Ref: #/dict143423
Ref: 269143504
Ref: !/dict143504
Ref: 26a143689
Ref: null/dict143689
Ref: 26b143756
Ref: member/dict143756
Ref: 24d143835
Ref: members/dict143835
Ref: 26c143859
Ref: list/dict143859
Ref: 24e143961
Ref: keys/dict143961
Ref: 24f144055
Ref: vals/dict144055
Ref: 26d144105
Ref: first/dict144105
Ref: 26e144127
Ref: last/dict144127
Ref: 250144212
Ref: rmfirst/dict144212
Ref: 251144236
Ref: rmlast/dict144236
Ref: 26f144325
Ref: insert/dict144325
Ref: 270144355
Ref: update/dict144355
Ref: 252144676
Ref: delete/dict144676
Ref: 271144824
Ref: delete_val/dict144824
Ref: 272145062
Ref: delete_all/dict145062
Node: Examples<3>146769
Ref: examples<3>146852
Ref: 273146852
Ref: id14146852
Ref: 274149627
Ref: module-set149627
Node: Sets and Bags149628
Ref: sets and bags149715
Ref: 239149715
Ref: sets-and-bags149715
Ref: 275150333
Ref: set/type150333
Ref: 276150347
Ref: bag/type150347
Ref: 277150498
Ref: hset/type150498
Ref: 278150513
Ref: hbag/type150513
Ref: 279150685
Ref: xset/type150685
Node: Imports<5>151847
Ref: imports<5>151930
Ref: 27a151930
Ref: id15151930
Node: Operations<4>152069
Ref: operations<4>152172
Ref: 27b152172
Ref: id16152172
Ref: 27c152207
Ref: emptyset152207
Ref: 27d152230
Ref: emptybag152230
Ref: 27e152253
Ref: emptyhset152253
Ref: 27f152277
Ref: emptyhbag152277
Ref: 280152334
Ref: set152334
Ref: 281152355
Ref: bag152355
Ref: 282152376
Ref: hset152376
Ref: 283152398
Ref: hbag152398
Ref: 284152610
Ref: setp152610
Ref: 285152631
Ref: bagp152631
Ref: 286152652
Ref: hsetp152652
Ref: 287152674
Ref: hbagp152674
Ref: 288152762
Ref: +/set152762
Ref: 289152842
Ref: -/set152842
Ref: 28a152928
Ref: */set152928
Ref: 28b153022
Ref: #/set153022
Ref: 28c153071
Ref: null/set153071
Ref: 28d153138
Ref: member/set153138
Ref: 28e153199
Ref: members/set153199
Ref: 28f153223
Ref: list/set153223
Ref: 290153326
Ref: first/set153326
Ref: 291153348
Ref: last/set153348
Ref: 292153433
Ref: rmfirst/set153433
Ref: 293153457
Ref: rmlast/set153457
Ref: 294153546
Ref: insert/set153546
Ref: 295153654
Ref: delete/set153654
Ref: 296153771
Ref: delete_all/set153771
Node: Examples<4>155017
Ref: examples<4>155101
Ref: 297155101
Ref: id17155101
Ref: 298156927
Ref: module-system156927
Node: System Interface156928
Ref: system interface157023
Ref: be157023
Ref: system-interface157023
Node: Imports<6>157896
Ref: imports<6>157986
Ref: 299157986
Ref: id18157986
Node: Errno and Friends158296
Ref: errno and friends158407
Ref: 29b158407
Ref: errno-and-friends158407
Ref: 29c158452
Ref: errno158452
Ref: 29d158472
Ref: set_errno158472
Ref: 29e158498
Ref: perror158498
Ref: 29f158523
Ref: strerror158523
Node: POSIX Locale158983
Ref: posix locale159099
Ref: 2a0159099
Ref: posix-locale159099
Ref: 2a1159134
Ref: setlocale159134
Node: Signal Handling160528
Ref: signal handling160641
Ref: 2a2160641
Ref: signal-handling160641
Ref: 2a3160682
Ref: trap160682
Node: Time Functions161510
Ref: time functions161628
Ref: 2a4161628
Ref: time-functions161628
Ref: 2a5161888
Ref: time161888
Ref: 2a6162113
Ref: gettimeofday162113
Ref: 2a7162587
Ref: clock162587
Ref: 2a8162875
Ref: sleep162875
Ref: 2a9162897
Ref: nanosleep162897
Ref: 2aa163910
Ref: tzset163910
Ref: 2ab163970
Ref: tzname163970
Ref: 2ac163991
Ref: timezone163991
Ref: 2ad164014
Ref: daylight164014
Ref: 2ae164831
Ref: ctime164831
Ref: 2af164957
Ref: gmtime164957
Ref: 2b0164980
Ref: localtime164980
Ref: 2b3165353
Ref: mktime165353
Ref: 2b1165513
Ref: asctime165513
Ref: 2b2165538
Ref: strftime165538
Ref: 2b4165759
Ref: strptime165759
Node: Process Functions170100
Ref: process functions170222
Ref: 2b5170222
Ref: process-functions170222
Ref: 2bb170547
Ref: system170547
Ref: 2bc170603
Ref: execv170603
Ref: 2bd170633
Ref: execvp170633
Ref: 2be170664
Ref: execve170664
Ref: 2bf171549
Ref: spawnv171549
Ref: 2c0171585
Ref: spawnvp171585
Ref: 2c1171622
Ref: spawnve171622
Node: Basic I/O Interface172985
Ref: basic i/o interface173109
Ref: 2c2173109
Ref: basic-i-o-interface173109
Ref: 2c3173513
Ref: stdin173513
Ref: 2c4173533
Ref: stdout173533
Ref: 2c5173554
Ref: stderr173554
Ref: 2c6173607
Ref: fopen173607
Ref: 2c7173637
Ref: popen173637
Ref: 2c8173952
Ref: fdopen173952
Ref: 2c9174175
Ref: freopen174175
Ref: 2ca174399
Ref: fclose174399
Ref: 2cb174423
Ref: pclose174423
Ref: 2cc174477
Ref: tmpfile174477
Ref: 2cd174666
Ref: feof174666
Ref: 2ce174688
Ref: ferror174688
Ref: 2cf174712
Ref: clearerr174712
Ref: 2d0174830
Ref: fileno174830
Ref: 2d1174920
Ref: fflush174920
Ref: 2d2175026
Ref: fgets175026
Ref: 2d3175049
Ref: gets175049
Ref: 2d4175184
Ref: fget175184
Ref: 2d5175295
Ref: fputs175295
Ref: 2d6175320
Ref: puts175320
Ref: 2d7175565
Ref: fread175565
Ref: 2d8175603
Ref: fwrite175603
Ref: 2d9175771
Ref: fseek175771
Ref: 2da175808
Ref: ftell175808
Ref: 2db175831
Ref: rewind175831
Ref: 2dc176218
Ref: setbuf176218
Ref: 2dd176246
Ref: setvbuf176246
Ref: 2de178619
Ref: gmp178619
Ref: 2df178619
Ref: mpfr178619
Ref: 2e0178619
Ref: printf178619
Ref: 2e1178652
Ref: fprintf178652
Ref: 2e2179194
Ref: sprintf179194
Ref: 2e3179661
Ref: scanf179661
Ref: 2e4179688
Ref: fscanf179688
Ref: 2e5180584
Ref: sscanf180584
Node: Stat and Friends181984
Ref: stat and friends182110
Ref: 2e6182110
Ref: stat-and-friends182110
Ref: 2e7182153
Ref: stat182153
Ref: 2e8182737
Ref: lstat182737
Ref: 2e9182979
Ref: fstat182979
Node: Reading Directories184802
Ref: reading directories184923
Ref: 2ea184923
Ref: reading-directories184923
Ref: 2eb184972
Ref: readdir184972
Node: Shell Globbing185159
Ref: shell globbing185278
Ref: 2ec185278
Ref: shell-globbing185278
Ref: 2ed185319
Ref: fnmatch185319
Ref: 2ee185482
Ref: glob185482
Node: Regex Matching186096
Ref: regex matching186222
Ref: 2ef186222
Ref: module-regex186222
Ref: af186222
Ref: regex-matching186222
Ref: 2f0187154
Ref: regex187154
Ref: 2f1190538
Ref: reg_result190538
Ref: 2f2190742
Ref: reg_info190742
Ref: 2f3190836
Ref: reg190836
Ref: 2f4190986
Ref: regs190986
Ref: 2f5191319
Ref: regexg191319
Ref: 2f6191711
Ref: regexgg191711
Ref: 2f7191828
Ref: regsub191828
Ref: 2f8192356
Ref: regsplit192356
Ref: 2f9192751
Ref: regexgs192751
Ref: 2fa192795
Ref: regexggs192795
Ref: 2fb192840
Ref: regsplits192840
Node: Basic Examples193206
Ref: basic examples193314
Ref: 2fc193314
Ref: basic-examples193314
Node: Regex Substitutions and Splitting195226
Ref: regex substitutions and splitting195356
Ref: 2fd195356
Ref: regex-substitutions-and-splitting195356
Node: Empty Matches196052
Ref: empty matches196178
Ref: 2fe196178
Ref: empty-matches196178
Node: Submatches197086
Ref: submatches197170
Ref: 2ff197170
Node: Additional POSIX Functions198546
Ref: additional posix functions198672
Ref: 2ba198672
Ref: module-posix198672
Ref: 29a198672
Ref: additional-posix-functions198672
Ref: 2b6199272
Ref: fork199272
Ref: 300199317
Ref: getpid199317
Ref: 301199338
Ref: getppid199338
Ref: 2b8199451
Ref: wait199451
Ref: 2b9199477
Ref: waitpid199477
Ref: 2b7199696
Ref: kill199696
Ref: 302199773
Ref: raise199773
Ref: 303199850
Ref: pause199850
Ref: 304199908
Ref: module-getopt199908
Node: Option Parsing199908
Ref: option parsing200011
Ref: bd200011
Ref: option-parsing200011
Ref: 305200297
Ref: getopt200297
Node: Index203435
Ref: index203506

End Tag Table


Local Variables:
coding: utf-8
End:
