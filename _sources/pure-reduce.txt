
====================================================
A Reduce Interface for the Pure Programming Language
====================================================

.. default-domain:: pure
.. module:: reduce

Version 0.1, |today|

| Albert Graef <Dr.Graef@t-online.de>
| Kurt Pagani <kp@scios.ch>

This is a module providing access to the Reduce_ computer algebra system from
Pure. It is based on the `PROC interface`_ (a "procedural" interface to embed
Reduce as a C library). More background information and a discussion of the
interface can be found in the `Embedding REDUCE`_ thread on the Pure mailing
list.

.. _Reduce: http://www.reduce-algebra.com/
.. _PROC interface: http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup
.. _Embedding REDUCE: http://groups.google.com/group/pure-lang/browse_thread/thread/c11e82ca2e9e8cbb

The interface can be found in reduce.pure (in particular, have a look at the
`high-level interface`_ defined near the end of the module), some basic
examples are in reduce_examp.pure. Please note that at present this module is
still experimental and under development. But the basic functionality appears
to work, and you're welcome to discuss the new interface on the mailing list
and/or submit bug reports and patches.

Installation
============

Get the latest source from
http://pure-lang.googlecode.com/files/pure-reduce-0.1.tar.gz.

You'll need both the embedded Reduce library (named reduce.so, reduce.dylib or
reduce.dll, depending on the system you have) and a Reduce image file
(reduce.img) to make this module work. A Makefile is included with this
package so that you can build these yourself from the Reduce sources. (In
principle, this only needs to be done once for the initial installation of
this module, but you may want to repeat this procedure every once in a while
to get the latest Reduce version.)

You can check out the latest Reduce version from its svn repository with the
following command:

.. code-block:: console

   svn co https://reduce-algebra.svn.sourceforge.net/svnroot/reduce-algebra/trunk/ reduce-algebra

This may take a while; Reduce is a *big* package. Once it's finished, just
drop the resulting reduce-algebra directory into the pure-reduce source
directory. Run ``make`` and then (if needed) ``make install`` in the
pure-reduce source directory. You should also run ``make check`` which runs a
few tests in order to verify that the interface works ok (this can be done
without installing the package, but needs the Reduce image and library).

.. note:: In case the above procedure doesn't work for you, there are more
   detailed instructions on how to compile the relevant parts of Reduce in the
   pure_reduce.txt file included in the distribution.
..

Low-Level Interface
===================

The low-level interface is a straight wrapper of the `PROC interface`_,
please check the proc.h file in the Reduce sources for details. These
routines are all in the ``reduce`` namespace. Normally you shouldn't have
to call these functions directly, since we provide a high-level, idiomatic
Pure interface which makes calling Reduce from Pure much more convenient.

..

High-Level Interface
====================

The goal here is to make it easy to run Reduce from Pure; to these ends,
the most important features of the low-level PROC interface are wrapped in
a convenient way. Currently the following variables and functions are
provided:

.. variable:: REDUCE_PATH

   This variable holds a colon-delimited search path used to locate the
   Reduce image file (see :func:`reduce::start` below). By default this
   includes the current directory and the Pure library directory.

.. function:: reduce::start image::string args::smatrix

   Initializes the Reduce system. This is done automatically when loading
   this module, so normally you shouldn't have to call this manually,
   unless the image file isn't found or you want to restart the Reduce
   system with your own image file or your own set of options. In any
   case, this needs to be executed once before calling any other operation
   of this module. When calling this operation manually, you need to
   specify the name of the Reduce image file and any desired extra
   arguments as a string vector. Unless the filename contains a slash,
   :func:`reduce::start` searches the directories in :var:`REDUCE_PATH` for
   the image file. An exception is raised if the image file isn't found.

.. function:: reduce::finish

   Finalizes the Reduce system. You can call this to release the resources
   of the Reduce system. (:func:`reduce::start` also invokes this
   automatically if a Reduce instance is already running, so it isn't
   necessary to call :func:`reduce::finish` in this case.)

.. function:: reduce::verbosity n

   Sets the verbosity level; 0 means no messages at all (which is the
   default when using this module), and the following values may be or'ed
   together to pick what you need:

     1: messages whenever garbage collection happens

     2: messages whenever a module of code is loaded

     4: extra details in the garbage collector messages

.. function:: reduce::load name::string

   Loads Reduce packages. This works like Reduce's ``load_package``
   command; please check the Reduce documentation for details.

.. function:: reduce::switch name:string val::int

   Lets you change global Reduce options. This works like Reduce's ``on``
   and ``off`` declarations; please check the Reduce documentation for
   details.

For convenience, the following operations are in the default namespace:

.. function:: simplify x

   This is the main entry point. It takes an algebraic expression in Pure
   format and tries to simplify it using Reduce. The result is then
   converted back to Pure format. Note that you need to quote ``x`` if you
   want to prevent it from being evaluated on the Pure side.

.. function:: lisp x

   This can be used to execute arbitrary Lisp code, which is sometimes
   necessary to perform special functions in the Reduce system. The result
   is always a Pure list or an atomic value. Note that you need to quote
   ``x`` if you want to prevent it from being evaluated on the Pure
   side. This is to be used with care. At present, the PROC interface isn't
   very forgiving if you try to execute invalid Lisp code; it will most
   likely crash in such cases.

.. function:: declare declsym [foo,bar,...]

   Declare symbols and their properties; please see the Declarations
   section in the Reduce manual for details. The second argument can also
   be a singleton symbol. In the present implementation, ``declsym`` must
   be one of:

   * ``operator`` (declares an operator symbol);

   * ``antisymmetric``, ``symmetric``, ``even``, ``odd``, ``linear``,
     ``noncom`` and ``nonzero`` (declares properties of already declared
     operator symbols);

   * ``depend``, ``nodepend``, ``factor``, ``remfac``, ``order``,
     ``korder`` (declares kernel dependencies and orders). These take both
     symbols and "kernels" as arguments (the latter are simple prefix
     expressions which denote irreducible subterms such as ``cos x``;
     Reduce treats these more or less like variables in algebraic
     simplifications).

.. function:: precision prec::int

   Sets the internal Reduce precision in decimal digits for floating point
   calculations, and returns the previously set precision. This takes
   effect when rounded mode is enabled (``reduce::switch "rounded" 1``).
   Note that at present this only affects Reduce's internal precision,
   floating point values are still returned as double precision numbers in
   Pure land.

At present, this module makes no attempt to capture terminal output such as
error messages produced by Reduce, so you should be prepared to read these
in the terminal in which Pure is running, or capture them yourself using
the output redirection facilities of the shell if needed.

In Pure land, Reduce and Lisp expressions are represented using Pure's
standard curried notation. Some special conversions are applied to
algebraic expressions to make arithmetic operations such as ``+``, ``*``
etc. work as expected. In addition, the ``==``, ``..`` and ``:=`` infix
operators can be used to denote equations, ranges and assignments in
Reduce, respectively. (Note that you may have to quote these in some cases
so that they don't get evaluated on the Pure side.) Also, Reduce's
``arbconst n``, ``arbint n`` and ``arbcomplex n`` terms are mapped to Greek
symbols ``αn``, ``βn`` and ``ζn`` on the Pure side. (All these automatic
conversions can also be turned off on the output side with the ``#!
--disable mapped`` compilation pragma; this may be useful for debugging
purposes.)

Basic Examples
==============

Here is a simple example showing how to start up Reduce and do some
calculations::

  > using reduce;
  Reduce (Free CSL version), 27-Sep-12 ...
  > simplify $ df ((x+5)^3) x;
  3*x^2+30*x+75
  > simplify $ solve (x^2+7) x;
  [x==sqrt 7*i,x==-sqrt 7*i]

Note that the result returned by :func:`simplify` is always a quoted
expression. If the expression can be further reduced on the Pure side,
you'll have to use Pure's :func:`eval` function to force its evaluation::

  > using math;
  > eval ans;
  [x==0.0+:2.64575131106459,x==0.0+:-2.64575131106459]

You can also execute Lisp code in the CSL interpreter hosting the Reduce
system. This is sometimes necessary to access special functionality, but
should be done with care (at present invalid Lisp code can easily crash the
interpreter). For instance::

  > lisp ('list a b c d e);
  [a,b,c,d,e]
  > lisp ('cdr [a,b,[c,d],e]);
  [b,[c,d],e]

Free symbols are quoted automatically, and Pure lists are mapped to
corresponding Lisp lists. If the result is a Lisp list, it will be
converted back to a Pure list. Most simple kinds of Lisp calls should be
doable that way, but don't expect any miracles; the :func:`lisp` function
is provided to access special functionality in the "symbolic mode" of the
Reduce system, not to turn Pure into a full-featured Lisp frontend.

The following example illustrates how you can use the :func:`lisp` function
to declare an operator symbol and change or query its properties::

  > lisp ('operator [myop]);
  []
  > lisp ('flag [myop] odd);
  []
  > lisp ('prop myop);
  [odd:t,simpfn:simpiden]
  > simplify (myop (-x));
  -myop x

If you find it awkward to evaluate Lisp forms in Pure, you can also achieve
the same with the :func:`declare` function which covers most of the common
Reduce declarations that might be needed::

  > declare operator myop;
  []
  > declare odd myop;
  []
  > simplify (myop (-x));
  -myop x

Many more examples can be found in the reduce_examp.pure and tests.pure
scripts included in the distribution.

