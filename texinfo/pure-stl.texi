\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-stl.info
@documentencoding UTF-8
@copying
Generated by Sphinx
@end copying
@settitle pure-stl
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-stl: (pure-stl.info).    pure-stl
@end direntry

@c %**end of header

@titlepage
@title pure-stl
@author Albert Gr√§f (Editor)
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-stl
@end ifnottex

@c %**start of body
@geindex stlvec module
Version 0.1, September 15, 2011

@display
Peter Summerland <@email{p.summerland@@gmail.com}>@w{ }
@end display
Pure's interface to C++ vectors, specialized to hold pointers to arbitrary
Pure expressions, and the C++ Standard Template Library algorithms that act on
them.

@anchor{0}@anchor{pure}
@menu
* Copying::
* Installation::
* Overview::
* Error Handling::
* Basic Operations::
* STL Nonmodifying Algorithms::
* STL Modifying Algorithms::
* STL Sort Algorithms::
* STL Merge Algorithms::
* STL Heap Algorithms::
* Min/Max STL Algorithms::
* STL Numeric Algorithms::
* Trace Mode::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Overview

* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Documentation::
* Parameter Names::

Error Handling

* Exception Symbols::
* Examples::

Basic Operations

* Imports::
* Data Structure::
* Support for Copy-On-Write Semantics::
* Operations::
* Convenience Functions::
* Examples: Examples<2>.

STL Nonmodifying Algorithms

* Imports: Imports<2>.
* Operations: Operations<2>.
* Examples: Examples<3>.

STL Modifying Algorithms

* Imports: Imports<3>.
* Operations: Operations<3>.
* Examples: Examples<4>.

STL Sort Algorithms

* Imports: Imports<4>.
* Operations: Operations<4>.
* Examples: Examples<5>.

STL Merge Algorithms

* Imports: Imports<5>.
* Operations: Operations<5>.
* Examples: Examples<6>.

STL Heap Algorithms

* Imports: Imports<6>.
* Operations: Operations<6>.
* Examples: Examples<7>.

Min/Max STL Algorithms

* Imports: Imports<7>.
* Operations: Operations<7>.
* Examples: Examples<8>.

STL Numeric Algorithms

* Imports: Imports<8>.
* Operations: Operations<8>.
* Examples: Examples<9>.
@end detailmenu
@end menu


@node Copying,Installation,Top,Top
@anchor{copying}@anchor{1}@anchor{module-stlvec}@anchor{2}@anchor{3}
@chapter Copying

@display
Copyright (c) 2011 by Peter Summerland <@email{p.summerland@@gmail.com}>.@w{ }
@end display
All rights reserved.

pure-stlvec is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.

pure-stlvec is distributed under a BSD-style license, see the COPYING file
for details.


@node Installation,Overview,Copying,Top
@anchor{installation}@anchor{4}
@chapter Installation
Get the latest source from
@indicateurl{http://pure-lang.googlecode.com/files/pure-stlvec-0.1.tar.gz}.

To install pure-stlvec (on Linux), extract the source, cd to the pure-stl
directory, and run @code{make}. After this you can (and should) also run @code{make
test} to run a few unit tests to make sure that pure-stl works properly on
your system. If @code{make test} works, run @code{sudo make install} to install
pure-stlvec on your system.  @code{make} tries to guess your Pure installation
directory and platform-specific setup. If it gets this wrong, you can set some
variables manually. In particular, @code{make install prefix=/usr} sets the
installation prefix. Please see the Makefile for details.


@node Overview,Error Handling,Installation,Top
@anchor{overview}@anchor{5}
@chapter Overview
The C++ Standard Template Library ("STL") is a library of generic containers
(data structures designed for storing other objects) and a rich set of generic
algorithms that operate on them. pure-stlvec provides an interface to one of
its most useful containers, "vector", adopted to hold pointers to Pure
expressions. The interface provides Pure programmers with a mutable container
"stlvec", that, like the STL's vector, holds a sequence of objects that can be
accessed in constant time according to their position in the sequence.


@menu
* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Documentation::
* Parameter Names::
@end menu


@node Modules,Simple Examples,,Overview
@anchor{modules}@anchor{6}
@section Modules
The usual operations for creating, accessing and modifying stlvecs are
provided by the stlvec module. The operations are similar in name and
function to those provided by the Pure Library for other containers. As is the
case for their Pure Library counterparts, these operations are in the global
namespace.

In addition to the stlvec module, pure-stlvec provides a group of modules,
sv_modifying, sv_nonmodifying, sv_sort, sv_merge, sv_heap, sv_minmax and
sv_numeric, that are straight wrappers the STL algorithms (specialized to work
with STL vectors of pointers to Pure expressions). This grouping of the STL
algorithms follows that found at
@indicateurl{http://www.cplusplus.com/reference/algorithm/}. This web page contains a table
that summarizes of all of the algorithms in one place.

pure-stlvec provides an "umbrella" module, stlvec_algorithms, that pulls in
all of the STL algorithm interface modules in one go. The STL algorithm
wrapper functions reside in the stl namespace and have the same names as their
counterparts in the STL.


@node Simple Examples,Members and Sequences of Members,Modules,Overview
@anchor{simple examples}@anchor{7}@anchor{simple-examples}
@section Simple Examples
Here are some examples that use the basic operations provided by the
stlvec module.

@example
> using stlvec;

> let sv1 = stlvec (0..4); members sv1;
[0,1,2,3,4]

> insert (sv1,stl::svend) (5..7); members sv1;
STLVEC #<pointer 0xaf4d2c0>
[0,1,2,3,4,5,6,7]

> sv1!3;
3

> update sv1 3 33; members sv1;
STLVEC #<pointer 0xaf4d2c0>
[0,1,2,33,4,5,6,7]

> erase (sv1,2,5); members sv1;
STLVEC #<pointer 0xaf4d2c0>
[0,1,5,6,7]

> insert (sv1,2) [2,3,4];  members sv1;
STLVEC #<pointer 0xaf4d2c0>
[0,1,2,3,4,5,6,7]

 > map (+10) sv1;
[10,11,12,13,14,15,16,17]

> map (+10) (sv1,2,5);
[12,13,14]

> foldl (+) 0 sv1;
28

> [x+10 | x = sv1; x mod 2];
[11,13,15,17]

> @{x+10 | x = (sv1,2,6); x mod 2@};
@{13,15@}
@end example

@noindent
Here are some examples that use STL algorithms.

@example
> using stlvec_algorithms;

> stl::reverse (sv1,2,6); members sv1;
()
[0,1,5,4,3,2,6,7]

> stl::stable_sort sv1 (>); members sv1;
()
[7,6,5,4,3,2,1,0]

> stl::random_shuffle sv1; members sv1;
()
[1,3,5,4,0,7,6,2]

> stl::partition sv1 (<3); members (sv1,0,ans); members sv1;
3
[1,2,0]
[1,2,0,4,5,7,6,3]

> stl::transform sv1 (sv1,0) (*2); members sv1;
-1
[2,4,0,8,10,14,12,6]

> let sv2 = emptystlvec;

> stl::transform sv1 (sv2,stl::svback) (div 2); members sv2;
-1
[1,2,0,4,5,7,6,3]
@end example

@noindent
Many more examples can be found in the pure-stl/ut directory.


@node Members and Sequences of Members,STL Iterators and Value Semantics,Simple Examples,Overview
@anchor{members and sequences of members}@anchor{8}@anchor{members-and-sequences-of-members}
@section Members and Sequences of Members
Throughout the documentation for pure-stlvec, the member of a stlvec that is
at the nth position in the sequence of expressions stored in the stlvec is
referred to as its nth member or nth element. The nth member of a stlvec, sv,
is sometimes denoted by sv!n.  The sequence of members of sv starting at
position i up to but not including j is denoted by sv[i,j). There is a
"past-the-end" symbol, stl::svend, that denotes the position after that
occupied by the last member contained by a stlvec.

For example, if sv contains the sequence "a", "b", "c" "d" and "e", sv!0 is
"a", sv[1,3) is the sequence consisting of "b" followed by "c" and
v[3,stl::svend) denotes the sequence consisting of "d" followed by "e".


@node STL Iterators and Value Semantics,Iterator Tuples,Members and Sequences of Members,Overview
@anchor{stl iterators and value semantics}@anchor{9}@anchor{stl-iterators-and-value-semantics}
@section STL Iterators and Value Semantics
In C++ a programmer accesses a STL container's elements by means of
"iterators", which can be thought of as pointers to the container's
elements. A single iterator can be used to access a specific element, and a
pair of iterators can be used to access a "range" of elements. By convention,
such a range includes the member pointed to by the first iterator and all
succeeding members up to but not including the member pointed to by the second
iterator. Each container has a past-the-end iterator that can be used to
specifiy ranges that include the container's last member.

In the case of vectors there is an obvious correspondence between an iterator
that points to an element and the element's position (starting at zero) in the
vector.  pure-stlvec uses this correspondence to designate a stlvec's members
in a way that makes it relatively easy to see how pure-stlvec's functions are
acting on the stlvec's underlying STL vector by referencing the STL's
documentation. Thus, if sv is a stlvec, and j is an int, "update sv j x" uses
the STL to replace the element pointed to by the iterator for position j of
sv's underlying STL vector. If, in addition, k is an int, stl::sort (sv,j,k)
(<) uses the STL to sort the elements in the range designated by the "jth" and
"kth" iterators for sv's underlying STL vector. This range, written as
sv[j,k), is the subsequence of sv that begins with the element at position j
and ends with the element at position (k-1).

Besides iterators, another cornerstone of the STL is its "value semantics",
i.e., all of the STL containers are mutable and if a container is copied, all
of its elements are copied. pure-stlvec deals with the STL's value semantics
by introducing mutable and nonmutable stlvecs, and by storing smart pointers
to objects (which have cheap copies) rather than the actual objects.


@node Iterator Tuples,Predefined Iterator Tuple Indexes,STL Iterators and Value Semantics,Overview
@anchor{iterator tuples}@anchor{a}@anchor{iterator-tuples}
@section Iterator Tuples
As mentioned in the previous section, in C++ ranges are specified by a pair
of STL iterators.

In pure-stlvec ranges of elements in a stlvec are specified by "iterator
tuples" rather than, say, actual pointers to STL iterators. Iterator tuples
consist of the name of a stlvec followed by one of more ints that indicate
positions (starting from zero) of the stlvec's elements.

To illustrate how iterator tuples are used, consider the STL stable_sort
function, which sorts objects in the range [first, last) in the order imposed
by comp. Its C++ signature looks like this:

@quotation
void stable_sort ( RandomAccessIterator first, RandomAccessIterator last, Compare comp )
@end quotation

The corresponding pure-stlvec function, from the sv_sort module, looks like
this:

@quotation
stable_sort (msv, first, last) comp
@end quotation

where msv is a mutable stlvec, and first and last are ints. The first thing
that the Pure stable_sort does is create a pair of C++ iterators that point to
the elements in msv's underlying STL vector that occupy the positions
designated by first and last.  Next it wraps the Pure comp function in a C++
function object that, along with the two iterators, is passed to the C++
stable_sort function.

For convenience, (sv,stl::svbeg, stl::svend) can be written simply as
sv. Thus, if first were stl::svbeg (or 0), and last were stl::svend (or #msv,
the number of elements in msv), the last Pure call could be written:

@quotation
stable_sort msv comp
@end quotation

It should be noted that often the STL library provides a default version of
functions, which like stable_sort, use a comparator or other callback function
provided by the caller. E.g., the C++ stable_sort has a default version that
assumes the "<" operator can be used on the elements held by the container in
question:

@quotation
void stable_sort ( RandomAccessIterator first, RandomAccessIterator last)
@end quotation

The corresponding functions provided by the pure-stlvec modules rarely, if
ever, supply a default version. A typical example is sv_sort's stable_sort
which must be called with a comparator callback function:

@quotation
stable_sort msv (<);
@end quotation

Note also that the comparator (e.g., (<)), or other function being passed to a
pure-stlvec algorithm wrapper is almost always the last parameter. This
is the opposite of what is required for similar Pure functions, but is
consistent with the STL calling conventions.


@node Predefined Iterator Tuple Indexes,Back Insert Iterators,Iterator Tuples,Overview
@anchor{predefined iterator tuple indexes}@anchor{b}@anchor{predefined-iterator-tuple-indexes}
@section Predefined Iterator Tuple Indexes
The following integer constants are defined in the stl namespace for use
in iterator tuples.

@geindex stl svbeg constant
@geindex stl svend constant
@geindex stl svback constant
@anchor{c}@anchor{stl svbeg}
@deffn {constant} stl::svbeg = 0
@anchor{d}@anchor{stl svend}
@deffnx {constant} stl::svend = -1
@anchor{e}@anchor{stl svback}
@deffnx {constant} stl::svback = -2
@end deffn

@code{svend} corresponds to STL's past-end iterator for STL vectors. It makes it
possible to specify ranges that include the last element of an stlvec. I.e.,
the iterator tuple (sv,stl::svbeg,stl::svend) would specify sv[0,n), where n
is the number of elements in sv. In order to understand the purpose of
@code{svback}, it is necessary to understand a bit about STL's "back insert
iterators."


@node Back Insert Iterators,Documentation,Predefined Iterator Tuple Indexes,Overview
@anchor{back insert iterators}@anchor{f}@anchor{back-insert-iterators}
@section Back Insert Iterators
Many of the STL algorithms insert members into a target range designated by an
iterator that points to the first member of the target range. Consistent with
raw C usage, it is ok to copy over existing elements the target
stlvec. E.g.,:

@example
> using sv_modifying;

> let v1 = stlvec (0..2);

> let v2 = stlvec ("a".."g");

> stl::copy v1 (v3,2) $$ members v3;
["a","b",0,1,2,"f","g"]
@end example

@noindent
This is great for C++ programmers, but for Pure programmers it is almost
always preferable to append the copied items to the end of a target stlvec,
rather than overwriting all or part or part of it. This can be accomplished
using stl::svback. E.g.,:

@example
> let v3 = emptystlvec;

> stl::copy v1 (v3,stl::svback) $$ members v3;
[0,1,2]

> stl::copy v2 (v3,stl::svback) $$ members v3;
[0,1,2,"a","b","c","d","e","f","g"]
@end example

@noindent
In short, when a pure-stlvec function detects "stl::svback" in a target
iterator tuple, it constructs a STL "back inserter iterator" and passes it on
to the corresponding wrapped STL function.


@node Documentation,Parameter Names,Back Insert Iterators,Overview
@anchor{documentation}@anchor{10}
@section Documentation
The documentation of the functions provided by the stlvec module are
reasonably complete.  In contrast, the descriptions of functions provided by
the STL algorithm modules are purposely simplified (and may not, therefore, be
technically accurate). This reflects that fact that the functions provided by
pure-stlvec have an obvious correspondence to the functions provided by the
STL, and the STL is extremely well documented. Furthermore, using the Pure
interpreter, it is very easy to simply play around with with any of the
pure-stlvec functions if there are doubts, especially with respect to "corner
cases."  Often this leads to a deeper understanding compared to reading a
precise technical description.

A good book on the STL is STL Tutorial and Reference Guide, Second Edition, by
David R. Musser, Gillmer J. Derge and Atul Saini. A summmary of all of the STL
algorithms can be found at @indicateurl{http://www.cplusplus.com/reference/stl/}.


@node Parameter Names,,Documentation,Overview
@anchor{parameter names}@anchor{11}@anchor{parameter-names}
@section Parameter Names
In the descriptions of functions that follow, parameter names used in
function descriptions represent specific types of Pure objects:


@table @asis
@item sv
stlvec (mutable or immutable)

@item imsv
immutable stlvec

@item msv
mutable stlvec

@item x
an arbitrary Pure expression

@item xs
a list of arbitrary Pure expressions

@item count, sz, n
whole numbers to indicate a number of elements, size of a vector, etc

@item i,j
whole numbers used to designate indexes into a stlvec

@item f,m,l
whole numbers (or stl::beg or stl::svend) designating the "first", "middle"
or "last" iterators in a stlvec iterator tuple

@item p
a whole number (or other iterator constant such as stl::svend or
stl::svback) used in a two element iterator tuple (e.g., (sv,p))

@item (sv,p)
an iterator tuple that will be mapped to an iterator that points
to the pth position of sv's underlying STL vector, v, (or to a
back iterator on v if p is stl::svback)

@item (sv,f,l)
an iterator tuple that will be mapped to the pair of iterators
that are designated by (sv,f) and (sv,l)

@item (sv,f,m,l)
an iterator tuple that will be mapped to the iterators that
are designated by (sv,f), (sv,m) and (sv,l)

@item sv[f,l)
the range of members beginning with that at (sv,f) up to but not
including that at (con,l)

@item comp
a function that accepts two objects and returns true if the
first argument is less than the second (in the strict
weak ordering defined by comp), and false otherwise

@item unary_pred
a function that accepts one object and returns true or false

@item bin_pred
a function that accepts two objects and returns true or false

@item unary_fun
a function that accepts one objects and returns another

@item bin_fun
a function that accepts two objects and returns another

@item gen_fun
a function of one parameter that produces a sequence of objects,
one for each call (gen_fun 0). E.g., see test_generate in
ut_sv_modifying.pure
@end table

For readability, and to correspond with the STL documentation, the words
"first", "middle", and "last", or variants such as "first1" are often used
instead of f,m,l.


@node Error Handling,Basic Operations,Overview,Top
@anchor{error handling}@anchor{12}@anchor{error-handling}
@chapter Error Handling
The functions provided this module handle errors by throwing exceptions.


@menu
* Exception Symbols::
* Examples::
@end menu


@node Exception Symbols,Examples,,Error Handling
@anchor{exception symbols}@anchor{13}@anchor{exception-symbols}
@section Exception Symbols

@geindex bad_argument constructor
@anchor{14}@anchor{bad_argument}
@deffn {constructor} bad_argument

This exception is thrown when a function is passed an unexpected value. A
subtle error to watch for is a malformed iterator tuple (e.g., one with
the wrong number of elements).
@end deffn

@geindex bad_function constructor
@anchor{15}@anchor{bad_function}
@deffn {constructor} bad_function

This exception is thrown when a purported Pure call-back function is not
even callable.
@end deffn

@geindex failed_cond constructor
@anchor{16}@anchor{failed_cond}
@deffn {constructor} failed_cond

This exception is thrown when a Pure call-back predicate returns a value
that is not an int.
@end deffn

@geindex out_of_bounds constructor
@anchor{17}@anchor{out_of_bounds}
@deffn {constructor} out_of_bounds

This exception is thrown if the specified index is out of bounds.
@end deffn

@geindex range_overflow constructor
@anchor{18}@anchor{range_overflow}
@deffn {constructor} range_overflow

This exception is thrown by functions that write over part of a target
stlvec (e.g., copy) when the target range too small to accommodate the
result.
@end deffn

@geindex range_overlap constructor
@anchor{19}@anchor{range_overlap}
@deffn {constructor} range_overlap

This exception is thrown by algorithm functions that write over part of a
target stlvec when the target and source ranges overlap in a way that is
not allowed.
@end deffn

In addition, any exception thrown by a Pure callback function passed to a
pure-stlvec function will be caught and be rethrown by the pure-stlvec
function.


@node Examples,,Exception Symbols,Error Handling
@anchor{examples}@anchor{1a}
@section Examples

@example
> using stlvec, sv_modifying;

> let sv1 = stlvec (0..4); members sv1;
[0,1,2,3,4]

> let sv2 = stlvec ("a".."e"); members sv2;
["a","b","c","d","e"]

> sv1!10;
<stdin>, line 25: unhandled exception 'out_of_bounds' ...

> stl::copy sv1 (sv2,10);
<stdin>, line 26: unhandled exception 'out_of_bounds' ...

> stl::copy sv1 (sv2,2,3); // sb (sv2,pos)
<stdin>, line 22: unhandled exception 'bad_argument' ...

> stl::copy sv1 (sv2,2);
<stdin>, line 23: unhandled exception 'range_overflow' ...

> stl::copy sv2 (sv2,2);
<stdin>, line 24: unhandled exception 'range_overlap' ...

> stl::copy (sv1,1,3) (sv2,0); members sv2; // ok
2
[1,2,"c","d","e"]

> stl::sort sv2 (>); // apples and oranges
<stdin>, line 31: unhandled exception 'failed_cond'

> listmap (\x->throw DOA) sv1; // callback function throws exception
<stdin>, line 34: unhandled exception 'DOA' ...
@end example

@noindent

@node Basic Operations,STL Nonmodifying Algorithms,Error Handling,Top
@anchor{basic operations}@anchor{1b}@anchor{basic-operations}
@chapter Basic Operations
The stlvec module provides functions for creating, accessing and modifying
stlvecs. They are all in the global namespace.


@menu
* Imports::
* Data Structure::
* Support for Copy-On-Write Semantics::
* Operations::
* Convenience Functions::
* Examples: Examples<2>.
@end menu


@node Imports,Data Structure,,Basic Operations
@anchor{imports}@anchor{1c}
@section Imports
To use the operations of this module, add the following import declaration
to your program:

@example
using stlvec;
@end example

@noindent

@node Data Structure,Support for Copy-On-Write Semantics,Imports,Basic Operations
@anchor{data structure}@anchor{1d}@anchor{data-structure}
@section Data Structure
Currently, stlvecs are of the form (STLVEC x) or (CONST_STLVEC x), where x is
a pointer to the underlying STL vector. E.g.:

@example
> let v1 = stlvec (0..3); v1;
STLVEC #<pointer 0x915c8e0>

> members v1;
[0,1,2,3]

> let v2 = stlconst $ stlvec (0..3); v2;
CONST_STLVEC #<pointer 0x8c1dbf0>
@end example

@noindent
This representation may change in the future, and must not be relied upon
by client modules. In particular, one must never attempt to use the
embedded pointer directly.

Three type tags are provided:

@geindex mutable_stlvec type
@anchor{1e}@anchor{mutable_stlvec/type}
@deffn {type} mutable_stlvec

The type for a mutable stlvec. The stlvec must have been constructed with
STLVEC.
@end deffn

@geindex const_stlvec type
@anchor{1f}@anchor{const_stlvec/type}
@deffn {type} const_stlvec

The type for an immutable stlvec. The stlvec must have been constructed
with CONST_STLVEC.
@end deffn

@geindex stlvec type
@anchor{20}@anchor{stlvec/type}
@deffn {type} stlvec

The type for a stlvec, mutable or immutable. The stvec can be constructed
with STLVEC or CONST_STLVEC.
@end deffn

Functions that modify a stlvec will simply fail unless the stlvec is
mutable:

@example
> update v2 0 100;
update (CONST_STLVEC #<pointer 0x9f07690>) 0 100
@end example

@noindent

@node Support for Copy-On-Write Semantics,Operations,Data Structure,Basic Operations
@anchor{support for copy-on-write semantics}@anchor{21}@anchor{support-for-copy-on-write-semantics}
@section Support for Copy-On-Write Semantics
The functions that create new stlvecs (emptystlvec, stlvec, and mkstlvec) all
return mutable stlvecs. For those that prefer immutable data structures,
stlvecs can be converted to immutable stlvecs (usually after they have been
created and modified within a function) by the @code{stlconst} function. This
function converts a mutable stlvec to an immutable stlvec without changing the
underlying STL vector.

Using a copy-on-write strategy it is possible to use stlvecs in a manner that
is consistent with functional programming.  Typically, a function that
"updates" a stlvec passed to it as an argument will copy the input stlvec to a
new locally scoped mutable stlvec, modify the new stlvec and use stlconst to
make the new stlvec immutable before it is returned. It should be noted that
several of the STL algorithms have "copy" versions which place their results
directly into a new stlvec, which can eliminate the need to copy the input
stlvec. E.g.:

@example
> let sv1 = stlvec ("a".."e");

> let sv2 = emptystlvec;

> stl::reverse_copy sv1 (sv2,stl::svback) $$ members sv2;
["e","d","c","b","a"]
@end example

@noindent
Without reverse_copy, one have to copy sv1 into sv2 and then reverse sv2.


@node Operations,Convenience Functions,Support for Copy-On-Write Semantics,Basic Operations
@anchor{operations}@anchor{22}
@section Operations
When reading the function descriptions that follow, please bear in mind
that whenever a function is passed an iterator tuple of the form (sv,first,
last), first and last can be dropped, leaving (sv), or simply sv. The
function will treat the "unary" iterator tuple (sv) as (sv, stl::svbeg,
stl::svend).

@geindex emptystlvec function
@anchor{23}@anchor{emptystlvec}
@deffn {Function} emptystlvec

return an empty stlvec
@end deffn

@geindex stlvec function
@anchor{24}@anchor{stlvec}
@deffn {Function} stlvec (sv,first,last)

create a new stlvec consisting of the elements in sv[first,last)
@end deffn

@geindex stlvec function
@deffn {Function} stlvec xs

create a new stlvec from a list of values
@end deffn

@geindex mkstlvec function
@anchor{25}@anchor{mkstlvec}
@deffn {Function} mkstlvec x count

create a new stlvec consisting of count x's.
@end deffn

@geindex stlconst function
@anchor{26}@anchor{stlconst}
@deffn {Function} stlconst sv

create an immutable stlvec that shares the same underlying STL vector
with sv
@end deffn

@geindex # prefix function
@anchor{27}@anchor{#}
@deffn {Function} # sv

return the size of sv
@end deffn

@geindex reserve function
@anchor{28}@anchor{reserve}
@deffn {Function} reserve msv count

modify the underlying STL vector have at least count slots, usually to
speed up addition of new members
@end deffn

@geindex capacity function
@anchor{29}@anchor{capacity}
@deffn {Function} capacity sv

return the total amount of slots held by the underlying STL vector
@end deffn

@geindex null function
@anchor{2a}@anchor{null}
@deffn {Function} null sv

test whether sv is empty
@end deffn

@geindex infix function
@anchor{2b}@anchor{!}
@deffn {Function} sv ! i

return the ith member of sv
@end deffn

@geindex first function
@geindex last function
@anchor{2c}@anchor{first}
@deffn {Function} first sv
@anchor{2d}@anchor{last}
@deffnx {Function} last sv

first and last member of sv
@end deffn

@geindex members function
@anchor{2e}@anchor{members}
@deffn {Function} members (sv, first, last)

return a list of values stored in sv[first,last)
@end deffn

@geindex update function
@anchor{2f}@anchor{update}
@deffn {Function} update msv i x

replace the ith member of msv by x and return msv
@end deffn

@geindex append function
@anchor{30}@anchor{append}
@deffn {Function} append sv x

append x to the end of sv
@end deffn

@geindex insert function
@anchor{31}@anchor{insert}
@deffn {Function} insert (msv,p) xs

@deffnx {Function} insert (msv,p) (sv,first,last)

insert members of the list xs or the range sv[first, last)
into msv, all preceding the pth member of msv. Members are shifted
to make room for the inserted members
@end deffn

@geindex rmfirst function
@geindex rmlast function
@anchor{32}@anchor{rmfirst}
@deffn {Function} rmfirst msv
@anchor{33}@anchor{rmlast}
@deffnx {Function} rmlast msv

remove first and last member from msv
@end deffn

@geindex erase function
@anchor{34}@anchor{erase}
@deffn {Function} erase (msv,first,last)

@deffnx {Function} erase (msv,p)

@deffnx {Function} erase msv

remove msv[first,last) from msv, remove msv!p from msv, or make msv
empty. Members are shifted to occupy vacated slots
@end deffn

@geindex clear function
@anchor{35}@anchor{clear}
@deffn {Function} clear msv

remove all of msv's members
@end deffn

@geindex all_equal function
@anchor{36}@anchor{all_equal}
@deffn {Function} all_equal comp (sv1, first1, last1) (sv2, first2, last2)

returns true if comp returns true for all corresponding members of
sv1[first1, last1) and sv1[first1, last1)
@end deffn

@geindex == infix function
@geindex ~= infix function
@anchor{37}@anchor{==}
@deffn {Function} sv1 == sv2
@anchor{38}@anchor{~=}
@deffnx {Function} sv1 ~= sv2

(x == y) is the same as equal (==) x y. (x ~= y is simply ~(equal (==) x
y)
@end deffn

Note that @code{==} and @code{~==} are not defined for iterator tuples (the rules
would never be executed because == is defined on tuples in the Prelude)


@node Convenience Functions,Examples<2>,Operations,Basic Operations
@anchor{convenience functions}@anchor{39}@anchor{convenience-functions}
@section Convenience Functions
The stlvec module provides convenience functions that apply map, catmap,
foldl, etc, to directly access Pure expressions stored in a stlvec.

@geindex map function
@anchor{3a}@anchor{map/stlvec}
@deffn {Function} map unary_fun (sv, first, last)

one pass equivalent of map unary_fun $ members (sv, first,
last)
@end deffn

@geindex listmap function
@anchor{3b}@anchor{listmap/stlvec}
@deffn {Function} listmap unary_fun (sv, first, last)

same as map, used in list comprehensions
@end deffn

@geindex catmap function
@anchor{3c}@anchor{catmap/stlvec}
@deffn {Function} catmap unary_fun (sv, first, last)

one pass equivalent of catmap unary_fun $ members (sv, first,
last)
@end deffn

@geindex do function
@anchor{3d}@anchor{do/stlvec}
@deffn {Function} do unary_fun (sv, first, last)

one pass equivalent of do unary_fun $ members (sv, first,
last)
@end deffn

@geindex foldl function
@anchor{3e}@anchor{foldl/stlvec}
@deffn {Function} foldl bin_fun x (sv, first, last)

one pass equivalent of foldl bin_fun x $ members (sv,
first, last)
@end deffn

@geindex foldl1 function
@anchor{3f}@anchor{foldl1/stlvec}
@deffn {Function} foldl1 bin_fun (sv, first, last)

one pass equivalent of foldl1 bin_fun $ members (sv, first,
last)
@end deffn

@geindex filter function
@anchor{40}@anchor{filter/stlvec}
@deffn {Function} filter unary_pred (sv, first, last)

one pass equivalent of filter unary_pred $ members (sv, first,
last)
@end deffn

The following four functions map (or catmap) stlvecs onto row and col
matrixes, primarily for use in matrix comprehensions.

@geindex rowmap function
@anchor{41}@anchor{rowmap/stlvec}
@deffn {Function} rowmap unary_fun (sv, first, last)
@end deffn

@geindex rowcatmap function
@anchor{42}@anchor{rowcatmap/stlvec}
@deffn {Function} rowcatmap unary_fun (sv, first, last)
@end deffn

@geindex colmap function
@anchor{43}@anchor{colmap/stlvec}
@deffn {Function} colmap unary_fun (sv, first, last)
@end deffn

@geindex colcatmap function
@anchor{44}@anchor{colcatmap/stlvec}
@deffn {Function} colcatmap unary_fun (sv, first, last)
@end deffn

Please note that "stlvec to stlvec" functions are provided by the pure-stl
algorithm modules. Thus, for example, the stlvec module does not provide a
function that maps one stlvec onto a new stlvec. That functionality, and
more, is provided by stl::transform, which can be found in the sv_modifying
module.


@node Examples<2>,,Convenience Functions,Basic Operations
@anchor{examples<2>}@anchor{45}@anchor{id1}
@section Examples
See ut_stvec in the pure-stl/ut directory.


@node STL Nonmodifying Algorithms,STL Modifying Algorithms,Basic Operations,Top
@anchor{stl nonmodifying algorithms}@anchor{46}@anchor{stl-nonmodifying-algorithms}
@chapter STL Nonmodifying Algorithms
The sv_nonmodifying module provides an interface to the STL's non-modifying
sequence operations.


@menu
* Imports: Imports<2>.
* Operations: Operations<2>.
* Examples: Examples<3>.
@end menu


@node Imports<2>,Operations<2>,,STL Nonmodifying Algorithms
@anchor{imports<2>}@anchor{47}@anchor{id2}
@section Imports
To use the operations of this module, add the following import declaration
to your program:

@example
using sv_nonmodifying;
@end example

@noindent
All of the functions are in the stl namespace.


@node Operations<2>,Examples<3>,Imports<2>,STL Nonmodifying Algorithms
@anchor{operations<2>}@anchor{48}@anchor{id3}
@section Operations

@geindex stl for_each function
@anchor{49}@anchor{stl for_each}
@deffn {Function} stl::for_each (sv, first, last) unary_fun

applies unary_fun to each of the elements in sv[first,last)
@end deffn

@geindex stl find function
@anchor{4a}@anchor{stl find}
@deffn {Function} stl::find (sv, first, last) x

returns the position of the first element in sv[first,last)
for which (==x) is true (or stl::svend if not found)
@end deffn

@geindex stl find_if function
@anchor{4b}@anchor{stl find_if}
@deffn {Function} stl::find_if (sv, first, last) unary_pred

returns the position of the first element in sv[first,last)
for which unary_pred is true (or stl::svend if not found)
@end deffn

@geindex stl find_first_of function
@anchor{4c}@anchor{stl find_first_of}
@deffn {Function} stl::find_first_of (sv1, first1, last1) (sv2, first2, last2) bin_pred

Returns the position of the first element, x, in
sv1[first1,last1) for which there exists y in
sv2[first2,last2) and (bin_pred x y) is true (or stl::svend if
no such x exists).
@end deffn

@geindex stl adjacent_find function
@anchor{4d}@anchor{stl adjacent_find}
@deffn {Function} stl::adjacent_find (sv, first, last) bin_pred

search sv[first,last) for the first occurrence of two
consecutive elements (x,y) for which (bin_pred x y) is
true. Returns the position of x, if found, or stl::svend if not found)
@end deffn

@geindex stl count function
@anchor{4e}@anchor{stl count}
@deffn {Function} stl::count (sv, first, last) x

returns the number of elements in the range sv[first,last) for
which (x==) is true
@end deffn

@geindex stl count_if function
@anchor{4f}@anchor{stl count_if}
@deffn {Function} stl::count_if (sv, first, last) unary_pred

returns the number of elements in the range sv[first,last) for
which unary_pred is true
@end deffn

@geindex stl mismatch function
@anchor{50}@anchor{stl mismatch}
@deffn {Function} stl::mismatch (sv1, first1, last1) (sv2, first2) bin_pred

applies bin_pred pairwise to the elements of
sv1[first1,last1) and (sv2,first2,first2 + n), with
n equal to last1-first1 until it finds i and j such
that bin_pred (sv1!i) (sv2!j) is false and returns
(i,j). If bin_pred is true for all of the pairs of elements,
i will be stl::svend and j will be first2 + n (or stl::svend)
@end deffn

@geindex stl equal function
@anchor{51}@anchor{stl equal}
@deffn {Function} stl::equal (sv1, first1, last1) (sv2, first2) bin_pred

applies bin_pred pairwise to the elements of
sv1[first1,last1) and (sv2,first2,first2 + n), with
n equal to last1-first1, and returns true if bin_pred is
true for each pair
@end deffn

@geindex stl search function
@anchor{52}@anchor{stl search}
@deffn {Function} stl::search (sv1, first1, last1) (sv2, first2) bin_pred

using bin_pred to determine equality of the elements, searches
sv1[first1,last1) for the first occurrence of the sequence
defined by sv2[first2,last2), and returns the position in sv1
of its first element (or stl::svend if not found)
@end deffn

@geindex stl search_n function
@anchor{53}@anchor{stl search_n}
@deffn {Function} stl::search_n (sv, first, last) count x bin_pred

using bin_pred to determine equality of the elements, searches
sv[first,last) for a sequence of count elements that equal
x. If such a sequence is found, it returns the position of the
first of its elements, otherwise it returns stl::svend
@end deffn

@geindex stl find_end function
@anchor{54}@anchor{stl find_end}
@deffn {Function} stl::find_end (sv1, first1, last1) (sv2, first2, last2) bin_pred

using bin_pred to determine equality of the elements, searches
sv1[first1,last1) for the last occurrence of
sv2[first2,last2). Returns the position of the first element in
sv1 of the occurrence (or stl::svend if not found).
@end deffn


@node Examples<3>,,Operations<2>,STL Nonmodifying Algorithms
@anchor{examples<3>}@anchor{55}@anchor{id4}
@section Examples
See ut_sv_nonmodifying.pure in the pure-stl/ut directory.


@node STL Modifying Algorithms,STL Sort Algorithms,STL Nonmodifying Algorithms,Top
@anchor{stl modifying algorithms}@anchor{56}@anchor{stl-modifying-algorithms}
@chapter STL Modifying Algorithms
The sv_modifying module provides an interface to the STL's modifying
algorithms.


@menu
* Imports: Imports<3>.
* Operations: Operations<3>.
* Examples: Examples<4>.
@end menu


@node Imports<3>,Operations<3>,,STL Modifying Algorithms
@anchor{imports<3>}@anchor{57}@anchor{id5}
@section Imports
To use the operations of this module, add the following import declaration
to your program:

@example
using sv_modifying;
@end example

@noindent
All of the functions are in the stl namespace.


@node Operations<3>,Examples<4>,Imports<3>,STL Modifying Algorithms
@anchor{operations<3>}@anchor{58}@anchor{id6}
@section Operations

@geindex stl copy function
@anchor{59}@anchor{stl copy}
@deffn {Function} stl::copy (sv, first1, last1) (msv, first2)

copies the elements in sv[first1,last1) into the range whose
first element is (msv,first2)
@end deffn

@geindex stl copy_backward function
@anchor{5a}@anchor{stl copy_backward}
@deffn {Function} stl::copy_backward (sv,first1,last1) (msv,last2)

copies the elements in sv[first1,last1), moving backward from
(last1), into the range msv[first2,last2) where first2 is
last2 minus the number of elements in sv[first1,last1)
@end deffn

@geindex stl swap_ranges function
@anchor{5b}@anchor{stl swap_ranges}
@deffn {Function} stl::swap_ranges (sv,first,last) (msv, p)

exchanges the elements in sv[first, last) with those in
msv[p, p+n) where n is last - first
@end deffn

@geindex stl transform function
@anchor{5c}@anchor{stl transform}
@deffn {Function} stl::transform (sv,first,last) (msv, p) unary_fun

applies unary_fun to the elements of sv[first,last) and
places the resulting sequence in msv[p, p+n) where n is
last - first. If sv is mutable, msv and sv can be the
same stlvec. Returns (msv,p+n)
@end deffn

@geindex stl transform_2 function
@anchor{5d}@anchor{stl transform_2}
@deffn {Function} stl::transform_2 (sv1,first1,last1) (sv2,first2) (msv, p) bin_fun

applies bin_fun to corresponding pairs of elements of
sv1[first1,last1) sv2[first2,n) and and places the
resulting sequence in msv[p, p+n) where n is last1 -
first1. Returns (msv,p+n)
@end deffn

@geindex stl replace function
@anchor{5e}@anchor{stl replace}
@deffn {Function} stl::replace (msv,first,last) x y

same as @pxref{5f,,replace_if} (msv,first,last) (x==) y
@end deffn

@geindex stl replace_if function
@anchor{5f}@anchor{stl replace_if}
@deffn {Function} stl::replace_if (msv,first,last) unary_pred x

replace the elements of msv[first,last) that satistfy
unary_pred with x
@end deffn

@geindex stl replace_copy function
@anchor{60}@anchor{stl replace_copy}
@deffn {Function} stl::replace_copy (sv,first,last) (msv,p) x y

same as @pxref{5e,,replace} (msv,first,last) x y except that
the modified sequence is placed in msv[p,p+last-first)
@end deffn

@geindex stl replace_copy_if function
@anchor{61}@anchor{stl replace_copy_if}
@deffn {Function} stl::replace_copy_if (sv,first,last) (msv,p) unary_pred x

same as @pxref{5f,,replace_if} except that the modified sequence is placed in
msv[p,p+last-first)
@end deffn

@geindex stl fill function
@anchor{62}@anchor{stl fill}
@deffn {Function} stl::fill (msv,first,last) x

replace all elements in msv[first,last) with x
@end deffn

@geindex stl fill_n function
@anchor{63}@anchor{stl fill_n}
@deffn {Function} stl::fill_n (msv,first) n x

replace the elements of msv[first,first+n) with x
@end deffn

@geindex stl generate function
@anchor{64}@anchor{stl generate}
@deffn {Function} stl::generate (msv,first,last) gen_fun

replace the elements in msv[first,last) with the sequence
generated by successive calls to gen_fun
@end deffn

@geindex stl generate_n function
@anchor{65}@anchor{stl generate_n}
@deffn {Function} stl::generate_n (msv,first) n gen_fun

replace all elements in msv[first,first+n) with the sequence
generated by successive calls to gen_fen
@end deffn

@geindex stl remove function
@anchor{66}@anchor{stl remove}
@deffn {Function} stl::remove (msv,first,last) x

same as @pxref{67,,remove_if} (msv,first,last) (==x).
@end deffn

@geindex stl remove_if function
@anchor{67}@anchor{stl remove_if}
@deffn {Function} stl::remove_if (msv,first,last) unary_pred

remove elements in msv[first,last) that do not satisfy
unary_pred. If n elements satisfy unary_pred, they are moved to
msv[first,first+n), preserving their relative order. The
content of msv[first+n,svend) is undefined. Returns
first+n, or stl::svend if first+n is greater than the number of
elements in msv
@end deffn

@geindex stl remove_copy function
@anchor{68}@anchor{stl remove_copy}
@deffn {Function} stl::remove_copy (sv,first,last) (msv,first) x

same as @pxref{66,,remove} except that the purged sequence is copied to
(msv,first) and sv[first,last) is not changed
@end deffn

@geindex stl remove_copy_if function
@anchor{69}@anchor{stl remove_copy_if}
@deffn {Function} stl::remove_copy_if (sv,first,last) (msv,first) unary_pred

same as @pxref{67,,remove_if} except that the purged sequence is copied to
(msv,first) and sv[first,last) is not changed
@end deffn

@geindex stl unique function
@anchor{6a}@anchor{stl unique}
@deffn {Function} stl::unique (msv,first,last) bin_pred

eliminates consecutive duplicates from sv[first,last), using
bin_pred to test for equality. The purged sequence is moved to
sv[first,first+n) preserving their relative order, where n
is the size of the purged sequence. Returns first+n or stl::svend if
first+n is greater than the number of elements in msv
@end deffn

@geindex stl unique_copy function
@anchor{6b}@anchor{stl unique_copy}
@deffn {Function} stl::unique_copy (sv,first,last) (msv,first) bin_pred

same as @pxref{6a,,unique} except that the purged sequence is copied to
(msv,first) and sv[first,last) is not changed
@end deffn

@geindex stl reverse function
@anchor{6c}@anchor{stl reverse}
@deffn {Function} stl::reverse (msv,first,last)

Reverses the order of the elements in sv[first,last).
@end deffn

@geindex stl reverse_copy function
@anchor{6d}@anchor{stl reverse_copy}
@deffn {Function} stl::reverse_copy (sv,first,last) (msv,first)

same as @pxref{6c,,reverse} except that the reversed sequence is copied to
(msv,first) and sv[first,last) is not changed.
@end deffn

@geindex stl rotate function
@anchor{6e}@anchor{stl rotate}
@deffn {Function} stl::rotate (msv,first,middle,last)

rotates the elements of msv[first,middle,last] so that
middle becomes the first element of msv[first,last].
@end deffn

@geindex stl rotate_copy function
@anchor{6f}@anchor{stl rotate_copy}
@deffn {Function} stl::rotate_copy (msv,first,middle,last) (msv,first)

same as rotate except that the rotated sequence is copied to
(msv,first) and sv[first,last) is not changed.
@end deffn

@geindex stl random_shuffle function
@anchor{70}@anchor{stl random_shuffle}
@deffn {Function} stl::random_shuffle (msv,first,last)

randomly reorders the elements in msv[first,last)
@end deffn

@geindex stl partition function
@anchor{71}@anchor{stl partition}
@deffn {Function} stl::partition (msv,first,last) unary_pred

places the elements in msv[first,last) that satisfy unary_pred
before those that don't. Returns middle, where msv
[first,middle) contains all of the elements that satisfy unary_pre,
and msv [middle, last) contains those that do not
@end deffn

@geindex stl stable_partition function
@anchor{72}@anchor{stl stable_partition}
@deffn {Function} stl::stable_partition (msv,first,last) unary_pred

same as partition except that the relative positions of the elements in
each group are preserved
@end deffn


@node Examples<4>,,Operations<3>,STL Modifying Algorithms
@anchor{examples<4>}@anchor{73}@anchor{id7}
@section Examples
See ut_sv_modifying.pure in the pure-stl/ut directory.


@node STL Sort Algorithms,STL Merge Algorithms,STL Modifying Algorithms,Top
@anchor{stl sort algorithms}@anchor{74}@anchor{stl-sort-algorithms}
@chapter STL Sort Algorithms
The sv_sort module provides an interface to the STL's sorting and binary
search algorithms.


@menu
* Imports: Imports<4>.
* Operations: Operations<4>.
* Examples: Examples<5>.
@end menu


@node Imports<4>,Operations<4>,,STL Sort Algorithms
@anchor{imports<4>}@anchor{75}@anchor{id8}
@section Imports
To use the operations of this module, add the following import declaration
to your program:

@example
using sv_sort;
@end example

@noindent
All of the functions are in the stl namespace.


@node Operations<4>,Examples<5>,Imports<4>,STL Sort Algorithms
@anchor{operations<4>}@anchor{76}@anchor{id9}
@section Operations
All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). The functions (<) and
(>) are commonly passed as comp.

@geindex stl sort function
@anchor{77}@anchor{stl sort}
@deffn {Function} stl::sort (msv, first, last) comp

sorts msv[first, last)
@end deffn

@geindex stl stable_sort function
@anchor{78}@anchor{stl stable_sort}
@deffn {Function} stl::stable_sort (msv, first, last) comp

sorts msv[first, last), preserving the relative order of equal
members
@end deffn

@geindex stl partial_sort function
@anchor{79}@anchor{stl partial_sort}
@deffn {Function} stl::partial_sort (msv, first, middle, last) comp

fills msv[first, middle) with the elements of msv[first,last) that would
appear there if msv[first,last) were sorted using comp and fills
msv[middle,last) with the remaining elements in unspecified order
@end deffn

@geindex stl partial_sort_copy function
@anchor{7a}@anchor{stl partial_sort_copy}
@deffn {Function} stl::partial_sort_copy (sv, first1, last1) (msv, first2, last2) comp

let n be the number of elements in sv[first1, last1) and r be the number of
elements in msv[first2, last2). If r < n, @pxref{7a,,partial_sort_copy} fills
msv[first2, last2) with the first r elements of what sv[first1, last1)
would be if it had been sorted. If r >= n, it fills msv[first2, first2+n)
with the elements of sv[first1, last1) in sorted order. sv[first1,last1) is
unchanged
@end deffn

@geindex stl nth_element function
@anchor{7b}@anchor{stl nth_element}
@deffn {Function} stl::nth_element (msv, first, middle, last) comp

rearranges the elements of msv[first, last) as follows. Let n be middle -
first, and let x be the nth smallest element of msv[first, last). After the
function is called, sv!middle will be x. All of the elements of msv[first,
middle) will be less than x and all of the elements of msv[middle+1, last)
will be greater than x
@end deffn

The next four functions assume that sv[first, last) is ordered by comp.

@geindex stl lower_bound function
@anchor{7c}@anchor{stl lower_bound}
@deffn {Function} stl::lower_bound (sv, first, last) x comp

returns an int designating the first position into which x can be inserted
into sv[first, last) while maintaining the sorted ordering
@end deffn

@geindex stl upper_bound function
@anchor{7d}@anchor{stl upper_bound}
@deffn {Function} stl::upper_bound (sv, first, last) x comp

returns an int designating the last position into which x can be inserted
into sv[first, last) while maintaining the sorted ordering
@end deffn

@geindex stl equal_range function
@anchor{7e}@anchor{stl equal_range}
@deffn {Function} stl::equal_range (sv, first, last) x comp

returns a pair of ints, (lower, upper) where lower and upper would have
been returned by separate calls to lower_bound and upper_bound.
@end deffn

@geindex stl binary_search function
@anchor{7f}@anchor{stl binary_search}
@deffn {Function} stl::binary_search (sv, first, last) x comp

returns true if x is an element of sv[first, last)
@end deffn


@node Examples<5>,,Operations<4>,STL Sort Algorithms
@anchor{examples<5>}@anchor{80}@anchor{id10}
@section Examples
See ut_sv_sort.pure in the pure-stl/ut directory.


@node STL Merge Algorithms,STL Heap Algorithms,STL Sort Algorithms,Top
@anchor{stl merge algorithms}@anchor{81}@anchor{stl-merge-algorithms}
@chapter STL Merge Algorithms
The sv_merge module provides an interface to the STL's merge algorithms. These
algorithms operate on sorted ranges.


@menu
* Imports: Imports<5>.
* Operations: Operations<5>.
* Examples: Examples<6>.
@end menu


@node Imports<5>,Operations<5>,,STL Merge Algorithms
@anchor{imports<5>}@anchor{82}@anchor{id11}
@section Imports
To use the operations of this module, add the following import declaration
to your program:

@example
using sv_merge;
@end example

@noindent
All of the functions are in the stl namespace.


@node Operations<5>,Examples<6>,Imports<5>,STL Merge Algorithms
@anchor{operations<5>}@anchor{83}@anchor{id12}
@section Operations
All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). They only work
properly on input ranges that have been previously sorted using comp.

See parameter naming conventions at ..

@geindex stl merge function
@anchor{84}@anchor{stl merge}
@deffn {Function} stl::merge (sv1,first1,last1) (sv2,first2,last2) (msv,p) comp

merges the two sorted ranges into the sorted range msv[p,p+n) where n is
the total length of the merged sequence
@end deffn

@c function::inplace_merge (msv,first, middle, last) comp
@c 
@c merges msv[first,middle) and msv[middle,last) into the sorted range
@c msv[first,last)
@c function::includes (sv1,first1,last1) (sv2,first2,last2) comp
@c 
@c returns true if every element of sv2[first2,last2) is an element
@c of sv1[first1,last1)
@c function::set_union (sv1,first1,last1) (sv2,first2,last2) (msv,p) comp
@c 
@c places the sorted union of sv1[first1,last1) and
@c sv2[first2,last2) into msv[p,p+n) where n is the number
@c of elements in the sorted union, and returns the past-the-end position of
@c the sorted union
@c function::set_intersection (sv1,first1,last1) (sv2,first2,last2)
@c  (msv,p) comp
@c 
@c places the sorted intersection of sv1[first1,last1) and sv2[first2,last2)
@c into msv[p,p+n) where n is the number of elements in the sorted
@c intersection, and returns p+n (or stl::svend, if applicable)
@c function::set_difference (sv1,first1,last1) (sv2,first2,last2)
@c  (msv,p) comp
@c 
@c places the sorted difference of sv1[first1,last1) and sv2[first2,last2)
@c into msv[p,p+n) where n is the number of elements in the sorted difference,
@c and returns p+n (or stl::svend, if applicable)
@c function::set_symmetric_difference (sv1,first1,last1)
@c (sv2,first2,last2) (msv,p) comp
@c 
@c places the sorted symmetric_difference of sv1[first1,last1) and
@c sv2[first2,last2) into msv[p,p+n) where n is the number of elements in the
@c sorted symmetric_difference, and returns returns p+n (or stl::svend, if
@c applicable)

@node Examples<6>,,Operations<5>,STL Merge Algorithms
@anchor{examples<6>}@anchor{85}@anchor{id13}
@section Examples
See ut_sv_merge.pure in the pure-stl/ut directory.


@node STL Heap Algorithms,Min/Max STL Algorithms,STL Merge Algorithms,Top
@anchor{stl heap algorithms}@anchor{86}@anchor{stl-heap-algorithms}
@chapter STL Heap Algorithms
The sv_heap module provides an interface to the STL's heap operations.


@menu
* Imports: Imports<6>.
* Operations: Operations<6>.
* Examples: Examples<7>.
@end menu


@node Imports<6>,Operations<6>,,STL Heap Algorithms
@anchor{imports<6>}@anchor{87}@anchor{id14}
@section Imports
To use the operations of this module, add the following import declaration
to your program:

@example
using sv_heap;
@end example

@noindent
All of the functions are in the stl namespace.


@node Operations<6>,Examples<7>,Imports<6>,STL Heap Algorithms
@anchor{operations<6>}@anchor{88}@anchor{id15}
@section Operations
All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). The functions (<)
and (>) are commonly passed as comp.

@geindex stl make_heap function
@anchor{89}@anchor{stl make_heap}
@deffn {Function} stl::make_heap (msv,first,last) comp

rearranges the elements of msv[first,last) so that they are a
heap, i.e., after this msv!first will be the largest element in
msv[first,last), and push_heap and pop_heap will work properly
@end deffn

@geindex stl push_heap function
@anchor{8a}@anchor{stl push_heap}
@deffn {Function} stl::push_heap (msv,first,last) comp

makes msv[first,last) a heap (assuming that msv[first,last-1) was a heap)
@end deffn

@geindex stl pop_heap function
@anchor{8b}@anchor{stl pop_heap}
@deffn {Function} stl::pop_heap (msv,first,last) comp

swaps msv!first with msv!(last-1), and makes msv[first,last-1) a heap
(assuming that msv[first,last) was a heap)
@end deffn

@geindex stl sort_heap function
@anchor{8c}@anchor{stl sort_heap}
@deffn {Function} stl::sort_heap (msv,first,last) comp

sorts the elements in msv[first,last)
@end deffn


@node Examples<7>,,Operations<6>,STL Heap Algorithms
@anchor{examples<7>}@anchor{8d}@anchor{id16}
@section Examples
See ut_sv_heap.pure in the pure-stl/ut directory.


@node Min/Max STL Algorithms,STL Numeric Algorithms,STL Heap Algorithms,Top
@anchor{min/max stl algorithms}@anchor{8e}@anchor{min-max-stl-algorithms}
@chapter Min/Max STL Algorithms
The sv_minmax module provides an interface to a few additional STL algorithms.


@menu
* Imports: Imports<7>.
* Operations: Operations<7>.
* Examples: Examples<8>.
@end menu


@node Imports<7>,Operations<7>,,Min/Max STL Algorithms
@anchor{imports<7>}@anchor{8f}@anchor{id17}
@section Imports
To use the operations of this module, add the following import declaration
to your program:

@example
using sv_minmax;
@end example

@noindent
All of the functions are in the stl namespace.


@node Operations<7>,Examples<8>,Imports<7>,Min/Max STL Algorithms
@anchor{operations<7>}@anchor{90}@anchor{id18}
@section Operations
All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). The functions (<)
and (>) are commonly passed as comp.

@geindex stl min_element function
@anchor{91}@anchor{stl min_element}
@deffn {Function} stl::min_element (sv,first,last) comp

returns the position of the minimal element of sv[first,last) under the
ordering defined by comp
@end deffn

@geindex stl max_element function
@anchor{92}@anchor{stl max_element}
@deffn {Function} stl::max_element (sv,first,last) comp

returns the position of the maximal element of sv[first,last) under the
ordering defined by comp
@end deffn

@geindex stl lexicographical_compare function
@anchor{93}@anchor{stl lexicographical_compare}
@deffn {Function} stl::lexicographical_compare (sv1,first1,last1) (sv2,first2,last2) comp

compares sv1[first1,last1) and sv2[first2,last2) element by element
according to the ordering defined by comp, and returns true if the first
sequence is less than the second
@end deffn

Algorithms are provided for stepping through all the permutations the elements
of a stlvec. For these purposes, the first permutation has the elements of
msv[first,last) sorted in ascending order and the last has the elements sorted
in descending order.

@geindex stl next_permutation function
@anchor{94}@anchor{stl next_permutation}
@deffn {Function} stl::next_permutation (msv,first,last) comp

rearranges msv[first,last) to produce the next permutation, in
the ordering imposed by comp. If msv[first,last) is not the
last permutation, change msv[first,last) to the next
permutation and return true. Otherwise, change it to the first
permutation and return true
@end deffn

@geindex stl prev_permutation function
@anchor{95}@anchor{stl prev_permutation}
@deffn {Function} stl::prev_permutation (msv,first,last) comp

next_permutation in reverse
@end deffn


@node Examples<8>,,Operations<7>,Min/Max STL Algorithms
@anchor{examples<8>}@anchor{96}@anchor{id19}
@section Examples
See ut_sv_minmax.pure in the pure-stl/ut directory.


@node STL Numeric Algorithms,Trace Mode,Min/Max STL Algorithms,Top
@anchor{stl numeric algorithms}@anchor{97}@anchor{stl-numeric-algorithms}
@chapter STL Numeric Algorithms
The sv_numeric module provides an interface to the STL's numeric algorithms.


@menu
* Imports: Imports<8>.
* Operations: Operations<8>.
* Examples: Examples<9>.
@end menu


@node Imports<8>,Operations<8>,,STL Numeric Algorithms
@anchor{imports<8>}@anchor{98}@anchor{id20}
@section Imports
To use the operations of this module, add the following import declaration
to your program:

@example
using sv_numeric;
@end example

@noindent
All of the functions are in the stl namespace.


@node Operations<8>,Examples<9>,Imports<8>,STL Numeric Algorithms
@anchor{operations<8>}@anchor{99}@anchor{id21}
@section Operations

@geindex stl accumulate function
@anchor{9a}@anchor{stl accumulate}
@deffn {Function} stl::accumulate (sv,first,last) x bin_fun

accumulate bin_fun over x and the members of sv[first,last), like foldl
@end deffn

@geindex stl inner_product function
@anchor{9b}@anchor{stl inner_product}
@deffn {Function} stl::inner_product (sv1,first1,last1) (sv2,first2,last2) x bin_fun1 bin_fun2

initialize ret with x. Traverse pairs of elements of sv1[first1,last1) and
sv2[first2,last2), denoted by (e1, e2), replacing ret with (bin_fun1 ret $
bin_fun2 e1 e2). The number pairs traversed is equal to the size of
sv1[first1,last1)
@end deffn

@geindex stl partial_sum function
@anchor{9c}@anchor{stl partial_sum}
@deffn {Function} stl::partial_sum (sv,first,last) (msv, p) bin_fun

accumulate bin_fun f over the elements of sv1[first1,last1), placing
itermediate results in msv[p,p+n), where n is last - first, and returns q
where m is q - n and msv[m,q) is the intermediate sequence
@end deffn

@geindex stl adjacent_difference function
@anchor{9d}@anchor{stl adjacent_difference}
@deffn {Function} stl::adjacent_difference (sv,first,last) (msv, p) bin_fun

produce a sequence of new elements by applying bin_fun to adjacent elements
of sv[first,last), placing the new elements in msv[p,p+n), where n is last
- first, with the intermediate results, and returns q where m is q - n and
msv[m,q) is the new sequence
@end deffn


@node Examples<9>,,Operations<8>,STL Numeric Algorithms
@anchor{examples<9>}@anchor{9e}@anchor{id22}
@section Examples
See ut_sv_numeric.pure in the pure-stl/ut directory.


@node Trace Mode,Index,STL Numeric Algorithms,Top
@anchor{trace mode}@anchor{9f}@anchor{trace-mode}
@chapter Trace Mode
If the pure-stl dlls are built using 'make debug' (as opposed to 'make', 'make
all' or 'make dlls'), the pure-stl tracing functions will be enabled. These
functions, all of which are defined in the stl namespace, can be used to trace
the creation and deletion of stlvecs as well as the changes in ref counts that
occur as Pure objects are moved and copied. In addition to being useful for
maintaining the pure-stl modules, these functions can be used to observe the
STL copy semantics.

@geindex stl set_sv_trace function
@anchor{a0}@anchor{stl set_sv_trace}
@deffn {Function} stl::set_sv_trace on_off::int

enables or disables tracing the creation and deletion of stlvecs
@end deffn

@geindex stl sv_trace_enabled function
@anchor{a1}@anchor{stl sv_trace_enabled}
@deffn {Function} stl::sv_trace_enabled

returns 1 if stlvec tracing is enabled, else 0
@end deffn

@geindex stl set_px_trace function
@anchor{a2}@anchor{stl set_px_trace}
@deffn {Function} stl::set_px_trace on_off::int

enables or disables tracing 'copying' of Pure expressions
@end deffn

@geindex stl px_trace_enabled function
@anchor{a3}@anchor{stl px_trace_enabled}
@deffn {Function} stl::px_trace_enabled

returns 1 if Pure expression tracing is enabled, else 0
@end deffn

In addition, the following function, also in the stl namespace, is available
whether or not debug is passed to make.

@geindex stl refc function
@anchor{a4}@anchor{stl refc}
@deffn {Function} stl::refc x

returns the x's reference count (maintained by the Pure runtime for
garbage collection purposes)
@end deffn


@node Index,,Trace Mode,Top
@anchor{index}
@unnumbered Index
@printindex ge

@c %**end of body
@bye
