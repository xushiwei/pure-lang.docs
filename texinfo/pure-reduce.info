This is pure-reduce.info, produced by makeinfo version 4.13 from
pure-reduce.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-reduce: (pure-reduce.info).    A REDUCE Interface for the Pure Programming Language
END-INFO-DIR-ENTRY


File: pure-reduce.info,  Node: Top,  Next: Installation,  Up: (dir)

pure-reduce
***********

  Version 0.1, October 09, 2012

    Albert Graef <<Dr.Graef@t-online.de>> 
    Kurt Pagani <<kp@scios.ch>> 
  One of Pure's distinguishing features as a term rewriting programming
language is that it makes the symbolic manipulation of expressions very
easy and convenient. It is thus a natural environment for hosting a
full-featured computer algebra system (CAS). Computer algebra systems
are complex pieces of software featuring advanced algorithms for
simplification of algebraic expressions, symbolic integration, equation
solving and much more.  Reimplementing all these algorithms in Pure
would be a major undertaking, to say the least. A much better option is
to interface to an existing CAS which has already proven its worth to
the scientific computing community, has been tested extensively and is
known to be both reliable and efficient.

  This is also the approach taken by Pure's *note reduce: 0. module
which interfaces to the well-known Reduce
(http://reduce-algebra.sourceforge.net/) system. Reduce is the
second-oldest computer algebra system (the oldest one being
Macsyma/Maxima (http://maxima.sourceforge.net/)) which is widely
recognized as a state-of-the-art, powerful and efficient CAS. It is
free/open source software distributed under a BSD-style license
(http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/README),
actively maintained on its SourceForge
(http://sourceforge.net/projects/reduce-algebra/) website, and
implementations exist for all major computing platforms. The *note
reduce: 0. module makes the functionality of Reduce available in Pure
in a seamless way. It uses an "embedded" version of Reduce in the form
of a shared library which is easy to build from the Reduce sources; the
*note Installation: 1. section below describes how to do this. More
background information and a discussion of the interface can be found
in the Embedding REDUCE
(http://groups.google.com/group/pure-lang/browse_thread/thread/c11e82ca2e9e8cbb)
thread on the Pure mailing list.

  The interface can be found in the reduce.pure module. It has two
parts, a *note low-level interface: 7. which consists of a handful of C
entry points supplied by the Reduce library, and a *note high-level
interface: 8. which provides everything that the Pure programmer needs
to use Reduce from Pure. Please note that at present this module is
still experimental. But the basic functionality works, and you're
welcome to discuss the new interface on the mailing list and/or submit
bug reports and patches.

* Menu:

* Installation::
* Low-Level Interface::
* High-Level Interface::
* Basic Examples::
* Examples by Topic::
* Index::

 --- The Detailed Node Listing ---

Examples by Topic

* Differentiation::
* Integration::
* Length and Map::
* Partial Fractions::
* Selection::
* Solving::
* Even and Odd Operators::
* Linear Operators::
* Non-commuting Operators::
* Symmetric and Antisymmetric Operators::
* Creating/Removing Variable Dependency::
* Internal Order of Variables::
* Parts of Algebraic Expressions::
* Polynomials and Rationals::
* Substitution::
* Assignment::
* Matrix Calculations::
* Limits::
* Ordinary differential equations solver::
* Series Summation and Products::
* Taylor Series::
* Boolean Expressions::
* Mathematical Functions::
* Definite Integrals::
* Declarations Switches and Loading::
* Plotting::
* References::


File: pure-reduce.info,  Node: Installation,  Next: Low-Level Interface,  Prev: Top,  Up: Top

1 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-reduce-0.1.tar.gz>.

  You'll need both the Reduce library (named reduce.so, reduce.dylib or
reduce.dll, depending on the system you have) and a Reduce image file
(reduce.img) to make this module work. A Makefile is included with this
package so that you can build these yourself from the Reduce sources.
(In principle, this only needs to be done once for the initial
installation of this module, but you may want to repeat this procedure
every once in a while to get the latest Reduce version.)

  You can check out the latest Reduce version from its svn repository
with the following command:

    svn co https://reduce-algebra.svn.sourceforge.net/svnroot/reduce-algebra/trunk/ reduce-algebra

This may take a while; Reduce is a _big_ package. Once it's finished,
just drop the resulting reduce-algebra directory into the pure-reduce
source directory. Run `make' and then (if needed) `make install' in the
pure-reduce directory (_not_ in the reduce-algebra directory!). You
should also run `make check' which performs a few tests in order to
verify that the interface works ok (this can be done without installing
the package, but needs the Reduce image and library).

  In case the above procedure doesn't work for you, there are more
detailed instructions on how to compile the relevant parts of Reduce in
the pure_reduce.txt file included in the distribution. Also note that
the pure-reduce module requires neither a full Reduce installation nor
a full build of the Reduce package; just the Reduce library and image.
Thus the additional items discussed below are all completely optional.

  For convenience, the Makefile also has a `make reduce' target which
builds a minimal Reduce executable. If you use that option, `make
install' installs this executable along with the library and image
files, so that you can then run Reduce directly from the command line
by just typing `reduce'. Please note that this is a really minimalistic
Reduce frontend. It's small, easy to build and doesn't need any support
files other than the image file, but it doesn't have any of the bells
and whistles of the full Reduce version either.

  If you want to install the full Reduce version, there are binary
packages for various systems available on SourceForge
(http://sourceforge.net/projects/reduce-algebra/). You can also build
Reduce yourself from the sources; please check the build instructions
in the reduce-algebra folder for details. (Basically, you'll need to
run `./configure --with-csl' or `./configure --with-psl' and then
`make' there. Be patient, this takes a while.)


File: pure-reduce.info,  Node: Low-Level Interface,  Next: High-Level Interface,  Prev: Installation,  Up: Top

2 Low-Level Interface
*********************

The low-level interface is a straight wrapper of the C entry points
provided by the Reduce library, also known as the "procedural" or PROC
(http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup)
interface, for short. It uses an embedded version of Reduce which runs
on a free and open-source Lisp flavour known as CSL
(http://lisp.codemist.co.uk/) (Codemist Standard Lisp). The external C
routines are all declared in the `reduce' namespace. Normally you
shouldn't have to call these functions directly, since we provide a
high-level, idiomatic Pure interface which makes calling Reduce from
Pure much easier, see below.


File: pure-reduce.info,  Node: High-Level Interface,  Next: Basic Examples,  Prev: Low-Level Interface,  Up: Top

3 High-Level Interface
**********************

The high-level interface provides a wrapper of the low-level PROC
interface which makes calling Reduce from Pure easy and convenient.
After installing the module, it can be imported in your Pure scripts as
follows:

    using reduce;

This starts up Reduce and makes the following variables and functions
available in Pure:

 -- variable: REDUCE_PATH
     This variable holds a colon-delimited search path used to locate
     the Reduce image file (see *note reduce start: d. below). By
     default this includes the current directory and the Pure library
     directory.

 -- Function: reduce::start image::string args::smatrix
     Initializes the Reduce system. This is done automatically when
     loading this module, so normally you shouldn't have to call this
     manually, unless the default image file wasn't found or you want
     to restart the Reduce system with your own image file or your own
     set of options. When calling this operation manually, you need to
     specify the name of the Reduce image file and any desired extra
     arguments as a string vector.  Unless the filename contains a
     slash, *note reduce start: d. searches the directories in *note
     REDUCE_PATH: c. for the image file. An exception is raised if the
     image file isn't found.

 -- Function: reduce::finish
     Finalizes the Reduce system. You can call this to release the
     resources of the Reduce system. (*note reduce start: d. also
     invokes this automatically if a Reduce instance is already
     running, so it isn't necessary to call *note reduce finish: e. in
     this case.)

 -- Function: reduce::verbosity n
     Sets the verbosity level; 0 means no messages at all (which is the
     default when using this module), and the following values may be
     or'ed together to pick what you need:

          1: messages whenever garbage collection happens

          2: messages whenever a module of code is loaded

          4: extra details in the garbage collector messages

 -- Function: reduce::load name::string
     Loads Reduce packages. This works like Reduce's `load_package'
     command; please check the Reduce documentation for details.

 -- Function: reduce::switch name:string val::int
     Lets you change global Reduce options. This works like Reduce's
     `on' and `off' declarations; please check the Reduce documentation
     for details.

  For convenience, the following operations are in the default
namespace:

 -- Function: simplify x
     This is the main entry point. It takes an algebraic expression in
     Pure format and tries to simplify it using Reduce. The result is
     then converted back to Pure format. Note that you need to quote
     `x' if you want to prevent it from being evaluated on the Pure
     side.

 -- Function: lisp x
     This can be used to execute arbitrary Lisp code, which is sometimes
     necessary to perform special functions in the Reduce system. Free
     symbols are quoted automatically, and Pure lists are mapped to
     corresponding Lisp lists and vice versa. The result is always a
     Pure list or an atomic value. Note that you need to quote `x' if
     you want to prevent it from being evaluated on the Pure side. This
     is to be used with care. At present, the PROC interface isn't very
     forgiving if you try to execute invalid Lisp code; it will most
     likely crash in such cases.

 -- Function: declare declsym [foo,bar,...]
     Declare symbols and their properties; please see the Declarations
     section in the Reduce manual for details. The second argument can
     also be a singleton symbol. In the present implementation,
     `declsym' must be one of:

        * `operator' (declares an operator symbol);

        * `antisymmetric', `symmetric', `even', `odd', `linear',
          `noncom' and `nonzero' (declares properties of already
          declared operator symbols);

        * `depend', `nodepend', `factor', `remfac', `order', `korder'
          (declares kernel dependencies and orders). These take both
          symbols and "kernels" as arguments (the latter are simple
          prefix expressions which denote irreducible subterms such as
          `cos x'; Reduce treats these more or less like variables in
          algebraic simplifications).

 -- Function: precision prec::int
     Sets the internal Reduce precision in decimal digits for floating
     point calculations, and returns the previously set precision. This
     takes effect when rounded mode is enabled (`reduce::switch
     "rounded" 1').  Note that at present this only affects Reduce's
     internal precision, floating point values are still returned as
     double precision numbers in Pure land.

 -- Function: plotreset
     This is identical to the `plotreset' command provided by Reduce's
     gnuplot (http://www.gnuplot.info/) interface, and is sometimes
     needed to reset the plot subsystem.

  At present, this module makes no attempt to capture terminal output
such as error messages produced by Reduce, so you should be prepared to
read these in the terminal in which Pure is running, or capture them
yourself using the output redirection facilities of the shell if needed.

  In Pure land, Reduce and Lisp expressions are represented using Pure's
standard curried notation. Marshalling of numeric data works in a
straightforward fashion and includes all natively supported Pure data
types (machine ints, bigints, doubles, rationals and complex numbers).
Some special conversions are applied to algebraic expressions to make
arithmetic operations such as `+', `*' etc. work as expected. In
addition, the `==', `..' and `:=' infix operators can be used to denote
equations, ranges and assignments in Reduce, respectively. (Note that
you may have to quote these in some cases so that they don't get
evaluated on the Pure side.) Also, Reduce's `arbconst n', `arbint n'
and `arbcomplex n' terms are mapped to Greek symbols `αn', `βn' and
`ζn' on the Pure side. For debugging purposes, all these automatic
conversions can also be turned off on the output side with the '`#!
--disable mapped'' compilation pragma; this needs to be placed _before_
the '`using reduce;'' import clause to take effect. There are a number
of other conditional compilation options which may be used to
selectively turn off some of the conversions; please check the module
source for details.


File: pure-reduce.info,  Node: Basic Examples,  Next: Examples by Topic,  Prev: High-Level Interface,  Up: Top

4 Basic Examples
****************

Here is a simple example showing how to start up Reduce and do some
calculations:

    > using reduce;
    Reduce (Free CSL version), 27-Sep-12 ...
    > simplify $ df ((x+5)^3) x;
    3*x^2+30*x+75
    > simplify $ solve (x^2+7) x;
    [x==sqrt 7*i,x==-sqrt 7*i]

Note that the result returned by *note simplify: 12. is always a quoted
expression. If the expression can be further reduced on the Pure side,
you'll have to use Pure's `eval' function to force its evaluation:

    > using math;
    > eval ans;
    [x==0.0+:2.64575131106459,x==0.0+:-2.64575131106459]

You can also execute Lisp code in the CSL interpreter hosting the Reduce
system. This is sometimes necessary to access special functionality, but
should be done with care (at present invalid Lisp code can easily crash
the interpreter). Most simple kinds of Lisp calls should be doable that
way, but don't expect any miracles; the *note lisp: 13. function is
provided to access special functionality in the "symbolic mode" of the
Reduce system, not to turn Pure into a full-featured Lisp frontend. The
following example illustrates how you can use the *note lisp: 13.
function to declare an operator symbol and change or query its
properties:

    > lisp ('operator [myop]);
    []
    > lisp ('flag [myop] odd);
    []
    > lisp ('prop myop);
    [odd:t,simpfn:simpiden]
    > simplify (myop (-x));
    -myop x

If you find it awkward to evaluate Lisp forms in Pure, you can also
achieve the same with the *note declare: 14. function which covers most
of the common Reduce declarations that might be needed:

    > declare operator myop;
    []
    > declare odd myop;
    []
    > simplify (myop (-x));
    -myop x

This example shows how you can do a simple plot using Reduce's gnuplot
(http://www.gnuplot.info/) module:

    > simplify $ plot [sin x/x, x=='(-20..20), terminal=="wxt"];
    0

This pops up a wxWidgets window (`terminal=="wxt"') with a plot of the
given function in it, see the screenshot below. The `x=='(-20..20)'
argument specifies the desired range of the `x' variable (note that the
range needs to be quoted so that it gets through to Reduce rather than
being evaluated on the Pure side).

 [image src="gnuplot.png" ]

Figure: Reduce gnuplot example.

  The same plot can be written to a PostScript file sinc.ps as follows:

    > simplify $ plot [sin x/x, x=='(-20..20), terminal=="postscript", output=="sinc.ps"];
    0

Many more examples can be found in the reduce_examp.pure and tests.pure
scripts included in the distribution.


File: pure-reduce.info,  Node: Examples by Topic,  Next: Index,  Prev: Basic Examples,  Up: Top

5 Examples by Topic
*******************

This is a small excerpt from the *REDUCE User's Manual* *note [REDUM]:
1a, translated to Pure syntax. For any details we refer to that
document. With this guide it should be straightforward to interprete
back and forth.  The REDUCE User's Manual as well as the documentation
of each package and other valuable information may be found at

  <http://www.reduce-algebra.com/documentation.htm>

* Menu:

* Differentiation::
* Integration::
* Length and Map::
* Partial Fractions::
* Selection::
* Solving::
* Even and Odd Operators::
* Linear Operators::
* Non-commuting Operators::
* Symmetric and Antisymmetric Operators::
* Creating/Removing Variable Dependency::
* Internal Order of Variables::
* Parts of Algebraic Expressions::
* Polynomials and Rationals::
* Substitution::
* Assignment::
* Matrix Calculations::
* Limits::
* Ordinary differential equations solver::
* Series Summation and Products::
* Taylor Series::
* Boolean Expressions::
* Mathematical Functions::
* Definite Integrals::
* Declarations Switches and Loading::
* Plotting::
* References::


File: pure-reduce.info,  Node: Differentiation,  Next: Integration,  Up: Examples by Topic

5.1 Differentiation
===================

The operator `df' is used to represent partial differentiation with
respect to one or more variables.

     `syntax: df exprn [var <num>]+.'

  Differentiation of the function x^2 y^3 z^4 with respect to x,y,z,
two, three and four times respectively, i.e \frac{\partial^9 x^2 y^3
z^4}{\partial x^2 \partial y^3 \partial z^4}:

    > simplify $ df (x^2*y^3*z^4) x 2 y 3 z 4 ;
    288

The derivative of \log \sin (x)^2:

    > simplify $ df (log(sin x)^2) x;
    2*cos x*log (sin x)/sin x

Note the parentheses.

  Suppose z(\cos(x),y): Let's calculate \frac{\partial \sin(z)}
{\partial \cos(x)} and \frac{\partial z^2}{\partial x} :

    > declare depend [z,cos x,y];
    []
    > simplify (df (sin z) (cos x));
    cos z*df z (cos x)
    > simplify (df (z^2) x);
    2*df z x*z

Note how to declare dependencies.

  The results are \cos(z) \frac{\partial z} {\partial \cos(x)} and  2 z
\frac{\partial z} {\partial x}) respectively, as expected.


File: pure-reduce.info,  Node: Integration,  Next: Length and Map,  Prev: Differentiation,  Up: Examples by Topic

5.2 Integration
===============

`INT' is an operator in REDUCE for indefinite integration using a
combination of the Risch-Norman algorithm and pattern matching.

     `syntax: intg exprn var.'

  Note that in Pure the operator is called `intg' in order not to clash
with the integer type `int'.

  Example 1:

    > simplify $ intg (1/(a*x+b)) x;
    log (a*x+b)/a

Example 2:

    > I a b n = simplify $ intg (x^2*(a*x+b)^n) x;
    > I a b n;
    ((a*x+b)^n*a^3*n^2*x^3+3*(a*x+b)^n*a^3*n*x^3+2*(a*x+b)^n*a^3*x^3+
     (a*x+b)^n*a^2*b*n^2*x^2+(a*x+b)^n*a^2*b*n*x^2-2*(a*x+b)^n*a*b^2*
      n*x+2*(a*x+b)^n*b^3)/(a^3*n^3+6*a^3*n^2+11*a^3*n+6*a^3)
    > I a b 0 ;
    x^3/3
    > I 0 b n;
    b^n*x^3/3
    > I a 0 k;
    x^k*a^k*x^3/(k+3)

Example 3:

    > simplify $ intg (sqrt(x+sqrt(x^2+1))/x) x ;
    intg (sqrt (sqrt (x^2+1)+x)/x) x

Apparently no solution was found. There is a package `ALGINT' in
REDUCE, that is specialized to deal with algebraic functions. The
REDUCE User's Manual *note [REDUM]: 1a. says

     ... _will analytically integrate a wide range of expressions
     involving square roots where the answer exists in that class of
     functions.  It is an implementation of the work described in J.H.
     Davenport_ *note [LNCS102]: 1d.

    > reduce::load "algint" ;
    0
    > simplify $ intg (sqrt(x+sqrt(x^2+1))/x) x ;
    atan ((sqrt (sqrt (x^2+1)+x)*sqrt (x^2+1)-sqrt (sqrt (x^2+1)+x)*x-sqrt
    (sqrt (x^2+1)+x))/2)+2*sqrt (sqrt (x^2+1)+x)+log (sqrt (sqrt
    (x^2+1)+x)-1)-log (sqrt (sqrt (x^2+1)+x)+1)

Note how to load packages.


File: pure-reduce.info,  Node: Length and Map,  Next: Partial Fractions,  Prev: Integration,  Up: Examples by Topic

5.3 Length and Map
==================

`LENGTH' is a generic operator for finding the length of various
objects in the system, while the `MAP' operator applies a uniform
evaluation pattern to all members of a composite structure: a matrix, a
list, or the arguments of an operator expression.

     `syntax: length exprn'

     `syntax: map fun obj'

    > simplify $ length (a+b);
    2
    > simplify $ length (x^n+a*x+2);
    3

    > simplify $ map sqrt [1,2,3];
    [1,2^(1/2),3^(1/2)]
    > simplify $ map log  [x^n,x^m,sin x] ;
    [log (x^n),log (x^m),log (sin x)]

    > simplify $ map (\y->df y x)  [x^n,x^m,sin x] ;
    [x^n*n/x,x^m*m/x,cos x]
    > simplify $ map (\y->intg y x)  [x^n,x^m,sin x] ;
    [x^n*x/(n+1),x^m*x/(m+1),-cos x]

Note that the `lambda' expression in REDUCE is replaced by the
corresponding Pure version.


File: pure-reduce.info,  Node: Partial Fractions,  Next: Selection,  Prev: Length and Map,  Up: Examples by Topic

5.4 Partial Fractions
=====================

The `PF' operator transforms an expression into a list of partial
fractions with respect to the main variable. `PF' does a complete
partial fraction decomposition.

     `syntax: pf expr var'

  Let us find the decomposition of:

    > let f = 2/((x+1)ˆ2*(x+2))
    > simplify $ pf f x;
    [2/(x+2),(-2)/(x+1),2/(x^2+2*x+1)]

this means

  If one wants the denominators in factored form, one has to use the
switch `off exp':

    > reduce::switch "exp" 0 ;
    0
    >
    > simplify $ pf f x;
    [2/(x+2),(-2)/(x+1),2/(((x:1):1):1)^2] // (x+1)^2 ???

Note how the switch `off exp' is used in Pure.


File: pure-reduce.info,  Node: Selection,  Next: Solving,  Prev: Partial Fractions,  Up: Examples by Topic

5.5 Selection
=============

The `SELECT' operator extracts from a list, or from the arguments of an
`n–ary' operator, elements corresponding to a boolean predicate.  It is
used with the syntax:

     `syntax: select fun list'


File: pure-reduce.info,  Node: Solving,  Next: Even and Odd Operators,  Prev: Selection,  Up: Examples by Topic

5.6 Solving
===========

`SOLVE' is an operator for solving one or more simultaneous algebraic
equations. It is used with the syntax:

     `syntax: solve expr [var | varlist]'

  where `expr' is a list of one or more expressions. Each expression is
an algebraic equation, or is the difference of the two sides of the
equation.

  Example 1:

  Find the solutions to

    > let eqn1 = log(sin (x+3))^5 == 8 ;
    > let sol1 = simplify $ solve eqn1 x;

The variable `sol1' now contains a huge list of solutions. How many?

    > #sol1 ;
    10

The first one is:

    > sol1!0;
    x==2*β5*pi+asin (e^(2^(3/5)*cos (2*pi/5))/e^(2^(3/5)*sin (2*pi/5)*i))-3

where `n' is an arbitrary integer constant.

  It is also possible - for example - to obtain the righthand side of
any solution in the list via REDUCE commands:

    > simplify $ rhs $ first $ solve eqn1 x;
    2*β10*pi+asin (e^(2^(3/5)*cos (2*pi/5))/e^(2^(3/5)*sin (2*pi/5)*i))-3
    >

where `first' gets the first solution in the list and `rhs' takes the
righthand side. Hence there is a wealth of possibilities to process the
solution list.

  Example 2:

  For the sake of clarity some simpler examples:

    > simplify $ solve [X^2+1==0] X;
    [X==i,X==-i]


    > simplify $ solve [x+3*y==7,y-x==1] [x,y] ;
    [[x==1,y==2]]

To get the multiplicities turn on the switch `multiplicities':

    > simplify $ solve [x^2==2*x-1] x;
    [x==1]

    > reduce::switch "multiplicities" 1;
    0

    > simplify $ solve [x^2==2*x-1] x;
    [x==1,x==1]

For details consult the REDUCE user manual.


File: pure-reduce.info,  Node: Even and Odd Operators,  Next: Linear Operators,  Prev: Solving,  Up: Examples by Topic

5.7 Even and Odd Operators
==========================

An operator can be declared to be even or odd in its first argument by
the declarations `EVEN' and `ODD' respectively.

    > declare operator [f1,f2];
    []
    > declare odd f1;
    []
    > declare even f2;
    []

    > simplify $ f1(-a);
    -f1 a

    > simplify $ f2 (-a);
    f2 a

    > simplify $ f1 (-a) (-b);
    -f1 a (-b)



File: pure-reduce.info,  Node: Linear Operators,  Next: Non-commuting Operators,  Prev: Even and Odd Operators,  Up: Examples by Topic

5.8 Linear Operators
====================

An operator can be declared to be linear in its first argument over
powers of its second argument.

    > declare operator L;
    []
    > declare linear L;
    []
    > simplify $ L (a*x^5+b*x+c) x ;
    L (x^5) x*a+L x x*b+L 1 x*c


    > simplify $ L (a+b+c+d) y;
    L 1 y*a+L 1 y*b+L 1 y*c+L 1 y*d

Note that L x y binds stronger than (*).


File: pure-reduce.info,  Node: Non-commuting Operators,  Next: Symmetric and Antisymmetric Operators,  Prev: Linear Operators,  Up: Examples by Topic

5.9 Non-commuting Operators
===========================

An operator can be declared to be non-commutative under multiplication
by the declaration `NONCOM'.

    > declare operator [u,v];
    []
    > simplify (u(x)*u(y)-u(y)*u(x));
    0
    > declare noncom [u,v];
    []
    > simplify (u(x)*u(y)-u(y)*u(x));
    u x*u y-u y*u x



File: pure-reduce.info,  Node: Symmetric and Antisymmetric Operators,  Next: Creating/Removing Variable Dependency,  Prev: Non-commuting Operators,  Up: Examples by Topic

5.10 Symmetric and Antisymmetric Operators
==========================================

An operator can be declared to be symmetric with respect to its
arguments by the declaration `SYMMETRIC', Similarly the declaration
`ANTISYMMETRIC' declares an operator antisymmetric.

    > declare operator [A,S];
    []
    > declare symmetric S;
    []
    > declare antisymmetric A;
    []

    > simplify $ A x x ;
    0

    > simplify $ (A x y z) + (A x z y) ;
    0

    > simplify $ S y x ;
    S x y

    > simplify $ A y x ;
    -A x y



File: pure-reduce.info,  Node: Creating/Removing Variable Dependency,  Next: Internal Order of Variables,  Prev: Symmetric and Antisymmetric Operators,  Up: Examples by Topic

5.11 Creating/Removing Variable Dependency
==========================================

There are several facilities in REDUCE, such as the differentiation
operator and the linear operator facility, that can utilize knowledge
of the dependency between various variables. Such dependency may be
expressed by the command `DEPEND'.

    > declare operator D ;
    []
    > declare depend [D,x,y];
    []

    > simplify $ df D a;
    0

D does not depend on a => 0, but

    > simplify $ df D x;
    df D x

because D depends on x by definition.  If we let a also depend on x,
then

    > declare depend [a,x];
    []
    > simplify $ df (D*a) x;
    df D x*a+df a x*D

*Note_* Dependencies remain active until they are explicitly removed:

    > declare nodepend [a,x];
    > simplify $ df a x;
    0
    > simplify $ df (D*a) x;
    df D x*a



File: pure-reduce.info,  Node: Internal Order of Variables,  Next: Parts of Algebraic Expressions,  Prev: Creating/Removing Variable Dependency,  Up: Examples by Topic

5.12 Internal Order of Variables
================================

It is possible for the user to change the internal order of variables
by means of the declaration `KORDER'. The syntax for this is:

     `syntax: declare korder [v1,...,vn];'

  Unlike the ORDER declaration, that has a purely cosmetic effect on
the way results are printed, the use of KORDER can have a significant
effect on computation time.

    > declare korder [z,y,x];
    []
    > x+y+z;
    x+y+z
    > simplify $ x+y+z;
    z+y+x



File: pure-reduce.info,  Node: Parts of Algebraic Expressions,  Next: Polynomials and Rationals,  Prev: Internal Order of Variables,  Up: Examples by Topic

5.13 Parts of Algebraic Expressions
===================================

The following operators can be used to obtain a specific part of an
expression, or even change such a part to another expression.

        - `coeff expr::polynomial var'

        - `coeffn expr::polynomial var n::int'

        - `part expr::algebraic [n::int])'

  Examples:

    > simplify $ coeff ((y^2+z)^3/z) y ;
    [z^2,0,3*z,0,3,0,1/z]

    > simplify $ coeffn ((y^2+z)^3/z) y 6;
    1/z

    > simplify $ part (a+b) 2 ;
    b

    > simplify $ part (a+b) 1 ;
    a

    > simplify $ part (a+b) 0 ;
    (+)

`PART' may also be used to substitute for a given part of an expression.
In this case, the PART construct appears on the left-hand side of an
assignment statement, and the expression to replace the given part on
the right-hand side.

    >  simplify $ xx:=a+b;
    a+b
    >  simplify $ part xx 2 := c ;
    c
    >  simplify $ xx;
    a+c



File: pure-reduce.info,  Node: Polynomials and Rationals,  Next: Substitution,  Prev: Parts of Algebraic Expressions,  Up: Examples by Topic

5.14 Polynomials and Rationals
==============================

Factorization of Polynomials

  REDUCE is capable of factorizing univariate and multivariate
polynomials that have integer coefficients, finding all factors that
also have integer coefficients. The package for doing this was written
by Dr. Arthur C. Norman and Ms. P. Mary Ann Moore at The University of
Cambridge.  It is described in *note [SYMSAC81]: 2a.

     `factorize expr::polynomial [p::prime]'

  Some examples:

    > simplify $ factorize (x^105-1) ;
    [[x^48+x^47+x^46-x^43-x^42-2*x^41-x^40 ... ]
    >
    > reduce::switch "ifactor" 1;
    0
    > simplify $ factorize (12*x^2 - 12) ;
    [[2,2],[3,1],[x+1,1],[x-1,1]]
    > reduce::switch "ifactor" 0;

The following operators should be well known:

        - *gcd* `expr1::polynomial expr2::polynomial -> polynomial'

        - *lcm* `expr1::polynomial expr2::polynomial -> polynomial'

        - *remainder* `expr1::polynomial expr2::polynomial ->
          polynomial'

        - *resultant* `expr1::polynomial expr2::polynomial var ->
          polynomial'

        - *decompose* `expr::polynomial -> list'

        - *interpol* `<values> <variable> <points>)  -> polynomial'

        - *deg* `expr::polynomial var ->int'

        - *den* `expr::rational -> polynomial'

        - *lcof* `expr::polynomial var -> polynomial'

        - *lpower* `expr::polynomial var-> polynomial'

        - *lterm* `expr::polynomial var -> polynomial'

        - *mainvar* `expr::polynomial -> expr'

        - *num* `expr::rational -> polynomial'

        - *reduct* `expr::polynomial var -> polynomial'

  Some examples of each operator:

  GCD/LCM

    > simplify $ gcd (x^2+2*x+1) (x^2+3*x+2) ;
    x+1
    > simplify $ gcd (2*x^2-2*y^2) (4*x+4*y) ;
    2*x+2*y
    > simplify $ gcd (x^2+y^2) (x-y) ;
    1
    >
    > simplify $ lcm (x^2+2*x+1) (x^2+3*x+2) ;
    x^3+4*x^2+5*x+2
    > simplify $ lcm (2*x^2-2*y^2) (4*x+4*y) ;
    4*x^2-4*y^2
    >

REMAINDER/RESULTANT

    > simplify $ remainder ((x+y)*(x+2*y)) (x+3*y) ;
    2*y^2
    > simplify $ remainder (2*x+y) 2 ;
    y
    >
    > simplify $ resultant (x/r*u+y) (u*y) u ;
    -y^2
    >

DECOMPOSE

    > simplify $ decompose (x^8-88*x^7+2924*x^6-43912*x^5+263431*x^4-
    >                                 218900*x^3+65690*x^2-7700*x+234) ;
    [u^2+35*u+234,u==v^2+10*v,v==x^2-22*x]
    >
    > simplify $ decompose (u^2+v^2+2*u*v+1) ;
    [w^2+1,w==u+v]
    >

DEG/DEN

    > simplify $ deg ((a+b)*(c+2*d)^2) d ;
    2
    > simplify $ deg ((x+b)*(x^6+2*y)^2) x ;
    13
    >
    > simplify $ den (x/y^2) ;
    y^2
    >

LCOF/LPOWER/LTERM

    > simplify $ lcof ((a+b)*(c+2*d)^2) a ;
    c^2+4*c*d+4*d^2
    > simplify $ lcof ((a+b)*(c+2*d)^2) d ;
    4*a+4*b
    > simplify $ lcof ((a+b)*(c+2*d)) ('e) ;
    a*c+2*a*d+b*c+2*b*d
    >
    > simplify $ lpower ((a+b)*(c+2*d)^2) a ;
    a
    > simplify $ lpower ((a+b)*(c+2*d)^2) d ;
    d^2
    > simplify $ lpower ((a+b)*(c+2*d)) x ;
    1
    >
    > simplify $ lterm ((a+b)*(c+2*d)^2) a ;
    a*c^2+4*a*c*d+4*a*d^2
    > simplify $ lterm ((a+b)*(c+2*d)^2) d ;
    4*a*d^2+4*b*d^2
    > simplify $ lterm ((a+b)*(c+2*d)) x ;
    a*c+2*a*d+b*c+2*b*d
    >

MAINVAR/NUM/REDUCT

    > simplify $ mainvar ((a+b)*(c+2*d)^2) ;
    a
    > simplify $ mainvar 2 ;
    0
    >
    > simplify $ num (x/y^2) ;
    x
    > simplify $ num ('(100/6)) ;
    50
    > simplify $ num (a/4+b/6) ;
    3*a+2*b
    >
    > simplify $ reduct ((a+b)*(c+2*d)) a ;
    b*c+2*b*d
    > simplify $ reduct ((a+b)*(c+2*d)) d ;
    a*c+b*c
    > simplify $ reduct ((a+b)*(c+2*d)) x ;
    0
    >



File: pure-reduce.info,  Node: Substitution,  Next: Assignment,  Prev: Polynomials and Rationals,  Up: Examples by Topic

5.15 Substitution
=================

An important class of commands in REDUCE define substitutions for
variables and expressions to be made during the evaluation of
expressions.  Such substitutions use (among others) the prefix operator
`SUB'.

     `syntax: sub <substlist> exprn::algebraic -> algebraic'

    > simplify $ sub [x==a+y,y==y+1] (x^2+y^2) ;
    a^2+2*a*y+2*y^2+2*y+1

    > simplify $ sub [a==sin x, b==sin y] (a^2+b^2) ;
    sin x^2+sin y^2



File: pure-reduce.info,  Node: Assignment,  Next: Matrix Calculations,  Prev: Substitution,  Up: Examples by Topic

5.16 Assignment
===============

One may assign values to variables in the REDUCE environment. Note that
in Pure the `set' operator and `:=' are equivalent, i.e. both sides are
evaluated, contrary to the `:=' version in REDUCE.

     `syntax: set expr expr ; or  expr := expr'

    > simplify $ P := a*x^n + b* x^m + c ;      // P:=a*x^n + b* x^m + c;
    x^m*b+x^n*a+c
    > simplify P ;                              // return P (from Reduce)
    x^m*b+x^n*a+c
    > simplify $ df P x;                        // diff P x
    (x^m*b*m+x^n*a*n)/x
    > simplify $ Q := intg P x ;                // integrate P x, store in Q
    (x^m*b*n*x+x^m*b*x+x^n*a*m*x+x^n*a*x+c*m*n*x+c*m*x+c*n*x+c*x)/(m*n+m+n+1)

    > simplify $ set Q (a*x^n + b* x^m + c) ;
    x^m*b+x^n*a+c



File: pure-reduce.info,  Node: Matrix Calculations,  Next: Limits,  Prev: Assignment,  Up: Examples by Topic

5.17 Matrix Calculations
========================

A very powerful feature of REDUCE is the ease with which matrix
calculations can be performed. It fits very well into Pure's native
matrix type.

  To keep it simple we show the usage of the different operators by
examples using the well known `Pauli matrices'. There is no loss of
generality using only `(2x2)' matrices.

  Pauli matrices (sigma 1..3).  See e.g.
<http://en.wikipedia.org/wiki/Pauli_matrices> for a reference.

    let s0 = {1,0;0,1} ;
    let s1 = {0,1;1,0} ;
    let s2 = {0,-i;i,0};
    let s3 = {1,0;0,-1};

Check the identities

  where \sigma_0 denotes the unit matrix.

  Note: `s1^2' or `s1*s1' works.

    > let r1 = simplify $ (s1*s1) ; r1;
    {1,0;0,1}
    > let r2 = simplify $ (s2*s2) ; r2;
    {1,0;0,1}
    > let r3 = simplify $ (s3*s3) ; r3;
    {1,0;0,1}
    > let r4 = simplify $ (-i*s1*s2*s3) ; r4;
    {1,0;0,1}
    > let r5 = all (==s0) [r1,r2,r3,r4] ; r5;
    1

Check: \det \sigma_i = -1, \forall i \in \{1,2,3\}.

    > map (simplify . det) [s1,s2,s3] ;
    [-1,-1,-1]

Calculate the Eigenvalues/-vectors of \sigma_2:

    > let r7 = simplify $ mateigen s2 q; r7;
    [[q-1,1,{-c1*i;c2}],[q+1,1,{c3*i;c4}]]

    > let r8 = map head r7; r8; // -> [q-1,q+1] => Eigenvalues q=+/-1
    [q-1,q+1]

    > let r9 = map (head.tail) r7 ; r9; // multiplicities
    [1,1]

    > let r10 = map last r7 ; r10; // eigenvectors
    [{-c1*i;c2},{c3*i;c4}]

Transpose (operator `tp'):

    > map (simplify.tp) [s1,s2,s3] ; // -> [s1',s2',s3']
    [{0,1;1,0},{0,i;-i,0},{1,0;0,-1}]

Trace (operator `trace'):

    > map (simplify.trace) [s1,s2,s3] ;
    [0,0,0]

Cofactor (trivial here)

    > simplify $ cofactor s2 1 1 ;
    0

Nullspace of \sigma_2 + {0,i;0,0}

    > simplify $ nullspace (s2+{0,i;0,0}) ;
    [{0;1}]

Rank

    > map (simplify . rank) [s0,s1,s2,s3] ;
    [2,2,2,2]

Inverse (simply \frac{1}{matrix})

    > let r15 = simplify $ 1/s2 ; r15;
    {0,1/i;(-1)/i,0}

    > simplify $ s2*r15 ;
    {1,0;0,1}

Solving without `solve':

    > simplify $ (1/{a11,a12;a21,a22}*{y1;y2}) ; // A^-1 * y' ;
    {(-a12*y2+a22*y1)/(a11*a22-a12*a21);(a11*y2-a21*y1)/(a11*a22-a12*a21)}



File: pure-reduce.info,  Node: Limits,  Next: Ordinary differential equations solver,  Prev: Matrix Calculations,  Up: Examples by Topic

5.18 Limits
===========

From the package description:

  LIMITS is a fast limit package for REDUCE for functions which are
continuous except for computable poles and singularities, based on some
earlier work by Ian Cohen and John P. Fitch.  This package defines a
LIMIT operator, called with the syntax:

     `limit expr::alg var limpoint::alg -> alg'

    > simplify $ limit (x*sin(1/x)) x infinity ;
    1

    > simplify $ limit (1/x) x 0 ;
    inf

Notes: This package loads automatically.  Author: Stanley L. Kameny.


File: pure-reduce.info,  Node: Ordinary differential equations solver,  Next: Series Summation and Products,  Prev: Limits,  Up: Examples by Topic

5.19 Ordinary differential equations solver
===========================================

The `ODESOLVE' package is a solver for ordinary differential equations.

  Problem 1:

    > declare depend [y,x];  // declare: y depends on x
    []

    > simplify $ odesolve [df y x == x^2+exp(x)] [y] x ;
    [y==(3*C+3*e^x+x^3)/3]

Problem 2:

    > simplify $ odesolve [(df y x 2) == y] [y] x [[x==0,y==A],[x==1,y==B]] ;
    [y==(-e^(2*x)*A+e^(2*x)*B*e+A*e^2-B*e)/(e^x*e^2-e^x)]

*Remember to remove dependencies*

    > declare nodepend [y,x];
    []



File: pure-reduce.info,  Node: Series Summation and Products,  Next: Taylor Series,  Prev: Ordinary differential equations solver,  Up: Examples by Topic

5.20 Series Summation and Products
==================================

`SUM': A package for series summation

  From the package description:

  The package implements the Gosper algorithm for the summation of
series. It defines operators `SUM' and `PROD'. The operator `SUM'
returns the indefinite or definite summation of a given expression, and
`PROD' returns the product of the given expression.  This package loads
automatically.  Author: Fujio Kako.

  Calculate

    > simplify $ sum (n^3) n 1 N ;
    (N^4+2*N^3+N^2)/4

    > simplify $ sum (a+k*r) k 0 (n-1) ;
    (2*a*n+n^2*r-n*r)/2

    > simplify $ sum (1/((p+(k-1)*q)*(p+k*q))) k 1 (n+1) ;
    (n+1)/(n*p*q+p^2+p*q)

    > simplify $ prod (k/(k+2)) k 1 N ;
    2/(N^2+3*N+2)



File: pure-reduce.info,  Node: Taylor Series,  Next: Boolean Expressions,  Prev: Series Summation and Products,  Up: Examples by Topic

5.21 Taylor Series
==================

`TAYLOR': Manipulation of Taylor series

  From the package description:

  This package carries out the Taylor expansion of an expression in one
or more variables and efficient manipulation of the resulting Taylor
series.  Capabilities include basic operations (addition, subtraction,
multiplication and division) and also application of certain algebraic
and transcendental functions.  Author: Rainer Schöpf.

  Example:

  For details consult the package documentation in the REDUCE
distribution.

    > simplify $ taylor (exp (x^2+y^2)) x 0 2 y 0 2 ;
    x^2*y^2+x^2+y^2+1

    > simplify $ taylor (exp x) x 0 3;
    (x^3+3*x^2+6*x+6)/6

    > simplify $ implicit_taylor (x^2+y^2-1) x y 0 1 5 ;
    (-x^4-4*x^2+8)/8

    > simplify $ inverse_taylor (exp(x)-1) x y 0 8;
    (-105*y^8+120*y^7-140*y^6+168*y^5-210*y^4+280*y^3-420*y^2+840*y)/840



File: pure-reduce.info,  Node: Boolean Expressions,  Next: Mathematical Functions,  Prev: Taylor Series,  Up: Examples by Topic

5.22 Boolean Expressions
========================

The truth values within REDUCE are `t' and `nil =  ()' but are mapped
to `1' and `0' respectively when interchanging results using `simplify'.
Not all predicates (functions returning a truth value), however, can be
called by `simplify', so one has to use the `lisp' function in some
rare cases.

  Some examples:

    > simplify $ evenp 200 ;
    1
    > simplify $ evenp 201 ;
    0

    > lisp (fixp 200) ;
    t

    where fixp tests for integers.

The following example shows a pitfall. Since there is a `numberp' in
Pure as well as in REDUCE one has to be careful:

     > lisp (numberp x) ;
     0

     > lisp (quote (numberp x)) ;
    []

     > lisp (quote (numberp 111)) ;
     t

In the first case `numberp x' evaluates to zero in Pure, so the `lisp'
function gets `0' and returns `0'. In the second case (quoted) the
function `numberp' is evaluated in REDUCE and returns `nil', i.e.  `[]'
in Pure. Of course, both results are correct but there may be other
cases where equally named functions have different meanings in the two
environments.

  Some other useful predicates in REDUCE are `ordp' and `freeof':

    > lisp (ordp x y) ;
    t
    > lisp (ordp y x) ;
    []
    > lisp (ordp "abc" "abd") ;
    t
    > lisp (ordp "abd" "abc") ;
    []
    > lisp (ordp 3 5) ;
    []
    > lisp (ordp 5 3) ;
    t

    > simplify $ freeof (x^2+y) x ;
    0
    > simplify $ freeof (x^2+y) z ;
    1
    > simplify $ freeof (x^n*y^m) (y^m) ;
    0



File: pure-reduce.info,  Node: Mathematical Functions,  Next: Definite Integrals,  Prev: Boolean Expressions,  Up: Examples by Topic

5.23 Mathematical Functions
===========================

REDUCE provides many mathematical functions that can take arbitrary
scalar expressions as their single argument:

        - ACOS ACOSH ACOT ACOTH ACSC ACSCH ASEC ASECH ASIN ASINH

        - ATAN ATANH ATAN2 COS COSH COT COTH CSC CSCH DILOG EI EXP

        - HYPOT LN LOG LOGB LOG10 SEC SECH SIN SINH SQRT TAN TANH ERF

  Note, however, if there is an equally named function in Pure and no
quotes are used then the Pure function is used, that is for example,
`cos x', means cos in Pure, `(quote cos) x' means cos in REDUCE ...

  See the difference:

    > simplify $ (cos 4.3);
    cos (43/10)
    > using math;
    warning: external 'exp' shadows previous undefined use of this symbol
    warning: external 'sin' shadows previous undefined use of this symbol
    warning: external 'cos' shadows previous undefined use of this symbol
    > simplify $ (cos 4.3);
    (-21601483)/53896027

Some examples:

    > simplify $ cos (-x) ;
    cos x
    > simplify $ cos (n*pi) ;
    cos (80143857*n/25510582)
    > simplify $ (quote e)^(3*i*(quote pi)/2) ;
    -i
    > simplify $ sec (quote pi);
    -1
    > let simplify $ log10 10 ;
    1
    > simplify $ erf (-a);
    -erf a

The special functions are in two separate packages `SPECFN' and
`SPECFN2':

        - Bernoulli Numbers and Euler Numbers;

        - Stirling Numbers;

        - Binomial Coefficients;

        - Pochhammer notation;

        - The Gamma function;

        - The Psi function and its derivatives;

        - The Riemann Zeta function;

        - The Bessel functions J and Y of the first and second kind;

        - The modified Bessel functions I and K;

        - The Hankel functions H1 and H2;

        - The Kummer hypergeometric functions M and U;

        - The Beta function, and Struve, Lommel and Whittaker functions;

        - The Airy functions;

        - The Exponential Integral, the Sine and Cosine Integrals;

        - The Hyperbolic Sine and Cosine Integrals;

        - The Fresnel Integrals and the Error function;

        - The Dilog function;

        - Hermite Polynomials;

        - Jacobi Polynomials;

        - Legendre Polynomials;

        - Spherical and Solid Harmonics;

        - Laguerre Polynomials;

        - Chebyshev Polynomials;

        - Gegenbauer Polynomials;

        - Euler Polynomials;

        - Bernoulli Polynomials.

        - Jacobi Elliptic Functions and Integrals;

        - 3j symbols, 6j symbols and Clebsch Gordan coefficients;

  In `SPECFN2' are the generalized hypergeometric functions and
Meijer’s G function.

  Author: Chris Cannam, with contributions from Winfried Neun, Herbert
Melenk, Victor Adamchik, Francis Wright and several others.


File: pure-reduce.info,  Node: Definite Integrals,  Next: Declarations Switches and Loading,  Prev: Mathematical Functions,  Up: Examples by Topic

5.24 Definite Integrals
=======================

Package: DEFINT (definite integrals) Calculating integrals by using the
Meijer G integration formula.

    > reduce::load "defint" ;
    0

    > simplify $ intg (exp(-x)) x 0 infinity ;
    1


    > simplify $ intg (x^2*cos(x)*exp(-2*x)) x 0 infinity ;
    4/125


    > simplify $ intg (x*exp(-1/2*x)) x 0 1 ;
    2*sqrt e*(2*sqrt e-3)/e


    > simplify $ intg (x*log(1+x)) x 0 1 ;
    1/4


    > simplify $ intg (cos(2*x)) x y (2*y);
    (sin (4*y)-sin (2*y))/2

Various transformations:

    > simplify $ laplace_transform (exp(-a*x)) x ;
    1/(a+s)

    > simplify $ hankel_transform (exp(-a*x)) x ;
    s^(n/2)*gamma (n/2)*hypergeometric [(n+2)/2] [n+1]
    ((-s)/a)*n/(2*a^(n/2)*gamma (n+1)*a)

    > simplify $ y_transform (exp(-a*x)) x ;
    (a^n*gamma (n+1)*gamma ((-n)/2)*gamma ((-2*n-1)/2)*gamma
    ((2*n+3)/2)*hypergeometric [(-n+2)/2] [-n+1] ((-s)/a)+s^n*gamma
    (-n)*gamma (n/2)*hypergeometric [(n+2)/2] [n+1] ((-s)/a)*n*pi)/
    (2*s^(n/2)*a^(n/2)*gamma ((-2*n-1)/2)*gamma ((2*n+3)/2)*a*pi)

    > simplify $ k_transform (exp(-a*x)) x ;
    (-a^n*gamma (n+1)*gamma ((-n)/2)*hypergeometric [(-n+2)/2] [-n+1]
    (s/a)+s^n*gamma (-n)*gamma (n/2)*hypergeometric [(n+2)/2] [n+1] (s/a)*n)/
    (4*s^(n/2)*a^(n/2)*a)

    >  simplify $ struveh_transform (exp(-a*x)) x ;
    2*s^((n+1)/2)*gamma ((n+3)/2)*hypergeometric [1,(n+3)/2] [(2*n+3)/2,3/2]
    ((-s)/a)/(sqrt pi*a^((n+1)/2)*gamma ((2*n+3)/2)*a)

    > simplify $ fourier_sin (exp(-a*x)) x ;
    s/(a^2+s^2)
    > simplify $ fourier_cos (exp(-a*x)) x ;
    a/(a^2+s^2)



File: pure-reduce.info,  Node: Declarations Switches and Loading,  Next: Plotting,  Prev: Definite Integrals,  Up: Examples by Topic

5.25 Declarations, Switches and Loading
=======================================

Lisp evaluation can be used in the REDUCE system, in particular, to
declare operator symbols and their properties (simplify won't do that).
E.g.:

    > lisp ('operator [myop]);
    > lisp ('flag [myop] odd);
    > lisp ('prop myop); // => [odd:t,simpfn:simpiden]
    > simplify (myop (-x)); // => -myop x

For the most common kinds of declarations, the reduce module already
provides the *note declare: 14. function which takes care of the
necessary Lisp magic and is safe to use. The above example can also be
done as follows:

    > declare operator myop;
    > declare odd myop;
    > simplify (myop (-x));
    -myop x

For a list of supported declarations via `declare' consult the module
file `reduce.pure'.

  In Pure the REDUCE switches can be turned `on/off' as follows:

     `reduce::switch "switch-id" 0/1 ;'

  A package can be loaded by the command

     `reduce::load "package-id" ;'

  A REDUCE source file may be _read-in_ by the command:

     `lisp ('in ["path/filename.red"]) ;'


File: pure-reduce.info,  Node: Plotting,  Next: References,  Prev: Declarations Switches and Loading,  Up: Examples by Topic

5.26 Plotting
=============

Using Gnuplot:

    > reduce::load "gnuplot";

Note that we have to quote the x..y ranges here so that they get
through to Reduce, rather than being evaluated on the Pure side.

    > simplify $ 'plot (sin x/x) (x==(-15..15));

    // Multiple ranges.
    > simplify $ 'plot (sin(x^2 + y^2) / sqrt(x^2 + y^2))
    [x==(-12 .. 12), y==(-12 .. 12)];

    // Specifying options.
    > simplify $ 'plot (cos (sqrt(x^2 + y^2))) [x==(-3 .. 3),y==(-3 .. 3)] hidden3d;

    // Specifying points.
    > simplify $ plot [[0,0],[0,1],[1,1],[0,0],[1,0],[0,1],[0.5,1.5],[1,1],[1,0]];

    // Output options.
    > simplify $ plot (sin x) [x=='(0 .. 10),terminal==postscript,output=="sin.ps"];



File: pure-reduce.info,  Node: References,  Prev: Plotting,  Up: Examples by Topic

5.27 References:
================

     (REDUM) _REDUCE User’s Manual_, Version 3.8, Anthony C. Hearn,
     Santa Monica, CA, USA.

     (LNCS102) _On the Integration of Algebraic Functions_, LNCS 102,
     Springer Verlag, 1981.

     (SYMSAC81) P. M. A. Moore and A.C. Norman, _Implementing a
     Polynomial Factorization and GCD Package_, Proc.  SYMSAC ’81, ACM
     (New York) (1981), 109-116.


File: pure-reduce.info,  Node: Index,  Prev: Examples by Topic,  Up: Top

Index
*****

 [index ]
* Menu:

* declare function:                      High-Level Interface.
                                                              (line  82)
* lisp function:                         High-Level Interface.
                                                              (line  71)
* plotreset function:                    High-Level Interface.
                                                              (line 109)
* precision function:                    High-Level Interface.
                                                              (line 101)
* reduce finish function:                High-Level Interface.
                                                              (line  34)
* reduce load function:                  High-Level Interface.
                                                              (line  52)
* reduce module:                         Top.                 (line   6)
* reduce start function:                 High-Level Interface.
                                                              (line  22)
* reduce switch function:                High-Level Interface.
                                                              (line  56)
* reduce verbosity function:             High-Level Interface.
                                                              (line  41)
* REDUCE_PATH variable:                  High-Level Interface.
                                                              (line  16)
* simplify function:                     High-Level Interface.
                                                              (line  64)

                                                             
                              



Tag Table:
Node: Top294
Ref: 22410
Ref: reduce2410
Ref: 32410
Ref: maxima2410
Ref: 42410
Ref: sourceforge2410
Ref: 52410
Ref: license2410
Ref: 62410
Ref: embedding-reduce2410
Node: Installation3764
Ref: installation3861
Ref: 03861
Ref: module-reduce3861
Ref: 93861
Ref: computer-algebra-with-pure-a-reduce-interface3861
Ref: 13861
Node: Low-Level Interface6537
Ref: low-level interface6651
Ref: 76651
Ref: low-level-interface6651
Ref: a7365
Ref: proc7365
Ref: b7365
Ref: csl7365
Node: High-Level Interface7365
Ref: high-level interface7481
Ref: 87481
Ref: high-level-interface7481
Ref: c7853
Ref: reduce_path7853
Ref: d8102
Ref: reduce start8102
Ref: e8814
Ref: reduce finish8814
Ref: f9129
Ref: reduce verbosity9129
Ref: 109529
Ref: reduce load9529
Ref: 119703
Ref: reduce switch9703
Ref: 129988
Ref: simplify9988
Ref: 1310303
Ref: lisp10303
Ref: 1410922
Ref: declare10922
Ref: 1511813
Ref: precision11813
Ref: 1612237
Ref: plotreset12237
Ref: 1712442
Ref: gnuplot12442
Node: Basic Examples13920
Ref: basic examples14034
Ref: 1814034
Ref: basic-examples14034
Node: Examples by Topic16598
Ref: examples by topic16697
Ref: 1916697
Ref: examples-by-topic16697
Node: Differentiation17802
Ref: differentiation17896
Ref: 1b17896
Node: Integration18884
Ref: integration19001
Ref: 1c19001
Node: Length and Map20566
Ref: length and map20685
Ref: 1e20685
Ref: length-and-map20685
Node: Partial Fractions21524
Ref: partial fractions21641
Ref: 1f21641
Ref: partial-fractions21641
Node: Selection22289
Ref: selection22399
Ref: 2022399
Node: Solving22629
Ref: solving22744
Ref: 2122744
Node: Even and Odd Operators24298
Ref: even and odd operators24420
Ref: 2224420
Ref: even-and-odd-operators24420
Node: Linear Operators24814
Ref: linear operators24952
Ref: 2324952
Ref: linear-operators24952
Node: Non-commuting Operators25341
Ref: non-commuting operators25494
Ref: 2425494
Ref: non-commuting-operators25494
Node: Symmetric and Antisymmetric Operators25828
Ref: symmetric and antisymmetric operators26002
Ref: 2526002
Ref: symmetric-and-antisymmetric-operators26002
Node: Creating/Removing Variable Dependency26538
Ref: creating/removing variable dependency26716
Ref: 2626716
Ref: creating-removing-variable-dependency26716
Node: Internal Order of Variables27558
Ref: internal order of variables27729
Ref: 2727729
Ref: internal-order-of-variables27729
Node: Parts of Algebraic Expressions28237
Ref: parts of algebraic expressions28396
Ref: 2828396
Ref: parts-of-algebraic-expressions28396
Node: Polynomials and Rationals29326
Ref: polynomials and rationals29470
Ref: 2929470
Ref: polynomials-and-rationals29470
Node: Substitution33076
Ref: substitution33200
Ref: 2b33200
Node: Assignment33659
Ref: assignment33777
Ref: 2c33777
Node: Matrix Calculations34545
Ref: matrix calculations34657
Ref: 2d34657
Ref: matrix-calculations34657
Node: Limits36823
Ref: limits36963
Ref: 2e36963
Node: Ordinary differential equations solver37488
Ref: ordinary differential equations solver37638
Ref: 2f37638
Ref: ordinary-differential-equations-solver37638
Node: Series Summation and Products38186
Ref: series summation and products38343
Ref: 3038343
Ref: series-summation-and-products38343
Node: Taylor Series39083
Ref: taylor series39221
Ref: 3139221
Ref: taylor-series39221
Node: Boolean Expressions40109
Ref: boolean expressions40240
Ref: 3240240
Ref: boolean-expressions40240
Node: Mathematical Functions41747
Ref: mathematical functions41883
Ref: 3341883
Ref: mathematical-functions41883
Node: Definite Integrals44627
Ref: definite integrals44777
Ref: 3444777
Ref: definite-integrals44777
Node: Declarations Switches and Loading46370
Ref: declarations switches and loading46506
Ref: 3546506
Ref: declarations-switches-and-loading46506
Node: Plotting47587
Ref: plotting47715
Ref: 3647715
Node: References48426
Ref: references48512
Ref: 3748512
Node: Index48916
Ref: index48992
Ref: 1a50596
Ref: 2a50627
Ref: 1d50658

End Tag Table


Local Variables:
coding: utf-8
End:
