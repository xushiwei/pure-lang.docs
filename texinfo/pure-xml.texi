\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-xml.info
@documentencoding UTF-8
@copying
Generated by Sphinx
@end copying
@settitle pure-xml
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-xml: (pure-xml.info).    Pure-XML - XML/XSLT interface
@end direntry

@c %**end of header

@titlepage
@title pure-xml
@author Albert Gr√§f (Editor)
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-xml
@end ifnottex

@c %**start of body
@geindex xml module
Version 0.6, June 26, 2012

Albert Graef <@email{Dr.Graef@@t-online.de}>

@uref{http://www.w3.org/TR/xml,XML}, the Extensible Markup Language, facilitates the exchange of complex
structured data between applications and systems. @uref{http://www.w3.org/TR/xslt,XSLT} allows you to
transform XML documents to other XML-based formats such as HTML. Together, XML
and XSLT let you create dynamic web content with ease. Both XML and XSLT are
open standards by the W3C consortium (@indicateurl{http://www.w3.org}).

@anchor{0}@anchor{xml}@anchor{1}@anchor{xslt}Pure's XML interface is based on the libxml2 and libxslt libraries from the
GNOME project. If you have a Linux system then you most likely have these
libraries, otherwise you can get them from @indicateurl{http://xmlsoft.org}. For Windows
users, the required dlls are available from the GnuWin32 project
(@indicateurl{http://gnuwin32.sourceforge.net}) and are already included in the Pure MSI
package.


@menu
* Copying::
* Installation::
* Usage::
* Data Structure::
* Operations::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Data Structure

* The Document Tree::
* Document Types::

Operations

* Document Operations::
* Traversing Documents::
* Node Information::
* Node Manipulation::
* Transformations::
@end detailmenu
@end menu


@node Copying,Installation,Top,Top
@anchor{copying}@anchor{2}@anchor{module-xml}@anchor{3}@anchor{pure-xml-xml-xslt-interface}@anchor{4}
@chapter Copying
Copyright (c) 2009 by Albert Graef <@email{Dr.Graef@@t-online.de}>.

pure-xml is free software: you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

pure-xml is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
details.

You should have received a copy of the GNU Lesser General Public License along
with this program.  If not, see <@indicateurl{http://www.gnu.org/licenses/}>.


@node Installation,Usage,Copying,Top
@anchor{installation}@anchor{5}
@chapter Installation
Get the latest source from
@indicateurl{http://pure-lang.googlecode.com/files/pure-xml-0.6.tar.gz}.

Run @code{make} and then @code{sudo make install} to compile and install this
module. This requires libxml2, libxslt and Pure.


@node Usage,Data Structure,Installation,Top
@anchor{usage}@anchor{6}
@chapter Usage
Use the following declaration to make the operations of this module available
in your programs:

@example
using xml;
@end example

@noindent
The module defines two namespaces @code{xml} and @code{xslt} for the XML and the
XSLT operations, respectively. For convenience, you can open these in your
program as follows:

@example
using namespace xml, xslt;
@end example

@noindent
A number of complete examples illustrating the use of this module can be found
in the examples directory in the source distribution.


@node Data Structure,Operations,Usage,Top
@anchor{data structure}@anchor{7}@anchor{data-structure}
@chapter Data Structure
This module represents XML documents using pointers to the @code{xmlDoc} and
@code{xmlNode} structures provided by the libxml2 library. Similarly,
stylesheets are simply pointers to the xmlStylesheet structure from libxslt
(cf. @pxref{8,,Transformations}). This makes it possible to use these objects
directly with the operations of the libxml2 and libsxslt libraries (via
Pure's C interface) if necessary. Note, however, that these are all
"cooked" pointers which take care of freeing themselves automatically when
they are no longer needed, therefore you shouldn't free them manually.

You can also check for these types of pointers using the following
predicates:

@geindex xml docp function
@anchor{9}@anchor{xml docp}
@deffn {Function} xml::docp x

checks whether @code{x} is an XML document pointer.
@end deffn

@geindex xml nodep function
@anchor{a}@anchor{xml nodep}
@deffn {Function} xml::nodep x

checks whether @code{x} is a pointer to a node in an XML document.
@end deffn

@geindex xslt stylesheetp function
@anchor{b}@anchor{xslt stylesheetp}
@deffn {Function} xslt::stylesheetp x

checks whether @code{x} is an XSLT stylesheet pointer.
@end deffn


@menu
* The Document Tree::
* Document Types::
@end menu


@node The Document Tree,Document Types,,Data Structure
@anchor{the document tree}@anchor{c}@anchor{the-document-tree}
@section The Document Tree
An XML document is a rooted tree which can be created, traversed and
manipulated using the operations of this module. There are different types
of nodes in the tree, each carrying their own type of data. In Pure land,
the node data is described using the following "node info" constructors.

@geindex node info
@anchor{d}@anchor{index-0}@anchor{e}@anchor{node-info}
@geindex xml element constructor
@anchor{f}@anchor{xml element}
@deffn {constructor} xml::element tag ns attrs

An XML element with given (possibly qualified) name @code{tag}, a (possibly
empty) list of namespace declarations @code{ns} and a (possibly empty) list
of attributes @code{attrs}. Namespace declarations normally take the form
of a pair of strings @code{(prefix,href)}, where @code{prefix} is the prefix
associated with the namespace and @code{href} the corresponding URI (the
name of the namespace), but they can also be just a string @code{href} if
the namespace prefix is missing. Attributes are encoded as
@code{key=>value} pairs, where @code{key} is the attribute name and @code{value}
the associated value; both @code{key} and @code{value} are strings.
@end deffn

@geindex xml element_text constructor
@anchor{10}@anchor{xml element_text}
@deffn {constructor} xml::element_text tag ns attrs content

A convenience function which denotes a combination of an element node
with a text child. This is only used when creating a new node, and
indicates that a text node child is to be added to the node
automatically.
@end deffn

@geindex xml attr constructor
@anchor{11}@anchor{xml attr}
@deffn {constructor} xml::attr key val

An attribute node. These only occur as results of the @code{select} and
@code{attrs} functions, and cannot be inserted directly into a
document.
@end deffn

@geindex xml text constructor
@anchor{12}@anchor{xml text}
@deffn {constructor} xml::text content

A text node with the given content (a string).
@end deffn

@geindex xml cdata constructor
@anchor{13}@anchor{xml cdata}
@deffn {constructor} xml::cdata content

Like @pxref{12,,xml text}, but contains unparsed character data.
@end deffn

@geindex xml comment constructor
@anchor{14}@anchor{xml comment}
@deffn {constructor} xml::comment content

A comment.
@end deffn

@geindex xml entity_ref constructor
@anchor{15}@anchor{xml entity_ref}
@deffn {constructor} xml::entity_ref name

An entity reference (@code{&name;}).
@end deffn

@geindex xml pi constructor
@anchor{16}@anchor{xml pi}
@deffn {constructor} xml::pi name content

Processing instructions. @code{name} is the application name, @code{content}
the text of the processing instructions.
@end deffn


@node Document Types,,The Document Tree,Data Structure
@anchor{document types}@anchor{17}@anchor{document-types}
@section Document Types

@geindex dtd
@anchor{18}@anchor{index-1}@anchor{19}@anchor{dtd}Besides the node types described above, there are some additional node
types used in the @uref{http://www.w3.org/TR/REC-xml/#dt-doctype,document type definition} (DTD), which can be extracted
from a document using the @code{int_subset} and @code{ext_subset}
functions. These are for inspection purposes only; it is not possible to
change the DTD of a document in-place. (However, you can create a new
document and attach a DTD to it, using the @code{new_doc} function.)

@anchor{1a}@anchor{document-type-definition}
@geindex xml doctype constructor
@anchor{1b}@anchor{xml doctype}
@deffn {constructor} xml::doctype name extid

DTDs are represented using this special type of node, where @code{name} is
the name of the root element, and @code{extid} is a pair consisting of the
external identifier and the URI of the DTD (or just the URI if there is
no external identifier). The @pxref{1b,,xml doctype} node has as its
children zero or more of the following kinds of DTD declaration nodes
(these are just straightforward abstract syntax for the !ELEMENT,
!ATTLIST and !ENTITY declarations inside a DTD declaration; see the XML
specification for details).
@end deffn

@geindex element declaration
@anchor{1c}@anchor{index-2}@anchor{1d}@anchor{element-declaration}@emph{Element declarations:} Here, @code{name} is the element tag and @code{content}
the definition of the element structure, see @pxref{1e,,element content} below. XML
supports various kinds of element types, please refer to @uref{http://www.w3.org/TR/REC-xml/#dt-doctype,document type definition} in the XML specification for details.

@geindex xml undefined_element constructor
@anchor{1f}@anchor{xml undefined_element}
@deffn {constructor} xml::undefined_element name

An undefined element. This is in libxml2, but not in the XML
specification, you shouldn't see this in normal operation.
@end deffn

@geindex xml empty_element constructor
@anchor{20}@anchor{xml empty_element}
@deffn {constructor} xml::empty_element name

An element without any content.
@end deffn

@geindex xml any_element constructor
@anchor{21}@anchor{xml any_element}
@deffn {constructor} xml::any_element name

An element with unrestricted content.
@end deffn

@geindex xml mixed_element constructor
@anchor{22}@anchor{xml mixed_element}
@deffn {constructor} xml::mixed_element name content

A "mixed" element which can contain character data, optionally
interspersed with child elements, as given in the @code{content}
specification.
@end deffn

@geindex xml std_element constructor
@anchor{23}@anchor{xml std_element}
@deffn {constructor} xml::std_element name content

A standard element consisting @emph{only} of child elements, as given in the
@code{content} specification.
@end deffn

@geindex attribute declaration
@anchor{24}@anchor{index-3}@anchor{25}@anchor{attribute-declaration}@emph{Attribute declarations:} These are used to declare the attributes of an
element. @code{elem_name} is the name of an element which describes the
attribute type, @code{name} is the name of the attribute itself, and
@code{default} specifies the default value of the attribute, see @pxref{26,,attribute defaults} below. XML supports a bunch of different attribute types, please
refer to @uref{http://www.w3.org/TR/REC-xml/#dt-doctype,document type definition} in the XML specification for details.

@geindex xml cdata_attr constructor
@anchor{27}@anchor{xml cdata_attr}
@deffn {constructor} xml::cdata_attr elem_name name default
@end deffn

@geindex xml id_attr constructor
@anchor{28}@anchor{xml id_attr}
@deffn {constructor} xml::id_attr elem_name name default
@end deffn

@geindex xml idref_attr constructor
@anchor{29}@anchor{xml idref_attr}
@deffn {constructor} xml::idref_attr elem_name name default
@end deffn

@geindex xml idrefs_attr constructor
@anchor{2a}@anchor{xml idrefs_attr}
@deffn {constructor} xml::idrefs_attr elem_name name default
@end deffn

@geindex xml entity_attr constructor
@anchor{2b}@anchor{xml entity_attr}
@deffn {constructor} xml::entity_attr elem_name name default
@end deffn

@geindex xml entities_attr constructor
@anchor{2c}@anchor{xml entities_attr}
@deffn {constructor} xml::entities_attr elem_name name default
@end deffn

@geindex xml nmtoken_attr constructor
@anchor{2d}@anchor{xml nmtoken_attr}
@deffn {constructor} xml::nmtoken_attr elem_name name default
@end deffn

@geindex xml nmtokens_attr constructor
@anchor{2e}@anchor{xml nmtokens_attr}
@deffn {constructor} xml::nmtokens_attr elem_name name default
@end deffn

@geindex xml enum_attr constructor
@anchor{2f}@anchor{xml enum_attr}
@deffn {constructor} xml::enum_attr elem_name name vals default
@end deffn

@geindex xml notation_attr constructor
@anchor{30}@anchor{xml notation_attr}
@deffn {constructor} xml::notation_attr elem_name name vals default
@end deffn

@geindex entity declaration
@anchor{31}@anchor{index-4}@anchor{32}@anchor{entity-declaration}@emph{Entity declarations:} These are used for internal and external entity
declarations. @code{name} is the entity name and @code{content} its
definition. External entities also have an @code{extid} (external
identifier/URI pair) identifying the entity.

@geindex xml int_entity constructor
@anchor{33}@anchor{xml int_entity}
@deffn {constructor} xml::int_entity name content
@end deffn

@geindex xml int_param_entity constructor
@anchor{34}@anchor{xml int_param_entity}
@deffn {constructor} xml::int_param_entity name content
@end deffn

@geindex xml ext_entity constructor
@anchor{35}@anchor{xml ext_entity}
@deffn {constructor} xml::ext_entity name extid content
@end deffn

@geindex xml ext_param_entity constructor
@anchor{36}@anchor{xml ext_param_entity}
@deffn {constructor} xml::ext_param_entity name extid content
@end deffn

@geindex element content
@anchor{37}@anchor{index-5}@anchor{1e}@anchor{element-content}The element content type (@code{content} argument of the @pxref{1d,,element declaration} nodes) is a kind of regular expression formed with tags
(specified as strings) and the following constructors:

@geindex xml pcdata constructor
@anchor{38}@anchor{xml pcdata}
@deffn {constructor} xml::pcdata: text data (``#PCDATA``)
@end deffn

@geindex xml sequence constructor
@anchor{39}@anchor{xml sequence}
@deffn {constructor} xml::sequence xs: concatenation (``x,y,z``)
@end deffn

@geindex xml union constructor
@anchor{3a}@anchor{xml union}
@deffn {constructor} xml::union xs: alternatives (``x|y|z``)
@end deffn

@geindex xml opt constructor
@anchor{3b}@anchor{xml opt}
@deffn {constructor} xml::opt x: optional element (``x?``)
@end deffn

@geindex xml mult constructor
@anchor{3c}@anchor{xml mult}
@deffn {constructor} xml::mult x: repeated element (``x*``)
@end deffn

@geindex xml plus constructor
@anchor{3d}@anchor{xml plus}
@deffn {constructor} xml::plus x: non-optional repeated element (``x+``)
@end deffn

@geindex attribute defaults
@anchor{3e}@anchor{index-6}@anchor{26}@anchor{attribute-defaults}Attribute defaults (the @code{default} argument of @pxref{25,,attribute declaration}
nodes) are represented using the following constructor symbols:

@geindex xml required constructor
@anchor{3f}@anchor{xml required}
@deffn {constructor} xml::required

a required attribute, i.e., the user must specify this
@end deffn

@geindex xml implied constructor
@anchor{40}@anchor{xml implied}
@deffn {constructor} xml::implied

an implied attribute, i.e., the user does not have to specify this
@end deffn

@geindex xml default constructor
@anchor{41}@anchor{xml default}
@deffn {constructor} xml::default val

an attribute with the given default value @code{val}
@end deffn

@geindex xml fixed constructor
@anchor{42}@anchor{xml fixed}
@deffn {constructor} xml::fixed val

an attribute with the given fixed value @code{val}
@end deffn


@node Operations,Index,Data Structure,Top
@anchor{operations}@anchor{43}
@chapter Operations
This module provides all operations necessary to create, inspect and
manipulate XML documents residing either in memory or on disk. Operations
for formatting XML documents using XSLT stylesheets are also available.


@menu
* Document Operations::
* Traversing Documents::
* Node Information::
* Node Manipulation::
* Transformations::
@end menu


@node Document Operations,Traversing Documents,,Operations
@anchor{document operations}@anchor{44}@anchor{document-operations}
@section Document Operations
The following functions allow you to create new XML documents, load them
from or save them to a file or a string, and provide general information
about a document.

@geindex xml new_doc function
@anchor{45}@anchor{xml new_doc}
@deffn {Function} xml::new_doc version dtd info

This function creates an XML document. It returns a pointer to the new
document. @code{version} is a string denoting the XML version (or @code{""} to
indicate the default). @code{info} is the @pxref{e,,node info} of the root node
(which should denote an element node). @code{dtd} denotes the document type
which can be @code{()} to denote an empty DTD, a string (the URI/filename
of the DTD), or a pair @code{(pubid,sysid)} where @code{pubid} denotes the
public identifier of the DTD and @code{sysid} its system identifier (URI).

Note that only simple kinds of documents with an internal DTD can be
created this way. Use the @code{load_file} or @code{load_string}
function below to create a skeleton document if a more elaborate prolog
is required.
@end deffn

@geindex xml load_file function
@geindex xml load_string function
@anchor{46}@anchor{xml load_file}
@deffn {Function} xml::load_file name flags
@anchor{47}@anchor{xml load_string}
@deffnx {Function} xml::load_string s flags

Load an XML document from a file @code{name} or a string @code{s}. @code{flags}
denotes the parser flags, a bitwise disjunction of any of the following
constants, or 0 for the default:

@itemize -
@item
@code{xml::DTDLOAD}: load DTD
@item
@code{xml::DTDVALID}: validate
@item
@code{xml::PEDANTIC}: pedantic parse
@item
@code{xml::SUBENT}: substitute entities
@item
@code{xml::NOBLANKS}: suppress blank nodes
@end itemize

The return value is the document pointer. These operations may also fail
if there is a fatal error parsing the document.
@end deffn

@geindex xml save_file function
@geindex xml save_string function
@anchor{48}@anchor{xml save_file}
@deffn {Function} xml::save_file name doc encoding compression
@anchor{49}@anchor{xml save_string}
@deffnx {Function} xml::save_string doc

Save an XML document @code{doc} to a file or a string. When saving to a
file, @code{encoding} denotes the desired encoding (or @code{""} for the
default), @code{compression} the desired level of zlib compression (0 means
none, 9 is maximum, -1 indicates the default). Note that with
@pxref{49,,xml save_string}, the result is always encoded as UTF-8.
@end deffn

@geindex xml doc_info function
@anchor{4a}@anchor{xml doc_info}
@deffn {Function} xml::doc_info doc

Retrieve general information about a document. Returns a tuple
@code{(version,encoding,url,compression,standalone)}, where @code{version} is
the XML version of the document, @code{encoding} the external encoding (if
any), @code{url} the name/location of the document (if any),
@code{compression} the level of zlib compression, and @code{standalone} is a
flag indicating whether the document contains any external markup
declarations "which affect the information passed from the XML processor
to the application", see the section on the @uref{http://www.w3.org/TR/REC-xml/#sec-rmd,standalone document declaration} in the XML spec for details. (Apparently, in libxml2
@code{standalone} is either a truth value or one of the special values -1,
indicating that there's no XML declaration in the prolog, or -2,
indicating that there's an XML declaration but no @code{standalone}
attribute.)
@end deffn

@anchor{4b}@anchor{standalone-document-declaration}
@geindex xml int_subset function
@geindex xml ext_subset function
@anchor{4c}@anchor{xml int_subset}
@deffn {Function} xml::int_subset doc
@anchor{4d}@anchor{xml ext_subset}
@deffnx {Function} xml::ext_subset doc

Retrieve the internal and external DTD subset of a document. Returns a
@code{doctype} node (fails if there's no corresponding DTD).
@end deffn

@strong{Example}

Read the sample.xml document distributed with the sources (ignoring blank
nodes) and retrieve the document info:

@example
> using xml;
> let sample = xml::load_file "sample.xml" xml::NOBLANKS;
> xml::doc_info sample;
"1.0","","sample.xml",0,-2
@end example

@noindent

@node Traversing Documents,Node Information,Document Operations,Operations
@anchor{traversing documents}@anchor{4e}@anchor{traversing-documents}
@section Traversing Documents
These operations are used to traverse the document tree, i.e., the nodes of
the document. They take either a document pointer @code{doc} or a node pointer
@code{node} as argument, and yield a corresponding node pointer (or a document
pointer, in the case of @pxref{4f,,xml doc}). The node pointers can then be
used with the @pxref{50,,Node Information} and @pxref{51,,Node Manipulation} operations
described below.

@geindex xml root function
@anchor{52}@anchor{xml root}
@deffn {Function} xml::root doc

the root node of @code{doc}
@end deffn

@geindex xml doc function
@anchor{4f}@anchor{xml doc}
@deffn {Function} xml::doc node

the document @code{node} belongs to
@end deffn

@geindex xml parent function
@anchor{53}@anchor{xml parent}
@deffn {Function} xml::parent node

the parent of @code{node}
@end deffn

@geindex xml first function
@geindex xml last function
@anchor{54}@anchor{xml first}
@deffn {Function} xml::first node
@anchor{55}@anchor{xml last}
@deffnx {Function} xml::last node

first and last child node
@end deffn

@geindex xml next function
@geindex xml prev function
@anchor{56}@anchor{xml next}
@deffn {Function} xml::next node
@anchor{57}@anchor{xml prev}
@deffnx {Function} xml::prev node

next and previous sibling
@end deffn

@geindex xml first_attr function
@geindex xml last_attr function
@anchor{58}@anchor{xml first_attr}
@deffn {Function} xml::first_attr node
@anchor{59}@anchor{xml last_attr}
@deffnx {Function} xml::last_attr node

first and last attribute node
@end deffn

All these operations fail if the corresponding target node does not exist,
or if the type of the given node is not supported by this implementation.

There are also two convenience functions to retrieve the children and
attribute nodes of a node:

@geindex xml children function
@anchor{5a}@anchor{xml children}
@deffn {Function} xml::children node

returns the list of all child nodes of @code{node}
@end deffn

@geindex xml attrs function
@anchor{5b}@anchor{xml attrs}
@deffn {Function} xml::attrs node

returns the list of all attribute nodes of @code{node}
@end deffn

Moreover, given a node pointer @code{node}, @code{node!i} can be used to retrieve
the @code{i}th child of @code{node}.

@strong{Example}

Peek at the root node of the sample document and its children:

@example
> let r = xml::root sample; r;
#<pointer 0xe15e10>
> xml::node_info r;
xml::element "story" [] []
> #xml::children r;
5
> xml::node_info (r!0);
xml::cdata "<greeting>Hello, world!</greeting>"
@end example

@noindent

@node Node Information,Node Manipulation,Traversing Documents,Operations
@anchor{node information}@anchor{50}@anchor{node-information}
@section Node Information
These operations retrieve information about the nodes of an XML document.

@geindex xml select function
@anchor{5c}@anchor{xml select}
@deffn {Function} xml::select doc xpath

@deffnx {Function} xml::select doc (xpath,ns)

Retrieve nodes using an @uref{http://www.w3.org/TR/xpath,XPath} specification. Given an XPath (a string)
@code{xpath}, this operation returns the list of all matching nodes in the
given document @code{doc}. You can also specify a node as the first
argument, in which case the document of the given node is searched and
paths are interpreted relative to the given node (rather than the root
node of the document).

Moreover, instead of just an XPath you can also specify a pair
@code{(xpath,ns)} consisting of an XPath @code{xpath} and a list @code{ns} of
@code{prefix=>uri} string pairs which describe the namespaces to be
recognized in the XPath expression. This is necessary to select nodes by
qualified tag or attribute names. Note that only the namespace URIs must
match up with those used in the queried document; the corresponding
namespace prefixes can be chosen freely, so you can use whatever
prefixes are convenient to formulate the XPath query. However, for each
namespace prefix used in the XPath expression (not the document!), there
@emph{must} be a corresponding binding in the @code{ns} list. Otherwise the
underlying libxml2 function will complain about an undefined namespace
prefix and @pxref{5c,,xml select} will fail.

@anchor{5d}@anchor{xpath}
@end deffn

@geindex xml node_info function
@anchor{5e}@anchor{xml node_info}
@deffn {Function} xml::node_info node

Retrieve the node data from @code{node}. Returns a @pxref{e,,node info} value, as
described in @pxref{7,,Data Structure} above. Fails if the node does not belong
to one of the supported node types.
@end deffn

@geindex xml is_blank_node function
@anchor{5f}@anchor{xml is_blank_node}
@deffn {Function} xml::is_blank_node

Checks whether a node is a blank node (empty or whitespace only) and
thus possibly ignorable.
@end deffn

@geindex xml node_base function
@anchor{60}@anchor{xml node_base}
@deffn {Function} xml::node_base node

Returns the base URI of the given node.
@end deffn

@geindex xml node_path function
@anchor{61}@anchor{xml node_path}
@deffn {Function} xml::node_path node

Returns the path of a node in the document, in the format accepted by
@code{select}.
@end deffn

@geindex xml node_content function
@anchor{62}@anchor{xml node_content}
@deffn {Function} xml::node_content node

Returns the text carried by the node, if any (after entity
substitution).
@end deffn

In addition, you can retrieve and change attributes of element nodes with
the following operations:

@geindex xml node_attr function
@anchor{63}@anchor{xml node_attr}
@deffn {Function} xml::node_attr node name

Retrieves the value of the attribute with the given @code{name} (after
entity substitution).
@end deffn

@geindex xml set_node_attr function
@geindex xml unset_node_attr function
@anchor{64}@anchor{xml set_node_attr}
@deffn {Function} xml::set_node_attr node name value
@anchor{65}@anchor{xml unset_node_attr}
@deffnx {Function} xml::unset_node_attr node name

Sets or unsets an attribute value.
@end deffn

@strong{Examples}

Set and unset a node attribute:

@example
> xml::set_node_attr r "foo" "4711";
()
> xml::node_info r;
xml::element "story" [] ["foo"=>"4711"]
> xml::node_attr r "foo";
"4711"
> xml::unset_node_attr r "foo";
()
> xml::node_info r;
xml::element "story" [] []
@end example

@noindent
The @code{select} function is @emph{very} powerful, and probably the single most
important operation of this module if you want to extract information from
an existing XML document without traversing the entire structure. Here is a
very simple example of its use:

@example
> [xml::node_content n, xml::node_path n | n = xml::select sample "//author"];
[("John Fleck","/story/storyinfo/author")]
@end example

@noindent
Note that if the XPath expression contains qualified names, the
corresponding namespace prefixes and their URIs must be given in the second
argument along with the XPath, as follows:

@example
xml::select doc ("//foo:bar", ["foo"=>"http://www.foo.org"]);
@end example

@noindent

@node Node Manipulation,Transformations,Node Information,Operations
@anchor{node manipulation}@anchor{51}@anchor{node-manipulation}
@section Node Manipulation
These operations enable you to manipulate the document structure by adding
a new node to the document tree (specified through its @pxref{e,,node info}), and
by removing (unlinking) existing nodes from the tree.

@geindex xml replace function
@anchor{66}@anchor{xml replace}
@deffn {Function} xml::replace node info

Add the new node specified by @code{info} in place of the given node
@code{node}.
@end deffn

@geindex xml add_first function
@geindex xml add_last function
@anchor{67}@anchor{xml add_first}
@deffn {Function} xml::add_first node info
@anchor{68}@anchor{xml add_last}
@deffnx {Function} xml::add_last node info

Add the new node as the first or last child of @code{node}, respectively.
@end deffn

@geindex xml add_next function
@geindex xml add_prev function
@anchor{69}@anchor{xml add_next}
@deffn {Function} xml::add_next node info
@anchor{6a}@anchor{xml add_prev}
@deffnx {Function} xml::add_prev node info

Add the new node as the next or previous sibling of @code{node},
respectively.
@end deffn

The operations above all return a pointer to the new XML node object.

@geindex xml unlink function
@anchor{6b}@anchor{xml unlink}
@deffn {Function} xml::unlink node

Deletes an existing node from the document tree. Returns @code{()}.
@end deffn

@strong{Examples}

Replace the first child of the root node in the sample document:

@example
> xml::node_info (r!0);
xml::cdata "<greeting>Hello, world!</greeting>"
> xml::replace (r!0) (xml::text "bla bla");
#<pointer 0xd40d80>
> xml::node_info (r!0);
xml::text "bla bla"
@end example

@noindent
Delete that node:

@example
> xml::unlink (r!0);
()
> xml::node_info (r!0);
xml::comment "This is a sample document for testing the xml interface."
@end example

@noindent

@node Transformations,,Node Manipulation,Operations
@anchor{transformations}@anchor{8}
@section Transformations
The following operations provide basic XSLT support. As already mentioned,
stylesheets are represented as pointers to the xsltStylesheet structure
provided by libxslt. Note that, in difference to XML document pointers,
this is an opaque type, i.e., there is no direct means to inspect and
manipulate parsed stylesheets in memory using the operations of this
module. However, a stylesheet is just a special kind of XML document and
thus can be manipulated after reading the stylesheet as an ordinary XML
document. The @pxref{6c,,load_stylesheet} function then allows you to convert
the document pointer to an XSLT Stylesheet object.

Applying a stylesheet to an XML document generally involves the following
steps:

@enumerate
@item
Load and parse the stylesheet using @pxref{6c,,load_stylesheet}. The
parameter to @pxref{6c,,load_stylesheet} can be either the name of a
stylesheet file or a corresponding document pointer. The function
returns a pointer to the stylesheet object which is used in the
subsequent processing.
@item
Invoke @pxref{6d,,apply_stylesheet} on the stylesheet and the target
document.  This returns a new document containing the transformed XML
document.
@item
Run @pxref{6e,,save_result_file} or @pxref{6f,,save_result_string} on the result
and the stylesheet to save the transformed document in a file or a
string.
@end enumerate

Here is a brief summary of the XSLT operations. Please check the @uref{http://www.w3.org/TR/xslt,XSLT}
documentation for details of the transformation process.

@geindex xslt load_stylesheet function
@anchor{6c}@anchor{xslt load_stylesheet}
@deffn {Function} xslt::load_stylesheet x

Load a stylesheet. @code{x} can be either an XML document pointer, or a
string denoting the desired @code{.xsl} file.
@end deffn

@geindex xslt apply_stylesheet function
@anchor{6d}@anchor{xslt apply_stylesheet}
@deffn {Function} xslt::apply_stylesheet style doc params

Apply the stylesheet @code{style} to the given document @code{doc} with the
given parameters @code{params}. The third argument is a (possibly empty)
list of @code{key=>value} string pairs which allows you to pass additional
parameters to the stylesheet.
@end deffn

@geindex xslt save_result_file function
@geindex xslt save_result_string function
@anchor{6e}@anchor{xslt save_result_file}
@deffn {Function} xslt::save_result_file name doc style compression
@anchor{6f}@anchor{xslt save_result_string}
@deffnx {Function} xslt::save_result_string doc style

Save the transformation result @code{doc} obtained with the stylesheet
@code{style} to a file or a string. This works pretty much like
@code{save_file} or @code{save_string}, but also keeps track of some
output-related information contained in the stylesheet.
@end deffn

@strong{Example}

Load the recipes.xml document and the recipes.xsl stylesheet distributed
with the sources:

@example
> let recipes = xml::load_file "recipes.xml" xml::DTDVALID;
> let style = xslt::load_stylesheet "recipes.xsl";
@end example

@noindent
Apply the stylesheet to the document and save the result in a html file:

@example
> let res = xslt::apply_stylesheet style recipes [];
> xslt::save_result_file "recipes.html" res style 0;
()
@end example

@noindent
That's all. You can now have a look at recipes.html in your favourite web
browser.


@node Index,,Operations,Top
@anchor{index}
@unnumbered Index
@printindex ge

@c %**end of body
@bye
