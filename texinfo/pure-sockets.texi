\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-sockets.info
@documentencoding UTF-8
@copying
Generated by Sphinx
@end copying
@settitle pure-sockets
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-sockets: (pure-sockets.info).    pure-sockets: Pure Sockets Interface
@end direntry

@c %**end of header

@titlepage
@title pure-sockets
@author Albert Gräf (Editor)
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-sockets
@end ifnottex

@c %**start of body
@geindex sockets module
Version 0.6, February 27, 2012

Albert Gräf <@email{Dr.Graef@@t-online.de}>

This is an interface to the Berkeley socket functions. It provides most of the
core functionality, so you can create sockets for both stream and datagram
based protocols and use these to transmit messages. Unix-style file sockets
are also available if the host system supports them.


@menu
* Installation::
* Usage::
* Example::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Usage

* Creating and Inspecting Socket Addresses::
* Creating and Closing Sockets::
* Establishing Connections::
* Socket I/O::
* Socket Information::
@end detailmenu
@end menu


@node Installation,Usage,Top,Top
@anchor{installation}@anchor{0}@anchor{module-sockets}@anchor{1}@anchor{pure-sockets-pure-sockets-interface}@anchor{2}
@chapter Installation
Get the latest source from
@indicateurl{http://pure-lang.googlecode.com/files/pure-sockets-0.6.tar.gz}.

Run @code{make} to compile the module and @code{sudo make install} to install it in
the Pure library directory. To uninstall the module, use @code{sudo make
uninstall}. There are a number of other targets (mostly for maintainers),
please see the Makefile for details.

@code{make} tries to guess your Pure installation directory and platform-specific
setup. If it gets this wrong, you can set some variables manually. In
particular, @code{make install prefix=/usr} sets the installation prefix, and
@code{make PIC=-fPIC} or some similar flag might be needed for compilation on 64
bit systems. You can also set custom compilation options with the CFLAGS
variable, e.g.: @code{make CFLAGS=-O3}. Again, please see the Makefile for
details.


@node Usage,Example,Installation,Top
@anchor{usage}@anchor{3}
@chapter Usage
To use the operations of this module, put the following in your Pure script:

@example
using sockets;
@end example

@noindent
With the @pxref{0,,sockets} module loaded, all the standard socket functions are
available and work pretty much like in C. The only real difference is that,
for convenience, functions taking socket addresses as parameters
(@code{struct_sockaddr*} pointers in Pure), are called without the @code{addrlen}
parameter; the size of the socket address structure will be inferred
automatically and passed to the underlying C functions. Also, there are some
convenience functions which act as wrappers around @code{getaddrinfo} and
@code{getnameinfo} to create socket addresses from symbolic information (hostname
or ip, port names or numbers) and return information about existing address
pointers, see @pxref{4,,Creating and Inspecting Socket Addresses} below.

Below is a list of the provided functions. Please see the corresponding manual
pages for details, and check the Pure scripts in the examples subdirectory for
some examples.


@menu
* Creating and Inspecting Socket Addresses::
* Creating and Closing Sockets::
* Establishing Connections::
* Socket I/O::
* Socket Information::
@end menu


@node Creating and Inspecting Socket Addresses,Creating and Closing Sockets,,Usage
@anchor{creating and inspecting socket addresses}@anchor{4}@anchor{creating-and-inspecting-socket-addresses}
@section Creating and Inspecting Socket Addresses
These functions are Pure-specific. The created socket addresses are malloc'ed
and free themselves automatically when garbage-collected.

@geindex sockaddr function
@anchor{5}@anchor{sockaddr}
@deffn {Function} sockaddr ()

Create a pointer to an empty socket address suitable to hold the socket
address result of routines like @pxref{6,,accept}, @pxref{7,,getsockname},
@pxref{8,,recvfrom}, etc. which return a socket address.
@end deffn

@geindex sockaddr function
@deffn {Function} sockaddr ([int family,] char *path)

Create a local (a.k.a. file) socket address for the given pathname. The
@code{family} parameter, if specified, must be @code{AF_UNIX} here. Please
note that @code{AF_UNIX} is not supported on all platforms. You can check
for this by testing the @code{HAVE_AF_UNIX} constant, which is a truth
value specifying whether @code{AF_UNIX} is available on your system.
@end deffn

@geindex sockaddr function
@deffn {Function} sockaddr ([int family,] char *host, char *port)

@deffnx {Function} sockaddr ([int family,] char *host, int port)

This uses @code{getaddrinfo} to retrieve an @code{AF_INET} or
@code{AF_INET6} address for the given hostname (or numeric IP address in
string form) and port (specified either as an int or a string). If
@code{family} is omitted, it defaults to @code{AF_UNSPEC} which matches both
@code{AF_INET} and @code{AF_INET6} addresses.
@end deffn

@geindex sockaddrs function
@anchor{9}@anchor{sockaddrs}
@deffn {Function} sockaddrs ([int family,] char *host, char *port)

@deffnx {Function} sockaddrs ([int family,] char *host, int port)

This works like @pxref{5,,sockaddr} above, but returns a list with @emph{all}
matching addresses.
@end deffn

@geindex sockaddr_family function
@anchor{a}@anchor{sockaddr_family}
@deffn {Function} sockaddr_family addr

Returns the address family of the given address.
@end deffn

@geindex sockaddr_path function
@anchor{b}@anchor{sockaddr_path}
@deffn {Function} sockaddr_path addr

Returns the pathname for @code{AF_UNIX} addresses.
@end deffn

@geindex sockaddr_hostname function
@anchor{c}@anchor{sockaddr_hostname}
@deffn {Function} sockaddr_hostname addr

Returns the hostname if available, the IP address otherwise.
@end deffn

@geindex sockaddr_ip function
@anchor{d}@anchor{sockaddr_ip}
@deffn {Function} sockaddr_ip addr

Returns the IP address.
@end deffn

@geindex sockaddr_service function
@anchor{e}@anchor{sockaddr_service}
@deffn {Function} sockaddr_service addr

Returns the service (a.k.a. port) name.
@end deffn

@geindex sockaddr_port function
@anchor{f}@anchor{sockaddr_port}
@deffn {Function} sockaddr_port addr

Returns the port number.
@end deffn

@geindex sockaddr_info function
@anchor{10}@anchor{sockaddr_info}
@deffn {Function} sockaddr_info addr

Returns a readable description of a socket address, as a
@code{(family,hostname,port)} tuple. You should be able to pass this into
@pxref{5,,sockaddr} again to get the original address.
@end deffn


@node Creating and Closing Sockets,Establishing Connections,Creating and Inspecting Socket Addresses,Usage
@anchor{creating and closing sockets}@anchor{11}@anchor{creating-and-closing-sockets}
@section Creating and Closing Sockets

@geindex socket function
@anchor{12}@anchor{socket}
@deffn {Function} socket domain type protocol

Creates a socket for the given protocol family (@code{AF_UNIX},
@code{AF_INET} or @code{AF_INET6}), socket type (@code{SOCK_STREAM},
@code{SOCK_DGRAM}, etc.) and protocol. Note that on Linux we also support
the @code{SOCK_NONBLOCK} (non-blocking) and @code{SOCK_CLOEXEC}
(close-on-exec) flags which can be or'ed with the socket type to get
sockets with the corresponding features. The protocol number is usually 0,
denoting the default protocol, but it can also be any of the prescribed
@code{IPPROTO} constants (a few common ones are predefined by this
module, try @code{show -g IPPROTO_*} for a list of those).
@end deffn

@geindex socketpair function
@anchor{13}@anchor{socketpair}
@deffn {Function} socketpair domain type protocol sv

Create a pair of sockets. The descriptors are returned in the integer
vector @code{sv} passed in the last argument.
@end deffn

@geindex shutdown function
@anchor{14}@anchor{shutdown}
@deffn {Function} shutdown fd how

Perform shutdown on a socket. The second argument should be one of
@code{SHUT_RD}, @code{SHUT_WR} and @code{SHUT_RDWR}.
@end deffn

@geindex closesocket function
@anchor{15}@anchor{closesocket}
@deffn {Function} closesocket fd

This is provided for Windows compatibility. On POSIX systems this is just
@code{close}.
@end deffn


@node Establishing Connections,Socket I/O,Creating and Closing Sockets,Usage
@anchor{establishing connections}@anchor{16}@anchor{establishing-connections}
@section Establishing Connections

@geindex accept function
@anchor{6}@anchor{accept}
@deffn {Function} accept sockfd addr
@end deffn

@geindex bind function
@anchor{17}@anchor{bind}
@deffn {Function} bind sockfd addr
@end deffn

@geindex connect function
@anchor{18}@anchor{connect}
@deffn {Function} connect sockfd addr
@end deffn

@geindex listen function
@anchor{19}@anchor{listen}
@deffn {Function} listen sockfd backlog
@end deffn


@node Socket I/O,Socket Information,Establishing Connections,Usage
@anchor{socket i/o}@anchor{1a}@anchor{socket-i-o}
@section Socket I/O

@geindex recv function
@anchor{1b}@anchor{recv}
@deffn {Function} recv fd buf len flags
@end deffn

@geindex send function
@anchor{1c}@anchor{send}
@deffn {Function} send fd buf len flags
@end deffn

@geindex recvfrom function
@anchor{8}@anchor{recvfrom}
@deffn {Function} recvfrom fd buf len flags addr
@end deffn

@geindex sendto function
@anchor{1d}@anchor{sendto}
@deffn {Function} sendto fd buf len flags addr
@end deffn

The usual @pxref{1c,,send}/@pxref{1b,,recv} flags specified by POSIX
(@code{MSG_EOR}, @code{MSG_OOB}, @code{MSG_PEEK}, @code{MSG_WAITALL})
are provided. On Linux we also support @code{MSG_DONTWAIT}. Note that on
POSIX systems you can also just @code{fdopen} the socket descriptor and use
the standard file I/O operations from the @code{system} module instead.


@node Socket Information,,Socket I/O,Usage
@anchor{socket information}@anchor{1e}@anchor{socket-information}
@section Socket Information

@geindex getsockname function
@anchor{7}@anchor{getsockname}
@deffn {Function} getsockname fd addr
@end deffn

@geindex getpeername function
@anchor{1f}@anchor{getpeername}
@deffn {Function} getpeername fd addr
@end deffn

@geindex getsockopt function
@anchor{20}@anchor{getsockopt}
@deffn {Function} getsockopt fd level name val len
@end deffn

@geindex setsockopt function
@anchor{21}@anchor{setsockopt}
@deffn {Function} setsockopt fd level name val len
@end deffn

For @pxref{20,,getsockopt} and @pxref{21,,setsockopt}, currently only the
@code{SOL_SOCKET} level is defined (@code{level} argument) along with the
available POSIX socket options (@code{name} argument). Try @code{show -g SO_*} to
get a list of those. Also note that for most socket level options the @code{val}
argument is actually an @code{int*}, so you can pass a Pure int vector (with
@code{len = SIZEOF_INT}) for that parameter.


@node Example,Index,Usage,Top
@anchor{example}@anchor{22}
@chapter Example
Here is a fairly minimal example using Unix stream sockets. To keep things
simple, this does no error checking whatsoever and just keeps sending strings
back and forth. More elaborate examples can be found in the examples directory
in the sources.

@example
using sockets, system;

const path = "server_socket";
extern int unlink(char *name);

server = loop with
  loop = loop if ~null s && ~response fp s when
    // Connect to a client.
    cfd = accept fd $ sockaddr ();
    // Open the client socket as a FILE* and read a request.
    fp = fdopen cfd "r+"; s = fgets fp;
  end;
  loop = puts "server is exiting" $$ closesocket fd $$
         unlink path $$ () otherwise;
  response fp s::string = s=="quit\n" when
    // Process the request. (Here we just print the received
    // message and echo it back to the client.)
    printf "server> %s" s;
    fputs s fp;
  end;
end when
  // Create the server socket and start listening.
  unlink path;
  fd = socket AF_UNIX SOCK_STREAM 0;
  bind fd (sockaddr path); listen fd 5;
  printf "server listening at '%s'\n" path;
end;

client = loop with
  // Keep reading requests from stdin.
  loop = loop if ~null s && ~request s when
    fputs "client> " stdout; s = fgets stdin;
  end;
  loop = puts "client is exiting" $$ () otherwise;
  request s::string = s=="quit\n" when
    fd = socket AF_UNIX SOCK_STREAM 0;
    connect fd (sockaddr path);
    // Send the request to the server.
    fp = fdopen fd "r+"; fputs s fp;
    // Get the reply.
    s = fgets fp;
  end;
end;
@end example

@noindent
To use this example, run the @code{server} function in one instance of the Pure
interpreter and the @code{client} function in another. Enter a line when the
client prompts you for input; it will be printed by the server. Behind the
scenes, the server also sends the line back to the client. After receiving the
reply, the client prompts for the next input line. Entering end-of-file at the
client prompt terminates the client but keeps the server running, so that you
can start another client and reconnect to the server. Entering just @code{quit}
in the client terminates both server and client. Here is how a typical
interaction may look like:

@example
> client;
client> 1+1
client> foo bar
client> quit
client is exiting
()

> server;
server listening at 'server_socket'
server> 1+1
server> foo bar
server> quit
server is exiting
()
@end example

@noindent
Note that while the server processes requests sequentially, it accepts
connections from a new client after each request, so that you can run as many
clients as you like.


@node Index,,Example,Top
@anchor{index}
@unnumbered Index
@printindex ge

@c %**end of body
@bye
