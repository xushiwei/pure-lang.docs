This is pure-reduce.info, produced by makeinfo version 4.13 from
pure-reduce.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-reduce: (pure-reduce.info).    A REDUCE Interface for the Pure Programming Language
END-INFO-DIR-ENTRY


File: pure-reduce.info,  Node: Top,  Next: Installation,  Up: (dir)

pure-reduce
***********

  Version 0.1, October 07, 2012

    Albert Graef <<Dr.Graef@t-online.de>> 
    Kurt Pagani <<kp@scios.ch>> 
  One of Pure's distinguishing features as a term rewriting programming
language is that it makes the symbolic manipulation of expressions very
easy and convenient. It is thus a natural environment for hosting a
full-featured computer algebra system (CAS). Computer algebra systems
are complex pieces of software including advanced algorithms for
symbolic integration and equation solving. While it would be possible
to reimplement all these algorithms in Pure, this would be a major
undertaking. A much better option is to interface to an existing CAS
which has already proven its worth to the scientific computing
community, has been tested extensively and is known to be both reliable
and efficient.

  This is also the approach taken by Pure's *note reduce: 0. module
which interfaces to the well-known Reduce
(http://reduce-algebra.sourceforge.net/) system. Reduce is the
second-oldest computer algebra system (the oldest one being
Macsyma/Maxima (http://maxima.sourceforge.net/)) and is widely
recognized as being very powerful and efficient. It is free/open source
software distributed under a BSD-style license
(http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/README),
actively maintained on its SourceForge
(http://sourceforge.net/projects/reduce-algebra/) website, and
implementations exist for all major computing platforms. It is thus a
very good choice of a CAS for Pure, and the *note reduce: 0. module
provides a seamless integration of Reduce and Pure. The module uses an
"embedded" version of Reduce in the form of a shared library which is
very easy to build from the Reduce sources; the *note Installation: 1.
section below describes how to do this. More background information and
a discussion of the interface can be found in the Embedding REDUCE
(http://groups.google.com/group/pure-lang/browse_thread/thread/c11e82ca2e9e8cbb)
thread on the Pure mailing list.

  The interface can be found in the reduce.pure module. It has two
parts, a *note low-level interface: 7. which consists of a number of C
entry points supplied by the Reduce library, and a *note high-level
interface: 8. which provides everything that the Pure programmer needs
to use Reduce from Pure. Please note that at present this module is
still experimental. But the basic functionality works, and you're
welcome to discuss the new interface on the mailing list and/or submit
bug reports and patches.

* Menu:

* Installation::
* Low-Level Interface::
* High-Level Interface::
* Basic Examples::
* Index::


File: pure-reduce.info,  Node: Installation,  Next: Low-Level Interface,  Prev: Top,  Up: Top

1 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-reduce-0.1.tar.gz>.

  You'll need both the Reduce library (named reduce.so, reduce.dylib or
reduce.dll, depending on the system you have) and a Reduce image file
(reduce.img) to make this module work. A Makefile is included with this
package so that you can build these yourself from the Reduce sources.
(In principle, this only needs to be done once for the initial
installation of this module, but you may want to repeat this procedure
every once in a while to get the latest Reduce version.)

  You can check out the latest Reduce version from its svn repository
with the following command:

    svn co https://reduce-algebra.svn.sourceforge.net/svnroot/reduce-algebra/trunk/ reduce-algebra

This may take a while; Reduce is a _big_ package. Once it's finished,
just drop the resulting reduce-algebra directory into the pure-reduce
source directory. Run `make' and then (if needed) `make install' in the
pure-reduce directory (_not_ in the reduce-algebra directory!). You
should also run `make check' which performs a few tests in order to
verify that the interface works ok (this can be done without installing
the package, but needs the Reduce image and library).

  In case the above procedure doesn't work for you, there are more
detailed instructions on how to compile the relevant parts of Reduce in
the pure_reduce.txt file included in the distribution. Also note that
the pure-reduce module requires neither a full Reduce installation nor
a full build of the Reduce package; just the Reduce library and image.
Thus the additional items discussed below are all completely optional.

  For convenience, the Makefile also has a `make reduce' target which
builds a minimal Reduce executable. If you use that option, `make
install' installs this executable along with the library and image
files, so that you can then run Reduce directly from the command line
by just typing `reduce'. Please note that this is a really minimalistic
Reduce frontend. It's small, easy to build and doesn't need any support
files other than the image file, but it doesn't have any of the bells
and whistles of the full Reduce version either.

  If you want to install the full Reduce version, there are binary
packages for various systems available on SourceForge
(http://sourceforge.net/projects/reduce-algebra/). You can also build
Reduce yourself from the sources; please check the build instructions
in the reduce-algebra folder for details. (Basically, you'll need to
run `./configure --with-csl' or `./configure --with-psl' and then
`make' there. Be patient, this takes a while.)


File: pure-reduce.info,  Node: Low-Level Interface,  Next: High-Level Interface,  Prev: Installation,  Up: Top

2 Low-Level Interface
*********************

The low-level interface is a straight wrapper of the C entry points
provided by the Reduce library, also known as the "procedural" or PROC
(http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup)
interface, for short. It uses an embedded version of Reduce which runs
on a free and open-source Lisp flavour known as CSL
(http://lisp.codemist.co.uk/) (Codemist Standard Lisp). The external C
routines are all declared in the `reduce' namespace. Normally you
shouldn't have to call these functions directly, since we provide a
high-level, idiomatic Pure interface which makes calling Reduce from
Pure much more convenient, see below.


File: pure-reduce.info,  Node: High-Level Interface,  Next: Basic Examples,  Prev: Low-Level Interface,  Up: Top

3 High-Level Interface
**********************

The goal here is to make it easy to run Reduce from Pure; to these ends,
the most important features of the low-level PROC interface are wrapped
in a convenient way. After installing the module, it can be imported in
your Pure scripts as follows:

    using reduce;

This makes the following variables and functions available:

 -- variable: REDUCE_PATH
     This variable holds a colon-delimited search path used to locate
     the Reduce image file (see *note reduce start: d. below). By
     default this includes the current directory and the Pure library
     directory.

 -- Function: reduce::start image::string args::smatrix
     Initializes the Reduce system. This is done automatically when
     loading this module, so normally you shouldn't have to call this
     manually, unless the default image file wasn't found or you want
     to restart the Reduce system with your own image file or your own
     set of options. When calling this operation manually, you need to
     specify the name of the Reduce image file and any desired extra
     arguments as a string vector.  Unless the filename contains a
     slash, *note reduce start: d. searches the directories in *note
     REDUCE_PATH: c. for the image file. An exception is raised if the
     image file isn't found.

 -- Function: reduce::finish
     Finalizes the Reduce system. You can call this to release the
     resources of the Reduce system. (*note reduce start: d. also
     invokes this automatically if a Reduce instance is already
     running, so it isn't necessary to call *note reduce finish: e. in
     this case.)

 -- Function: reduce::verbosity n
     Sets the verbosity level; 0 means no messages at all (which is the
     default when using this module), and the following values may be
     or'ed together to pick what you need:

          1: messages whenever garbage collection happens

          2: messages whenever a module of code is loaded

          4: extra details in the garbage collector messages

 -- Function: reduce::load name::string
     Loads Reduce packages. This works like Reduce's `load_package'
     command; please check the Reduce documentation for details.

 -- Function: reduce::switch name:string val::int
     Lets you change global Reduce options. This works like Reduce's
     `on' and `off' declarations; please check the Reduce documentation
     for details.

  For convenience, the following operations are in the default
namespace:

 -- Function: simplify x
     This is the main entry point. It takes an algebraic expression in
     Pure format and tries to simplify it using Reduce. The result is
     then converted back to Pure format. Note that you need to quote
     `x' if you want to prevent it from being evaluated on the Pure
     side.

 -- Function: lisp x
     This can be used to execute arbitrary Lisp code, which is sometimes
     necessary to perform special functions in the Reduce system. The
     result is always a Pure list or an atomic value. Note that you
     need to quote `x' if you want to prevent it from being evaluated
     on the Pure side. This is to be used with care. At present, the
     PROC interface isn't very forgiving if you try to execute invalid
     Lisp code; it will most likely crash in such cases.

 -- Function: declare declsym [foo,bar,...]
     Declare symbols and their properties; please see the Declarations
     section in the Reduce manual for details. The second argument can
     also be a singleton symbol. In the present implementation,
     `declsym' must be one of:

        * `operator' (declares an operator symbol);

        * `antisymmetric', `symmetric', `even', `odd', `linear',
          `noncom' and `nonzero' (declares properties of already
          declared operator symbols);

        * `depend', `nodepend', `factor', `remfac', `order', `korder'
          (declares kernel dependencies and orders). These take both
          symbols and "kernels" as arguments (the latter are simple
          prefix expressions which denote irreducible subterms such as
          `cos x'; Reduce treats these more or less like variables in
          algebraic simplifications).

 -- Function: precision prec::int
     Sets the internal Reduce precision in decimal digits for floating
     point calculations, and returns the previously set precision. This
     takes effect when rounded mode is enabled (`reduce::switch
     "rounded" 1').  Note that at present this only affects Reduce's
     internal precision, floating point values are still returned as
     double precision numbers in Pure land.

 -- Function: plotreset
     This is identical to the `plotreset' command provided by Reduce's
     gnuplot (http://www.gnuplot.info/) interface, and is sometimes
     needed to reset the plot subsystem.

  At present, this module makes no attempt to capture terminal output
such as error messages produced by Reduce, so you should be prepared to
read these in the terminal in which Pure is running, or capture them
yourself using the output redirection facilities of the shell if needed.

  In Pure land, Reduce and Lisp expressions are represented using Pure's
standard curried notation. Some special conversions are applied to
algebraic expressions to make arithmetic operations such as `+', `*'
etc. work as expected. In addition, the `==', `..' and `:=' infix
operators can be used to denote equations, ranges and assignments in
Reduce, respectively. (Note that you may have to quote these in some
cases so that they don't get evaluated on the Pure side.) Also, Reduce's
`arbconst n', `arbint n' and `arbcomplex n' terms are mapped to Greek
symbols `αn', `βn' and `ζn' on the Pure side. For debugging purposes,
all these automatic conversions can also be turned off on the output
side with the '`#!  --disable mapped'' compilation pragma; this needs
to be placed _before_ the '`using reduce;'' import clause to take
effect. There are a number of other conditional compilation options
which may be used to selectively turn off some of the conversions;
please check the module source for details.


File: pure-reduce.info,  Node: Basic Examples,  Next: Index,  Prev: High-Level Interface,  Up: Top

4 Basic Examples
****************

Here is a simple example showing how to start up Reduce and do some
calculations:

    > using reduce;
    Reduce (Free CSL version), 27-Sep-12 ...
    > simplify $ df ((x+5)^3) x;
    3*x^2+30*x+75
    > simplify $ solve (x^2+7) x;
    [x==sqrt 7*i,x==-sqrt 7*i]

Note that the result returned by *note simplify: 12. is always a quoted
expression. If the expression can be further reduced on the Pure side,
you'll have to use Pure's `eval' function to force its evaluation:

    > using math;
    > eval ans;
    [x==0.0+:2.64575131106459,x==0.0+:-2.64575131106459]

You can also execute Lisp code in the CSL interpreter hosting the Reduce
system. This is sometimes necessary to access special functionality, but
should be done with care (at present invalid Lisp code can easily crash
the interpreter). For instance:

    > lisp ('list a b c d e);
    [a,b,c,d,e]
    > lisp ('cdr [a,b,[c,d],e]);
    [b,[c,d],e]

Free symbols are quoted automatically, and Pure lists are mapped to
corresponding Lisp lists. If the result is a Lisp list, it will be
converted back to a Pure list. Most simple kinds of Lisp calls should be
doable that way, but don't expect any miracles; the *note lisp: 13.
function is provided to access special functionality in the "symbolic
mode" of the Reduce system, not to turn Pure into a full-featured Lisp
frontend.

  The following example illustrates how you can use the *note lisp: 13.
function to declare an operator symbol and change or query its
properties:

    > lisp ('operator [myop]);
    []
    > lisp ('flag [myop] odd);
    []
    > lisp ('prop myop);
    [odd:t,simpfn:simpiden]
    > simplify (myop (-x));
    -myop x

If you find it awkward to evaluate Lisp forms in Pure, you can also
achieve the same with the *note declare: 14. function which covers most
of the common Reduce declarations that might be needed:

    > declare operator myop;
    []
    > declare odd myop;
    []
    > simplify (myop (-x));
    -myop x

This example shows how you can do a simple plot using Reduce's gnuplot
(http://www.gnuplot.info/) module:

    > simplify $ plot [sin x/x, x=='(-20..20), terminal=="wxt"];
    0

This pops up a wxWidgets window (`terminal=="wxt"') with a plot of the
given function in it, see the screenshot below. The `x=='(-20..20)'
argument specifies the desired range of the `x' variable (note that the
range needs to be quoted so that it gets through to Reduce rather than
being evaluated on the Pure side).

 [image src="gnuplot.png" ]

Figure: Reduce gnuplot example.

  The same plot can be written to a PostScript file sinc.ps as follows:

    > simplify $ plot [sin x/x, x=='(-20..20), terminal=="postscript", output=="sinc.ps"];
    0

Many more examples can be found in the reduce_examp.pure and tests.pure
scripts included in the distribution.


File: pure-reduce.info,  Node: Index,  Prev: Basic Examples,  Up: Top

Index
*****

 [index ]
* Menu:

* declare function:                      High-Level Interface.
                                                              (line  79)
* lisp function:                         High-Level Interface.
                                                              (line  70)
* plotreset function:                    High-Level Interface.
                                                              (line 106)
* precision function:                    High-Level Interface.
                                                              (line  98)
* reduce finish function:                High-Level Interface.
                                                              (line  33)
* reduce load function:                  High-Level Interface.
                                                              (line  51)
* reduce module:                         Top.                 (line   6)
* reduce start function:                 High-Level Interface.
                                                              (line  21)
* reduce switch function:                High-Level Interface.
                                                              (line  55)
* reduce verbosity function:             High-Level Interface.
                                                              (line  40)
* REDUCE_PATH variable:                  High-Level Interface.
                                                              (line  15)
* simplify function:                     High-Level Interface.
                                                              (line  63)



Tag Table:
Node: Top294
Ref: 22404
Ref: sourceforge2404
Ref: 32404
Ref: license2404
Ref: 42404
Ref: reduce2404
Ref: 52404
Ref: maxima2404
Ref: 62404
Ref: embedding-reduce2404
Node: Installation3017
Ref: installation3114
Ref: 03114
Ref: module-reduce3114
Ref: 93114
Ref: computer-algebra-with-pure-a-reduce-interface3114
Ref: 13114
Node: Low-Level Interface5790
Ref: low-level interface5904
Ref: 75904
Ref: low-level-interface5904
Ref: a6627
Ref: proc6627
Ref: b6627
Ref: csl6627
Node: High-Level Interface6627
Ref: high-level interface6743
Ref: 86743
Ref: high-level-interface6743
Ref: c7118
Ref: reduce_path7118
Ref: d7367
Ref: reduce start7367
Ref: e8079
Ref: reduce finish8079
Ref: f8394
Ref: reduce verbosity8394
Ref: 108794
Ref: reduce load8794
Ref: 118968
Ref: reduce switch8968
Ref: 129253
Ref: simplify9253
Ref: 139568
Ref: lisp9568
Ref: 1410068
Ref: declare10068
Ref: 1510959
Ref: precision10959
Ref: 1611383
Ref: plotreset11383
Ref: 1711588
Ref: gnuplot11588
Node: Basic Examples12887
Ref: basic examples12989
Ref: 1812989
Ref: basic-examples12989
Node: Index15833
Ref: index15906

End Tag Table


Local Variables:
coding: utf-8
End:
