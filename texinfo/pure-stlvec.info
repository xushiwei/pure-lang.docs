This is pure-stlvec.info, produced by makeinfo version 4.13 from
pure-stlvec.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-stlvec: (pure-stlvec.info).    pure-stlvec
END-INFO-DIR-ENTRY


File: pure-stlvec.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-stlvec
***********

  Version 0.3, March 03, 2012

    Peter Summerland <<p.summerland@gmail.com>> 
  Pure's interface to C++ vectors, specialized to hold pointers to
arbitrary Pure expressions, and the C++ Standard Template Library
algorithms that act on them.

* Menu:

* Copying::
* Installation::
* Overview::
* Error Handling::
* Operations Included in the stlvec Module::
* STL Nonmodifying Algorithms::
* STL Modifying Algorithms::
* STL Sort Algorithms::
* STL Merge Algorithms::
* STL Heap Algorithms::
* Min/Max STL Algorithms::
* STL Numeric Algorithms::
* Reference Counting::
* Backward Compatibilty::
* Index::

 --- The Detailed Node Listing ---

Overview

* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Data Structure::
* Types::
* Copy-On-Write Semantics::
* Documentation::
* Parameter Names::

Error Handling

* Exception Symbols::
* Examples::

Operations Included in the stlvec Module

* Imports::
* Operations in the Global Namespace::
* Operations in the stl Namespace::
* Examples: Examples<2>.

STL Nonmodifying Algorithms

* Imports: Imports<2>.
* Operations::
* Examples: Examples<3>.

STL Modifying Algorithms

* Imports: Imports<3>.
* Operations: Operations<2>.
* Examples: Examples<4>.

STL Sort Algorithms

* Imports: Imports<4>.
* Operations: Operations<3>.
* Examples: Examples<5>.

STL Merge Algorithms

* Imports: Imports<5>.
* Operations: Operations<4>.
* Examples: Examples<6>.

STL Heap Algorithms

* Imports: Imports<6>.
* Operations: Operations<5>.
* Examples: Examples<7>.

Min/Max STL Algorithms

* Imports: Imports<7>.
* Operations: Operations<6>.
* Examples: Examples<8>.

STL Numeric Algorithms

* Imports: Imports<8>.
* Operations: Operations<7>.
* Examples: Examples<9>.

Backward Compatibilty

* stlvec-0 3::


File: pure-stlvec.info,  Node: Copying,  Next: Installation,  Prev: Top,  Up: Top

1 Copying
*********

    Copyright (c) 2011 by Peter Summerland <<p.summerland@gmail.com>>. 
All rights reserved.

  pure-stlvec is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  pure-stlvec is distributed under a BSD-style license, see the COPYING
file for details.


File: pure-stlvec.info,  Node: Installation,  Next: Overview,  Prev: Copying,  Up: Top

2 Installation
**************

pure-stlvec-0.3 requires at least Pure 0.48. The latest version of Pure
is available at <http://code.google.com/p/pure-lang/downloads/list>.

  The latest version of the source code for pure-stlvec can be
downloaded from
<http://pure-lang.googlecode.com/files/pure-stlvec-0.3.tar.gz>.

  To install pure-stlvec (on Linux), extract the source code (e.g., tar
-xzf pure-stlvec-0.3.tar.gz), cd to the pure-stlvec-0.3 directory, and
run `make'. After this you can (and should) also run `make check' to
run a few unit tests to make sure that pure-stlvec works properly on
your system. If `make check' works, run `sudo make install' to install
pure-stlvec on your system.  `make' tries to guess your Pure
installation directory and platform-specific setup. If it gets this
wrong, you can set some variables manually. In particular, `make
install prefix=/usr' sets the installation prefix. Please see the
Makefile for details.


File: pure-stlvec.info,  Node: Overview,  Next: Error Handling,  Prev: Installation,  Up: Top

3 Overview
**********

The C++ Standard Template Library ("STL") is a library of generic
containers (data structures designed for storing other objects) and a
rich set of generic algorithms that operate on them. pure-stlvec
provides an interface to one of its most useful containers, "vector",
adopted to hold pointers to Pure expressions. The interface provides
Pure programmers with a mutable container "stlvec", that, like the
STL's vector, holds a sequence of objects that can be accessed in
constant time according to their position in the sequence.

* Menu:

* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Data Structure::
* Types::
* Copy-On-Write Semantics::
* Documentation::
* Parameter Names::


File: pure-stlvec.info,  Node: Modules,  Next: Simple Examples,  Up: Overview

3.1 Modules
===========

The usual operations for creating, accessing and modifying stlvecs are
provided by the stlvec module. Most of the operations are similar in
name and function to those provided by the Pure Library for other
containers. As is the case for their Pure Library counterparts, these
operations are in the global namespace. There are a few operations that
have been placed in the stl namespace usually because they do not have
Pure Library counterparts.

  In addition to the stlvec module, pure-stlvec provides a group of
modules, stlvec::modifying, stlvec::nonmodifying, stlvec::sort,
stlvec::merge, stlvec::heap, stlvec::minmax and stlvec::numeric, that
are straight wrappers the STL algorithms (specialized to work with STL
vectors of pointers to Pure expressions). This grouping of the STL
algorithms follows that found at
http://www.cplusplus.com/reference/algorithm/. This web page contains a
table that summarizes of all of the algorithms in one place.

  pure-stlvec provides an "umbrella" module, stlvec::algorithms, that
pulls in all of the STL algorithm interface modules in one go. The STL
algorithm wrapper functions reside in the stl namespace and have the
same names as their counterparts in the STL.


File: pure-stlvec.info,  Node: Simple Examples,  Next: Members and Sequences of Members,  Prev: Modules,  Up: Overview

3.2 Simple Examples
===================

Here are some examples that use the basic operations provided by the
stlvec module.

    > using stlvec;

    > let sv1 = stlvec (0..4); members sv1;
    [0,1,2,3,4]

    > insert (sv1,stl::svend) (5..7); members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,3,4,5,6,7]

    > sv1!3;
    3

    > sv1!![2,4,6];
    [2,4,6]

    > replace sv1 3 33; members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,33,4,5,6,7]

    > stl::erase (sv1,2,5); members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,5,6,7]

    > insert (sv1,2) [2,3,4];  members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,3,4,5,6,7]

    > let pure_vector = stl::vector (sv1,1,5); pure_vector;
    {1,2,3,4}

    > stlvec pure_vector;
    STLVEC #<pointer 0x9145a38>

    > members ans;
    [1,2,3,4]

     > map (+10) sv1;
    [10,11,12,13,14,15,16,17]

    > map (+10) (sv1,2,5);
    [12,13,14]

    > foldl (+) 0 sv1;
    28

    > [x+10 | x = sv1; x mod 2];
    [11,13,15,17]

    > {x+10 | x = (sv1,2,6); x mod 2};
    {13,15}

Here are some examples that use STL algorithms.

    > using stlvec::algorithms;

    > stl::reverse (sv1,2,6); members sv1;
    ()
    [0,1,5,4,3,2,6,7]

    > stl::stable_sort sv1 (>); members sv1;
    ()
    [7,6,5,4,3,2,1,0]

    > stl::random_shuffle sv1; members sv1;
    ()
    [1,3,5,4,0,7,6,2]

    > stl::partition sv1 (<3); members (sv1,0,ans); members sv1;
    3
    [1,2,0]
    [1,2,0,4,5,7,6,3]

    > stl::transform sv1 (sv1,0) (*2); members sv1;
    -1
    [2,4,0,8,10,14,12,6]

    > let sv2 = emptystlvec;

    > stl::transform sv1 (sv2,stl::svback) (div 2); members sv2;
    -1
    [1,2,0,4,5,7,6,3]

Many more examples can be found in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Members and Sequences of Members,  Next: STL Iterators and Value Semantics,  Prev: Simple Examples,  Up: Overview

3.3 Members and Sequences of Members
====================================

Throughout the documentation for pure-stlvec, the member of a stlvec
that is at the nth position in the sequence of expressions stored in
the stlvec is referred to as its nth member or nth element. The nth
member of a stlvec, sv, is sometimes denoted by sv!n.  The sequence of
members of sv starting at position i up to but not including j is
denoted by sv[i,j). There is a "past-the-end" symbol, stl::svend, that
denotes the position after that occupied by the last member contained
by a stlvec.

  For example, if sv contains the sequence "a", "b", "c" "d" and "e",
sv!0 is "a", sv[1,3) is the sequence consisting of "b" followed by "c"
and v[3,stl::svend) denotes the sequence consisting of "d" followed by
"e".


File: pure-stlvec.info,  Node: STL Iterators and Value Semantics,  Next: Iterator Tuples,  Prev: Members and Sequences of Members,  Up: Overview

3.4 STL Iterators and Value Semantics
=====================================

In C++ a programmer accesses a STL container's elements by means of
"iterators", which can be thought of as pointers to the container's
elements. A single iterator can be used to access a specific element,
and a pair of iterators can be used to access a "range" of elements. By
convention, such a range includes the member pointed to by the first
iterator and all succeeding members up to but not including the member
pointed to by the second iterator. Each container has a past-the-end
iterator that can be used to specifiy ranges that include the
container's last member.

  In the case of vectors there is an obvious correspondence between an
iterator that points to an element and the element's position (starting
at zero) in the vector.  pure-stlvec uses this correspondence to
designate a stlvec's members in a way that makes it relatively easy to
see how pure-stlvec's functions are acting on the stlvec's underlying
STL vector by referencing the STL's documentation. Thus, if sv is a
stlvec, and j is an int, "replace sv j x" uses the STL to replace the
element pointed to by the iterator for position j of sv's underlying
STL vector. If, in addition, k is an int, stl::sort (sv,j,k) (<) uses
the STL to sort the elements in the range designated by the "jth" and
"kth" iterators for sv's underlying STL vector. This range, written as
sv[j,k), is the subsequence of sv that begins with the element at
position j and ends with the element at position (k-1).

  Besides iterators, another cornerstone of the STL is its "value
semantics", i.e., all of the STL containers are mutable and if a
container is copied, all of its elements are copied. pure-stlvec deals
with the STL's value semantics by introducing mutable and nonmutable
stlvecs, and by storing smart pointers to objects (which have cheap
copies) rather than the actual objects.


File: pure-stlvec.info,  Node: Iterator Tuples,  Next: Predefined Iterator Tuple Indexes,  Prev: STL Iterators and Value Semantics,  Up: Overview

3.5 Iterator Tuples
===================

As mentioned in the previous section, in C++ ranges are specified by a
pair of STL iterators.

  In pure-stlvec ranges of elements in a stlvec are specified by
"iterator tuples" rather than, say, actual pointers to STL iterators.
Iterator tuples consist of the name of a stlvec followed by one of more
ints that indicate positions (starting from zero) of the stlvec's
elements.

  To illustrate how iterator tuples are used, consider the STL
stable_sort function, which sorts objects in the range [first, last) in
the order imposed by comp. Its C++ signature looks like this:

     void stable_sort ( RandomAccessIterator first,
     RandomAccessIterator last, Compare comp )

  The corresponding pure-stlvec function, from the stlvec::sort module,
looks like this:

     stable_sort (msv, first, last) comp

  where msv is a mutable stlvec, and first and last are ints. The first
thing that the Pure stable_sort does is create a pair of C++ iterators
that point to the elements in msv's underlying STL vector that occupy
the positions designated by first and last.  Next it wraps the Pure
comp function in a C++ function object that, along with the two
iterators, is passed to the C++ stable_sort function.

  For convenience, (sv,stl::svbeg, stl::svend) can be written simply as
sv. Thus, if first were stl::svbeg (or 0), and last were stl::svend (or
#msv, the number of elements in msv), the last Pure call could be
written:

     stable_sort msv comp

  It should be noted that often the STL library provides a default
version of its functions, which like stable_sort, use a comparator or
other callback function provided by the caller. E.g., the C++
stable_sort has a default version that assumes the "<" operator can be
used on the elements held by the container in question:

     void stable_sort ( RandomAccessIterator first,
     RandomAccessIterator last)

  The corresponding functions provided by the pure-stlvec modules
rarely, if ever, supply a default version. A typical example is
stlvec::sort's stable_sort which must be called with a comparator
callback function:

     stable_sort msv (<);

  Note also that the comparator (e.g., (<)), or other function being
passed to a pure-stlvec algorithm wrapper is almost always the last
parameter. This is the opposite of what is required for similar Pure
functions, but is consistent with the STL calling conventions.


File: pure-stlvec.info,  Node: Predefined Iterator Tuple Indexes,  Next: Back Insert Iterators,  Prev: Iterator Tuples,  Up: Overview

3.6 Predefined Iterator Tuple Indexes
=====================================

The following integer constants are defined in the stl namespace for use
in iterator tuples.

 -- constant: stl::svbeg = 0
 -- constant: stl::svend = -1
 -- constant: stl::svback = -2

  These three symbols are declared as nonfix. `svend' corresponds to
STL's past-end iterator for STL vectors. It makes it possible to
specify ranges that include the last element of an stlvec. I.e., the
iterator tuple (sv,stl::svbeg,stl::svend) would specify sv[0,n), where
n is the number of elements in sv. In order to understand the purpose
of `svback', it is necessary to understand a bit about STL's "back
insert iterators."


File: pure-stlvec.info,  Node: Back Insert Iterators,  Next: Data Structure,  Prev: Predefined Iterator Tuple Indexes,  Up: Overview

3.7 Back Insert Iterators
=========================

Many of the STL algorithms insert members into a target range
designated by an iterator that points to the first member of the target
range. Consistent with raw C usage, it is ok to copy over existing
elements the target stlvec. E.g.,:

    > using stlvec::modifying;

    > let v1 = stlvec (0..2);

    > let v2 = stlvec ("a".."g");

    > stl::copy v1 (v2,2) $$ members v2;
    ["a","b",0,1,2,"f","g"]

This is great for C++ programmers, but for Pure programmers it is almost
always preferable to append the copied items to the end of a target
stlvec, rather than overwriting all or part or part of it. This can be
accomplished using stl::svback. E.g.,:

    > stl::copy v1 (v2,stl::svback) $$ members v2;
    ["a","b",0,1,2,"f","g",0,1,2]

In short, when a pure-stlvec function detects "stl::svback" in a target
iterator tuple, it constructs a STL "back inserter iterator" and passes
it on to the corresponding wrapped STL function.


File: pure-stlvec.info,  Node: Data Structure,  Next: Types,  Prev: Back Insert Iterators,  Up: Overview

3.8 Data Structure
==================

Currently, stlvecs are of the form (STLVEC x) or (CONST_STLVEC x), where
STLVEC AND CONST_STLVEC are defined as nonfix symbols in the global
namespace and x is a pointer to the underlying STL vector. The stlvec
module defines corresponding type tags, stlvec and const_stlvec, so the
programmer never needs to worry about the underlying representaton.

  This representation may change in the future, and must not be relied
upon by client modules. In particular, one must never attempt to use the
embedded pointer directly.

  As the names suggest, stlvecs are mutable and const_stlvecs are
immutable. Functions that modify a stlvec will simply fail unless the
stlvec is mutable.

    > let v = const_stlvec $ stlvec (0..3); v2;
    CONST_STLVEC #<pointer 0x8c1dbf0>

    > replace v 0 100; // fails
    replace (CONST_STLVEC #<pointer 0x9f07690> 0 100



File: pure-stlvec.info,  Node: Types,  Next: Copy-On-Write Semantics,  Prev: Data Structure,  Up: Overview

3.9 Types
=========

pure-stlvec introduces six type tags, all of which are in the global
namespace:

 -- type: mutable_stlvec
     The type for a mutable stlvec.

 -- type: const_stlvec
     The type for an immutable stlvec.

 -- type: stlvec
     The type for a stlvec, mutable or immutable.

 -- type: mutable_svit
     The type for an iterator tuple whose underlying stlvec is mutable.

 -- type: const_svit
     The type for an iterator tuple whose underlying stlvec is
     immutable.

 -- type: svit
     The type for an iterator tuple. The underlying stlvec can be
     mutable or immutable.


File: pure-stlvec.info,  Node: Copy-On-Write Semantics,  Next: Documentation,  Prev: Types,  Up: Overview

3.10 Copy-On-Write Semantics
============================

The pure-stlvec module functions do not implement automatic
copy-on-write semantics. Functions that modify stlvec parameters will
simply fail if they are passed a const_stlvec when they expect a
mutable_stlvec.

  For those that prefer immutable data structures, stlvecs can be
converted to const_stlvecs (usually after they have been created and
modified within a function) by the `const_stlvec' function. This
function converts a mutable stlvec to an immutable stlvec without
changing the underlying STL vector.

  Typically, a "pure" function that "modifies" a stlvec passed to it as
an argument will first copy the input stlvec to a new locally scoped
(mutable) stlvec using the stlvec function. It will then modify the new
stlvec and use const_stlvec to make the new stlvec immutable before it
is returned. It should be noted that several of the STL algorithms have
"copy" versions which place their results directly into a new stlvec,
which can eliminate the need to copy the input stlvec. E.g.:

    > let sv1 = stlvec ("a".."e");

    > let sv2 = emptystlvec;

    > stl::reverse_copy sv1 (sv2,stl::svback) $$ members sv2;
    ["e","d","c","b","a"]

Without reverse_copy, one would have had to copy sv1 into sv2 and then
reverse sv2.

  If desired, in Pure it is easy to write functions that have automatic
copy-on-write semantics. E.g.,

    > my_replace csv::const_stlvec i x = my_replace (stlvec csv) i x;
    > my_replace sv::stlvec i x = replace sv i x;



File: pure-stlvec.info,  Node: Documentation,  Next: Parameter Names,  Prev: Copy-On-Write Semantics,  Up: Overview

3.11 Documentation
==================

The documentation of the functions provided by the stlvec module are
reasonably complete.  In contrast, the descriptions of functions
provided by the STL algorithm modules are purposely simplified (and may
not, therefore, be technically accurate). This reflects that fact that
the functions provided by pure-stlvec have an obvious correspondence to
the functions provided by the STL, and the STL is extremely well
documented. Furthermore, using the Pure interpreter, it is very easy to
simply play around with with any of the pure-stlvec functions if there
are doubts, especially with respect to "corner cases."  Often this
leads to a deeper understanding compared to reading a precise technical
description.

  A good book on the STL is STL Tutorial and Reference Guide, Second
Edition, by David R. Musser, Gillmer J. Derge and Atul Saini. A summary
of all of the STL algorithms can be found at
<http://www.cplusplus.com/reference/stl/>.


File: pure-stlvec.info,  Node: Parameter Names,  Prev: Documentation,  Up: Overview

3.12 Parameter Names
====================

In the descriptions of functions that follow, parameter names used in
function descriptions represent specific types of Pure objects:

sv
     stlvec (mutable or immutable)

csv
     const (i.e., immutable) stlvec

msv
     mutable stlvec

x
     an arbitrary Pure expression

xs
     a list of arbitrary Pure expressions

count, sz, n
     whole numbers to indicate a number of elements, size of a vector,
     etc

i,j
     whole numbers used to designate indexes into a stlvec

f,m,l
     whole numbers (or stl::beg or stl::svend) designating the "first",
     "middle" or "last" iterators in a stlvec iterator tuple

p
     a whole number (or other iterator constant such as stl::svend or
     stl::svback) used in a two element iterator tuple (e.g., (sv,p))

(sv,p)
     an iterator tuple that will be mapped to an iterator that points
     to the pth position of sv's underlying STL vector, v, (or to a
     back iterator on v if p is stl::svback)

(sv,f,l)
     an iterator tuple that will be mapped to the pair of iterators
     that are designated by (sv,f) and (sv,l)

(sv,f,m,l)
     an iterator tuple that will be mapped to the iterators that are
     designated by (sv,f), (sv,m) and (sv,l)

sv[f,l)
     the range of members beginning with that at (sv,f) up to but not
     including that at (con,l)

comp
     a function that accepts two objects and returns true if the first
     argument is less than the second (in the strict weak ordering
     defined by comp), and false otherwise

unary_pred
     a function that accepts one object and returns true or false

bin_pred
     a function that accepts two objects and returns true or false

unary_fun
     a function that accepts one objects and returns another

bin_fun
     a function that accepts two objects and returns another

gen_fun
     a function of one parameter that produces a sequence of objects,
     one for each call

  For readability, and to correspond with the STL documentation, the
words "first", "middle", and "last", or variants such as "first1" are
often used instead of f,m,l.


File: pure-stlvec.info,  Node: Error Handling,  Next: Operations Included in the stlvec Module,  Prev: Overview,  Up: Top

4 Error Handling
****************

The functions provided this module handle errors by throwing exceptions.

* Menu:

* Exception Symbols::
* Examples::


File: pure-stlvec.info,  Node: Exception Symbols,  Next: Examples,  Up: Error Handling

4.1 Exception Symbols
=====================

 -- constructor: bad_argument
     This exception is thrown when a function is passed an unexpected
     value. A subtle error to watch for is a malformed iterator tuple
     (e.g., one with the wrong number of elements).

 -- constructor: bad_function
     This exception is thrown when a purported Pure call-back function
     is not even callable.

 -- constructor: failed_cond
     This exception is thrown when a Pure call-back predicate returns a
     value that is not an int.

 -- constructor: out_of_bounds
     This exception is thrown if the specified index is out of bounds.

 -- constructor: range_overflow
     This exception is thrown by functions that write over part of a
     target stlvec (e.g., copy) when the target range too small to
     accommodate the result.

 -- constructor: range_overlap
     This exception is thrown by algorithm functions that write over
     part of a target stlvec when the target and source ranges overlap
     in a way that is not allowed.

  In addition, any exception thrown by a Pure callback function passed
to a pure-stlvec function will be caught and be rethrown by the
pure-stlvec function.


File: pure-stlvec.info,  Node: Examples,  Prev: Exception Symbols,  Up: Error Handling

4.2 Examples
============

    > using stlvec, stlvec::modifying;

    > let sv1 = stlvec (0..4); members sv1;
    [0,1,2,3,4]

    > let sv2 = stlvec ("a".."e"); members sv2;
    ["a","b","c","d","e"]

    > sv1!10;
    <stdin>, line 25: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,10);
    <stdin>, line 26: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,2,3); // sb (sv2,pos)
    <stdin>, line 22: unhandled exception 'bad_argument' ...

    > stl::copy sv1 (sv2,2);
    <stdin>, line 23: unhandled exception 'range_overflow' ...

    > stl::copy sv2 (sv2,2);
    <stdin>, line 24: unhandled exception 'range_overlap' ...

    > stl::copy (sv1,1,3) (sv2,0); members sv2; // ok
    2
    [1,2,"c","d","e"]

    > stl::sort sv2 (>); // apples and oranges
    <stdin>, line 31: unhandled exception 'failed_cond'

    > listmap (\x->throw DOA) sv1; // callback function throws exception
    <stdin>, line 34: unhandled exception 'DOA' ...



File: pure-stlvec.info,  Node: Operations Included in the stlvec Module,  Next: STL Nonmodifying Algorithms,  Prev: Error Handling,  Up: Top

5 Operations Included in the stlvec Module
******************************************

The stlvec module provides functions for creating, accessing and
modifying stlvecs. In general, operations that have the same name as a
corresponding function in the Pure standard library are in the global
namespace. The remaining functions, which are usually specific to
stlvecs, are in the stl namespace.

  Please note that "stlvec to stlvec" functions are provided by the
pure-stl algorithm modules. Thus, for example, the stlvec module does
not provide a function that maps one stlvec onto a new stlvec. That
functionality, and more, is provided by stl::transform, which can be
found in the stlvec::modifying module.

* Menu:

* Imports::
* Operations in the Global Namespace::
* Operations in the stl Namespace::
* Examples: Examples<2>.


File: pure-stlvec.info,  Node: Imports,  Next: Operations in the Global Namespace,  Up: Operations Included in the stlvec Module

5.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec;



File: pure-stlvec.info,  Node: Operations in the Global Namespace,  Next: Operations in the stl Namespace,  Prev: Imports,  Up: Operations Included in the stlvec Module

5.2 Operations in the Global Namespace
======================================

When reading the function descriptions that follow, please bear in mind
that whenever a function is passed an iterator tuple of the form
(sv,first, last), first and last can be dropped, leaving (sv), or
simply sv. The function will treat the "unary" iterator tuple (sv) as
(sv, stl::svbeg, stl::svend).

 -- Function: emptystlvec
     return an empty stlvec

 -- Function: stlvec source
     create a new stlvec that contains the elements of source; source
     can be a stlvec, an iterator tuple(sv,first,last), a list or a
     vector (i.e., a matrix consisting of a single row or column). The
     underlying STL vector is always a new STL vector. I.e., if source
     is a stlvec the new stlvec does not share source's underlying STL
     vector.

 -- Function: mkstlvec x count
     create a new stlvec consisting of count x's.

 -- Function: const_stlvec source
     create a new const_stlvec that contains the elements of source;
     source can be a stlvec, an iterator tuple(sv,first,last), a list
     or a vector (i.e., a matrix consisting of a single row or column).
     If source is a stlvec (mutable or const), the new const_stlvec
     shares source's underlying STL vector.

 -- Function: # sv
     return the number of elements in sv.

  Note that # applied to an iterator tuple like (sv,b,e) will just
return the number of elements in the tuple. Use stl::bounds if you need
to know the number of elements in the range denoted by an iterator
tuple.

 -- Function: sv ! i
     return the ith member of sv

  Note that !k applied to an iterator tuple like (sv,b,e) will just
return the kth element of the tuple. In addition, in stlvec, integers
used to denote postions (as in !k) or in iterators, _always_, are
relative to the beginning of the underlying vector. So it makes no
sense to apply ! to an iterator tuple.

 -- Function: first sv
 -- Function: last sv
     first and last member of sv

 -- Function: members (sv, first, last)
     return a list of values stored in sv[first,last)

 -- Function: replace msv i x
     replace the ith member of msv by x and return x; throws
     out_of_bounds if i is less than 0 or great or equal to the number
     of elements in msv

 -- Function: update msv i x
     the same as replace except that update returns msv instead of x.
     This function is DEPRECATED.

 -- Function: append sv x
     append x to the end of sv

 -- Function: insert (msv,p) xs
 -- Function: insert (msv,p) (sv,first,last)
     insert members of the list xs or the range sv[first, last) into
     msv, all preceding the pth member of msv. Members are shifted to
     make room for the inserted members

 -- Function: rmfirst msv
 -- Function: rmlast msv
     remove the first or last member from msv

 -- Function: erase (msv,first,last)
 -- Function: erase (msv,p)
 -- Function: erase msv
     remove msv[first,last) from msv, remove msv!p from msv, or make msv
     empty. Members are shifted to occupy vacated slots

 -- Function: sv1 == sv2
 -- Function: sv1 ~= sv2
     (x == y) is the same as stl::allpairs (==) x y and x ~= y is simply
     ~(allpairs (==) x y)

  Note that `==' and `~==' are not defined for iterator tuples (the
rules would never be executed because == is defined on tuples in the
Prelude).

  The stlvec module provides convenience functions that apply map,
catmap, foldl, etc, to directly access Pure expressions stored in a
stlvec.

 -- Function: map unary_fun (sv, first, last)
     one pass equivalent of map unary_fun $ members (sv, first, last)

 -- Function: listmap unary_fun (sv, first, last)
     same as map, used in list comprehensions

 -- Function: catmap unary_fun (sv, first, last)
     one pass equivalent of catmap unary_fun $ members (sv, first, last)

 -- Function: do unary_fun (sv, first, last)
     one pass equivalent of do unary_fun $ members (sv, first, last)

 -- Function: foldl bin_fun x (sv, first, last)
     one pass equivalent of foldl bin_fun x $ members (sv, first, last)

 -- Function: foldl1 bin_fun (sv, first, last)
     one pass equivalent of foldl1 bin_fun $ members (sv, first, last)

 -- Function: filter unary_pred (sv, first, last)
     one pass equivalent of filter unary_pred $ members (sv, first,
     last)

  The following four functions map (or catmap) stlvecs onto row and col
matrixes, primarily for use in matrix comprehensions.

 -- Function: rowmap unary_fun (sv, first, last)

 -- Function: rowcatmap unary_fun (sv, first, last)

 -- Function: colmap unary_fun (sv, first, last)

 -- Function: colcatmap unary_fun (sv, first, last)


File: pure-stlvec.info,  Node: Operations in the stl Namespace,  Next: Examples<2>,  Prev: Operations in the Global Namespace,  Up: Operations Included in the stlvec Module

5.3 Operations in the stl Namespace
===================================

 -- Function: stl::empty sv
     test whether sv is empty

 -- Function: stl::vector (sv,first,last)
     create a Pure vector that contains the members of sv[first,last)

 -- Function: stl::allpairs bin_pred (sv1, first1, last1) (sv2, first2,
          last2)
     returns true if bin_pred is true for all corresponding members of
     sv1[first1, last1) and sv2[first2, last2)

 -- Function: stl::bounds (sv,first,last)
     throws out-of-bounds if first or last is out of bounds. returns
     the tuple (sv,first,last) except that if first is stl::begin it
     will be replaced by 0 and if last is stl::svend it will be
     replaced by the number of elements in sv.

 -- Function: stl::reserve msv count
     modify the underlying STL vector to have at least count slots,
     useful for packing data into a fixed size vector and possibly to
     speed up the addition of new members

 -- Function: stl::capacity sv
     return the number of slots (as opposed to the number of elements)
     held by the underlying STL vector


File: pure-stlvec.info,  Node: Examples<2>,  Prev: Operations in the stl Namespace,  Up: Operations Included in the stlvec Module

5.4 Examples
============

See ut_stlvec.pure and ut_global_stlvec.pure in the pure-stlvec/ut
directory.


File: pure-stlvec.info,  Node: STL Nonmodifying Algorithms,  Next: STL Modifying Algorithms,  Prev: Operations Included in the stlvec Module,  Up: Top

6 STL Nonmodifying Algorithms
*****************************

The stlvec::nonmodifying module provides an interface to the STL's
non-modifying sequence operations.

* Menu:

* Imports: Imports<2>.
* Operations::
* Examples: Examples<3>.


File: pure-stlvec.info,  Node: Imports<2>,  Next: Operations,  Up: STL Nonmodifying Algorithms

6.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::nonmodifying;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations,  Next: Examples<3>,  Prev: Imports<2>,  Up: STL Nonmodifying Algorithms

6.2 Operations
==============

 -- Function: stl::for_each (sv, first, last) unary_fun
     applies unary_fun to each of the elements in sv[first,last)

 -- Function: stl::find (sv, first, last) x
     returns the position of the first element in sv[first,last) for
     which (==x) is true (or stl::svend if not found)

 -- Function: stl::find_if (sv, first, last) unary_pred
     returns the position of the first element in sv[first,last) for
     which unary_pred is true (or stl::svend if not found)

 -- Function: stl::find_first_of (sv1, first1, last1) (sv2, first2,
          last2) bin_pred
     Returns the position of the first element, x, in sv1[first1,last1)
     for which there exists y in sv2[first2,last2) and (bin_pred x y)
     is true (or stl::svend if no such x exists).

 -- Function: stl::adjacent_find (sv, first, last) bin_pred
     search sv[first,last) for the first occurrence of two consecutive
     elements (x,y) for which (bin_pred x y) is true. Returns the
     position of x, if found, or stl::svend if not found)

 -- Function: stl::count (sv, first, last) x
     returns the number of elements in the range sv[first,last) for
     which (x==) is true

 -- Function: stl::count_if (sv, first, last) unary_pred
     returns the number of elements in the range sv[first,last) for
     which unary_pred is true

 -- Function: stl::mismatch (sv1, first1, last1) (sv2, first2) bin_pred
     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1 until it
     finds i and j such that bin_pred (sv1!i) (sv2!j) is false and
     returns (i,j). If bin_pred is true for all of the pairs of
     elements, i will be stl::svend and j will be first2 + n (or
     stl::svend)

 -- Function: stl::equal (sv1, first1, last1) (sv2, first2) bin_pred
     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1, and returns
     true if bin_pred is true for each pair

 -- Function: stl::search (sv1, first1, last1) (sv2, first2) bin_pred
     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the first occurrence of the sequence defined
     by sv2[first2,last2), and returns the position in sv1 of its first
     element (or stl::svend if not found)

 -- Function: stl::search_n (sv, first, last) count x bin_pred
     using bin_pred to determine equality of the elements, searches
     sv[first,last) for a sequence of count elements that equal x. If
     such a sequence is found, it returns the position of the first of
     its elements, otherwise it returns stl::svend

 -- Function: stl::find_end (sv1, first1, last1) (sv2, first2, last2)
          bin_pred
     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the last occurrence of sv2[first2,last2).
     Returns the position of the first element in sv1 of the occurrence
     (or stl::svend if not found).


File: pure-stlvec.info,  Node: Examples<3>,  Prev: Operations,  Up: STL Nonmodifying Algorithms

6.3 Examples
============

See ut_nonmodifying.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Modifying Algorithms,  Next: STL Sort Algorithms,  Prev: STL Nonmodifying Algorithms,  Up: Top

7 STL Modifying Algorithms
**************************

The stlvec::modifying module provides an interface to the STL's
modifying algorithms.

* Menu:

* Imports: Imports<3>.
* Operations: Operations<2>.
* Examples: Examples<4>.


File: pure-stlvec.info,  Node: Imports<3>,  Next: Operations<2>,  Up: STL Modifying Algorithms

7.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::modifying;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<2>,  Next: Examples<4>,  Prev: Imports<3>,  Up: STL Modifying Algorithms

7.2 Operations
==============

 -- Function: stl::copy (sv, first1, last1) (msv, first2)
     copies the elements in sv[first1,last1) into the range whose first
     element is (msv,first2)

 -- Function: stl::copy_backward (sv,first1,last1) (msv,last2)
     copies the elements in sv[first1,last1), moving backward from
     (last1), into the range msv[first2,last2) where first2 is last2
     minus the number of elements in sv[first1,last1)

 -- Function: stl::swap_ranges (sv,first,last) (msv, p)
     exchanges the elements in sv[first, last) with those in msv[p,
     p+n) where n is last - first

 -- Function: stl::transform (sv,first,last) (msv, p) unary_fun
     applies unary_fun to the elements of sv[first,last) and places the
     resulting sequence in msv[p, p+n) where n is last - first. If sv
     is mutable, msv and sv can be the same stlvec. Returns (msv,p+n)

 -- Function: stl::transform_2 (sv1,first1,last1) (sv2,first2) (msv, p)
          bin_fun
     applies bin_fun to corresponding pairs of elements of
     sv1[first1,last1) sv2[first2,n) and and places the resulting
     sequence in msv[p, p+n) where n is last1 - first1. Returns
     (msv,p+n)

 -- Function: stl::replace_if (msv,first,last) unary_pred x
     replace the elements of msv[first,last) that satistfy unary_pred
     with x

 -- Function: stl::replace_copy (sv,first,last) (msv,p) x y
     same as `replace' (msv,first,last) x y except that the modified
     sequence is placed in msv[p,p+last-first)

 -- Function: stl::replace_copy_if (sv,first,last) (msv,p) unary_pred x
     same as *note replace_if: 65. except that the modified sequence is
     placed in msv[p,p+last-first)

 -- Function: stl::fill (msv,first,last) x
     replace all elements in msv[first,last) with x

 -- Function: stl::fill_n (msv,first) n x
     replace the elements of msv[first,first+n) with x

 -- Function: stl::generate (msv,first,last) gen_fun
     replace the elements in msv[first,last) with the sequence
     generated by successive calls to gen_fun (), e.g.,

         > let count = ref 0;

         > g _ = n when n = get count + 1; put count n; end;

         > let sv = mkstlvec 0 10;

         > stl::generate sv g $$ members sv;
         [1,2,3,4,5,6,7,8,9,10]



 -- Function: stl::generate_n (msv,first) n gen_fun
     replace all elements in msv[first,first+n) with the sequence
     generated by successive calls to gen_fen

 -- Function: stl::remove (msv,first,last) x
     same as *note remove_if: 6d. (msv,first,last) (==x).

 -- Function: stl::remove_if (msv,first,last) unary_pred
     remove elements in msv[first,last) that satisfy unary_pred. If n
     elements do not satisfy unary_pred, they are moved to
     msv[first,first+n), preserving their relative order. The content
     of msv[first+n,svend) is undefined. Returns first+n, or stl::svend
     if first+n is greater than the number of elements in msv

 -- Function: stl::remove_copy (sv,first,last) (msv,first) x
     same as *note remove: 6c. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::remove_copy_if (sv,first,last) (msv,first) unary_pred
     same as *note remove_if: 6d. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::unique (msv,first,last) bin_pred
     eliminates consecutive duplicates from sv[first,last), using
     bin_pred to test for equality. The purged sequence is moved to
     sv[first,first+n) preserving their relative order, where n is the
     size of the purged sequence. Returns first+n or stl::svend if
     first+n is greater than the number of elements in msv

 -- Function: stl::unique_copy (sv,first,last) (msv,first) bin_pred
     same as *note unique: 70. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::reverse (msv,first,last)
     Reverses the order of the elements in sv[first,last).

 -- Function: stl::reverse_copy (sv,first,last) (msv,first)
     same as *note reverse: 72. except that the reversed sequence is
     copied to (msv,first) and sv[first,last) is not changed.

 -- Function: stl::rotate (msv,first,middle,last)
     rotates the elements of msv[first,middle,last] so that middle
     becomes the first element of msv[first,last].

 -- Function: stl::rotate_copy (msv,first,middle,last) (msv,first)
     same as rotate except that the rotated sequence is copied to
     (msv,first) and sv[first,last) is not changed.

 -- Function: stl::random_shuffle (msv,first,last)
     randomly reorders the elements in msv[first,last)

 -- Function: stl::partition (msv,first,last) unary_pred
     places the elements in msv[first,last) that satisfy unary_pred
     before those that don't. Returns middle, where msv [first,middle)
     contains all of the elements that satisfy unary_pre, and msv
     [middle, last) contains those that do not

 -- Function: stl::stable_partition (msv,first,last) unary_pred
     same as partition except that the relative positions of the
     elements in each group are preserved


File: pure-stlvec.info,  Node: Examples<4>,  Prev: Operations<2>,  Up: STL Modifying Algorithms

7.3 Examples
============

See ut_modifying.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Sort Algorithms,  Next: STL Merge Algorithms,  Prev: STL Modifying Algorithms,  Up: Top

8 STL Sort Algorithms
*********************

The stlvec::sort module provides an interface to the STL's sorting and
binary search algorithms.

* Menu:

* Imports: Imports<4>.
* Operations: Operations<3>.
* Examples: Examples<5>.


File: pure-stlvec.info,  Node: Imports<4>,  Next: Operations<3>,  Up: STL Sort Algorithms

8.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::sort;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<3>,  Next: Examples<5>,  Prev: Imports<4>,  Up: STL Sort Algorithms

8.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering function, comp. The functions (<) and (>) are commonly passed
as comp.

 -- Function: stl::sort (msv, first, last) comp
     sorts msv[first, last)

 -- Function: stl::stable_sort (msv, first, last) comp
     sorts msv[first, last), preserving the relative order of equal
     members

 -- Function: stl::partial_sort (msv, first, middle, last) comp
     fills msv[first, middle) with the elements of msv[first,last) that
     would appear there if msv[first,last) were sorted using comp and
     fills msv[middle,last) with the remaining elements in unspecified
     order

 -- Function: stl::partial_sort_copy (sv, first1, last1) (msv, first2,
          last2) comp
     let n be the number of elements in sv[first1, last1) and r be the
     number of elements in msv[first2, last2). If r < n, *note
     partial_sort_copy: 80. fills msv[first2, last2) with the first r
     elements of what sv[first1, last1) would be if it had been sorted.
     If r >= n, it fills msv[first2, first2+n) with the elements of
     sv[first1, last1) in sorted order. sv[first1,last1) is unchanged

 -- Function: stl::nth_element (msv, first, middle, last) comp
     rearranges the elements of msv[first, last) as follows. Let n be
     middle - first, and let x be the nth smallest element of
     msv[first, last). After the function is called, sv!middle will be
     x. All of the elements of msv[first, middle) will be less than x
     and all of the elements of msv[middle+1, last) will be greater
     than x

  The next four functions assume that sv[first, last) is ordered by
comp.

 -- Function: stl::lower_bound (sv, first, last) x comp
     returns an int designating the first position into which x can be
     inserted into sv[first, last) while maintaining the sorted ordering

 -- Function: stl::upper_bound (sv, first, last) x comp
     returns an int designating the last position into which x can be
     inserted into sv[first, last) while maintaining the sorted ordering

 -- Function: stl::equal_range (sv, first, last) x comp
     returns a pair of ints, (lower, upper) where lower and upper would
     have been returned by separate calls to lower_bound and
     upper_bound.

 -- Function: stl::binary_search (sv, first, last) x comp
     returns true if x is an element of sv[first, last)


File: pure-stlvec.info,  Node: Examples<5>,  Prev: Operations<3>,  Up: STL Sort Algorithms

8.3 Examples
============

See ut_sort.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Merge Algorithms,  Next: STL Heap Algorithms,  Prev: STL Sort Algorithms,  Up: Top

9 STL Merge Algorithms
**********************

The stlvec::merge module provides an interface to the STL's merge
algorithms. These algorithms operate on sorted ranges.

* Menu:

* Imports: Imports<5>.
* Operations: Operations<4>.
* Examples: Examples<6>.


File: pure-stlvec.info,  Node: Imports<5>,  Next: Operations<4>,  Up: STL Merge Algorithms

9.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::merge;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<4>,  Next: Examples<6>,  Prev: Imports<5>,  Up: STL Merge Algorithms

9.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering function, comp (as for the Pure library sort function). They
only work properly on input ranges that have been previously sorted
using comp. The set operations generally do not check for range
overflow because it is not generally possible to determine the length
of the result of a set operation until after it is completed. In most
cases you will get a nasty segmentation fault if the result is bigger
than the target range. The best way to avoid this possibility it to use
a back iterator to specifify the target range.

  See parameter naming conventions at ..

 -- Function: stl::merge (sv1,first1,last1) (sv2,first2,last2) (msv,p)
          comp
     merges the two sorted ranges into the sorted range msv[p,p+n)
     where n is the total length of the merged sequence

 -- Function: stl::inplace_merge (msv,first, middle, last) comp
     merges msv[first,middle) and msv[middle,last) into the sorted range
     msv[first,last)

 -- Function: stl::includes (sv1,first1,last1) (sv2,first2,last2) comp
     returns true if every element of sv2[first2,last2) is an element
     of sv1[first1,last1)

 -- Function: stl::set_union (sv1,first1,last1) (sv2,first2,last2)
          (msv,p) comp
     places the sorted union of sv1[first1,last1) and sv2[first2,last2)
     into msv[p,p+n) where n is the number of elements in the sorted
     union, and returns the past-the-end position of the sorted union

 -- Function: stl::set_intersection (sv1,first1,last1)
          (sv2,first2,last2) (msv,p) comp
     places the sorted intersection of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of
     elements in the sorted intersection, and returns p+n (or
     stl::svend, if applicable)

 -- Function: stl::set_difference (sv1,first1,last1) (sv2,first2,last2)
          (msv,p) comp
     places the sorted difference of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of
     elements in the sorted difference, and returns p+n (or stl::svend,
     if applicable)

 -- Function: stl::set_symmetric_difference (sv1,first1,last1)
          (sv2,first2,last2) (msv,p) comp
     places the sorted symmetric_difference of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of
     elements in the sorted symmetric_difference, and returns returns
     p+n (or stl::svend, if applicable)


File: pure-stlvec.info,  Node: Examples<6>,  Prev: Operations<4>,  Up: STL Merge Algorithms

9.3 Examples
============

See ut_merge.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Heap Algorithms,  Next: Min/Max STL Algorithms,  Prev: STL Merge Algorithms,  Up: Top

10 STL Heap Algorithms
**********************

The stlvec::heap module provides an interface to the STL's heap
operations.

* Menu:

* Imports: Imports<6>.
* Operations: Operations<5>.
* Examples: Examples<7>.


File: pure-stlvec.info,  Node: Imports<6>,  Next: Operations<5>,  Up: STL Heap Algorithms

10.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::heap;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<5>,  Next: Examples<7>,  Prev: Imports<6>,  Up: STL Heap Algorithms

10.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering function, comp (as for the Pure library sort function). The
functions (<) and (>) are commonly passed as comp.

 -- Function: stl::make_heap (msv,first,last) comp
     rearranges the elements of msv[first,last) so that they are a
     heap, i.e., after this msv!first will be the largest element in
     msv[first,last), and push_heap and pop_heap will work properly

 -- Function: stl::push_heap (msv,first,last) comp
     makes msv[first,last) a heap (assuming that msv[first,last-1) was
     a heap)

 -- Function: stl::pop_heap (msv,first,last) comp
     swaps msv!first with msv!(last-1), and makes msv[first,last-1) a
     heap (assuming that msv[first,last) was a heap)

 -- Function: stl::sort_heap (msv,first,last) comp
     sorts the elements in msv[first,last)


File: pure-stlvec.info,  Node: Examples<7>,  Prev: Operations<5>,  Up: STL Heap Algorithms

10.3 Examples
=============

See ut_heap.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Min/Max STL Algorithms,  Next: STL Numeric Algorithms,  Prev: STL Heap Algorithms,  Up: Top

11 Min/Max STL Algorithms
*************************

The stlvec::minmax module provides an interface to a few additional STL
algorithms.

* Menu:

* Imports: Imports<7>.
* Operations: Operations<6>.
* Examples: Examples<8>.


File: pure-stlvec.info,  Node: Imports<7>,  Next: Operations<6>,  Up: Min/Max STL Algorithms

11.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::minmax;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<6>,  Next: Examples<8>,  Prev: Imports<7>,  Up: Min/Max STL Algorithms

11.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering function, comp (as for the Pure library sort function). The
functions (<) and (>) are commonly passed as comp.

 -- Function: stl::min_element (sv,first,last) comp
     returns the position of the minimal element of sv[first,last)
     under the ordering defined by comp

 -- Function: stl::max_element (sv,first,last) comp
     returns the position of the maximal element of sv[first,last)
     under the ordering defined by comp

 -- Function: stl::lexicographical_compare (sv1,first1,last1)
          (sv2,first2,last2) comp
     compares sv1[first1,last1) and sv2[first2,last2) element by element
     according to the ordering defined by comp, and returns true if the
     first sequence is less than the second

  Algorithms are provided for stepping through all the permutations the
elements of a stlvec. For these purposes, the first permutation has the
elements of msv[first,last) sorted in ascending order and the last has
the elements sorted in descending order.

 -- Function: stl::next_permutation (msv,first,last) comp
     rearranges msv[first,last) to produce the next permutation, in the
     ordering imposed by comp. If msv[first,last) is not the last
     permutation, change msv[first,last) to the next permutation and
     return true. Otherwise, change it to the first permutation and
     return true

 -- Function: stl::prev_permutation (msv,first,last) comp
     next_permutation in reverse


File: pure-stlvec.info,  Node: Examples<8>,  Prev: Operations<6>,  Up: Min/Max STL Algorithms

11.3 Examples
=============

See ut_minmax.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Numeric Algorithms,  Next: Reference Counting,  Prev: Min/Max STL Algorithms,  Up: Top

12 STL Numeric Algorithms
*************************

The stlvec::numeric module provides an interface to the STL's numeric
algorithms.

* Menu:

* Imports: Imports<8>.
* Operations: Operations<7>.
* Examples: Examples<9>.


File: pure-stlvec.info,  Node: Imports<8>,  Next: Operations<7>,  Up: STL Numeric Algorithms

12.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::numeric;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<7>,  Next: Examples<9>,  Prev: Imports<8>,  Up: STL Numeric Algorithms

12.2 Operations
===============

 -- Function: stl::accumulate (sv,first,last) x bin_fun
     accumulate bin_fun over x and the members of sv[first,last), like
     foldl

 -- Function: stl::inner_product (sv1,first1,last1) (sv2,first2,last2)
          x bin_fun1 bin_fun2
     initialize ret with x. Traverse pairs of elements of
     sv1[first1,last1) and sv2[first2,last2), denoted by (e1, e2),
     replacing ret with (bin_fun1 ret $ bin_fun2 e1 e2). The number
     pairs traversed is equal to the size of sv1[first1,last1)

 -- Function: stl::partial_sum (sv,first,last) (msv, p) bin_fun
     accumulate bin_fun f over the elements of sv1[first1,last1),
     placing itermediate results in msv[p,p+n), where n is last -
     first, and returns q where m is q - n and msv[m,q) is the
     intermediate sequence

 -- Function: stl::adjacent_difference (sv,first,last) (msv, p) bin_fun
     produce a sequence of new elements by applying bin_fun to adjacent
     elements of sv[first,last), placing the new elements in
     msv[p,p+n), where n is last - first, with the intermediate
     results, and returns q where m is q - n and msv[m,q) is the new
     sequence


File: pure-stlvec.info,  Node: Examples<9>,  Prev: Operations<7>,  Up: STL Numeric Algorithms

12.3 Examples
=============

See ut_numeric.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Reference Counting,  Next: Backward Compatibilty,  Prev: STL Numeric Algorithms,  Up: Top

13 Reference Counting
*********************

The following function, also in the stl namespace, is available if you
want to observe how pure-stlvec maintains reference counts for items in
its containers.

 -- Function: stl::refc x
     returns the x's reference count (maintained by the Pure runtime for
     garbage collection purposes)


File: pure-stlvec.info,  Node: Backward Compatibilty,  Next: Index,  Prev: Reference Counting,  Up: Top

14 Backward Compatibilty
************************

This section documents changes in stlvec that might have introduced
backward compatiblity issues.

* Menu:

* stlvec-0 3::


File: pure-stlvec.info,  Node: stlvec-0 3,  Up: Backward Compatibilty

14.1 stlvec-0.3
===============

Version 0.3 reflects some changes made to make stlvec consistent with
its sister package, stlmap.

  The `update' function was deprecated. Please use `replace' instead.

  The `replace' function was added to the stlvec module. This function
is the same as `update' except that "`replace' sv i x" returns x
instead of sv.

  The `stl::replace' function was removed from the stlvec/modifying
module. You can use "*note stl replace_if: 65. (sv,first,last) (x==) y"
instead of ":func:>`<stl::replace (sv,first,last) x y" to replace all
instances of x in the specified range.

  The function `null' was removed and `stl::empty' was added to replace
it.

  The function `list' was removed. You can use `members' instead.

  All of the tracing functions were removed.


File: pure-stlvec.info,  Node: Index,  Prev: Backward Compatibilty,  Up: Top

Index
*****

 [index ]
* Menu:

* # prefix function:                     Operations in the Global Namespace.
                                                              (line  33)
* == infix function:                     Operations in the Global Namespace.
                                                              (line  85)
* append function:                       Operations in the Global Namespace.
                                                              (line  66)
* bad_argument constructor:              Exception Symbols.   (line   6)
* bad_function constructor:              Exception Symbols.   (line  11)
* catmap function:                       Operations in the Global Namespace.
                                                              (line 104)
* colcatmap function:                    Operations in the Global Namespace.
                                                              (line 129)
* colmap function:                       Operations in the Global Namespace.
                                                              (line 127)
* const_stlvec function:                 Operations in the Global Namespace.
                                                              (line  26)
* const_stlvec type:                     Types.               (line  12)
* const_svit type:                       Types.               (line  21)
* do function:                           Operations in the Global Namespace.
                                                              (line 107)
* emptystlvec function:                  Operations in the Global Namespace.
                                                              (line  12)
* erase function:                        Operations in the Global Namespace.
                                                              (line  79)
* failed_cond constructor:               Exception Symbols.   (line  15)
* filter function:                       Operations in the Global Namespace.
                                                              (line 116)
* first function:                        Operations in the Global Namespace.
                                                              (line  50)
* foldl function:                        Operations in the Global Namespace.
                                                              (line 110)
* foldl1 function:                       Operations in the Global Namespace.
                                                              (line 113)
* infix function:                        Operations in the Global Namespace.
                                                              (line  41)
* insert function:                       Operations in the Global Namespace.
                                                              (line  69)
* last function:                         Operations in the Global Namespace.
                                                              (line  50)
* listmap function:                      Operations in the Global Namespace.
                                                              (line 101)
* map function:                          Operations in the Global Namespace.
                                                              (line  98)
* members function:                      Operations in the Global Namespace.
                                                              (line  54)
* mkstlvec function:                     Operations in the Global Namespace.
                                                              (line  23)
* mutable_stlvec type:                   Types.               (line   9)
* mutable_svit type:                     Types.               (line  18)
* out_of_bounds constructor:             Exception Symbols.   (line  19)
* range_overflow constructor:            Exception Symbols.   (line  22)
* range_overlap constructor:             Exception Symbols.   (line  27)
* replace function:                      Operations in the Global Namespace.
                                                              (line  57)
* rmfirst function:                      Operations in the Global Namespace.
                                                              (line  75)
* rmlast function:                       Operations in the Global Namespace.
                                                              (line  75)
* rowcatmap function:                    Operations in the Global Namespace.
                                                              (line 125)
* rowmap function:                       Operations in the Global Namespace.
                                                              (line 123)
* stl accumulate function:               Operations<7>.       (line   6)
* stl adjacent_difference function:      Operations<7>.       (line  23)
* stl adjacent_find function:            Operations.          (line  23)
* stl allpairs function:                 Operations in the stl Namespace.
                                                              (line  12)
* stl binary_search function:            Operations<3>.       (line  56)
* stl bounds function:                   Operations in the stl Namespace.
                                                              (line  17)
* stl capacity function:                 Operations in the stl Namespace.
                                                              (line  28)
* stl copy function:                     Operations<2>.       (line   6)
* stl copy_backward function:            Operations<2>.       (line  10)
* stl count function:                    Operations.          (line  28)
* stl count_if function:                 Operations.          (line  32)
* stl empty function:                    Operations in the stl Namespace.
                                                              (line   6)
* stl equal function:                    Operations.          (line  44)
* stl equal_range function:              Operations<3>.       (line  51)
* stl fill function:                     Operations<2>.       (line  43)
* stl fill_n function:                   Operations<2>.       (line  46)
* stl find function:                     Operations.          (line   9)
* stl find_end function:                 Operations.          (line  61)
* stl find_first_of function:            Operations.          (line  17)
* stl find_if function:                  Operations.          (line  13)
* stl for_each function:                 Operations.          (line   6)
* stl generate function:                 Operations<2>.       (line  49)
* stl generate_n function:               Operations<2>.       (line  64)
* stl includes function:                 Operations<4>.       (line  27)
* stl inner_product function:            Operations<7>.       (line  10)
* stl inplace_merge function:            Operations<4>.       (line  23)
* stl lexicographical_compare function:  Operations<6>.       (line  18)
* stl lower_bound function:              Operations<3>.       (line  43)
* stl make_heap function:                Operations<5>.       (line  10)
* stl max_element function:              Operations<6>.       (line  14)
* stl merge function:                    Operations<4>.       (line  18)
* stl min_element function:              Operations<6>.       (line  10)
* stl mismatch function:                 Operations.          (line  36)
* stl next_permutation function:         Operations<6>.       (line  29)
* stl nth_element function:              Operations<3>.       (line  32)
* stl partial_sort function:             Operations<3>.       (line  17)
* stl partial_sort_copy function:        Operations<3>.       (line  23)
* stl partial_sum function:              Operations<7>.       (line  17)
* stl partition function:                Operations<2>.       (line 115)
* stl pop_heap function:                 Operations<5>.       (line  19)
* stl prev_permutation function:         Operations<6>.       (line  36)
* stl push_heap function:                Operations<5>.       (line  15)
* stl random_shuffle function:           Operations<2>.       (line 112)
* stl refc function:                     Reference Counting.  (line  10)
* stl remove function:                   Operations<2>.       (line  68)
* stl remove_copy function:              Operations<2>.       (line  78)
* stl remove_copy_if function:           Operations<2>.       (line  82)
* stl remove_if function:                Operations<2>.       (line  71)
* stl replace_copy function:             Operations<2>.       (line  35)
* stl replace_copy_if function:          Operations<2>.       (line  39)
* stl replace_if function:               Operations<2>.       (line  31)
* stl reserve function:                  Operations in the stl Namespace.
                                                              (line  23)
* stl reverse function:                  Operations<2>.       (line  97)
* stl reverse_copy function:             Operations<2>.       (line 100)
* stl rotate function:                   Operations<2>.       (line 104)
* stl rotate_copy function:              Operations<2>.       (line 108)
* stl search function:                   Operations.          (line  49)
* stl search_n function:                 Operations.          (line  55)
* stl set_difference function:           Operations<4>.       (line  44)
* stl set_intersection function:         Operations<4>.       (line  37)
* stl set_symmetric_difference function: Operations<4>.       (line  51)
* stl set_union function:                Operations<4>.       (line  31)
* stl sort function:                     Operations<3>.       (line  10)
* stl sort_heap function:                Operations<5>.       (line  23)
* stl stable_partition function:         Operations<2>.       (line 121)
* stl stable_sort function:              Operations<3>.       (line  13)
* stl svback constant:                   Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl svbeg constant:                    Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl svend constant:                    Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl swap_ranges function:              Operations<2>.       (line  15)
* stl transform function:                Operations<2>.       (line  19)
* stl transform_2 function:              Operations<2>.       (line  24)
* stl unique function:                   Operations<2>.       (line  86)
* stl unique_copy function:              Operations<2>.       (line  93)
* stl upper_bound function:              Operations<3>.       (line  47)
* stl vector function:                   Operations in the stl Namespace.
                                                              (line   9)
* stlvec function:                       Operations in the Global Namespace.
                                                              (line  15)
* stlvec module:                         Top.                 (line   6)
* stlvec type:                           Types.               (line  15)
* svit type:                             Types.               (line  25)
* update function:                       Operations in the Global Namespace.
                                                              (line  62)
* ~= infix function:                     Operations in the Global Namespace.
                                                              (line  85)



Tag Table:
Node: Top253
Ref: 0587
Ref: pure587
Node: Copying2228
Ref: copying2313
Ref: 12313
Ref: module-stlvec2313
Ref: 22313
Ref: 32313
Node: Installation2701
Ref: installation2791
Ref: 42791
Node: Overview3743
Ref: overview3840
Ref: 53840
Node: Modules4692
Ref: modules4773
Ref: 64773
Node: Simple Examples6008
Ref: simple examples6130
Ref: 76130
Ref: simple-examples6130
Node: Members and Sequences of Members7864
Ref: members and sequences of members8012
Ref: 88012
Ref: members-and-sequences-of-members8012
Node: STL Iterators and Value Semantics8803
Ref: stl iterators and value semantics8951
Ref: 98951
Ref: stl-iterators-and-value-semantics8951
Node: Iterator Tuples10873
Ref: iterator tuples11022
Ref: a11022
Ref: iterator-tuples11022
Node: Predefined Iterator Tuple Indexes13444
Ref: predefined iterator tuple indexes13581
Ref: b13581
Ref: predefined-iterator-tuple-indexes13581
Ref: c13752
Ref: stl svbeg13752
Ref: d13781
Ref: stl svend13781
Ref: e13811
Ref: stl svback13811
Node: Back Insert Iterators14274
Ref: back insert iterators14410
Ref: f14410
Ref: back-insert-iterators14410
Node: Data Structure15400
Ref: data structure15508
Ref: 1015508
Ref: data-structure15508
Node: Types16401
Ref: types16511
Ref: 1116511
Ref: 1216613
Ref: mutable_stlvec/type16613
Ref: 1316675
Ref: const_stlvec/type16675
Ref: 1416738
Ref: stlvec/type16738
Ref: 1516806
Ref: mutable_svit/type16806
Ref: 1616902
Ref: const_svit/type16902
Ref: 1717003
Ref: svit/type17003
Node: Copy-On-Write Semantics17112
Ref: copy-on-write semantics17221
Ref: 1817221
Ref: copy-on-write-semantics17221
Node: Documentation18749
Ref: documentation18868
Ref: 1918868
Node: Parameter Names19847
Ref: parameter names19934
Ref: 1a19934
Ref: parameter-names19934
Node: Error Handling22047
Ref: error handling22172
Ref: 1b22172
Ref: error-handling22172
Node: Exception Symbols22326
Ref: exception symbols22416
Ref: 1c22416
Ref: exception-symbols22416
Ref: 1d22461
Ref: bad_argument22461
Ref: 1e22684
Ref: bad_function22684
Ref: 1f22813
Ref: failed_cond/stlvec22813
Ref: 2022946
Ref: out_of_bounds/stlvec22946
Ref: 2123049
Ref: range_overflow23049
Ref: 2223247
Ref: range_overlap23247
Node: Examples23612
Ref: examples23702
Ref: 2323702
Node: Operations Included in the stlvec Module24683
Ref: operations included in the stlvec module24827
Ref: 2424827
Ref: operations-included-in-the-stlvec-module24827
Node: Imports25659
Ref: imports25791
Ref: 2525791
Node: Operations in the Global Namespace25929
Ref: operations in the global namespace26101
Ref: 2626101
Ref: operations-in-the-global-namespace26101
Ref: 2726484
Ref: emptystlvec26484
Ref: 2826539
Ref: stlvec26539
Ref: 2926932
Ref: mkstlvec26932
Ref: 2a27014
Ref: const_stlvec27014
Ref: 2b27372
Ref: #/stlvec27372
Ref: 2c27648
Ref: !/stlvec27648
Ref: 2d28014
Ref: first/stlvec28014
Ref: 2e28037
Ref: last/stlvec28037
Ref: 2f28093
Ref: members/stlvec28093
Ref: 3028188
Ref: replace/stlvec28188
Ref: 3128375
Ref: update/stlvec28375
Ref: 3228509
Ref: append/stlvec28509
Ref: 3328567
Ref: insert/stlvec28567
Ref: 3428599
Ref: insert28599
Ref: 3528824
Ref: rmfirst/stlvec28824
Ref: 3628850
Ref: rmlast/stlvec28850
Ref: 3728922
Ref: erase28922
Ref: 3829141
Ref: ==/stlvec29141
Ref: 3929166
Ref: ~=/stlvec29166
Ref: 3a29583
Ref: map/stlvec29583
Ref: 3b29700
Ref: listmap/stlvec29700
Ref: 3c29797
Ref: catmap/stlvec29797
Ref: 3d29920
Ref: do/stlvec29920
Ref: 3e30035
Ref: foldl/stlvec30035
Ref: 3f30156
Ref: foldl1/stlvec30156
Ref: 4030275
Ref: filter/stlvec30275
Ref: 4130532
Ref: rowmap/stlvec30532
Ref: 4230582
Ref: rowcatmap/stlvec30582
Ref: 4330635
Ref: colmap/stlvec30635
Ref: 4430685
Ref: colcatmap/stlvec30685
Node: Operations in the stl Namespace30738
Ref: operations in the stl namespace30914
Ref: 4530914
Ref: operations-in-the-stl-namespace30914
Ref: 4630987
Ref: stl empty/stlvec30987
Ref: 4731046
Ref: stl vector31046
Ref: 4831159
Ref: stl allpairs31159
Ref: 4931367
Ref: stl bounds31367
Ref: 4a31659
Ref: stl reserve31659
Ref: 4b31877
Ref: stl capacity31877
Node: Examples<2>32019
Ref: examples<2>32152
Ref: 4c32152
Ref: id132152
Node: STL Nonmodifying Algorithms32258
Ref: stl nonmodifying algorithms32412
Ref: 4d32412
Ref: stl-nonmodifying-algorithms32412
Node: Imports<2>32649
Ref: imports<2>32747
Ref: 4e32747
Ref: id232747
Node: Operations32946
Ref: operations33064
Ref: 4f33064
Ref: 5033095
Ref: stl for_each33095
Ref: 5133217
Ref: stl find33217
Ref: 5233385
Ref: stl find_if33385
Ref: 5333570
Ref: stl find_first_of33570
Ref: 5433857
Ref: stl adjacent_find33857
Ref: 5534113
Ref: stl count34113
Ref: 5634252
Ref: stl count_if34252
Ref: 5734408
Ref: stl mismatch34408
Ref: 5834834
Ref: stl equal34834
Ref: 5935092
Ref: stl search35092
Ref: 5a35417
Ref: stl search_n35417
Ref: 5b35741
Ref: stl find_end35741
Node: Examples<3>36075
Ref: examples<3>36174
Ref: 5c36174
Ref: id336174
Node: STL Modifying Algorithms36260
Ref: stl modifying algorithms36393
Ref: 5d36393
Ref: stl-modifying-algorithms36393
Node: Imports<3>36622
Ref: imports<3>36720
Ref: 5e36720
Ref: id436720
Node: Operations<2>36916
Ref: operations<2>37034
Ref: 5f37034
Ref: id537034
Ref: 6037065
Ref: stl copy37065
Ref: 6137225
Ref: stl copy_backward37225
Ref: 6237479
Ref: stl swap_ranges37479
Ref: 6337638
Ref: stl transform37638
Ref: 6437915
Ref: stl transform_237915
Ref: 6538210
Ref: stl replace_if38210
Ref: 6638353
Ref: stl replace_copy38353
Ref: 6738530
Ref: stl replace_copy_if38530
Ref: 6838710
Ref: stl fill38710
Ref: 6938806
Ref: stl fill_n38806
Ref: 6a38904
Ref: stl generate38904
Ref: 6b39286
Ref: stl generate_n39286
Ref: 6c39451
Ref: stl remove39451
Ref: 6d39555
Ref: stl remove_if39555
Ref: 6e39946
Ref: stl remove_copy39946
Ref: 6f40135
Ref: stl remove_copy_if40135
Ref: 7040339
Ref: stl unique40339
Ref: 7140723
Ref: stl unique_copy40723
Ref: 7240919
Ref: stl reverse40919
Ref: 7341023
Ref: stl reverse_copy41023
Ref: 7441215
Ref: stl rotate41215
Ref: 7541384
Ref: stl rotate_copy41384
Ref: 7641570
Ref: stl random_shuffle41570
Ref: 7741677
Ref: stl partition41677
Ref: 7841987
Ref: stl stable_partition41987
Node: Examples<4>42159
Ref: examples<4>42258
Ref: 7942258
Ref: id642258
Node: STL Sort Algorithms42341
Ref: stl sort algorithms42467
Ref: 7a42467
Ref: stl-sort-algorithms42467
Node: Imports<4>42697
Ref: imports<4>42790
Ref: 7b42790
Ref: id742790
Node: Operations<3>42981
Ref: operations<3>43094
Ref: 7c43094
Ref: id843094
Ref: 7d43274
Ref: stl sort43274
Ref: 7e43351
Ref: stl stable_sort43351
Ref: 7f43488
Ref: stl partial_sort43488
Ref: 8043777
Ref: stl partial_sort_copy43777
Ref: 8144285
Ref: stl nth_element44285
Ref: 8244777
Ref: stl lower_bound44777
Ref: 8344978
Ref: stl upper_bound44978
Ref: 8445178
Ref: stl equal_range45178
Ref: 8545386
Ref: stl binary_search45386
Node: Examples<5>45501
Ref: examples<5>45595
Ref: 8645595
Ref: id945595
Node: STL Merge Algorithms45673
Ref: stl merge algorithms45794
Ref: 8745794
Ref: stl-merge-algorithms45794
Node: Imports<5>46050
Ref: imports<5>46144
Ref: 8846144
Ref: id1046144
Node: Operations<4>46336
Ref: operations<4>46450
Ref: 8946450
Ref: id1146450
Ref: 8a47123
Ref: stl merge47123
Ref: 8b47333
Ref: stl inplace_merge47333
Ref: 8c47492
Ref: stl includes47492
Ref: 8d47660
Ref: stl set_union47660
Ref: 8e47962
Ref: stl set_intersection47962
Ref: 8f48279
Ref: stl set_difference48279
Ref: 9048590
Ref: stl set_symmetric_difference48590
Node: Examples<6>48939
Ref: examples<6>49034
Ref: 9149034
Ref: id1249034
Node: STL Heap Algorithms49113
Ref: stl heap algorithms49237
Ref: 9249237
Ref: stl-heap-algorithms49237
Node: Imports<6>49448
Ref: imports<6>49541
Ref: 9349541
Ref: id1349541
Node: Operations<5>49734
Ref: operations<5>49847
Ref: 9449847
Ref: id1449847
Ref: 9550069
Ref: stl make_heap50069
Ref: 9650325
Ref: stl push_heap50325
Ref: 9750461
Ref: stl pop_heap50461
Ref: 9850635
Ref: stl sort_heap50635
Node: Examples<7>50730
Ref: examples<7>50824
Ref: 9950824
Ref: id1550824
Node: Min/Max STL Algorithms50904
Ref: min/max stl algorithms51030
Ref: 9a51030
Ref: min-max-stl-algorithms51030
Node: Imports<7>51255
Ref: imports<7>51351
Ref: 9b51351
Ref: id1651351
Node: Operations<6>51546
Ref: operations<6>51662
Ref: 9c51662
Ref: id1751662
Ref: 9d51884
Ref: stl min_element51884
Ref: 9e52044
Ref: stl max_element52044
Ref: 9f52204
Ref: stl lexicographical_compare52204
Ref: a052747
Ref: stl next_permutation52747
Ref: a153098
Ref: stl prev_permutation53098
Node: Examples<8>53190
Ref: examples<8>53287
Ref: a253287
Ref: id1853287
Node: STL Numeric Algorithms53369
Ref: stl numeric algorithms53494
Ref: a353494
Ref: stl-numeric-algorithms53494
Node: Imports<8>53717
Ref: imports<8>53813
Ref: a453813
Ref: id1953813
Node: Operations<7>54009
Ref: operations<7>54125
Ref: a554125
Ref: id2054125
Ref: a654158
Ref: stl accumulate54158
Ref: a754297
Ref: stl inner_product54297
Ref: a854655
Ref: stl partial_sum54655
Ref: a954942
Ref: stl adjacent_difference54942
Node: Examples<9>55295
Ref: examples<9>55392
Ref: aa55392
Ref: id2155392
Node: Reference Counting55475
Ref: reference counting55599
Ref: ab55599
Ref: reference-counting55599
Ref: ac55804
Ref: stl refc55804
Node: Backward Compatibilty55938
Ref: backward compatibilty56045
Ref: ad56045
Ref: backward-compatibilty56045
Node: stlvec-0 356220
Ref: ae56293
Ref: stlvec-0-356293
Node: Index57088
Ref: index57168

End Tag Table


Local Variables:
coding: utf-8
End:
