This is pure-reduce.info, produced by makeinfo version 4.13 from
pure-reduce.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-reduce: (pure-reduce.info).    A REDUCE Interface for the Pure Programming Language
END-INFO-DIR-ENTRY


File: pure-reduce.info,  Node: Top,  Next: Installation,  Up: (dir)

pure-reduce
***********

  Version 0.1, October 05, 2012

    Albert Graef <<Dr.Graef@t-online.de>> 
    Kurt Pagani <<kp@scios.ch>> 
  This is a module providing access to the REDUCE
(http://www.reduce-algebra.com/) computer algebra system from Pure. It
is based on the PROC interface
(http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup)
(a "procedural" interface to embed REDUCE as a C library). More
background information and a discussion of the interface can be found
in the Embedding REDUCE
(http://groups.google.com/group/pure-lang/browse_thread/thread/c11e82ca2e9e8cbb)
thread on the Pure mailing list.

  The interface can be found in reduce.pure (in particular, have a look
at the *note high-level interface: 3. defined near the end of the
module), some basic examples are in reduce_examp.pure. Please note that
at present, this module is still experimental and under development.
But the basic functionality appears to work, and you're welcome to
discuss the new interface on the mailing list and/or submit bug reports
and patches.

* Menu:

* Installation::
* High-Level Interface::
* Index::


File: pure-reduce.info,  Node: Installation,  Next: High-Level Interface,  Prev: Top,  Up: Top

1 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-reduce-0.1.tar.gz>.

  You'll need both the embedded REDUCE library (named reduce.so,
reduce.dylib or reduce.dll, depending on the system you have) and a
REDUCE image file (reduce.img) to make this module work. A Makefile is
included with this package so that you can build these yourself from
the REDUCE sources. (In principle, this only needs to be done once for
the initial installation of this module, but you may want to repeat
this procedure every once in a while to get the latest REDUCE version.)

  Check out the latest REDUCE version from its svn repository with the
following command:

    svn co https://reduce-algebra.svn.sourceforge.net/svnroot/reduce-algebra/trunk/ reduce-algebra

This may take a while; REDUCE is a _big_ package. Once it's finished,
just drop the resulting reduce-algebra directory into the pure-reduce
source directory. Run `make' and then (if needed) `make install' in the
pure-reduce source directory. You should also run `make check' which
runs a few tests in order to check that the interface works ok (this
can be done without installing the package, but needs the REDUCE image
and library).

     Note: In case the above procedure doesn't work for you, there are
     more detailed instructions by Kurt Pagani on how to compile the
     relevant parts of REDUCE, see the accompanying pure_reduce.txt
     file for details.


File: pure-reduce.info,  Node: High-Level Interface,  Next: Index,  Prev: Installation,  Up: Top

2 High-Level Interface
**********************

The goal here is to make it easy to run REDUCE from Pure; to these ends,
the most important features of the low-level PROC interface are wrapped
in a convenient way. Currently the following variables and functions are
provided:

 -- variable: REDUCE_PATH
     This variable holds a colon-delimited search path used to locate
     the REDUCE image file (see *note reduce start: 8. below). By
     default this includes the current directory and the Pure library
     directory.

 -- Function: reduce::start image::string args::smatrix
     Initializes the REDUCE system. This is done automatically when
     loading this module, so normally you shouldn't have to call this
     manually, unless the image file isn't found or you want to restart
     the REDUCE system with your own image file or your own set of
     options. In any case, this needs to be executed once before
     calling any other operation of this module. When calling this
     operation manually, you need to specify the name of the REDUCE
     image file and any desired extra arguments as a string vector.
     Unless the filename contains a slash, *note reduce start: 8.
     searches the directories in *note REDUCE_PATH: 7. for the image
     file. An exception is raised if the image file isn't found.

 -- Function: reduce::finish
     Finalizes the REDUCE system. You can call this to release the
     resources of the REDUCE system. (*note reduce start: 8. also
     invokes this automatically if a REDUCE instance is already
     running, so it isn't necessary to call *note reduce finish: 9. in
     this case.)

 -- Function: reduce::verbosity n
     Sets the verbosity level; 0 means no messages at all (which is the
     default when using this module), and the following values may be
     or'ed together to pick what you need:

          1 messages whenever garbage collection happens

          2 messages whenever a module of code is loaded

          4 extra details in the garbage collector messages

 -- Function: reduce::load name::string
     Loads REDUCE packages. This works like REDUCE's `load_package'
     command; please check the REDUCE documentation for details.

 -- Function: reduce::switch name:string val::int
     Lets you change global REDUCE options. This works like REDUCE's
     `on' and `off' declarations; please check the REDUCE documentation
     for details.

  For convenience, the following operations are in the default
namespace:

 -- Function: simplify x
     This is the main entry point. It takes a REDUCE expression in Pure
     format and tries to simplify it using REDUCE. The result is then
     converted back to Pure format. Note that you need to quote `x' if
     you want to prevent it from being evaluated on the Pure side.

 -- Function: lisp x
     This can be used to execute arbitrary Lisp code, which is sometimes
     necessary to perform special functions in the REDUCE system such as
     declarations. The result is always a Pure list or an atomic value.
     Note that you need to quote `x' if you want to prevent it from
     being evaluated on the Pure side. Use this with care; at present,
     the PROC interface isn't very forgiving if you try to execute
     invalid Lisp code; it will most likely crash in such cases.

 -- Function: declare declsym [foo,bar,...]
     Declare symbols and their properties; please see the Declarations
     section in the Reduce manual for details. The second argument can
     also be a singleton symbol if the particular kind of declaration
     permits this. In the present implementation, `declsym' must be one
     of:

        * `operator' (declares an operator symbol);

        * `antisymmetric', `symmetric', `even', `odd', `linear',
          `noncom' and `nonzero' (declares properties of already
          declared operator symbols).

        * `depend', `nodepend', `factor', `remfac', `order', `korder'
          (declares kernel dependencies and orders, these take both
          symbols and prefix expressions as arguments).

  In Pure land, REDUCE expressions are represented using standard
curried notation; some special conversions are applied to make
arithmetic operations such as +, * etc. work as expected. For
convenience, the REDUCE terms `arbconst n', `arbint n' and `arbcomplex
n' are converted from/to Greek symbols `αn', `βn' and `ζn'. (All these
automatic conversions can also be turned off on the output side by
disabling the `mapped' compilation option; this may be useful for
debugging purposes.)

  Here is a simple example showing how to start up REDUCE and do some
calculations:

    > using reduce;
    Reduce (Free CSL version), 27-Sep-12 ...
    > simplify $ df ((x+5)^3) x;
    3*x^2+30*x+75
    > simplify $ solve (x^2+7) x;
    [x==sqrt 7*i,x==-sqrt 7*i]

Note that the result returned by *note simplify: d. is always a quoted
expression. Even if the expression can be further reduced on the Pure
side, you'll have to use `eval' to force its evaluation:

    > using math;
    > eval ans;
    [x==0.0+:2.64575131106459,x==0.0+:-2.64575131106459]

You can also execute Lisp code in the CSL interpreter hosting the REDUCE
system. This is sometimes necessary to access special functionality, but
should be done with care (at present invalid Lisp code can easily crash
the interpreter). For instance:

    > lisp ('list a b c d e);
    [a,b,c,d,e]
    > lisp ('cdr [a,b,[c,d],e]);
    [b,[c,d],e]

Note that Lisp forms are represented in curried notation. Free symbols
are quoted automatically, and Pure lists are mapped to corresponding
Lisp lists. If the result is a Lisp list, it will be converted back to
a Pure list. Most simple kinds of Lisp calls should be doable that way,
but don't expect any miracles; the *note lisp: e. function is provided
to access special functionality in the "symbolic mode" of the REDUCE
system, not to turn Pure into a full-featured Lisp frontend.

  The following example illustrates how you can use the *note lisp: e.
function to declare an operator symbol and change or query its
properties:

    > lisp ('operator [myop]);
    []
    > lisp ('flag [myop] odd);
    []
    > lisp ('prop myop);
    [odd:t,simpfn:simpiden]
    > simplify (myop (-x));
    -myop x

If you find it awkward to evaluate Lisp forms in Pure, you can also
achieve the same with the *note declare: f. function which covers most
of the common REDUCE declarations that might be needed:

    > declare operator myop;
    []
    > declare odd myop;
    []
    > simplify (myop (-x));
    -myop x

Many more examples can be found in the reduce_examp.pure and tests.pure
scripts included in the distribution.


File: pure-reduce.info,  Node: Index,  Prev: High-Level Interface,  Up: Top

Index
*****

 [index ]
* Menu:

* declare function:                      High-Level Interface. (line 75)
* lisp function:                         High-Level Interface. (line 66)
* reduce finish function:                High-Level Interface. (line 30)
* reduce load function:                  High-Level Interface. (line 48)
* reduce module:                         Top.                  (line  6)
* reduce start function:                 High-Level Interface. (line 17)
* reduce switch function:                High-Level Interface. (line 52)
* reduce verbosity function:             High-Level Interface. (line 37)
* REDUCE_PATH variable:                  High-Level Interface. (line 11)
* simplify function:                     High-Level Interface. (line 60)



Tag Table:
Node: Top294
Ref: 01027
Ref: reduce1027
Ref: 11027
Ref: proc-interface1027
Ref: 21027
Ref: embedding-reduce1027
Node: Installation1521
Ref: installation1619
Ref: 41619
Ref: module-reduce1619
Ref: 51619
Ref: a-reduce-interface-for-the-pure-programming-language1619
Ref: 61619
Node: High-Level Interface3086
Ref: high-level interface3186
Ref: 33186
Ref: high-level-interface3186
Ref: 73462
Ref: reduce_path3462
Ref: 83711
Ref: reduce start3711
Ref: 94513
Ref: reduce finish4513
Ref: a4828
Ref: reduce verbosity4828
Ref: b5225
Ref: reduce load5225
Ref: c5399
Ref: reduce switch5399
Ref: d5684
Ref: simplify5684
Ref: e5990
Ref: lisp5990
Ref: f6501
Ref: declare6501
Node: Index9869
Ref: index9948

End Tag Table


Local Variables:
coding: utf-8
End:
