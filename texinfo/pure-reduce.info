This is pure-reduce.info, produced by makeinfo version 4.13 from
pure-reduce.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-reduce: (pure-reduce.info).    A REDUCE Interface for the Pure Programming Language
END-INFO-DIR-ENTRY


File: pure-reduce.info,  Node: Top,  Next: Installation,  Up: (dir)

pure-reduce
***********

  Version 0.1, October 06, 2012

    Albert Graef <<Dr.Graef@t-online.de>> 
    Kurt Pagani <<kp@scios.ch>> 
  This is a module providing access to the Reduce
(http://www.reduce-algebra.com/) computer algebra system from Pure. It
is based on the PROC interface
(http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup)
(a "procedural" interface to embed Reduce as a C library). More
background information and a discussion of the interface can be found
in the Embedding REDUCE
(http://groups.google.com/group/pure-lang/browse_thread/thread/c11e82ca2e9e8cbb)
thread on the Pure mailing list.

  The interface can be found in reduce.pure (in particular, have a look
at the *note high-level interface: 3. defined near the end of the
module), some basic examples are in reduce_examp.pure. Please note that
at present this module is still experimental and under development. But
the basic functionality appears to work, and you're welcome to discuss
the new interface on the mailing list and/or submit bug reports and
patches.

* Menu:

* Installation::
* Low-Level Interface::
* High-Level Interface::
* Basic Examples::
* Index::


File: pure-reduce.info,  Node: Installation,  Next: Low-Level Interface,  Prev: Top,  Up: Top

1 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-reduce-0.1.tar.gz>.

  You'll need both the embedded Reduce library (named reduce.so,
reduce.dylib or reduce.dll, depending on the system you have) and a
Reduce image file (reduce.img) to make this module work. A Makefile is
included with this package so that you can build these yourself from
the Reduce sources. (In principle, this only needs to be done once for
the initial installation of this module, but you may want to repeat
this procedure every once in a while to get the latest Reduce version.)

  You can check out the latest Reduce version from its svn repository
with the following command:

    svn co https://reduce-algebra.svn.sourceforge.net/svnroot/reduce-algebra/trunk/ reduce-algebra

This may take a while; Reduce is a _big_ package. Once it's finished,
just drop the resulting reduce-algebra directory into the pure-reduce
source directory. Run `make' and then (if needed) `make install' in the
pure-reduce source directory. You should also run `make check' which
runs a few tests in order to verify that the interface works ok (this
can be done without installing the package, but needs the Reduce image
and library).

     Note: In case the above procedure doesn't work for you, there are
     more detailed instructions on how to compile the relevant parts of
     Reduce in the pure_reduce.txt file included in the distribution.


File: pure-reduce.info,  Node: Low-Level Interface,  Next: High-Level Interface,  Prev: Installation,  Up: Top

2 Low-Level Interface
*********************

The low-level interface is a straight wrapper of the PROC interface
(http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup),
please check the proc.h file in the Reduce sources for details. These
routines are all in the `reduce' namespace. Normally you shouldn't have
to call these functions directly, since we provide a high-level,
idiomatic Pure interface which makes calling Reduce from Pure much more
convenient.


File: pure-reduce.info,  Node: High-Level Interface,  Next: Basic Examples,  Prev: Low-Level Interface,  Up: Top

3 High-Level Interface
**********************

The goal here is to make it easy to run Reduce from Pure; to these ends,
the most important features of the low-level PROC interface are wrapped
in a convenient way. Currently the following variables and functions are
provided:

 -- variable: REDUCE_PATH
     This variable holds a colon-delimited search path used to locate
     the Reduce image file (see *note reduce start: 9. below). By
     default this includes the current directory and the Pure library
     directory.

 -- Function: reduce::start image::string args::smatrix
     Initializes the Reduce system. This is done automatically when
     loading this module, so normally you shouldn't have to call this
     manually, unless the image file isn't found or you want to restart
     the Reduce system with your own image file or your own set of
     options. In any case, this needs to be executed once before
     calling any other operation of this module. When calling this
     operation manually, you need to specify the name of the Reduce
     image file and any desired extra arguments as a string vector.
     Unless the filename contains a slash, *note reduce start: 9.
     searches the directories in *note REDUCE_PATH: 8. for the image
     file. An exception is raised if the image file isn't found.

 -- Function: reduce::finish
     Finalizes the Reduce system. You can call this to release the
     resources of the Reduce system. (*note reduce start: 9. also
     invokes this automatically if a Reduce instance is already
     running, so it isn't necessary to call *note reduce finish: a. in
     this case.)

 -- Function: reduce::verbosity n
     Sets the verbosity level; 0 means no messages at all (which is the
     default when using this module), and the following values may be
     or'ed together to pick what you need:

          1: messages whenever garbage collection happens

          2: messages whenever a module of code is loaded

          4: extra details in the garbage collector messages

 -- Function: reduce::load name::string
     Loads Reduce packages. This works like Reduce's `load_package'
     command; please check the Reduce documentation for details.

 -- Function: reduce::switch name:string val::int
     Lets you change global Reduce options. This works like Reduce's
     `on' and `off' declarations; please check the Reduce documentation
     for details.

  For convenience, the following operations are in the default
namespace:

 -- Function: simplify x
     This is the main entry point. It takes an algebraic expression in
     Pure format and tries to simplify it using Reduce. The result is
     then converted back to Pure format. Note that you need to quote
     `x' if you want to prevent it from being evaluated on the Pure
     side.

 -- Function: lisp x
     This can be used to execute arbitrary Lisp code, which is sometimes
     necessary to perform special functions in the Reduce system. The
     result is always a Pure list or an atomic value. Note that you
     need to quote `x' if you want to prevent it from being evaluated
     on the Pure side. This is to be used with care. At present, the
     PROC interface isn't very forgiving if you try to execute invalid
     Lisp code; it will most likely crash in such cases.

 -- Function: declare declsym [foo,bar,...]
     Declare symbols and their properties; please see the Declarations
     section in the Reduce manual for details. The second argument can
     also be a singleton symbol. In the present implementation,
     `declsym' must be one of:

        * `operator' (declares an operator symbol);

        * `antisymmetric', `symmetric', `even', `odd', `linear',
          `noncom' and `nonzero' (declares properties of already
          declared operator symbols);

        * `depend', `nodepend', `factor', `remfac', `order', `korder'
          (declares kernel dependencies and orders). These take both
          symbols and "kernels" as arguments (the latter are simple
          prefix expressions which denote irreducible subterms such as
          `cos x'; Reduce treats these more or less like variables in
          algebraic simplifications).

 -- Function: precision prec::int
     Sets the internal Reduce precision in decimal digits for floating
     point calculations, and returns the previously set precision. This
     takes effect when rounded mode is enabled (`reduce::switch
     "rounded" 1').  Note that at present this only affects Reduce's
     internal precision, floating point values are still returned as
     double precision numbers in Pure land.

  At present, this module makes no attempt to capture terminal output
such as error messages produced by Reduce, so you should be prepared to
read these in the terminal in which Pure is running, or capture them
yourself using the output redirection facilities of the shell if needed.

  In Pure land, Reduce and Lisp expressions are represented using Pure's
standard curried notation. Some special conversions are applied to
algebraic expressions to make arithmetic operations such as `+', `*'
etc. work as expected. In addition, the `==', `..' and `:=' infix
operators can be used to denote equations, ranges and assignments in
Reduce, respectively. (Note that you may have to quote these in some
cases so that they don't get evaluated on the Pure side.) Also, Reduce's
`arbconst n', `arbint n' and `arbcomplex n' terms are mapped to Greek
symbols `αn', `βn' and `ζn' on the Pure side. (All these automatic
conversions can also be turned off on the output side with the `#!
--disable mapped' compilation pragma; this may be useful for debugging
purposes.)


File: pure-reduce.info,  Node: Basic Examples,  Next: Index,  Prev: High-Level Interface,  Up: Top

4 Basic Examples
****************

Here is a simple example showing how to start up Reduce and do some
calculations:

    > using reduce;
    Reduce (Free CSL version), 27-Sep-12 ...
    > simplify $ df ((x+5)^3) x;
    3*x^2+30*x+75
    > simplify $ solve (x^2+7) x;
    [x==sqrt 7*i,x==-sqrt 7*i]

Note that the result returned by *note simplify: e. is always a quoted
expression. If the expression can be further reduced on the Pure side,
you'll have to use Pure's `eval' function to force its evaluation:

    > using math;
    > eval ans;
    [x==0.0+:2.64575131106459,x==0.0+:-2.64575131106459]

You can also execute Lisp code in the CSL interpreter hosting the Reduce
system. This is sometimes necessary to access special functionality, but
should be done with care (at present invalid Lisp code can easily crash
the interpreter). For instance:

    > lisp ('list a b c d e);
    [a,b,c,d,e]
    > lisp ('cdr [a,b,[c,d],e]);
    [b,[c,d],e]

Free symbols are quoted automatically, and Pure lists are mapped to
corresponding Lisp lists. If the result is a Lisp list, it will be
converted back to a Pure list. Most simple kinds of Lisp calls should be
doable that way, but don't expect any miracles; the *note lisp: f.
function is provided to access special functionality in the "symbolic
mode" of the Reduce system, not to turn Pure into a full-featured Lisp
frontend.

  The following example illustrates how you can use the *note lisp: f.
function to declare an operator symbol and change or query its
properties:

    > lisp ('operator [myop]);
    []
    > lisp ('flag [myop] odd);
    []
    > lisp ('prop myop);
    [odd:t,simpfn:simpiden]
    > simplify (myop (-x));
    -myop x

If you find it awkward to evaluate Lisp forms in Pure, you can also
achieve the same with the *note declare: 10. function which covers most
of the common Reduce declarations that might be needed:

    > declare operator myop;
    []
    > declare odd myop;
    []
    > simplify (myop (-x));
    -myop x

Many more examples can be found in the reduce_examp.pure and tests.pure
scripts included in the distribution.


File: pure-reduce.info,  Node: Index,  Prev: Basic Examples,  Up: Top

Index
*****

 [index ]
* Menu:

* declare function:                      High-Level Interface. (line 76)
* lisp function:                         High-Level Interface. (line 67)
* precision function:                    High-Level Interface. (line 95)
* reduce finish function:                High-Level Interface. (line 30)
* reduce load function:                  High-Level Interface. (line 48)
* reduce module:                         Top.                  (line  6)
* reduce start function:                 High-Level Interface. (line 17)
* reduce switch function:                High-Level Interface. (line 52)
* reduce verbosity function:             High-Level Interface. (line 37)
* REDUCE_PATH variable:                  High-Level Interface. (line 11)
* simplify function:                     High-Level Interface. (line 60)



Tag Table:
Node: Top294
Ref: 01027
Ref: reduce1027
Ref: 11027
Ref: proc-interface1027
Ref: 21027
Ref: embedding-reduce1027
Node: Installation1563
Ref: installation1660
Ref: 41660
Ref: module-reduce1660
Ref: 51660
Ref: a-reduce-interface-for-the-pure-programming-language1660
Ref: 61660
Node: Low-Level Interface3118
Ref: low-level interface3232
Ref: 73232
Ref: low-level-interface3232
Node: High-Level Interface3741
Ref: high-level interface3857
Ref: 33857
Ref: high-level-interface3857
Ref: 84133
Ref: reduce_path4133
Ref: 94382
Ref: reduce start4382
Ref: a5184
Ref: reduce finish5184
Ref: b5499
Ref: reduce verbosity5499
Ref: c5899
Ref: reduce load5899
Ref: d6073
Ref: reduce switch6073
Ref: e6358
Ref: simplify6358
Ref: f6673
Ref: lisp6673
Ref: 107173
Ref: declare7173
Ref: 118064
Ref: precision8064
Node: Basic Examples9549
Ref: basic examples9651
Ref: 129651
Ref: basic-examples9651
Node: Index11760
Ref: index11833

End Tag Table


Local Variables:
coding: utf-8
End:
