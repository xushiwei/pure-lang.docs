This is pure-glpk.info, produced by makeinfo version 4.13 from
pure-glpk.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-glpk: (pure-glpk.info).    Pure-GLPK - GLPK interface for the Pure programming language
END-INFO-DIR-ENTRY


File: pure-glpk.info,  Node: Top,  Next: Installation,  Up: (dir)

pure-glpk
*********

  Version 0.2, October 12, 2011

  Jiri Spitz <<jiri.spitz@bluetone.cz>>

  This module provides a feature complete GLPK interface for the Pure
programming language, which lets you use all capabilities of the GNU
Linear Programming Kit (GLPK) directly from Pure.

  GLPK (see <http://www.gnu.org/software/glpk>) contains an efficient
simplex LP solver, a simplex LP solver in exact arithmetics, an
interior-point solver, a branch-and-cut solver for mixed integer
programming and some specialized algorithms for net/grid problems.
Using this interface you can build, modify and solve the problem,
retrieve the solution, load and save the problem and solution data in
standard formats and use any of advanced GLPK features.

  The interface uses native Pure data types - lists and tuples - so
that you need not perform any data conversions to/from GLPK internal
data structures.

  To make this module work, you must have a GLPK installation on your
system, the version 4.42 or higher is required.

* Menu:

* Installation::
* Error Handling::
* Further Information and Examples::
* Interface description::
* Descriptions of interface functions::
* Index::

 --- The Detailed Node Listing ---

Descriptions of interface functions

* Basic API routines::
* Utility API routines::
* Advanced API routines::
* Branch-and-cut API routines::
* Graph and network API routines::
* Miscellaneous routines::


File: pure-glpk.info,  Node: Installation,  Next: Error Handling,  Prev: Top,  Up: Top

1 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-glpk-0.2.tar.gz>.

  Run `make' to compile the module and `make install' (as root) to
install it in the Pure library directory. This requires GNU make, and
of course you need to have Pure installed.

  The default make options suppose that GLPK was configured with the
following options: `--enable-dl --enable-odbc --enable-mysql --with-gmp
--with-zlib'

  Using the given options the depndencies are:

   - GNU Multiprecision Library (GMP) - serves for the exact simplex
     solver.  When disabled, the exact solver still works but it is
     much slower.

   - ODBC library - serves for reading data directly from database
     tables within the GNU MathProg language translator through the
     ODBC interface.

   - zlib compression library - enables reading and writing gzip
     compressed problem and solution files.

   - MySQL client library - serves for reading data directly from MySQL
     tables within the GNU MathProg language translator.

   - ltdl dlopen library - must be enabled together with any of ODBC,
     zlib or MySQL.

  `make' tries to guess your Pure installation directory and
platform-specific setup. If it gets this wrong, you can set some
variables manually. In particular, `make install prefix=/usr' sets the
installation prefix, and `make PIC=-fPIC' or some similar flag might be
needed for compilation on 64 bit systems. The variable `ODBCLIB'
specifies the ODBC library to be linked with. The default value is
`ODBCLIB=-lodbc'. Please see the Makefile for details.


File: pure-glpk.info,  Node: Error Handling,  Next: Further Information and Examples,  Prev: Installation,  Up: Top

2 Error Handling
****************

When an error condition occurs, the GLPK library itself prints an error
mesage and terminates the application. This behaviour is not pleasant
when working within an interpreter. Therefore, the Pure - GLPK bindings
catches at least the most common errors like indices out of bounds. On
such an error an appropriate message is returned to the interpreter.
The less common errors are still trapped by the GLPK library.

  When one of the most common errors occurs, an error term of the form
`glp::error message' will be returned, which specifies what kind of
error happend. For instance, an index out of boundsd will cause a
report like the following:

  `glp::error "[Pure GLPK error] row index out of bounds"'

  You can check for such return values and take some appropriate
action. By redefining `glp::error' accordingly, you can also have it
generate exceptions or print an error message. For instance:

  `glp::error message = fprintf stderr "%s\n" message $$ ();'

  *NOTE_* When redefining `glp::error' in this manner, you should be
aware that the return value of `glp::error' is what will be returned by
the other operations of this module in case of an error condition.
These return values are checked by other functions. Thus the return
value should still indicate that an error has happened, and not be
something that might be interpreted as a legal return value, such as an
integer or a nonempty tuple. It is usually safe to have `glp::error'
return an empty tuple or throw an exception, but other types of return
values should be avoided.

  *IMPORTANT:* It is really good to define a `glp::error' function,
otherwise the errors might remain unnoticed.


File: pure-glpk.info,  Node: Further Information and Examples,  Next: Interface description,  Prev: Error Handling,  Up: Top

3 Further Information and Examples
**********************************

For further details about the operations provided by this module please
see the GLPK Reference Manual. Sample scripts illustrating the usage of
the module can be found in the examples directory.


File: pure-glpk.info,  Node: Interface description,  Next: Descriptions of interface functions,  Prev: Further Information and Examples,  Up: Top

4 Interface description
***********************

Most GLPK functions and symbols live in the namespace `glp'. There are
a few functions and symbols in the namespace `lpx'. These functions and
symbols are likely to be removed and replaced by new ones in the future.

  In general, when you replace the `glp_' prefix from the GLPK
Reference Manual with the namespace specification `glp::' then you
receive the function name in this module. The same is valid for `lpx_'
and `lpx::'. The symbolic constants are converted into lower case in
this module, again obeying the same prefix rules.


File: pure-glpk.info,  Node: Descriptions of interface functions,  Next: Index,  Prev: Interface description,  Up: Top

5 Descriptions of interface functions
*************************************

* Menu:

* Basic API routines::
* Utility API routines::
* Advanced API routines::
* Branch-and-cut API routines::
* Graph and network API routines::
* Miscellaneous routines::


File: pure-glpk.info,  Node: Basic API routines,  Next: Utility API routines,  Up: Descriptions of interface functions

5.1 Basic API routines
======================

* Menu:

* Problem creating and modifying routines::
* Problem retrieving routines::
* Row and column searching routines::
* Problem scaling routines::
* LP basis constructing routines::
* Simplex method routines::
* Interior-point method routines::
* Mixed integer programming routines::
* Additional routines::


File: pure-glpk.info,  Node: Problem creating and modifying routines,  Next: Problem retrieving routines,  Up: Basic API routines

5.1.1 Problem creating and modifying routines
---------------------------------------------

* Menu:

* Create the GLPK problem object::
* Set the problem name::
* Set objective name::
* Set the objective direction::
* Add new rows to the problem::
* Add new columns to the problem::
* Set the row name::
* Set the column name::
* Set change row bounds::
* Set change column bounds::
* Set change objective coefficient or constant term::
* Load or replace matrix row::
* Load or replace matrix column::
* Load or replace the whole problem matrix::
* Check for duplicate elements in sparse matrix::
* Sort elements of the constraint matrix::
* Delete rows from the matrix::
* Delete columns from the matrix::
* Copy the whole content of the GLPK problem object to another one::
* Erase all data from the GLPK problem object::
* Delete the GLPK problem object::


File: pure-glpk.info,  Node: Create the GLPK problem object,  Next: Set the problem name,  Up: Problem creating and modifying routines

5.1.1.1 Create the GLPK problem object
......................................

*Synopsis*:

    glp::create_prob

*Parameters*:

     none

  *Returns*:

     pointer to the LP problem object

  *Example*:

    > let lp = glp::create_prob;
    > lp;
    #<pointer 0x9de7168>



File: pure-glpk.info,  Node: Set the problem name,  Next: Set objective name,  Prev: Create the GLPK problem object,  Up: Problem creating and modifying routines

5.1.1.2 Set the problem name
............................

*Synopsis*:

    glp::set_prob_name lp name

*Parameters*:

          lp: pointer to the LP problem object

          name: problem name

  *Returns*:

     `()'

  *Example*:

    > glp::set_prob_name lp "Testing problem";
    ()



File: pure-glpk.info,  Node: Set objective name,  Next: Set the objective direction,  Prev: Set the problem name,  Up: Problem creating and modifying routines

5.1.1.3 Set objective name
..........................

*Synopsis*:

    glp::set_obj_name lp name

*Parameters*:

          lp: pointer to the LP problem object

          name: objective name

  *Returns*:

     `()'

  *Example*:

    > glp::set_obj_name lp "Total costs";
    ()



File: pure-glpk.info,  Node: Set the objective direction,  Next: Add new rows to the problem,  Prev: Set objective name,  Up: Problem creating and modifying routines

5.1.1.4 Set the objective direction
...................................

*Synopsis*:

    glp::set_obj_dir lp direction

*Parameters*:

          lp: pointer to the LP problem object

          direction: one of the following:

               glp::min: minimize

               glp::max: maximize

  *Returns*:

     `()'

  *Example*:

    > glp::set_obj_dir lp glp::min;
    ()



File: pure-glpk.info,  Node: Add new rows to the problem,  Next: Add new columns to the problem,  Prev: Set the objective direction,  Up: Problem creating and modifying routines

5.1.1.5 Add new rows to the problem
...................................

*Synopsis*:

    glp::add_rows lp count

*Parameters*:

          lp: pointer to the LP problem object

          count: number of rows to add

  *Returns*:

     index of the first row added

  *Example*:

    > let first_added_row = glp_add_rows lp 3;
    > first_added_row;
    6



File: pure-glpk.info,  Node: Add new columns to the problem,  Next: Set the row name,  Prev: Add new rows to the problem,  Up: Problem creating and modifying routines

5.1.1.6 Add new columns to the problem
......................................

*Synopsis*:

    glp::add_cols lp count

*Parameters*:

          lp: pointer to the LP problem object

          count: number of columns to add

  *Returns*:

     index of the first column added

  *Example*:

    > let first_added_col = glp_add_cols lp 3;
    > first_added_col;
    5



File: pure-glpk.info,  Node: Set the row name,  Next: Set the column name,  Prev: Add new columns to the problem,  Up: Problem creating and modifying routines

5.1.1.7 Set the row name
........................

*Synopsis*:

    glp::set_row_name lp (rowindex, rowname)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          rowname: row name

  *Returns*:

     `()'

  *Example*:

    > glp::set_row_name lp (3, "The third row");
    ()



File: pure-glpk.info,  Node: Set the column name,  Next: Set change row bounds,  Prev: Set the row name,  Up: Problem creating and modifying routines

5.1.1.8 Set the column name
...........................

*Synopsis*:

    glp::set_col_name lp (colindex, colname)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          colname: column name

  *Returns*:

     `()'

  *Example*:

    > glp::set_col_name lp (3, "The third column");
    ()



File: pure-glpk.info,  Node: Set change row bounds,  Next: Set change column bounds,  Prev: Set the column name,  Up: Problem creating and modifying routines

5.1.1.9 Set (change) row bounds
...............................

*Synopsis*:

    glp::set_row_bnds lp (rowindex, rowtype, lowerbound, upperbound)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          rowtype: one of the following:

               glp::fr: free variable (both bounds are ignored)

               glp::lo: variable with lower bound (upper bound is
               ignored)

               glp::up: variable with upper bound (lower bound is
               ignored)

               glp::db: double bounded variable

               glp::fx: fixed variable (lower bound applies, upper
               bound is ignored)

          lowerbound: lower row bound

          upperbound: upper row bound

*Returns*:
     `()'

*Example*::
     `glp::set_row_bnds lp (3, glp::up, 0.0, 150.0);'


File: pure-glpk.info,  Node: Set change column bounds,  Next: Set change objective coefficient or constant term,  Prev: Set change row bounds,  Up: Problem creating and modifying routines

5.1.1.10 Set (change) column bounds
...................................

*Synopsis*:

    glp::set_col_bnds lp (colindex, coltype, lowerbound, upperbound)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          coltype: one of the following:

               glp::fr: free variable (both bounds are ignored)

               glp::lo: variable with lower bound (upper bound is
               ignored)

               glp::up: variable with upper bound (lower bound is
               ignored)

               glp::db: double bounded variable

               glp::fx: fixed variable (lower bound applies, upper
               bound is ignored)

          lowerbound: lower column bound

          upperbound: upper column bound

  *Returns*:

     `()'

  *Example*:

    > glp::set_col_bnds lp (3, glp::db, 100.0, 150.0);
    ()



File: pure-glpk.info,  Node: Set change objective coefficient or constant term,  Next: Load or replace matrix row,  Prev: Set change column bounds,  Up: Problem creating and modifying routines

5.1.1.11 Set (change) objective coefficient or constant term
............................................................

*Synopsis*:

    glp::set_obj_coef lp (colindex, coefficient)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index, zero index denotes the constant term
          (objective shift)

  *Returns*:

     `()'

  *Example*:

    > glp::set_obj_coef lp (3, 15.8);
    ()



File: pure-glpk.info,  Node: Load or replace matrix row,  Next: Load or replace matrix column,  Prev: Set change objective coefficient or constant term,  Up: Problem creating and modifying routines

5.1.1.12 Load or replace matrix row
...................................

*Synopsis*:

    glp::set_mat_row lp (rowindex, rowvector)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          rowvector: list of tuples (colindex, coefficient); only
          non-zero coefficients have to be specified, the order of
          column indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Example*:

    > glp::set_mat_row lp (3, [(1, 3.0), (4, 5.2)]);
    ()



File: pure-glpk.info,  Node: Load or replace matrix column,  Next: Load or replace the whole problem matrix,  Prev: Load or replace matrix row,  Up: Problem creating and modifying routines

5.1.1.13 Load or replace matrix column
......................................

*Synopsis*:

    glp::set_mat_col lp (colindex, colvector)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          colvector: list of tuples (rowindex, coefficient); only
          non-zero coefficients have to be specified, the order of row
          indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Example*:

    > glp::set_mat_col lp (2, [(4, 2.0), (2, 1.5)]);
    ()



File: pure-glpk.info,  Node: Load or replace the whole problem matrix,  Next: Check for duplicate elements in sparse matrix,  Prev: Load or replace matrix column,  Up: Problem creating and modifying routines

5.1.1.14 Load or replace the whole problem matrix
.................................................

*Synopsis*:

    glp::load_matrix lp matrix

*Parameters*:

          lp: pointer to the LP problem object

          matrix: list of tuples (rowindex, colindex, coefficient);
          only non-zero coefficients have to be specified, the order of
          indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Example*:

    > glp::load_matrix lp [(1, 3, 5.0), (2, 2, 3.5), (3, 1, -2.0), (3, 2, 1.0)];
    ()



File: pure-glpk.info,  Node: Check for duplicate elements in sparse matrix,  Next: Sort elements of the constraint matrix,  Prev: Load or replace the whole problem matrix,  Up: Problem creating and modifying routines

5.1.1.15 Check for duplicate elements in sparse matrix
......................................................

*Synopsis*:

    glp::check_dup numrows numcols indices

*Parameters*:

          numrows: number of rows

          numcols: number of columns

          indices: list of tuples (rowindex, colindex); indices of only
          non-zero coefficients have to be specified, the order of
          indices is not important

  *Returns*:

     returns one of the following:

               0: the matrix has no duplicate elements

               -k: rowindex or colindex of the k-th element in indices
               is out of range

               +k: the k-th element in indices is duplicate

  *Remark:*

     Notice, that `k' counts from 1, whereas list members are counted
     from 0.

  *Example*:

    > glp::check_dup 3 3  [(1, 3), (2, 2), (3, 1), (2, 2)];
    4



File: pure-glpk.info,  Node: Sort elements of the constraint matrix,  Next: Delete rows from the matrix,  Prev: Check for duplicate elements in sparse matrix,  Up: Problem creating and modifying routines

5.1.1.16 Sort elements of the constraint matrix
...............................................

*Synopsis*:

    glp::sort_matrix lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::sort_matrix lp;
    ()



File: pure-glpk.info,  Node: Delete rows from the matrix,  Next: Delete columns from the matrix,  Prev: Sort elements of the constraint matrix,  Up: Problem creating and modifying routines

5.1.1.17 Delete rows from the matrix
....................................

*Synopsis*:

    glp::del_rows lp rows

*Parameters*:

          lp: pointer to the LP problem object

          rows: list of indices of rows to be deleted; the order of
          indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Remark:*

     Deleting rows involves changing ordinal numbers of other rows
     remaining in the problem object. New ordinal numbers of the
     remaining rows are assigned under the assumption that the original
     order of rows is not changed.

  *Example*:

    > glp::del_rows lp [3, 4, 7];
    ()



File: pure-glpk.info,  Node: Delete columns from the matrix,  Next: Copy the whole content of the GLPK problem object to another one,  Prev: Delete rows from the matrix,  Up: Problem creating and modifying routines

5.1.1.18 Delete columns from the matrix
.......................................

*Synopsis*:

    glp::del_cols lp cols

*Parameters*:

          lp: pointer to the LP problem object

          cols: list of indices of columns to be deleted; the order of
          indices is not important, duplicates are *not* allowed

  *Returns*:

     `()'

  *Remark:*

     Deleting columns involves changing ordinal numbers of other columns
     remaining in the problem object. New ordinal numbers of the
     remaining columns are assigned under the assumption that the
     original order of columns is not changed.

  *Example*:

    > glp::del_cols lp [6, 4, 5];
    ()



File: pure-glpk.info,  Node: Copy the whole content of the GLPK problem object to another one,  Next: Erase all data from the GLPK problem object,  Prev: Delete columns from the matrix,  Up: Problem creating and modifying routines

5.1.1.19 Copy the whole content of the GLPK problem object to another one
.........................................................................

*Synopsis*:

    glp::copy_prob destination source names

*Parameters*:

          destination: pointer to the destination LP problem object
          (must already exist)

          source: pointer to the source LP problem object

          names: one of the following:

               glp::on: copy all symbolic names as well

               glp::off: do not copy the symbolic names

  *Returns*:

     `()'

  *Example*:

    > glp::copy_prob lp_dest lp_src glp::on;
    ()



File: pure-glpk.info,  Node: Erase all data from the GLPK problem object,  Next: Delete the GLPK problem object,  Prev: Copy the whole content of the GLPK problem object to another one,  Up: Problem creating and modifying routines

5.1.1.20 Erase all data from the GLPK problem object
....................................................

*Synopsis*:

    glp::erase_prob lp

*Parameters*:

          lp: pointer to the LP problem object, it remains still valid
          after the function call

  *Returns*:

     `()'

  *Example*:

    > glp::erase_prob lp;
    ()



File: pure-glpk.info,  Node: Delete the GLPK problem object,  Prev: Erase all data from the GLPK problem object,  Up: Problem creating and modifying routines

5.1.1.21 Delete the GLPK problem object
.......................................

*Synopsis*:

    glp::delete_prob lp

*Parameters*:

          lp: pointer to the LP problem object, it is not valid any
          more after the function call

  *Returns*:

     `()'

  *Example*:

    > glp::delete_prob lp;
    ()



File: pure-glpk.info,  Node: Problem retrieving routines,  Next: Row and column searching routines,  Prev: Problem creating and modifying routines,  Up: Basic API routines

5.1.2 Problem retrieving routines
---------------------------------

* Menu:

* Get the problem name::
* Get the objective name::
* Get the objective direction::
* Get number of rows::
* Get number of columns::
* Get name of a row::
* Get name of a column::
* Get row type::
* Get row lower bound::
* Get row upper bound::
* Get column type::
* Get column lower bound::
* Get column upper bound::
* Get objective coefficient::
* Get number of nonzero coefficients::
* Retrive a row from the problem matrix::
* Retrive a column from the problem matrix::


File: pure-glpk.info,  Node: Get the problem name,  Next: Get the objective name,  Up: Problem retrieving routines

5.1.2.1 Get the problem name
............................

*Synopsis*:

    glp::get_prob_name lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     name of the problem

  *Example*:

    > glp::get_prob_name lp;
    "Testing problem"



File: pure-glpk.info,  Node: Get the objective name,  Next: Get the objective direction,  Prev: Get the problem name,  Up: Problem retrieving routines

5.1.2.2 Get the objective name
..............................

*Synopsis*:

    glp::get_obj_name lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     name of the objective

  *Example*:

    > glp::get_obj_name lp;
    "Total costs"



File: pure-glpk.info,  Node: Get the objective direction,  Next: Get number of rows,  Prev: Get the objective name,  Up: Problem retrieving routines

5.1.2.3 Get the objective direction
...................................

*Synopsis*:

    glp::get_obj_dir lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     returns one of the following:

               glp::min: minimize

               glp::max: maximize

  *Example*:

    > glp::get_obj_dir lp;
    glp::min



File: pure-glpk.info,  Node: Get number of rows,  Next: Get number of columns,  Prev: Get the objective direction,  Up: Problem retrieving routines

5.1.2.4 Get number of rows
..........................

*Synopsis*:

    glp::get_num_rows lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of rows (constraints)

  *Example*:

    > glp::get_num_rows lp;
    58



File: pure-glpk.info,  Node: Get number of columns,  Next: Get name of a row,  Prev: Get number of rows,  Up: Problem retrieving routines

5.1.2.5 Get number of columns
.............................

*Synopsis*:

    glp::get_num_cols lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of columns (structural variables)

  *Example*:

    > glp::get_num_cols lp;
    65



File: pure-glpk.info,  Node: Get name of a row,  Next: Get name of a column,  Prev: Get number of columns,  Up: Problem retrieving routines

5.1.2.6 Get name of a row
.........................

*Synopsis*:

    glp::get_row_name lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     name of the given row

  *Example*:

    > glp::get_row_name lp 3;
    "The third row"



File: pure-glpk.info,  Node: Get name of a column,  Next: Get row type,  Prev: Get name of a row,  Up: Problem retrieving routines

5.1.2.7 Get name of a column
............................

*Synopsis*:

    glp::get_col_name lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     name of the given column

  *Example*:

    > glp::get_col_name lp 2;
    "The second column"



File: pure-glpk.info,  Node: Get row type,  Next: Get row lower bound,  Prev: Get name of a column,  Up: Problem retrieving routines

5.1.2.8 Get row type
....................

*Synopsis*:

    glp::get_row_type lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     returns one of the following:

               glp::fr: free variable

               glp::lo: variable with lower bound

               glp::up: variable with upper bound

               glp::db: double bounded variable

               glp::fx: fixed variable

  *Example*:

    > glp::get_row_type lp 3;
    glp::db



File: pure-glpk.info,  Node: Get row lower bound,  Next: Get row upper bound,  Prev: Get row type,  Up: Problem retrieving routines

5.1.2.9 Get row lower bound
...........................

*Synopsis*:

    glp::get_row_lb lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     the row lower bound; if the row has no lower bound then it returns
     the smallest double number

  *Example*:

    > glp::get_row_lb lp 3;
    50.0



File: pure-glpk.info,  Node: Get row upper bound,  Next: Get column type,  Prev: Get row lower bound,  Up: Problem retrieving routines

5.1.2.10 Get row upper bound
............................

*Synopsis*:

    glp::get_row_ub lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     the row upper bound; if the row has no upper bound then it returns
     the biggest double number

  *Example*:

    > glp::get_row_ub lp 3;
    150.0



File: pure-glpk.info,  Node: Get column type,  Next: Get column lower bound,  Prev: Get row upper bound,  Up: Problem retrieving routines

5.1.2.11 Get column type
........................

*Synopsis*:

    glp::get_col_type lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     returns one of the following:

               glp::fr: free variable

               glp::lo: variable with lower bound

               glp::up: variable with upper bound

               glp::db: double bounded variable

               glp::fx: fixed variable

  *Example*:

    > glp::get_col_type lp 2;
    glp::up



File: pure-glpk.info,  Node: Get column lower bound,  Next: Get column upper bound,  Prev: Get column type,  Up: Problem retrieving routines

5.1.2.12 Get column lower bound
...............................

*Synopsis*:

    glp::get_col_lb lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     the column lower bound; if the column has no lower bound then it
     returns the smallest double number

  *Example*:

    > glp::get_col_lb lp 3;
    -1.79769313486232e+308



File: pure-glpk.info,  Node: Get column upper bound,  Next: Get objective coefficient,  Prev: Get column lower bound,  Up: Problem retrieving routines

5.1.2.13 Get column upper bound
...............................

*Synopsis*:

    glp::get_col_ub lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     the column upper bound; if the column has no upper bound then it
     returns the biggest double number

  *Example*:

    > glp::get_col_lb lp 3;
    150.0



File: pure-glpk.info,  Node: Get objective coefficient,  Next: Get number of nonzero coefficients,  Prev: Get column upper bound,  Up: Problem retrieving routines

5.1.2.14 Get objective coefficient
..................................

*Synopsis*:

    glp::get_obj_coef lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index; zero index denotes the constant term
          (objective shift)

  *Returns*:

     the coefficient of given column in the objective

  *Example*:

    > glp::get_obj_coef lp 3;
    5.8



File: pure-glpk.info,  Node: Get number of nonzero coefficients,  Next: Retrive a row from the problem matrix,  Prev: Get objective coefficient,  Up: Problem retrieving routines

5.1.2.15 Get number of nonzero coefficients
...........................................

*Synopsis*:

    glp::get_num_nz lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of non-zero coefficients in the problem matrix

  *Example*:

    > glp::get_num_nz lp;
    158



File: pure-glpk.info,  Node: Retrive a row from the problem matrix,  Next: Retrive a column from the problem matrix,  Prev: Get number of nonzero coefficients,  Up: Problem retrieving routines

5.1.2.16 Retrive a row from the problem matrix
..............................................

*Synopsis*:

    glp::get_mat_row lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     non-zero coefficients of the given row in a list form of tuples
     (colindex, coefficient)

  *Example*:

    > get_mat_row lp 3;
    [(3,6.0),(2,2.0),(1,2.0)]



File: pure-glpk.info,  Node: Retrive a column from the problem matrix,  Prev: Retrive a row from the problem matrix,  Up: Problem retrieving routines

5.1.2.17 Retrive a column from the problem matrix
.................................................

*Synopsis*:

    glp::get_mat_col lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     non-zero coefficients of the given column in a list form of tuples
     (rowindex, coefficient)

  *Example*:

    > get_mat_col lp 2;
    [(3,2.0),(2,4.0),(1,1.0)]



File: pure-glpk.info,  Node: Row and column searching routines,  Next: Problem scaling routines,  Prev: Problem retrieving routines,  Up: Basic API routines

5.1.3 Row and column searching routines
---------------------------------------

* Menu:

* Create index for searching rows and columns by their names::
* Find a row number by name::
* Find a column number by name::
* Delete index for searching rows and columns by their names::


File: pure-glpk.info,  Node: Create index for searching rows and columns by their names,  Next: Find a row number by name,  Up: Row and column searching routines

5.1.3.1 Create index for searching rows and columns by their names
..................................................................

*Synopsis*:

    glp::create_index lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::create_index lp;
    ()



File: pure-glpk.info,  Node: Find a row number by name,  Next: Find a column number by name,  Prev: Create index for searching rows and columns by their names,  Up: Row and column searching routines

5.1.3.2 Find a row number by name
.................................

*Synopsis*:

    glp::find_row lp rowname

*Parameters*:

          lp: pointer to the LP problem object

          rowname: row name

  *Returns*:

     ordinal number (index) of the row

  *Remark*:

     The search index is automatically created if it does not already
     exists.

  *Example*:

    > glp::find_row lp "The third row";
    3



File: pure-glpk.info,  Node: Find a column number by name,  Next: Delete index for searching rows and columns by their names,  Prev: Find a row number by name,  Up: Row and column searching routines

5.1.3.3 Find a column number by name
....................................

*Synopsis*:

    glp::find_col lp colname

*Parameters*:

          lp: pointer to the LP problem object

          colname: column name

  *Returns*:

     ordinal number (index) of the column

  *Remark*:

     The search index is automatically created if it does not already
     exists.

  *Example*:

    > glp::find_col lp "The second row";
    2



File: pure-glpk.info,  Node: Delete index for searching rows and columns by their names,  Prev: Find a column number by name,  Up: Row and column searching routines

5.1.3.4 Delete index for searching rows and columns by their names
..................................................................

*Synopsis*:

    glp::delete_index lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::delete:index lp;
    ()



File: pure-glpk.info,  Node: Problem scaling routines,  Next: LP basis constructing routines,  Prev: Row and column searching routines,  Up: Basic API routines

5.1.4 Problem scaling routines
------------------------------

* Menu:

* Set the row scale factor::
* Set the column scale factor::
* Retrieve the row scale factor::
* Retrieve the column scale factor::
* Scale the problem data according to supplied flags::
* Unscale the problem data::


File: pure-glpk.info,  Node: Set the row scale factor,  Next: Set the column scale factor,  Up: Problem scaling routines

5.1.4.1 Set the row scale factor
................................

*Synopsis*:

    glp::set_rii lp (rowindex, coefficient)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          coefficient: scaling coefficient

  *Returns*:

     `()'

  *Example*:

    > glp::set_rii lp (3, 258.6);
    ()



File: pure-glpk.info,  Node: Set the column scale factor,  Next: Retrieve the row scale factor,  Prev: Set the row scale factor,  Up: Problem scaling routines

5.1.4.2 Set the column scale factor
...................................

*Synopsis*:

    glp::set_sjj lp (colindex, coefficient)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          coefficient: scaling coefficient

  *Returns*:

     `()'

  *Example*:

    > glp::set_sjj lp (2, 12.8);
    ()



File: pure-glpk.info,  Node: Retrieve the row scale factor,  Next: Retrieve the column scale factor,  Prev: Set the column scale factor,  Up: Problem scaling routines

5.1.4.3 Retrieve the row scale factor
.....................................

*Synopsis*:

    glp::get_rii lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     scaling coefficient of given row

  *Example*:

    > glp::get_rii lp 3;
    258.6



File: pure-glpk.info,  Node: Retrieve the column scale factor,  Next: Scale the problem data according to supplied flags,  Prev: Retrieve the row scale factor,  Up: Problem scaling routines

5.1.4.4 Retrieve the column scale factor
........................................

*Synopsis*:

    glp::get_sjj lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     scaling coefficient of given column

  *Example*:

    > glp::get_sjj lp 2;
    12.8



File: pure-glpk.info,  Node: Scale the problem data according to supplied flags,  Next: Unscale the problem data,  Prev: Retrieve the column scale factor,  Up: Problem scaling routines

5.1.4.5 Scale the problem data according to supplied flags
..........................................................

*Synopsis*:

    glp::scale_prob lp flags

*Parameters*:

          lp: pointer to the LP problem object

          flags: symbolic integer constants which can be combined
          together by arithmetic *or*; the possible constants are:

               glp::sf_gm: perform geometric mean scaling

               glp::sf_eq: perform equilibration scaling

               glp::sf_2n: round scale factors to power of two

               glp::sf_skip: skip if problem is well scaled

               glp::sf_auto: choose scaling options automatically

  *Returns*:

     `()'

  *Example*:

    > glp::scale_prob lp (glp::sf_gm || glp::sf_2n);
    ()



File: pure-glpk.info,  Node: Unscale the problem data,  Prev: Scale the problem data according to supplied flags,  Up: Problem scaling routines

5.1.4.6 Unscale the problem data
................................

*Synopsis*:

    glp::unscale_prob lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::unscale_prob lp;
    ()



File: pure-glpk.info,  Node: LP basis constructing routines,  Next: Simplex method routines,  Prev: Problem scaling routines,  Up: Basic API routines

5.1.5 LP basis constructing routines
------------------------------------

* Menu:

* Set the row status::
* Set the column status::
* Construct standard problem basis::
* Construct advanced problem basis::
* Construct Bixby's problem basis::


File: pure-glpk.info,  Node: Set the row status,  Next: Set the column status,  Up: LP basis constructing routines

5.1.5.1 Set the row status
..........................

*Synopsis*:

    glp::set_row_stat lp (rowindex, status)

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          status: one of the following:

               glp::bs: make the row basic (make the constraint
               inactive)

               glp::nl: make the row non-basic (make the constraint
               active)

               glp::nu: make the row non-basic and set it to the upper
               bound; if the row is not double-bounded, this status is
               equivalent to glp::nl (only in the case of this routine)

               glp::nf: the same as glp::nl (only in the case of this
               routine)

               glp::ns: the same as glp::nl (only in the case of this
               routine)

  *Returns*:

     `()'

  *Example*:

    > glp::set_row_stat lp (3, glp::nu);
    ()



File: pure-glpk.info,  Node: Set the column status,  Next: Construct standard problem basis,  Prev: Set the row status,  Up: LP basis constructing routines

5.1.5.2 Set the column status
.............................

*Synopsis*:

    glp::set_col_stat lp (colindex, status)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          status: one of the following:

               glp::bs: make the column basic

               glp::nl: make the column non-basic

               glp::nu: make the column non-basic and set it to the
               upper bound; if the column is not double-bounded, this
               status is equivalent to glp::nl (only in the case of
               this routine)

               glp::nf: the same as glp::nl (only in the case of this
               routine)

               glp::ns: the same as glp::nl (only in the case of this
               routine)

  *Returns*:

     `()'

  *Example*:

    > glp::set_col_stat lp (2, glp::bs);
    ()



File: pure-glpk.info,  Node: Construct standard problem basis,  Next: Construct advanced problem basis,  Prev: Set the column status,  Up: LP basis constructing routines

5.1.5.3 Construct standard problem basis
........................................

*Synopsis*:

    glp::std_basis lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::std_basis lp;
    ()



File: pure-glpk.info,  Node: Construct advanced problem basis,  Next: Construct Bixby's problem basis,  Prev: Construct standard problem basis,  Up: LP basis constructing routines

5.1.5.4 Construct advanced problem basis
........................................

*Synopsis*:

    glp::adv_basis lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::adv_basis lp;
    ()



File: pure-glpk.info,  Node: Construct Bixby's problem basis,  Prev: Construct advanced problem basis,  Up: LP basis constructing routines

5.1.5.5 Construct Bixby's problem basis
.......................................

*Synopsis*:

    glp::cpx_basis lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::cpx_basis lp;
    ()



File: pure-glpk.info,  Node: Simplex method routines,  Next: Interior-point method routines,  Prev: LP basis constructing routines,  Up: Basic API routines

5.1.6 Simplex method routines
-----------------------------

* Menu:

* Solve the LP problem using simplex method::
* Solve the LP problem using simplex method in exact arithmetics::
* Retrieve generic status of basic solution::
* Retrieve generic status of primal solution::
* Retrieve generic status of dual solution::
* Retrieve value of the objective function::
* Retrieve generic status of a row variable::
* Retrieve row primal value::
* Retrieve row dual value::
* Retrieve generic status of a column variable::
* Retrieve column primal value::
* Retrieve column dual value::
* Determine variable causing unboundedness::


File: pure-glpk.info,  Node: Solve the LP problem using simplex method,  Next: Solve the LP problem using simplex method in exact arithmetics,  Up: Simplex method routines

5.1.6.1 Solve the LP problem using simplex method
.................................................

*Synopsis*:

    glp::simplex lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::msg_lev:

              (default: glp::msg_all) - message level for
                    terminal output:

                   *glp::msg_off:* no output 
                   *glp::msg_err:* error and warning messages only 
                   *glp::msg_on:*  normal output; 
                   *glp::msg_all:* full output (including informational messages) 

               glp::meth: (default: glp::primal) - simplex method option

                   *glp::primal:* use two-phase primal simplex 
                   *glp::dual:* use two-phase dual simplex; 
                   *glp::dualp:* use two-phase dual simplex, and if it fails, switch to the primal simplex 

               glp::pricing: (default: glp::pt_pse) - pricing technique

                   *glp::pt_std:* standard (textbook) 
                   *glp::pt_pse:* projected steepest edge 

               glp::r_test: (default: glp::rt_har) - ratio test
               technique

                   *glp::rt_std:* standard (textbook) 
                   *glp::rt_har:* Harris' two-pass ratio test 

               glp::tol_bnd: (default: 1e-7) - tolerance used to check
               if the basic solution is primal feasible

               glp::tol_dj: (default: 1e-7) - tolerance used to check
               if the basic solution is dual feasible

               glp::tol_piv: (default: 1e-10) - tolerance used to choose
               eligble pivotal elements of the simplex table

               glp::obj_ll: (default: -DBL_MAX) - lower limit of the
               objective function - if the objective function reaches
               this limit and continues decreasing, the solver
               terminates the search - used in the dual simplex only

               glp::obj_ul: (default: +DBL_MAX) - upper limit of the
               objective function. If the objective function reaches
               this limit and continues increasing, the solver
               terminates the search - used in the dual simplex only

               glp::it_lim: (default: INT_MAX) - simplex iteration limit

               glp::tm lim: (default: INT_MAX) - searching time limit,
               in milliseconds

               glp::out_frq: (default: 200) - output frequency, in
               iterations - this parameter specifies how frequently the
               solver sends information about the solution process to
               the terminal

               glp::out_dly: (default: 0) - output delay, in
               milliseconds - this parameter specifies how long the
               solver should delay sending information about the
               solution process to the terminal

               glp::presolve: (default: glp::off) - LP presolver option:

                   *glp::on:* enable using the LP presolver 
                   *glp::off:* disable using the LP presolver 

  *Returns*:

     one of the following:

          glp::ok: the LP problem instance has been successfully
          solved; this code does not necessarily mean that the solver
          has found optimal solution, it only means that the solution
          process was successful

          glp::ebadb: unable to start the search, because the initial
          basis specified in the problem object is invalid - the number
          of basic (auxiliary and structural) variables is not the same
          as the number of rows in the problem object

          glp::esing: unable to start the search, because the basis
          matrix corresponding to the initial basis is singular within
          the working precision

          glp::econd: unable to start the search, because the basis
          matrix corresponding to the initial basis is ill-conditioned,
          i.e. its condition number is too large

          glp::ebound: unable to start the search, because some
          double-bounded (auxiliary or structural) variables have
          incorrect bounds

          glp::efail: the search was prematurely terminated due to the
          solver failure

          glp::eobjll: the search was prematurely terminated, because
          the objective function being maximized has reached its lower
          limit and continues decreasing (the dual simplex only)

          glp::eobjul: the search was prematurely terminated, because
          the objective function being minimized has reached its upper
          limit and continues increasing (the dual simplex only)

          glp::eitlim: the search was prematurely terminated, because
          the simplex iteration limit has been exceeded

          glp::etmlim: the search was prematurely terminated, because
          the time limit has been exceeded

          glp::enopfs: the LP problem instance has no primal feasible
          solution (only if the LP presolver is used)

          glp::enodfs: the LP problem instance has no dual feasible
          solution (only if the LP presolver is used)

     When the list of options contains some bad option(s) then a list
     of bad options is returned instead.

  *Remark*:

     Options not mentioned in the option list are set to their default
     values.

  *Example*:

    > glp::simplex lp [(glp::presolve, glp::on), (glp::msg_lev, glp::msg_all)];
    glp_simplex: original LP has 3 rows, 3 columns, 9 non-zeros
    glp_simplex: presolved LP has 3 rows, 3 columns, 9 non-zeros
    Scaling...
     A: min|aij| = 1,000e+000  max|aij| = 1,000e+001  ratio = 1,000e+001
    Problem data seem to be well scaled
    Crashing...
    Size of triangular part = 3
    *     0: obj =  0,000000000e+000  infeas = 0,000e+000 (0)
    *     2: obj =  7,333333333e+002  infeas = 0,000e+000 (0)
    OPTIMAL SOLUTION FOUND
    glp::ok



File: pure-glpk.info,  Node: Solve the LP problem using simplex method in exact arithmetics,  Next: Retrieve generic status of basic solution,  Prev: Solve the LP problem using simplex method,  Up: Simplex method routines

5.1.6.2 Solve the LP problem using simplex method in exact arithmetics
......................................................................

*Synopsis*:

    glp::exact lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::it_lim: (default: INT_MAX) - simplex iteration limit

               glp::tm lim: (default: INT_MAX) - searching time limit,
               in milliseconds

  *Returns*:

     one of the following:

          glp::ok: the LP problem instance has been successfully
          solved; this code does not necessarily mean that the solver
          has found optimal solution, it only means that the solution
          process was successful

          glp::ebadb: unable to start the search, because the initial
          basis specified in the problem object is invalid - the number
          of basic (auxiliary and structural) variables is not the same
          as the number of rows in the problem object

          glp::esing: unable to start the search, because the basis
          matrix corresponding to the initial basis is singular within
          the working precision

          glp::ebound: unable to start the search, because some
          double-bounded (auxiliary or structural) variables have
          incorrect bounds

          glp::efail: the search was prematurely terminated due to the
          solver failure

          glp::eitlim: the search was prematurely terminated, because
          the simplex iteration limit has been exceeded

          glp::etmlim: the search was prematurely terminated, because
          the time limit has been exceeded

     When the list of options contains some bad option(s) then a list
     of bad options is returned instead.

  *Remark*:

     Options not mentioned in the option list are set to their default
     values.

  *Example*:

    > glp::exact lp [];
    glp_exact: 3 rows, 3 columns, 9 non-zeros
    GNU MP bignum library is being used
    *     2:   objval =                      0   (0)
    *     4:   objval =       733,333333333333   (0)
    OPTIMAL SOLUTION FOUND
    glp::ok



File: pure-glpk.info,  Node: Retrieve generic status of basic solution,  Next: Retrieve generic status of primal solution,  Prev: Solve the LP problem using simplex method in exact arithmetics,  Up: Simplex method routines

5.1.6.3 Retrieve generic status of basic solution
.................................................

*Synopsis*:

    glp::get_status lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: solution is undefined

          glp::feas: solution is feasible

          glp::infeas: solution is infeasible

          glp::nofeas: no feasible solution exists

          glp::opt: solution is optimal

          glp::unbnd: solution is unbounded

  *Example*:

    > glp::get_status lp;
    glp::opt



File: pure-glpk.info,  Node: Retrieve generic status of primal solution,  Next: Retrieve generic status of dual solution,  Prev: Retrieve generic status of basic solution,  Up: Simplex method routines

5.1.6.4 Retrieve generic status of primal solution
..................................................

*Synopsis*:

    glp::get_prim_stat lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: primal solution is undefined

          glp::feas: primal solution is feasible

          glp::infeas: primal solution is infeasible

          glp::nofeas: no primal feasible solution exists

  *Example*:

    > glp::get_prim_stat lp;
    glp::feas



File: pure-glpk.info,  Node: Retrieve generic status of dual solution,  Next: Retrieve value of the objective function,  Prev: Retrieve generic status of primal solution,  Up: Simplex method routines

5.1.6.5 Retrieve generic status of dual solution
................................................

*Synopsis*:

    glp::get_dual_stat lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: dual solution is undefined

          glp::feas: dual solution is feasible

          glp::infeas: dual solution is infeasible

          glp::nofeas: no dual feasible solution exists

  *Example*:

    > glp::get_dual_stat lp;
    glp::feas



File: pure-glpk.info,  Node: Retrieve value of the objective function,  Next: Retrieve generic status of a row variable,  Prev: Retrieve generic status of dual solution,  Up: Simplex method routines

5.1.6.6 Retrieve value of the objective function
................................................

*Synopsis*:

    glp::get_obj_val lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     value of the objective function

  *Example*:

    > glp::get_obj_val lp
    733.333333333333



File: pure-glpk.info,  Node: Retrieve generic status of a row variable,  Next: Retrieve row primal value,  Prev: Retrieve value of the objective function,  Up: Simplex method routines

5.1.6.7 Retrieve generic status of a row variable
.................................................

*Synopsis*:

    glp::get_row_stat lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     one of the following:

          glp::bs: basic variable

          glp::nl: non-basic variable on its lower bound

          glp::nu: non-basic variable on its upper bound

          glp::nf: non-basic free (unbounded) variable

          glp::ns: non-basic fixed variable

  *Example*:

    > glp::get_row_stat lp 3;
    glp::bs



File: pure-glpk.info,  Node: Retrieve row primal value,  Next: Retrieve row dual value,  Prev: Retrieve generic status of a row variable,  Up: Simplex method routines

5.1.6.8 Retrieve row primal value
.................................

*Synopsis*::
     glp::get_row_prim lp rowindex

  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     primal value of the row (auxiliary) variable

  *Example*:

    > glp::get_row_prim lp 3;
    200.0



File: pure-glpk.info,  Node: Retrieve row dual value,  Next: Retrieve generic status of a column variable,  Prev: Retrieve row primal value,  Up: Simplex method routines

5.1.6.9 Retrieve row dual value
...............................

*Synopsis*:

    glp::get_row_dual lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     dual value of the row (auxiliary) variable

  *Example*:

    > glp::get_row_dual lp 3;
    0.0



File: pure-glpk.info,  Node: Retrieve generic status of a column variable,  Next: Retrieve column primal value,  Prev: Retrieve row dual value,  Up: Simplex method routines

5.1.6.10 Retrieve generic status of a column variable
.....................................................

*Synopsis*:

    glp::get_col_stat lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     one of the following:

          glp::bs: basic variable

          glp::nl: non-basic variable on its lower bound

          glp::nu: non-basic variable on its upper bound

          glp::nf: non-basic free (unbounded) variable

          glp::ns: non-basic fixed variable

  *Example*:

    > glp::get_col_stat lp 2;
    glp::bs



File: pure-glpk.info,  Node: Retrieve column primal value,  Next: Retrieve column dual value,  Prev: Retrieve generic status of a column variable,  Up: Simplex method routines

5.1.6.11 Retrieve column primal value
.....................................

*Synopsis*:

    glp::get_col_prim lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     primal value of the column (structural) variable

  *Example*:

    > glp::get_col_prim lp 2;
    66.6666666666667



File: pure-glpk.info,  Node: Retrieve column dual value,  Next: Determine variable causing unboundedness,  Prev: Retrieve column primal value,  Up: Simplex method routines

5.1.6.12 Retrieve column dual value
...................................

*Synopsis*:

    glp::get_col_dual lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     dual value of the column (structural) variable

  *Example*:

    > glp::get_col_dual lp 2;
    0.0



File: pure-glpk.info,  Node: Determine variable causing unboundedness,  Prev: Retrieve column dual value,  Up: Simplex method routines

5.1.6.13 Determine variable causing unboundedness
.................................................

*Synopsis*:

    glp::get_unbnd_ray lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     The routine glp_get_unbnd_ray returns the number k of a variable,
     which causes primal or dual unboundedness. If 1 <= k <= m, it is
     k-th auxiliary variable, and if m + 1 <= k <= m + n, it is (k -
     m)-th structural variable, where m is the number of rows, n is the
     number of columns in the problem object. If such variable is not
     defined, the routine returns 0.

  *Remark*:

     If it is not exactly known which version of the simplex solver
     detected unboundedness, i.e. whether the unboundedness is primal
     or dual, it is sufficient to check the status of the variable with
     the routine glp::get_row_stat or glp::get_col_stat. If the
     variable is non-basic, the unboundedness is primal, otherwise, if
     the variable is basic, the unboundedness is dual (the latter case
     means that the problem has no primal feasible dolution).

  *Example*:

    > glp::get_unbnd_ray lp;
    0



File: pure-glpk.info,  Node: Interior-point method routines,  Next: Mixed integer programming routines,  Prev: Simplex method routines,  Up: Basic API routines

5.1.7 Interior-point method routines
------------------------------------

* Menu:

* Solve the LP problem using interior-point method::
* Retrieve status of interior-point solution::
* Retrieve the objective function value of interior-point solution::
* Retrieve row primal value of interior-point solution::
* Retrieve row dual value of interior-point solution::
* Retrieve column primal value of interior-point solution::
* Retrieve column dual value of interior-point solution::


File: pure-glpk.info,  Node: Solve the LP problem using interior-point method,  Next: Retrieve status of interior-point solution,  Up: Interior-point method routines

5.1.7.1 Solve the LP problem using interior-point method
........................................................

*Synopsis*:

    glp::interior lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::msg_lev:

              (default: glp::msg_all) - message level for
                    terminal output:

                   *glp::msg_off:* no output 
                   *glp::msg_err:* error and warning messages only 
                   *glp::msg_on:* normal output; 
                   *glp::msg_all:* full output (including informational messages) 

               glp::ord_alg: (default: glp::ord_amd) - ordering
               algorithm option

                   *glp::ord_none:* use natural (original) ordering 
                   *glp::ord_qmd:* quotient minimum degree (QMD) 
                   *glp::ord_amd:* approximate minimum degree (AMD) 
                   *glp::ord_sysamd:* approximate minimum degree (SYSAMD) 

  *Returns*:

     one of the following:

          glp::ok: the LP problem instance has been successfully solved;
          this code does not necessarily mean that the solver has found
          optimal solution, it only means that the solution process was
          successful

          glp::efail: the problem has no rows/columns

          glp::enocvg: very slow convergence or divergence

          glp::eitlim: iteration limit exceeded

          glp::einstab: numerical instability on solving Newtonian
          system

  *Example*:

    > glp::interior lp [(glp::ord_alg, glp::ord_amd)];
    Original LP has 3 row(s), 3 column(s), and 9 non-zero(s)
    Working LP has 3 row(s), 6 column(s), and 12 non-zero(s)
    Matrix A has 12 non-zeros
    Matrix S = A*A' has 6 non-zeros (upper triangle)
    Approximate minimum degree ordering (AMD)...
    Computing Cholesky factorization S = L*L'...
    Matrix L has 6 non-zeros
    Guessing initial point...
    Optimization begins...
      0: obj = -8,218489503e+002; rpi = 3,6e-001; rdi = 6,8e-001; gap = 2,5e-001
      1: obj = -6,719060895e+002; rpi = 3,6e-002; rdi = 1,9e-001; gap = 1,4e-002
      2: obj = -6,917210389e+002; rpi = 3,6e-003; rdi = 9,3e-002; gap = 3,0e-002
      3: obj = -7,267557732e+002; rpi = 2,1e-003; rdi = 9,3e-003; gap = 4,4e-002
      4: obj = -7,323038146e+002; rpi = 2,1e-004; rdi = 1,1e-003; gap = 4,8e-003
      5: obj = -7,332295932e+002; rpi = 2,1e-005; rdi = 1,1e-004; gap = 4,8e-004
      6: obj = -7,333229585e+002; rpi = 2,1e-006; rdi = 1,1e-005; gap = 4,8e-005
      7: obj = -7,333322959e+002; rpi = 2,1e-007; rdi = 1,1e-006; gap = 4,8e-006
      8: obj = -7,333332296e+002; rpi = 2,1e-008; rdi = 1,1e-007; gap = 4,8e-007
      9: obj = -7,333333230e+002; rpi = 2,1e-009; rdi = 1,1e-008; gap = 4,8e-008
     10: obj = -7,333333323e+002; rpi = 2,1e-010; rdi = 1,1e-009; gap = 4,8e-009
    OPTIMAL SOLUTION FOUND
    glp::ok



File: pure-glpk.info,  Node: Retrieve status of interior-point solution,  Next: Retrieve the objective function value of interior-point solution,  Prev: Solve the LP problem using interior-point method,  Up: Interior-point method routines

5.1.7.2 Retrieve status of interior-point solution
..................................................

*Synopsis*:

    glp::ipt_status lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following

          glp::undef: interior-point solution is undefined

          glp::opt: interior-point solution is optimal

          glp::infeas: interior-point solution is infeasible

          glp::nofeas: no feasible primal-dual solution exists

  *Example*:

    > glp::ipt_status lp;
    glp::opt



File: pure-glpk.info,  Node: Retrieve the objective function value of interior-point solution,  Next: Retrieve row primal value of interior-point solution,  Prev: Retrieve status of interior-point solution,  Up: Interior-point method routines

5.1.7.3 Retrieve the objective function value of interior-point solution
........................................................................

*Synopsis*:

    glp::ipt_obj_val lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     objective function value of interior-point solution

  *Example*:

    > glp::ipt_obj_val lp;
    733.333332295849



File: pure-glpk.info,  Node: Retrieve row primal value of interior-point solution,  Next: Retrieve row dual value of interior-point solution,  Prev: Retrieve the objective function value of interior-point solution,  Up: Interior-point method routines

5.1.7.4 Retrieve row primal value of interior-point solution
............................................................

*Synopsis*:

    glp::ipt_row_prim lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     primal value of the row (auxiliary) variable

  *Example*:

    > glp::ipt_row_prim lp 3;
    200.000000920688



File: pure-glpk.info,  Node: Retrieve row dual value of interior-point solution,  Next: Retrieve column primal value of interior-point solution,  Prev: Retrieve row primal value of interior-point solution,  Up: Interior-point method routines

5.1.7.5 Retrieve row dual value of interior-point solution
..........................................................

*Synopsis*:

    glp::ipt_row_dual lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     dual value of the row (auxiliary) variable

  *Example*:

    > glp::ipt_row_dual lp 3;
    2.50607466186742e-008



File: pure-glpk.info,  Node: Retrieve column primal value of interior-point solution,  Next: Retrieve column dual value of interior-point solution,  Prev: Retrieve row dual value of interior-point solution,  Up: Interior-point method routines

5.1.7.6 Retrieve column primal value of interior-point solution
...............................................................

*Synopsis*:

    glp::ipt_col_prim lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     primal value of the column (structural) variable

  *Example*:

    > glp::ipt_col_prim lp 2;
    66.666666406779



File: pure-glpk.info,  Node: Retrieve column dual value of interior-point solution,  Prev: Retrieve column primal value of interior-point solution,  Up: Interior-point method routines

5.1.7.7 Retrieve column dual value of interior-point solution
.............................................................

*Synopsis*:

    glp::ipt_col_dual lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     dual value of the column (structural) variable

  *Example*:

    > glp::ipt_col_dual lp 2;
    2.00019467655466e-009



File: pure-glpk.info,  Node: Mixed integer programming routines,  Next: Additional routines,  Prev: Interior-point method routines,  Up: Basic API routines

5.1.8 Mixed integer programming routines
----------------------------------------

* Menu:

* Set column kind::
* Retrieve column kind::
* Retrieve number of integer columns::
* Retrieve number of binary columns::
* Solve the MIP problem using branch-and-cut method::
* Retrieve status of mip solution::
* Retrieve the objective function value of mip solution::
* Retrieve row value of mip solution::
* Retrieve column value of mip solution::


File: pure-glpk.info,  Node: Set column kind,  Next: Retrieve column kind,  Up: Mixed integer programming routines

5.1.8.1 Set column kind
.......................

*Synopsis*:

    glp::set_col_kind lp (colindex, colkind)

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          colkind: column kind - one of the following:

               glp::cv: continuous variable

               glp::iv: integer variable

               glp::bv: binary variable

  *Returns*:

     `()'

  *Example*:

    > glp::set_col_kind lp (1, glp::iv);
    ()



File: pure-glpk.info,  Node: Retrieve column kind,  Next: Retrieve number of integer columns,  Prev: Set column kind,  Up: Mixed integer programming routines

5.1.8.2 Retrieve column kind
............................

*Synopsis*:

    glp::get_col_kind lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     one of the following:

          glp::cv: continuous variable

          glp::iv: integer variable

          glp::bv: binary variable

  *Example*:

    > glp::get_col_kind lp 1;
    glp::iv



File: pure-glpk.info,  Node: Retrieve number of integer columns,  Next: Retrieve number of binary columns,  Prev: Retrieve column kind,  Up: Mixed integer programming routines

5.1.8.3 Retrieve number of integer columns
..........................................

*Synopsis*:

    glp::get_num_int lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of integer columns (including binary columns)

  *Example*:

    > glp_get_num_int lp;
    1



File: pure-glpk.info,  Node: Retrieve number of binary columns,  Next: Solve the MIP problem using branch-and-cut method,  Prev: Retrieve number of integer columns,  Up: Mixed integer programming routines

5.1.8.4 Retrieve number of binary columns
.........................................

*Synopsis*:

    glp::get_num_bin lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of binary columns

  *Example*:

    > glp::get_num_bin lp
    0



File: pure-glpk.info,  Node: Solve the MIP problem using branch-and-cut method,  Next: Retrieve status of mip solution,  Prev: Retrieve number of binary columns,  Up: Mixed integer programming routines

5.1.8.5 Solve the MIP problem using branch-and-cut method
.........................................................

*Synopsis*:

    glp::intopt lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::msg_lev:

              (default: glp::msg_all) - message level for
                    terminal output:

                   *glp::msg_off:* no output 
                   *glp::msg_err:* error and warning messages only 
                   *glp::msg_on:* normal output; 
                   *glp::msg_all:* full output (including informational messages) 

               glp::br_tech: (default: glp::bt::blb) - branching
               technique

                   *glp::br_ffv:* first fractional variable 
                   *glp::br_lfv:* last fractional variable 
                   *glp::br_mfv:* most fractional variable 
                   *glp::br_dth:* heuristic by Driebeck and Tomlin 
                   *glp::br_pch:* hybrid pseudocost heuristic 

               glp::bt_tech: (default: glp::pt_pse) - backtracking
               technique

                   *glp::bt_dfs:* depth first search; 
                   *glp::bt_bfs:* breadth first search; 
                   *glp::bt_blb:* best local bound; 
                   *glp::bt_bph:* best projection heuristic. 

               glp::pp_tech: (default: glp::pp_all) - preprocessing
               technique

                   *glp::pp_none:* disable preprocessing; 
                   *glp::pp_root:* perform preprocessing only on the root level 
                   *glp::pp_all:* perform preprocessing on all levels 

               glp::fp_heur: (default: glp::off) - feasibility pump
               heuristic:

                   *glp::on:* enable applying the feasibility pump heuristic 
                   *glp::off:* disable applying the feasibility pump heuristic 

               glp::gmi_cuts:

              (default: glp::off) - Gomory’s mixed integer
                    cuts:

                   *glp::on:* enable generating Gomory’s cuts; 
                   *glp::off:* disable generating Gomory’s cuts. 

               glp::mir_cuts:

              (default: glp::off) - mixed integer rounding
                    (MIR) cuts:

                   *glp::on:* enable generating MIR cuts; 
                   *glp::off:* disable generating MIR cuts. 

               glp::cov_cuts: (default: glp::off) - mixed cover cuts:

                   *glp::on:* enable generating mixed cover cuts; 
                   *glp::off:* disable generating mixed cover cuts. 

               glp::clq_cuts (default: glp::off) - clique cuts:

                   *glp::on:* enable generating clique cuts; 
                   *glp::off:* disable generating clique cuts. 

               glp::tol_int: (default: 1e-5) - absolute tolerance used
               to check if optimal solution to the current LP
               relaxation is integer feasible

               glp::tol_obj: (default: 1e-7) - relative tolerance used
               to check if the objective value in optimal solution to
               the current LP relaxation is not better than in the best
               known integer feasible solution

               glp::mip_gap: (default: 0.0) - the relative mip gap
               tolerance; if the relative mip gap for currently known
               best integer feasible solution falls below this
               tolerance, the solver terminates the search - this
               allows obtainig suboptimal integer feasible solutions if
               solving the problem to optimality takes too long time

               glp::tm lim: (default: INT_MAX) - searching time limit,
               in milliseconds

               glp::out_frq: (default: 5000) - output frequency, in
               miliseconds - this parameter specifies how frequently
               the solver sends information about the solution process
               to the terminal

               glp::out_dly: (default: 10000) - output delay, in
               milliseconds - this parameter specifies how long the
               solver should delay sending information about the
               solution of the current LP relaxation with the simplex
               method to the terminal

               glp::cb_func:

              (default: glp::off) - specifies whether to use
                    the user-defined callback routine

                   *glp::on:* use user-defined callback function - the function `glp::mip_cb tree info' *must* be defined by the user 
                   *glp::off:* do not use user-defined callback function 

               glp::cb_info: (default: NULL) - transit pointer passed
               to the routine `glp::mip_cb tree info' (see above)

               glp::cb_size: (default: 0) - the number of extra (up to
               256) bytes allocated for each node of the
               branch-and-bound tree to store application-specific data
               - on creating a node these bytes are initialized by
               binary zeros

               glp::presolve: (default: glp::off) - LP presolver option:

                   *glp::on:* enable using the MIP presolver 
                   *glp::off:* disable using the MIP presolver 

               glp::binarize:

              (default: glp::off) - binarization (used only if
                    the presolver is enabled):

                   *glp::on:* replace general integer variables by binary ones 
                   *glp::off:* do not use binarization 

  *Returns*:

     one of the following:

          glp::ok: the MIP problem instance has been successfully
          solved; this code does not necessarily mean that the solver
          has found optimal solution, it only means that the solution
          process was successful

          glp::ebound: unable to start the search, because some
          double-bounded (auxiliary or structural) variables have
          incorrect bounds or some integer variables have non-integer
          (fractional) bounds

          glp::eroot: unable to start the search, because optimal basis
          for initial LP relaxation is not provided - this code may
          appear only if the presolver is disabled

          glp::enopfs: unable to start the search, because LP
          relaxation of the MIP problem instance has no primal feasible
          solution - this code may appear only if the presolver is
          enabled

          glp::enodfs: unable to start the search, because LP
          relaxation of the MIP problem instance has no dual feasible
          solution; in other word, this code means that if the LP
          relaxation has at least one primal feasible solution, its
          optimal solution is unbounded, so if the MIP problem has at
          least one integer feasible solution, its (integer) optimal
          solution is also unbounded - this code may appear only if the
          presolver is enabled

          glp::efail: the search was prematurely terminated due to the
          solver failure

          glp::emipgap: the search was prematurely terminated, because
          the relative mip gap tolerance has been reached

          glp::etmlim: the search was prematurely terminated, because
          the time limit has been exceeded

          glp::estop: the search was prematurely terminated by
          application - this code may appear only if the advanced solver
          interface is used

     When the list of options contains some bad option(s) then a list
     of bad options is returned instead.

  *Remark*:

     Options not mentioned in the option list are set to their default
     values.

  *Example*:

    > glp::intopt lp [(glp::presolve, glp::on)];
    ipp_basic_tech:  0 row(s) and 0 column(s) removed
    ipp_reduce_bnds: 2 pass(es) made, 3 bound(s) reduced
    ipp_basic_tech:  0 row(s) and 0 column(s) removed
    ipp_reduce_coef: 1 pass(es) made, 0 coefficient(s) reduced
    glp_intopt: presolved MIP has 3 rows, 3 columns, 9 non-zeros
    glp_intopt: 3 integer columns, none of which are binary
    Scaling...
     A: min|aij| =  1,000e+00  max|aij| =  1,000e+01  ratio =  1,000e+01
    Problem data seem to be well scaled
    Crashing...
    Size of triangular part = 3
    Solving LP relaxation...
    *     2: obj =   0,000000000e+00  infeas =  0,000e+00 (0)
    *     5: obj =   7,333333333e+02  infeas =  0,000e+00 (0)
    OPTIMAL SOLUTION FOUND
    Integer optimization begins...
    +     5: mip =     not found yet <=              +inf        (1; 0)
    +     6: >>>>>   7,320000000e+02 <=   7,320000000e+02   0.0% (2; 0)
    +     6: mip =   7,320000000e+02 <=     tree is empty   0.0% (0; 3)
    INTEGER OPTIMAL SOLUTION FOUND
    glp::ok



File: pure-glpk.info,  Node: Retrieve status of mip solution,  Next: Retrieve the objective function value of mip solution,  Prev: Solve the MIP problem using branch-and-cut method,  Up: Mixed integer programming routines

5.1.8.6 Retrieve status of mip solution
.......................................

*Synopsis*:

    glp::mip_status lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: MIP solution is undefined

          glp::opt: MIP solution is integer optimal

          glp::feas: MIP solution is integer feasible, however, its
          optimality (or non-optimality) has not been proven, perhaps
          due to premature termination of the search

          glp::nofeas: problem has no integer feasible solution (proven
          by the solver)

  *Example*:

    > glp::mip_status lp;
    glp::opt



File: pure-glpk.info,  Node: Retrieve the objective function value of mip solution,  Next: Retrieve row value of mip solution,  Prev: Retrieve status of mip solution,  Up: Mixed integer programming routines

5.1.8.7 Retrieve the objective function value of mip solution
.............................................................

*Synopsis*:

    glp::mip_obj_val lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     objective function value of mip solution

  *Example*:

    > glp::mip_obj_val lp;
    732.0



File: pure-glpk.info,  Node: Retrieve row value of mip solution,  Next: Retrieve column value of mip solution,  Prev: Retrieve the objective function value of mip solution,  Up: Mixed integer programming routines

5.1.8.8 Retrieve row value of mip solution
..........................................

*Synopsis*:

    glp::mip_row_val lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     row value (value of auxiliary variable)

  *Example*:

    > glp::mip_row_val lp 3;
    200.0



File: pure-glpk.info,  Node: Retrieve column value of mip solution,  Prev: Retrieve row value of mip solution,  Up: Mixed integer programming routines

5.1.8.9 Retrieve column value of mip solution
.............................................

*Synopsis*:

    glp::mip_col_val lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     column value (value of structural variable)

  *Example*:

    > glp::mip_col_val lp 2;
    67.0



File: pure-glpk.info,  Node: Additional routines,  Prev: Mixed integer programming routines,  Up: Basic API routines

5.1.9 Additional routines
-------------------------

* Menu:

* Check Karush-Kuhn-Tucker conditions::


File: pure-glpk.info,  Node: Check Karush-Kuhn-Tucker conditions,  Up: Additional routines

5.1.9.1 Check Karush-Kuhn-Tucker conditions
...........................................

*Synopsis*:

    lpx::check_kkt lp scaled

*Parameters*:

          lp: pointer to the LP problem object

          scaled: one of the following:

               true: test the scaled problem

               false: test the unscaled problem

  *Returns*:

     list of four tuples with five mebers (see GLPK reference manual):

     Condition       Member           Comment
     -------------------------------------------------------------------------------------- 
     (KKT.PE)        pe_ae_max        Largest absolute error
                     pe_ae_row        Number of row with largest absolute error
                     pe_re_max        Largest relative error
                     pe_re_row        Number of row with largest relative error
                     pe_quality       Quality of primal solution
     (KKT.PB)        pb_ae_max        Largest absolute error
                     pb_ae_ind        Number of variable with largest absolute error
                     pb_re_max        Largest relative error
                     pb_re_ind        Number of variable with largest relative error
                     pb_quality       Quality of primal feasibility
     (KKT.DE)        de_ae_max        Largest absolute error
                     de_ae_col        Number of column with largest absolute error
                     de_re_max        Largest relative error
                     de_re_col        Number of column with largest relative error
                     de_quality       Quality of dual solution
     (KKT.DB)        db_ae_max        Largest absolute error
                     db_ae_ind        Number of variable with largest absolute error
                     db_re_max        Largest relative error
                     db_re_ind        Number of variable with largest relative error
                     db_quality       Quality of dual feasibility

     where number of variable is (1 <= k <= m) for auxiliary variable
     and (m+1 <= k <= m+n) for structural variable

  *Example*:

    > lpx::check_kkt lp true;
    [(1.4210854715202e-14,2,3.54385404369127e-17,3,"H"),(0.0,0,0.0,0,"H"),
    (4.44089209850063e-16,1,2.11471052309554e-17,1,"H"),(0.0,0,0.0,0,"H")]



File: pure-glpk.info,  Node: Utility API routines,  Next: Advanced API routines,  Prev: Basic API routines,  Up: Descriptions of interface functions

5.2 Utility API routines
========================

* Menu:

* Problem data reading/writing routines::
* Routines for MathProg models::
* Problem solution reading/writing routines::


File: pure-glpk.info,  Node: Problem data reading/writing routines,  Next: Routines for MathProg models,  Up: Utility API routines

5.2.1 Problem data reading/writing routines
-------------------------------------------

* Menu:

* Read LP problem data from a MPS file::
* Write LP problem data into a MPS file::
* Read LP problem data from a CPLEX file::
* Write LP problem data into a CPLEX file::
* Read LP problem data in GLPK format::
* Write LP problem data in GLPK format::


File: pure-glpk.info,  Node: Read LP problem data from a MPS file,  Next: Write LP problem data into a MPS file,  Up: Problem data reading/writing routines

5.2.1.1 Read LP problem data from a MPS file
............................................

*Synopsis*:

    glp::read_mps lp format filename

*Parameters*:

          lp: pointer to the LP problem object

          format: one of the following

               glp::mps_deck: fixed (ancient) MPS file format

               glp::mps_file: free (modern) MPS file format

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::read_mps decompresses it “on the fly”

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_mps lp glp::mps_deck "examples/plan.mps";
    Reading problem data from `examples/plan.mps'...
    Problem PLAN
    Objective R0000000
    8 rows, 7 columns, 55 non-zeros
    63 records were read
    0



File: pure-glpk.info,  Node: Write LP problem data into a MPS file,  Next: Read LP problem data from a CPLEX file,  Prev: Read LP problem data from a MPS file,  Up: Problem data reading/writing routines

5.2.1.2 Write LP problem data into a MPS file
.............................................

*Synopsis*:

    glp::write_mps lp format filename

*Parameters*:

          lp: pointer to the LP problem object

          format: one of the following

               glp::mps_deck: fixed (ancient) MPS file format

               glp::mps_file: free (modern) MPS file format

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp_write_mps performs automatic compression on
          writing it

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_mps lp glp::mps_file "examples/plan1.mps";
    Writing problem data to `examples/plan1.mps'...
    63 records were written
    0



File: pure-glpk.info,  Node: Read LP problem data from a CPLEX file,  Next: Write LP problem data into a CPLEX file,  Prev: Write LP problem data into a MPS file,  Up: Problem data reading/writing routines

5.2.1.3 Read LP problem data from a CPLEX file
..............................................

*Synopsis*:

    glp::read_lp lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::read_lp decompresses it “on the fly”

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::read_lp lp "examples/plan.lp";
    reading problem data from `examples/plan.lp'...
    8 rows, 7 columns, 48 non-zeros
    39 lines were read
    0



File: pure-glpk.info,  Node: Write LP problem data into a CPLEX file,  Next: Read LP problem data in GLPK format,  Prev: Read LP problem data from a CPLEX file,  Up: Problem data reading/writing routines

5.2.1.4 Write LP problem data into a CPLEX file
...............................................

*Synopsis*:

    glp::write_lp lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::write_lp performs automatic compression on
          writing it

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_lp lp "examples/plan1.lp";
    writing problem data to `examples/plan1.lp'...
    29 lines were written
    0



File: pure-glpk.info,  Node: Read LP problem data in GLPK format,  Next: Write LP problem data in GLPK format,  Prev: Write LP problem data into a CPLEX file,  Up: Problem data reading/writing routines

5.2.1.5 Read LP problem data in GLPK format
...........................................

*Synopsis*:

    glp::read_prob lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::read_prob decompresses it “on the fly”

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::read_prob lp "examples/plan.glpk";
    reading problem data from `examples/plan.glpk'...
    8 rows, 7 columns, 48 non-zeros
    86 lines were read
    0



File: pure-glpk.info,  Node: Write LP problem data in GLPK format,  Prev: Read LP problem data in GLPK format,  Up: Problem data reading/writing routines

5.2.1.6 Write LP problem data in GLPK format
............................................

*Synopsis*:

    glp::write_prob lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::write_prob performs automatic compression on
          writing it

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_prob lp "examples/plan1.glpk";
    writing problem data to `examples/plan1.glpk'...
    86 lines were written
    0



File: pure-glpk.info,  Node: Routines for MathProg models,  Next: Problem solution reading/writing routines,  Prev: Problem data reading/writing routines,  Up: Utility API routines

5.2.2 Routines for MathProg models
----------------------------------

* Menu:

* Create the MathProg translator object::
* Read and translate model section::
* Read and translate data section::
* Generate the model::
* Build problem instance from the model::
* Postsolve the model::
* Delete the MathProg translator object::


File: pure-glpk.info,  Node: Create the MathProg translator object,  Next: Read and translate model section,  Up: Routines for MathProg models

5.2.2.1 Create the MathProg translator object
.............................................

*Synopsis*:

    glp::mpl_alloc_wksp

*Parameters*:

     none

  *Returns*:

     pointer to the MathProg translator object

  *Example*:

    > let mpt = glp::mpl_alloc_wksp;
    > mpt;
    #<pointer 0xa0d0180>



File: pure-glpk.info,  Node: Read and translate model section,  Next: Read and translate data section,  Prev: Create the MathProg translator object,  Up: Routines for MathProg models

5.2.2.2 Read and translate model section
........................................

*Synopsis*:

    glp::mpl_read_model tranobject filename skip

*Parameters*:

          tranobject: pointer to the MathProg translator object

          filename: file name

          skip: if *0* then the data section from the model file is
          read; if non-zero, the data section in the data model is
          skipped

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > mpl_read_model mpt "examples/sudoku.mod" 1;
    Reading model section from examples/sudoku.mod...
    examples/sudoku.mod:69: warning: data section ignored
    69 lines were read
    0



File: pure-glpk.info,  Node: Read and translate data section,  Next: Generate the model,  Prev: Read and translate model section,  Up: Routines for MathProg models

5.2.2.3 Read and translate data section
.......................................

*Synopsis*:

    glp::mpl_read_data tranobject filename

*Parameters*:

          tranobject: pointer to the MathProg translator object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::mpl_read_data mpt "examples/sudoku.dat";
    Reading data section from examples/sudoku.dat...
    16 lines were read
    0



File: pure-glpk.info,  Node: Generate the model,  Next: Build problem instance from the model,  Prev: Read and translate data section,  Up: Routines for MathProg models

5.2.2.4 Generate the model
..........................

*Synopsis*:

    glp::mpl_generate tranobject filename

*Parameters*:

          tranobject: pointer to the MathProg translator object

          filename: file name

  *Returns*:

     *0* if generating went OK; non-zero in case of an error

  *Example*:

    > glp::mpl_generate mpt "examples/sudoku.lst";
    Generating fa...
    Generating fb...
    Generating fc...
    Generating fd...
    Generating fe...
    Model has been successfully generated
    0



File: pure-glpk.info,  Node: Build problem instance from the model,  Next: Postsolve the model,  Prev: Generate the model,  Up: Routines for MathProg models

5.2.2.5 Build problem instance from the model
.............................................

*Synopsis*:

    glp::mpl_build_prob tranobject lp

*Parameters*:

          tranobject: pointer to the MathProg translator object

          lp: pointer to the LP problem object

  *Returns*:

     `()'

  *Example*:

    > glp::mpl_build_prob mpt lp;
    ()



File: pure-glpk.info,  Node: Postsolve the model,  Next: Delete the MathProg translator object,  Prev: Build problem instance from the model,  Up: Routines for MathProg models

5.2.2.6 Postsolve the model
...........................

*Synopsis*:

    glp::mpl_postsolve tran lp solution

*Parameters*:

          tranobject: pointer to the MathProg translator object

          lp: pointer to the LP problem object

          solution: one of the following:

               glp::sol: use the basic solution

               glp::ipt: use the interior-point solution

               glp::mip: use mixed integer solution

  *Returns*:

     *0* if postsolve went OK; non-zero in case of an error

  *Example*:

    > glp::mpl_postsolve mpt lp glp::sol;
    Model has been successfully processed
    0



File: pure-glpk.info,  Node: Delete the MathProg translator object,  Prev: Postsolve the model,  Up: Routines for MathProg models

5.2.2.7 Delete the MathProg translator object
.............................................

*Synopsis*:

    glp::mpl_free_wksp tranobject

*Parameters*:

          tranobject: pointer to the MathProg translator object

  *Returns*:

     `()'

  *Example*:

    > glp::mpl_free_wksp mpt;
    ()



File: pure-glpk.info,  Node: Problem solution reading/writing routines,  Prev: Routines for MathProg models,  Up: Utility API routines

5.2.3 Problem solution reading/writing routines
-----------------------------------------------

* Menu:

* Write basic solution in printable format::
* Read basic solution from a text file::
* Write basic solution into a text file::
* Print sensitivity analysis report::
* Write interior-point solution in printable format::
* Read interior-point solution from a text file::
* Write interior-point solution into a text file::
* Write MIP solution in printable format::
* Read MIP solution from a text file::
* Write MIP solution into a text file::


File: pure-glpk.info,  Node: Write basic solution in printable format,  Next: Read basic solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.1 Write basic solution in printable format
................................................

*Synopsis*:

    glp::print_sol lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::print_sol lp "examples/test.txt";
    Writing basic solution to `examples/test.txt'...
    0



File: pure-glpk.info,  Node: Read basic solution from a text file,  Next: Write basic solution into a text file,  Prev: Write basic solution in printable format,  Up: Problem solution reading/writing routines

5.2.3.2 Read basic solution from a text file
............................................

*Synopsis*:

    glp::read_sol lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_sol lp "examples/test.txt";
    Reading basic solution from `examples/test.txt'...
    1235 lines were read
    0



File: pure-glpk.info,  Node: Write basic solution into a text file,  Next: Print sensitivity analysis report,  Prev: Read basic solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.3 Write basic solution into a text file
.............................................

*Synopsis*:

    glp::write_sol lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_sol lp "examples/test.txt";
    Writing basic solution to `examples/test.txt'...
    1235 lines were written
    0



File: pure-glpk.info,  Node: Print sensitivity analysis report,  Next: Write interior-point solution in printable format,  Prev: Write basic solution into a text file,  Up: Problem solution reading/writing routines

5.2.3.4 Print sensitivity analysis report
.........................................

*Synopsis*:

    glp::print_ranges lp indices filename

*Parameters*:

          lp: pointer to the LP problem object

          indices: list indices k of of rows and columns to be included
          in the report.  If 1 ≤ k ≤ m, the basic variable is k-th
          auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic
          variable is (k − m)-th structural variable, where m is the
          number of rows and n is the number of columns in the
          specified problem object. An empty lists means printing
          report for all rows and columns.

          filename: file name

  *Returns*:

          0: if the operation was successful

          non-zero: if the operation failed

  *Example*:

    > glp::print_ranges lp [] "sensitivity.rpt";
    Write sensitivity analysis report to `sensitivity.rpt'...
    0



File: pure-glpk.info,  Node: Write interior-point solution in printable format,  Next: Read interior-point solution from a text file,  Prev: Print sensitivity analysis report,  Up: Problem solution reading/writing routines

5.2.3.5 Write interior-point solution in printable format
.........................................................

*Synopsis*:

    glp::print_ipt lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::print_ipt lp "examples/test.txt";
    Writing interior-point solution to `examples/test.txt'...
    0



File: pure-glpk.info,  Node: Read interior-point solution from a text file,  Next: Write interior-point solution into a text file,  Prev: Write interior-point solution in printable format,  Up: Problem solution reading/writing routines

5.2.3.6 Read interior-point solution from a text file
.....................................................

*Synopsis*:

    glp::read_ipt lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_ipt lp "examples/test.txt";
    Reading interior-point solution from `examples/test.txt'...
    1235 lines were read
    0



File: pure-glpk.info,  Node: Write interior-point solution into a text file,  Next: Write MIP solution in printable format,  Prev: Read interior-point solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.7 Write interior-point solution into a text file
......................................................

*Synopsis*:

    glp::write_ipt lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_ipt lp "examples/test.txt";
    Writing interior-point solution to `examples/test.txt'...
    1235 lines were written
    0



File: pure-glpk.info,  Node: Write MIP solution in printable format,  Next: Read MIP solution from a text file,  Prev: Write interior-point solution into a text file,  Up: Problem solution reading/writing routines

5.2.3.8 Write MIP solution in printable format
..............................................

*Synopsis*:

    glp::print_mip lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::print_mip lp "examples/test.txt";
    Writing MIP solution to `examples/test.txt'...
    0



File: pure-glpk.info,  Node: Read MIP solution from a text file,  Next: Write MIP solution into a text file,  Prev: Write MIP solution in printable format,  Up: Problem solution reading/writing routines

5.2.3.9 Read MIP solution from a text file
..........................................

*Synopsis*:

    glp::read_mip lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_mip lp "examples/test.txt";
    Reading MIP solution from `examples/test.txt'...
    1235 lines were read
    0



File: pure-glpk.info,  Node: Write MIP solution into a text file,  Prev: Read MIP solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.10 Write MIP solution into a text file
............................................

*Synopsis*:

    glp::write_mip lp filename

*Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

    > glp::write_mip lp "examples/test.txt";
    Writing MIP solution to `examples/test.txt'...
    1235 lines were written
    0



File: pure-glpk.info,  Node: Advanced API routines,  Next: Branch-and-cut API routines,  Prev: Utility API routines,  Up: Descriptions of interface functions

5.3 Advanced API routines
=========================

* Menu:

* LP basis routines::
* Simplex tableau routines::


File: pure-glpk.info,  Node: LP basis routines,  Next: Simplex tableau routines,  Up: Advanced API routines

5.3.1 LP basis routines
-----------------------

* Menu:

* Check whether basis factorization exists::
* Compute the basis factorization::
* Check whether basis factorization has been updated::
* Get basis factorization parameters::
* Change basis factorization parameters::
* Retrieve the basis header information::
* Retrieve row index in the basis header::
* Retrieve column index in the basis header::
* Perform forward transformation::
* Perform backward transformation::
* Warm up LP basis::


File: pure-glpk.info,  Node: Check whether basis factorization exists,  Next: Compute the basis factorization,  Up: LP basis routines

5.3.1.1 Check whether basis factorization exists
................................................

*Synopsis*:

    glp::bf_exists lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

          non-zero: the basis factorization exists and can be used for
          calculations

          0: the basis factorization does not exist

  *Example*:

    > glp::bf:exists lp;
    1



File: pure-glpk.info,  Node: Compute the basis factorization,  Next: Check whether basis factorization has been updated,  Prev: Check whether basis factorization exists,  Up: LP basis routines

5.3.1.2 Compute the basis factorization
.......................................

*Synopsis*:

    glp::factorize lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::ok: the basis factorization has been successfully
          computed

          glp::ebadb: the basis matrix is invalid, because the number
          of basic (auxiliary and structural) variables is not the same
          as the number of rows in the problem object

          glp::esing: the basis matrix is singular within the working
          precision

          glp::exond: the basis matrix is ill-conditioned, i.e. its
          condition number is too large

  *Example*:

    > glp::factorize lp;
    glp::ok



File: pure-glpk.info,  Node: Check whether basis factorization has been updated,  Next: Get basis factorization parameters,  Prev: Compute the basis factorization,  Up: LP basis routines

5.3.1.3 Check whether basis factorization has been updated
..........................................................

*Synopsis*:

    glp::bf_updated lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

          0: if the basis factorization has been just computed from
          “scratch”

          non-zero: if the factorization has been updated at least once

  *Example*:

    > glp::bf_updated lp;
    0



File: pure-glpk.info,  Node: Get basis factorization parameters,  Next: Change basis factorization parameters,  Prev: Check whether basis factorization has been updated,  Up: LP basis routines

5.3.1.4 Get basis factorization parameters
..........................................

*Synopsis*:

    glp::get_bfcp lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     complete list of options in a form of tuples (option_name, value):

          glp::fact_type: basis factorization type:

               glp::bf_ft: LU + Forrest–Tomlin update

               glp::bf_bg: LU + Schur complement + Bartels–Golub update

               glp::bf_gr: LU + Schur complement + Givens rotation
               update

          glp::lu_size: the initial size of the Sparse Vector Area, in
          non-zeros, used on computing LU-factorization of the basis
          matrix for the first time - if this parameter is set to 0,
          the initial SVA size is determined automatically

          glp::piv_tol: threshold pivoting (Markowitz) tolerance, 0 <
          piv_tol < 1, used on computing LU-factorization of the basis
          matrix

          glp::piv_lim: this parameter is used on computing
          LU-factorization of the basis matrix and specifies how many
          pivot candidates needs to be considered on choosing a pivot
          element, piv_lim ≥ 1

          glp::suhl: this parameter is used on computing
          LU-factorization of the basis matrix

               glp::on: enables applying the heuristic proposed by Uwe
               Suhl

               glp::off: disables this heuristic

          glp::eps_tol: epsilon tolerance, eps_tol ≥ 0, used on
          computing LU-factorization of the basis matrix

          glp::max_gro: maximal growth of elements of factor U, max_gro
          ≥ 1, allowable on computing LU-factorization of the basis
          matrix

          glp::nfs_max: maximal number of additional row-like factors
          (entries of the eta file), nfs_max ≥ 1, which can be added to
          LU-factorization of the basis matrix on updating it with the
          Forrest–Tomlin technique

          glp::upd_tol: update tolerance, 0 < upd_tol < 1, used on
          updating LU-factorization of the basis matrix with the
          Forrest–Tomlin technique

          glp::nrs_max: maximal number of additional rows and columns,
          nrs_max ≥ 1, which can be added to LU-factorization of the
          basis matrix on updating it with the Schur complement
          technique

          glp::rs_size: the initial size of the Sparse Vector Area, in
          non-zeros, used to store non-zero elements of additional rows
          and columns introduced on updating LU-factorization of the
          basis matrix with the Schur complement technique - if this
          parameter is set to 0, the initial SVA size is determined
          automatically

  *Example*:

    > glp::get_bfcp lp;
    [(glp::fact_type,glp::bf_ft),(glp::lu_size,0),(glp::piv_tol,0.1),
    (glp::piv_lim,4),(glp::suhl,glp::on),(glp::eps_tol,1e-15),
    (glp::max_gro,10000000000.0),(glp::nfs_max,50),(glp::upd_tol,1e-06),
    (glp::nrs_max,50),(glp::rs_size,0)]



File: pure-glpk.info,  Node: Change basis factorization parameters,  Next: Retrieve the basis header information,  Prev: Get basis factorization parameters,  Up: LP basis routines

5.3.1.5 Change basis factorization parameters
.............................................

*Synopsis*:

    glp::set_bfcp lp options

*Parameters*:

          lp: pointer to the LP problem object

          options: list of options in a form of tuples (option_name,
          value):

          glp::fact_type: (default: glp::bf_ft) - basis factorization
          type:

               glp::bf_ft: LU + Forrest–Tomlin update

               glp::bf_bg: LU + Schur complement + Bartels–Golub update

               glp::bf_gr: LU + Schur complement + Givens rotation
               update

          glp::lu_size: (default: 0) - the initial size of the Sparse
          Vector Area, in non-zeros, used on computing LU-factorization
          of the basis matrix for the first time - if this parameter is
          set to 0, the initial SVA size is determined automatically

          glp::piv_tol: (default: 0.10) - threshold pivoting
          (Markowitz) tolerance, 0 < piv_tol < 1, used on computing
          LU-factorization of the basis matrix.

          glp::piv_lim: (default: 4) - this parameter is used on
          computing LU-factorization of the basis matrix and specifies
          how many pivot candidates needs to be considered on choosing
          a pivot element, piv_lim ≥ 1

          glp::suhl: (default: glp::on) - this parameter is used on
          computing LU-factorization of the basis matrix.

               glp::on: enables applying the heuristic proposed by Uwe
               Suhl

               glp::off: disables this heuristic

          glp::eps_tol: (default: 1e-15) - epsilon tolerance, eps_tol ≥
          0, used on computing LU -factorization of the basis matrix.

          glp::max_gro: (default: 1e+10) - maximal growth of elements
          of factor U, max_gro ≥ 1, allowable on computing
          LU-factorization of the basis matrix.

          glp::nfs_max: (default: 50) - maximal number of additional
          row-like factors (entries of the eta file), nfs_max ≥ 1,
          which can be added to LU-factorization of the basis matrix on
          updating it with the Forrest–Tomlin technique.

          glp::upd_tol: (default: 1e-6) - update tolerance, 0 < upd_tol
          < 1, used on updating LU -factorization of the basis matrix
          with the Forrest–Tomlin technique.

          glp::nrs_max: (default: 50) - maximal number of additional
          rows and columns, nrs_max ≥ 1, which can be added to
          LU-factorization of the basis matrix on updating it with the
          Schur complement technique.

          glp::rs_size: (default: 0) - the initial size of the Sparse
          Vector Area, in non-zeros, used to store non-zero elements of
          additional rows and columns introduced on updating
          LU-factorization of the basis matrix with the Schur
          complement technique - if this parameter is set to 0, the
          initial SVA size is determined automatically

  *Remarks*:

     Options not mentioned in the option list are left unchanged.

     All options will be reset to their default values when an empty
     option list is supplied.

  *Returns*:

     `()' if all options are OK, otherwise returns a list of bad options

  *Example*:

    > glp_set_bfcp lp [(glp::fact_type, glp::bf_ft), (glp::piv_tol, 0.15)];
    ()



File: pure-glpk.info,  Node: Retrieve the basis header information,  Next: Retrieve row index in the basis header,  Prev: Change basis factorization parameters,  Up: LP basis routines

5.3.1.6 Retrieve the basis header information
.............................................

*Synopsis*:

    glp::get_bhead lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: variable index in the basis matrix

  *Returns*:

     If basic variable (xB )k , 1 ≤ k ≤ m, is i-th auxiliary variable
     (1 ≤ i ≤ m), the routine returns i. Otherwise, if (xB )k is j-th
     structural variable (1 ≤ j ≤ n), the routine returns m+j. Here m
     is the number of rows and n is the number of columns in the
     problem object.

  *Example*:

    > glp::get_bhead lp 3;
    5



File: pure-glpk.info,  Node: Retrieve row index in the basis header,  Next: Retrieve column index in the basis header,  Prev: Retrieve the basis header information,  Up: LP basis routines

5.3.1.7 Retrieve row index in the basis header
..............................................

*Synopsis*:

    glp::get_row_bind lp rowindex

*Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤
     m, which is i-th auxiliary variable (that is, the auxiliary
     variable corresponding to i-th row), 1 ≤ i ≤ m, in the current
     basis associated with the specified problem object, where m is the
     number of rows. However, if i-th auxiliary variable is non-basic,
     the routine returns zero.

  *Example*:

    > glp::get_row_bind lp 3;
    1



File: pure-glpk.info,  Node: Retrieve column index in the basis header,  Next: Perform forward transformation,  Prev: Retrieve row index in the basis header,  Up: LP basis routines

5.3.1.8 Retrieve column index in the basis header
.................................................

*Synopsis*:

    glp::get_col_bind lp colindex

*Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤
     m, which is j-th structural variable (that is, the structural
     variable corresponding to j-th column), 1 ≤ j ≤ n, in the current
     basis associated with the specified problem object, where m is the
     number of rows, n is the number of columns. However, if j-th
     structural variable is non-basic, the routine returns zero.

  *Example*:

    > glp::get_col_bind lp 2;
    3



File: pure-glpk.info,  Node: Perform forward transformation,  Next: Perform backward transformation,  Prev: Retrieve column index in the basis header,  Up: LP basis routines

5.3.1.9 Perform forward transformation
......................................

*Synopsis*:

    glp::ftran lp vector

*Parameters*:

          lp: pointer to the LP problem object

          vector: vector to be transformed - a dense vector in a form
          of a list of double numbers has to be supplied and the number
          of its members must exactly correspond to the number of LP
          problem constraints

  *Returns*:

     the transformed vector in the same format

  *Example*:

    > glp::ftran lp [1.5, 3.2, 4.8];
    [1.8,0.466666666666667,-1.96666666666667]



File: pure-glpk.info,  Node: Perform backward transformation,  Next: Warm up LP basis,  Prev: Perform forward transformation,  Up: LP basis routines

5.3.1.10 Perform backward transformation
........................................

*Synopsis*:

    glp::btran lp vector

*Parameters*:

          lp: pointer to the LP problem object

          vector: vector to be transformed - a dense vector in a form
          of a list of double numbers has to be supplied and the number
          of its members must exactly correspond to the number of LP
          problem constraints

  *Returns*:

     the transformed vector in the same format

  *Example*:

    > glp::btran lp [1.5, 3.2, 4.8];
    [-8.86666666666667,0.266666666666667,1.5]



File: pure-glpk.info,  Node: Warm up LP basis,  Prev: Perform backward transformation,  Up: LP basis routines

5.3.1.11 Warm up LP basis
.........................

*Synopsis*:

    glp::warm_up lp

*Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::ok: the LP basis has been successfully “warmed up”

          glp::ebadb: the LP basis is invalid, because the number of
          basic variables is not the same as the number of rows

          glp::esing: the basis matrix is singular within the working
          precision

          glp::econd: the basis matrix is ill-conditioned, i.e. its
          condition number is too large

  *Example*:

    > glp::warm_up lp;
    glp::e_ok



File: pure-glpk.info,  Node: Simplex tableau routines,  Prev: LP basis routines,  Up: Advanced API routines

5.3.2 Simplex tableau routines
------------------------------

* Menu:

* Compute row of the tableau::
* Compute column of the tableau::
* Transform explicitly specified row::
* Transform explicitly specified column::
* Perform primal ratio test::
* Perform dual ratio test::
* Analyze active bound of non-basic variable::
* Analyze objective coefficient at basic variable::


File: pure-glpk.info,  Node: Compute row of the tableau,  Next: Compute column of the tableau,  Up: Simplex tableau routines

5.3.2.1 Compute row of the tableau
..................................

*Synopsis*:

    glp::eval_tab_row lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: variable index such that it corresponds to some basic
          variable: if 1 ≤ k ≤ m, the basic variable is k-th auxiliary
          variable, and if m + 1 ≤ k ≤ m + n, the basic variable is (k
          − m)-th structural variable, where m is the number of rows
          and n is the number of columns in the specified problem
          object (the basis factorization must exist)

  *Returns*:

     simplex tableau row in a sparse form as a list of tuples (index,
     value), where index has the same meaning as k in parameters

  *Example*:

    > glp::eval_tab_row lp 3;
    [(1,2.0),(6,4.0)]



File: pure-glpk.info,  Node: Compute column of the tableau,  Next: Transform explicitly specified row,  Prev: Compute row of the tableau,  Up: Simplex tableau routines

5.3.2.2 Compute column of the tableau
.....................................

*Synopsis*:

    glp::eval_tab_col lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: variable index such that it corresponds to some non-basic
          variable: if 1 ≤ k ≤ m, the non-basic variable is k-th
          auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic
          variable is (k − m)-th structural variable, where m is the
          number of rows and n is the number of columns in the
          specified problem object (the basis factorization must exist)

  *Returns*:

     simplex tableau column in a sparse form as a list of tuples
     (index, value), where index has the same meaning as k in parameters

  *Example*:

    > glp::eval_tab_col lp 1;
    [(3,2.0),(4,-0.666666666666667),(5,1.66666666666667)]



File: pure-glpk.info,  Node: Transform explicitly specified row,  Next: Transform explicitly specified column,  Prev: Compute column of the tableau,  Up: Simplex tableau routines

5.3.2.3 Transform explicitly specified row
..........................................

*Synopsis*:

    glp::transform_row lp rowvector

*Parameters*:

          lp: pointer to the LP problem object

          rowvector: row vector to be transformed in a sparse form as a
          list of tuples (k, value): if 1 ≤ k ≤ m, the non-basic
          variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m +
          n, the non-basic variable is (k − m)-th structural variable,
          where m is the number of rows and n is the number of columns
          in the specified problem object (the basis factorization must
          exist)

  *Returns*:

     the transformed row in a sparse form as a list of tuples (index,
     value), where index has the same meaning as k in parameters

  *Example*:

    > glp::transform_row lp [(1, 3.0), (2, 3.5)];
    [(1,3.83333333333333),(2,-0.0833333333333333),(6,-3.41666666666667)]



File: pure-glpk.info,  Node: Transform explicitly specified column,  Next: Perform primal ratio test,  Prev: Transform explicitly specified row,  Up: Simplex tableau routines

5.3.2.4 Transform explicitly specified column
.............................................

*Synopsis*:

    glp::transform_col lp colvector

*Parameters*:

          lp: pointer to the LP problem object

          colvector: column vector to be transformed in a sparse form
          as a list of tuples (k, value): if 1 ≤ k ≤ m, the non-basic
          variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m +
          n, the non-basic variable is (k − m)-th structural variable,
          where m is the number of rows and n is the number of columns
          in the specified problem object (the basis factorization must
          exist)

  *Returns*:

     the transformed column in a sparse form as a list of tuples
     (index, value), where index has the same meaning as k in parameters

  *Example*:

    > glp::transform_col lp [(2, 1.0), (3, 2.3)];
    [(3,2.3),(4,-0.166666666666667),(5,0.166666666666667)]



File: pure-glpk.info,  Node: Perform primal ratio test,  Next: Perform dual ratio test,  Prev: Transform explicitly specified column,  Up: Simplex tableau routines

5.3.2.5 Perform primal ratio test
.................................

*Synopsis*:

    glp::prim_rtest lp colvector dir eps

*Parameters*:

          lp: pointer to the LP problem object

          colvector: simplex tableau column in a sparse form as a list
          of tuples (k, value): if 1 ≤ k ≤ m, the basic variable is k-th
          auxiliary variable, and if m + 1 ≤ k ≤ m + n, the basic
          variable is (k − m)-th structural variable, where m is the
          number of rows and n is the number of columns in the
          specified problem object (the basis factorization must exist
          and the primal solution must be feasible)

          dir: specifies in which direction the variable y changes on
          entering the basis: +1 means increasing, −1 means decreasing

          eps: relative tolerance (small positive number) used to skip
          small values in the column

  *Returns*:

     The routine returns the index, piv, in the colvector corresponding
     to the pivot element chosen, 1 ≤ piv ≤ len. If the adjacent basic
     solution is primal unbounded, and therefore the choice cannot be
     made, the routine returns zero.

  *Example*:

    > glp::prim_rtest lp [(3, 2.5), (5, 7.0)] 1 1.0e-5;
    3



File: pure-glpk.info,  Node: Perform dual ratio test,  Next: Analyze active bound of non-basic variable,  Prev: Perform primal ratio test,  Up: Simplex tableau routines

5.3.2.6 Perform dual ratio test
...............................

*Synopsis*:

    glp::dual_rtest lp rowvector dir eps

*Parameters*:

          lp: pointer to the LP problem object

          rowvector: simplex tableau row in a sparse form as a list of
          tuples (k, value): if 1 ≤ k ≤ m, the non-basic variable is
          k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the
          non-basic variable is (k − m)-th structural variable, where m
          is the number of rows and n is the number of columns in the
          specified problem object (the basis factorization must exist
          and the dual solution must be feasible)

          dir: specifies in which direction the variable y changes on
          leaving the basis: +1 means increasing, −1 means decreasing

          eps: relative tolerance (small positive number) used to skip
          small values in the row

  *Returns*:

     The routine returns the index, piv, in the rowvector corresponding
     to the pivot element chosen, 1 ≤ piv ≤ len. If the adjacent basic
     solution is dual unbounded, and therefore the choice cannot be
     made, the routine returns zero.

  *Example*:

    > glp::dual_rtest lp [(1, 1.5), (6, 4.0)] 1 1.0e-5;
    6



File: pure-glpk.info,  Node: Analyze active bound of non-basic variable,  Next: Analyze objective coefficient at basic variable,  Prev: Perform dual ratio test,  Up: Simplex tableau routines

5.3.2.7 Analyze active bound of non-basic variable
..................................................

*Synopsis*:

    glp::analyze_bound lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary
          variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is
          (k − m)-th structural variable, where m is the number of rows
          and n is the number of columns in the specified problem
          object (the basis factorization must exist and the solution
          must be optimal)

  *Returns*:

     The routine returns a tuple (limit1, var1, limit2 var2) where:

          value1: the minimal value of the active bound, at which the
          basis still remains primal feasible and thus optimal.
          -DBL_MAX means that the active bound has no lower limit.

          var1: the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) basic variable, which reaches its
          bound first and thereby limits further decreasing the active
          bound being analyzed. If value1 = -DBL_MAX, var1 is set to 0.

          value2: the maximal value of the active bound, at which the
          basis still remains primal feasible and thus optimal.
          +DBL_MAX means that the active bound has no upper limit.

          var2: the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) basic variable, which reaches its
          bound first and thereby limits further increasing the active
          bound being analyzed. If value2 = +DBL_MAX, var2 is set to 0.

  *Example*:

    > analyze_bound lp 2;
    1995.06864446899,12,2014.03478832467,4



File: pure-glpk.info,  Node: Analyze objective coefficient at basic variable,  Prev: Analyze active bound of non-basic variable,  Up: Simplex tableau routines

5.3.2.8 Analyze objective coefficient at basic variable
.......................................................

*Synopsis*:

    glp::analyze_coef lp k

*Parameters*:

          lp: pointer to the LP problem object

          k: if 1 ≤ k ≤ m, the basic variable is k-th auxiliary
          variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is
          (k − m)-th structural variable, where m is the number of rows
          and n is the number of columns in the specified problem
          object (the basis factorization must exist and the solution
          must be optimal)

  *Returns*:

     The routine returns a tuple (coef1, var1, value1, coef2 var2,
     value2) where:

          coef1: the minimal value of the objective coefficient, at
          which the basis still remains dual feasible and thus optimal.
          -DBL_MAX means that the objective coefficient has no lower
          limit.

          var1: is the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) non-basic variable, whose reduced
          cost reaches its zero bound first and thereby limits further
          decreasing the objective coefficient being analyzed. If coef1
          = -DBL_MAX, var1 is set to 0.

          value1: value of the basic variable being analyzed in an
          adjacent basis, which is defined as follows. Let the
          objective coefficient reaches its minimal value (coef1) and
          continues decreasing. Then the reduced cost of the limiting
          non-basic variable (var1) becomes dual infeasible and the
          current basis becomes non-optimal that forces the limiting
          non-basic variable to enter the basis replacing there some
          basic variable that leaves the basis to keep primal
          feasibility. Should note that on determining the adjacent
          basis current bounds of the basic variable being analyzed are
          ignored as if it were free (unbounded) variable, so it cannot
          leave the basis. It may happen that no dual feasible adjacent
          basis exists, in which case value1 is set to -DBL_MAX or
          +DBL_MAX.

          coef2: the maximal value of the objective coefficient, at
          which the basis still remains dual feasible and thus optimal.
          +DBL_MAX means that the objective coefficient has no upper
          limit.

          var2: the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) non-basic variable, whose reduced
          cost reaches its zero bound first and thereby limits further
          increasing the objective coefficient being analyzed. If coef2
          = +DBL_MAX, var2 is set to 0.

          value2: value of the basic variable being analyzed in an
          adjacent basis, which is defined exactly in the same way as
          value1 above with exception that now the objective
          coefficient is increasing.

  *Example*:

    > analyze_coef lp 1;
    -1.0,3,306.771624713959,1.79769313486232e+308,0,296.216606498195



File: pure-glpk.info,  Node: Branch-and-cut API routines,  Next: Graph and network API routines,  Prev: Advanced API routines,  Up: Descriptions of interface functions

5.4 Branch-and-cut API routines
===============================

     All branch-and-cut API routines are supposed to be called from the
     callback routine. They cannot be called directly.

* Menu:

* Basic routines::
* The search tree exploring routines::
* The cut pool routines::


File: pure-glpk.info,  Node: Basic routines,  Next: The search tree exploring routines,  Up: Branch-and-cut API routines

5.4.1 Basic routines
--------------------

* Menu:

* Determine reason for calling the callback routine::
* Access the problem object::
* Determine additional row attributes::
* Compute relative MIP gap::
* Access application-specific data::
* Select subproblem to continue the search::
* Provide solution found by heuristic::
* Check whether can branch upon specified variable::
* Choose variable to branch upon::
* Terminate the solution process::


File: pure-glpk.info,  Node: Determine reason for calling the callback routine,  Next: Access the problem object,  Up: Basic routines

5.4.1.1 Determine reason for calling the callback routine
.........................................................

*Synopsis*:

    glp::ios_reason tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     one of the following:

          glp::irowgen: request for row generation

          glp::ibingo: better integer solution found

          glp::iheur: request for heuristic solution

          glp::icutgen: request for cut generation

          glp::ibranch: request for branching

          glp::iselect: request for subproblem selection

          glp::iprepro: request for preprocessing

  *Example*:

    glp::ios:reason tree;



File: pure-glpk.info,  Node: Access the problem object,  Next: Determine additional row attributes,  Prev: Determine reason for calling the callback routine,  Up: Basic routines

5.4.1.2 Access the problem object
.................................

*Synopsis*:

    glp::ios_get_prob tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns a pointer to the problem object used by the
     MIP solver.

  *Example*:

    glp::ios_get_prob tree;



File: pure-glpk.info,  Node: Determine additional row attributes,  Next: Compute relative MIP gap,  Prev: Access the problem object,  Up: Basic routines

5.4.1.3 Determine additional row attributes
...........................................

*Synopsis*:

    glp::ios_row_attr tree rowindex

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          rowindex: row index

  *Returns*:

     The routine returns a tuple consisting of three values (level,
     origin, klass):

          level: subproblem level at which the row was created

          origin: the row origin flag - one of the following:

               glp::rf_reg: regular constraint

               glp::rf_lazy: “lazy” constraint

               glp::rf_cut: cutting plane constraint

          klass: the row class descriptor, which is a number passed to
          the routine glp_ios_add_row as its third parameter - if the
          row is a cutting plane constraint generated by the solver,
          its class may be the following:

               glp::rf_gmi: Gomory’s mixed integer cut

               glp::rf_mir: mixed integer rounding cut

               glp::rf_cov: mixed cover cut

               glp::rf_clq: clique cut

  *Example*:

    glp::ios_row_attr tree 3;



File: pure-glpk.info,  Node: Compute relative MIP gap,  Next: Access application-specific data,  Prev: Determine additional row attributes,  Up: Basic routines

5.4.1.4 Compute relative MIP gap
................................

*Synopsis*:

    glp::ios_mip_gap tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the relative MIP gap.

  *Example*:

    > glp::ios_mip_gap tree;



File: pure-glpk.info,  Node: Access application-specific data,  Next: Select subproblem to continue the search,  Prev: Compute relative MIP gap,  Up: Basic routines

5.4.1.5 Access application-specific data
........................................

*Synopsis*:

    glp::ios_node_data tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine glp_ios_node_data returns a pointer to the memory
     block for the specified subproblem. Note that if cb_size = 0 was
     specified in the call of the *intopt* function, the routine
     returns a null pointer.

  *Example*:

    > glp::ios_node_data tree 23;



File: pure-glpk.info,  Node: Select subproblem to continue the search,  Next: Provide solution found by heuristic,  Prev: Access application-specific data,  Up: Basic routines

5.4.1.6 Select subproblem to continue the search
................................................

*Synopsis*:

    glp::ios_select_node tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of the subproblem from which the
          search will continue

  *Returns*:

     ()

  *Example*:

    > glp::ios_select_node tree 23;



File: pure-glpk.info,  Node: Provide solution found by heuristic,  Next: Check whether can branch upon specified variable,  Prev: Select subproblem to continue the search,  Up: Basic routines

5.4.1.7 Provide solution found by heuristic
...........................................

*Synopsis*:

    glp::ios_heur_sol tree colvector

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          colvector: solution found by a primal heuristic. Primal
          values of all variables (columns) found by the heuristic
          should be placed in the list, i. e. the list must contain n
          numbers where n is the number of columns in the original
          problem object.  Note that the routine does not check primal
          feasibility of the solution provided.

  *Returns*:

     If the provided solution is accepted, the routine returns zero.
     Otherwise, if the provided solution is rejected, the routine
     returns non-zero.

  *Example*:

    > glp::ios_heur_sol tree [15.7, (-3.1), 2.2];



File: pure-glpk.info,  Node: Check whether can branch upon specified variable,  Next: Choose variable to branch upon,  Prev: Provide solution found by heuristic,  Up: Basic routines

5.4.1.8 Check whether can branch upon specified variable
........................................................

*Synopsis*:

    glp::ios_can_branch tree j

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          j: variable (column) index

  *Returns*:

     The function returns non-zero if j-th variable can be used for
     branching.  Otherwise, it returns zero.

  *Example*:

    > glp::ios_can_branch tree 23;



File: pure-glpk.info,  Node: Choose variable to branch upon,  Next: Terminate the solution process,  Prev: Check whether can branch upon specified variable,  Up: Basic routines

5.4.1.9 Choose variable to branch upon
......................................

*Synopsis*:

    glp::ios_branch_upon tree j selection

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          j: ordinal number of the selected branching variable

          selection: one of the following:

               glp::dn_brnch: select down-branch

               glp::up_brnch: select up-branch

               glp::no_brnch: use general selection technique

  *Returns*:

     ()

  *Example*:

    > glp::ios_branch_upon tree 23 glp::up_brnch;



File: pure-glpk.info,  Node: Terminate the solution process,  Prev: Choose variable to branch upon,  Up: Basic routines

5.4.1.10 Terminate the solution process
.......................................

*Synopsis*:

    glp::ios_terminate tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     ()

  *Example*:

    > glp::ios_terminate tree;



File: pure-glpk.info,  Node: The search tree exploring routines,  Next: The cut pool routines,  Prev: Basic routines,  Up: Branch-and-cut API routines

5.4.2 The search tree exploring routines
----------------------------------------

* Menu:

* Determine the search tree size::
* Determine current active subproblem::
* Determine next active subproblem::
* Determine previous active subproblem::
* Determine parent active subproblem::
* Determine subproblem level::
* Determine subproblem local bound::
* Find active subproblem with the best local bound::


File: pure-glpk.info,  Node: Determine the search tree size,  Next: Determine current active subproblem,  Up: The search tree exploring routines

5.4.2.1 Determine the search tree size
......................................

*Synopsis*:

    glp::ios_tree_size tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns a tuple (a_cnt, n_cnt, t_cnt), where

          a_cnt: the current number of active nodes

          n_cnt: the current number of all (active and inactive) nodes

          t_cnt: the total number of nodes including those which have
          been already removed from the tree. This count is increased
          whenever a new node appears in the tree and never decreased.

  *Example*:

    > glp::ios_tree_size tree;



File: pure-glpk.info,  Node: Determine current active subproblem,  Next: Determine next active subproblem,  Prev: Determine the search tree size,  Up: The search tree exploring routines

5.4.2.2 Determine current active subproblem
...........................................

*Synopsis*:

    glp::ios_curr_node tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the reference number of the current active
     subproblem.  If the current subproblem does not exist, the routine
     returns zero.

  *Example*:

    > glp::ios_curr_node tree;



File: pure-glpk.info,  Node: Determine next active subproblem,  Next: Determine previous active subproblem,  Prev: Determine current active subproblem,  Up: The search tree exploring routines

5.4.2.3 Determine next active subproblem
........................................

*Synopsis*:

    glp::ios_next_node tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active subproblem or zero

  *Returns*:

     If the parameter p is zero, the routine returns the reference
     number of the first active subproblem. If the tree is empty, zero
     is returned.  If the parameter p is not zero, it must specify the
     reference number of some active subproblem, in which case the
     routine returns the reference number of the next active
     subproblem. If there is no next active subproblem in the list,
     zero is returned. All subproblems in the active list are ordered
     chronologically, i.e. subproblem A precedes subproblem B if A was
     created before B.

  *Example*:

    > glp::ios_next_node tree 23;



File: pure-glpk.info,  Node: Determine previous active subproblem,  Next: Determine parent active subproblem,  Prev: Determine next active subproblem,  Up: The search tree exploring routines

5.4.2.4 Determine previous active subproblem
............................................

*Synopsis*:

    glp::ios_prev_node tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active subproblem or zero

  *Returns*:

     If the parameter p is zero, the routine returns the reference
     number of the last active subproblem. If the tree is empty, zero
     is returned.  If the parameter p is not zero, it must specify the
     reference number of some active subproblem, in which case the
     routine returns the reference number of the previous active
     subproblem. If there is no previous active subproblem in the list,
     zero is returned. All subproblems in the active list are ordered
     chronologically, i.e. subproblem A precedes subproblem B if A was
     created before B.

  *Example*:

    > glp::ios_prev_node tree 23;



File: pure-glpk.info,  Node: Determine parent active subproblem,  Next: Determine subproblem level,  Prev: Determine previous active subproblem,  Up: The search tree exploring routines

5.4.2.5 Determine parent active subproblem
..........................................

*Synopsis*:

    glp::ios_up_node tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active or inactive subproblem

  *Returns*:

     The routine returns the reference number of its parent subproblem.
     If the specified subproblem is the root of the tree, the routine
     returns zero.

  *Example*:

    > glp::ios_up_node tree 23;



File: pure-glpk.info,  Node: Determine subproblem level,  Next: Determine subproblem local bound,  Prev: Determine parent active subproblem,  Up: The search tree exploring routines

5.4.2.6 Determine subproblem level
..................................

*Synopsis*:

    glp::ios_node_level tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active or inactive subproblem

  *Returns*:

     The routine returns the level of the given subproblem in the
     branch-and-bound tree. (The root subproblem has level 0.)

  *Example*:

    > glp::ios_node_level tree 23;



File: pure-glpk.info,  Node: Determine subproblem local bound,  Next: Find active subproblem with the best local bound,  Prev: Determine subproblem level,  Up: The search tree exploring routines

5.4.2.7 Determine subproblem local bound
........................................

*Synopsis*:

    glp::ios_node_bound tree node

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active or inactive subproblem

  *Returns*:

     The routine returns the local bound for the given subproblem.

  *Example*:

    > glp::ios_node_bound tree 23;



File: pure-glpk.info,  Node: Find active subproblem with the best local bound,  Prev: Determine subproblem local bound,  Up: The search tree exploring routines

5.4.2.8 Find active subproblem with the best local bound
........................................................

*Synopsis*:

    glp::ios_best_node tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the reference number of the active subproblem,
     whose local bound is best (i.e. smallest in case of minimization
     or largest in case of maximization). If the tree is empty, the
     routine returns zero.

  *Example*:

    > glp::ios_best_node tree;



File: pure-glpk.info,  Node: The cut pool routines,  Prev: The search tree exploring routines,  Up: Branch-and-cut API routines

5.4.3 The cut pool routines
---------------------------

* Menu:

* Determine current size of the cut pool::
* Add constraint to the cut pool::
* Remove constraint from the cut pool::
* Remove all constraints from the cut pool::


File: pure-glpk.info,  Node: Determine current size of the cut pool,  Next: Add constraint to the cut pool,  Up: The cut pool routines

5.4.3.1 Determine current size of the cut pool
..............................................

*Synopsis*:

    glp::ios_pool_size tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the current size of the cut pool, that is, the
     number of cutting plane constraints currently added to it.

  *Example*:

    > glp::ios_pool_size tree;



File: pure-glpk.info,  Node: Add constraint to the cut pool,  Next: Remove constraint from the cut pool,  Prev: Determine current size of the cut pool,  Up: The cut pool routines

5.4.3.2 Add constraint to the cut pool
......................................

*Synopsis*:

    glp::ios_add_row tree (name, klass, flags, row, rowtype, rhs)

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          name: symbolic name of the constraint

          klass: specifies the constraint class, which must be either
          zero or a number in the range from 101 to 200. The
          application may use this attribute to distinguish between
          cutting plane constraints of different classes.

          flags: currently is not used and must be zero

          row: list of pairs (colindex, coefficient)

          rowtype: one of the following:

               glp::lo: ∑(aj.xj) ≥ RHS constraint

               glp::up: ∑(aj.xj) ≤ RHS constraint

          rhs: right hand side of the constraint

  *Returns*:

     The routine returns the ordinal number of the cutting plane
     constraint added, which is the new size of the cut pool.

  *Example*:

    > glp::ios_add_row tree ("new_constraint", 101, 0,
                             [(3, 15.0), (4, 6.7), (8, 1.25)], glp::up, 152.7);



File: pure-glpk.info,  Node: Remove constraint from the cut pool,  Next: Remove all constraints from the cut pool,  Prev: Add constraint to the cut pool,  Up: The cut pool routines

5.4.3.3 Remove constraint from the cut pool
...........................................

*Synopsis*:

    glp::ios_del_row tree rowindex

*Parameters*:

          tree: pointer to the branch-and-cut search tree

          rowindex: index of row to be deleted from the cut pool

  *Returns*:

     ()

  *Remark*:

     Note that deleting a constraint from the cut pool leads to changing
     ordinal numbers of other constraints remaining in the pool. New
     ordinal numbers of the remaining constraints are assigned under
     assumption that the original order of constraints is not changed.

  *Example*:

    > glp::ios_del_row tree 5;



File: pure-glpk.info,  Node: Remove all constraints from the cut pool,  Prev: Remove constraint from the cut pool,  Up: The cut pool routines

5.4.3.4 Remove all constraints from the cut pool
................................................

*Synopsis*:

    glp::ios_clear_pool tree

*Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     ()

  *Example*:

    > glp::ios_clear_pool tree;



File: pure-glpk.info,  Node: Graph and network API routines,  Next: Miscellaneous routines,  Prev: Branch-and-cut API routines,  Up: Descriptions of interface functions

5.5 Graph and network API routines
==================================

* Menu:

* Basic graph routines::
* Graph analysis routines::
* Minimum cost flow problem::
* Maximum flow problem::


File: pure-glpk.info,  Node: Basic graph routines,  Next: Graph analysis routines,  Up: Graph and network API routines

5.5.1 Basic graph routines
--------------------------

* Menu:

* Create the GLPK graph object::
* Set the graph name::
* Add vertices to a graph::
* Add arc to a graph::
* Erase content of the GLPK graph object::
* Delete the GLPK graph object::
* Read graph in a plain text format::
* Write graph in a plain text format::


File: pure-glpk.info,  Node: Create the GLPK graph object,  Next: Set the graph name,  Up: Basic graph routines

5.5.1.1 Create the GLPK graph object
....................................

*Synopsis*:

    glp::create_graph v_size a_size

*Parameters*:

          v_size: size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256

          a_size: size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.

  *Returns*:

     The routine returns a pointer to the graph created.

  *Example*:

    > let g = glp::create_graph 32 64;
    > g;
    #<pointer 0x9de7168>



File: pure-glpk.info,  Node: Set the graph name,  Next: Add vertices to a graph,  Prev: Create the GLPK graph object,  Up: Basic graph routines

5.5.1.2 Set the graph name
..........................

*Synopsis*:

    glp::set_graph_name graph name

*Parameters*:

          graph: pointer to the graph object

          name: the graph name, an empty string erases the current name

  *Returns*:

     ()

  *Example*:

    > glp::set_graph_name graph "MyGraph";
    ()



File: pure-glpk.info,  Node: Add vertices to a graph,  Next: Add arc to a graph,  Prev: Set the graph name,  Up: Basic graph routines

5.5.1.3 Add vertices to a graph
...............................

*Synopsis*:

    glp::add_vertices graph count

*Parameters*:

          graph: pointer to the graph object

          count: number of vertices to add

  *Returns*:

     The routine returns the ordinal number of the first new vertex
     added to the graph.

  *Example*:

    > glp::add_vertices graph 5;
    18



File: pure-glpk.info,  Node: Add arc to a graph,  Next: Erase content of the GLPK graph object,  Prev: Add vertices to a graph,  Up: Basic graph routines

5.5.1.4 Add arc to a graph
..........................

*Synopsis*:

    glp::add_arc graph i j

*Parameters*:

          graph: pointer to the graph object

          i: index of the tail vertex

          j: index of the head vertex

  *Returns*:

     ()

  *Example*:

    > glp::add_arc graph 7 12;
    ()



File: pure-glpk.info,  Node: Erase content of the GLPK graph object,  Next: Delete the GLPK graph object,  Prev: Add arc to a graph,  Up: Basic graph routines

5.5.1.5 Erase content of the GLPK graph object
..............................................

*Synopsis*:

    glp::erase_graph graph v_size a_size

*Parameters*:

          graph: pointer to the graph object

          v_size: size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256

          a_size: size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.

  *Returns*:

     ()

  *Remark*:

     The routine reinitialises the graph object. Its efect is
     equivalent to calling delete_graph followed by a call to
     create_graph.

  *Example*:

    > glp::erase_graph graph 16 34;
    ()



File: pure-glpk.info,  Node: Delete the GLPK graph object,  Next: Read graph in a plain text format,  Prev: Erase content of the GLPK graph object,  Up: Basic graph routines

5.5.1.6 Delete the GLPK graph object
....................................

*Synopsis*:

    glp::delete_graph graph

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

     ()

  *Remark*:

     The routine destroys the graph object and invalidates the pointer.
     This is done automatically when the graph is not needed anymore,
     the routine need not be usually called.

  *Example*:

    > glp::delete_graph graph
    ()



File: pure-glpk.info,  Node: Read graph in a plain text format,  Next: Write graph in a plain text format,  Prev: Delete the GLPK graph object,  Up: Basic graph routines

5.5.1.7 Read graph in a plain text format
.........................................

*Synopsis*:

    glp::read_graph graph filename

*Parameters*:

          graph: pointer to the graph object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_graph graph "graph_data.txt";
    0



File: pure-glpk.info,  Node: Write graph in a plain text format,  Prev: Read graph in a plain text format,  Up: Basic graph routines

5.5.1.8 Write graph in a plain text format
..........................................

*Synopsis*:

    glp::write_graph graph filename

*Parameters*:

          graph: pointer to the graph object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::write_graph graph "graph_data.txt";
    0



File: pure-glpk.info,  Node: Graph analysis routines,  Next: Minimum cost flow problem,  Prev: Basic graph routines,  Up: Graph and network API routines

5.5.2 Graph analysis routines
-----------------------------

* Menu:

* Find all weakly connected components of a graph::
* Find all strongly connected components of a graph::


File: pure-glpk.info,  Node: Find all weakly connected components of a graph,  Next: Find all strongly connected components of a graph,  Up: Graph analysis routines

5.5.2.1 Find all weakly connected components of a graph
.......................................................

*Synopsis*:

    glp::weak_comp graph v_num

*Parameters*:

          graph: pointer to the graph object

          v_num: offset of the field of type int in the vertex data
          block, to which the routine stores the number of a weakly
          connected component containing that vertex - if v_num < 0, no
          component numbers are stored

  *Returns*:

     The routine returns the total number of components found.

  *Example*:

    > glp::weak_comp graph 16;
    3



File: pure-glpk.info,  Node: Find all strongly connected components of a graph,  Prev: Find all weakly connected components of a graph,  Up: Graph analysis routines

5.5.2.2 Find all strongly connected components of a graph
.........................................................

*Synopsis*:

    glp::strong_comp graph v_num

*Parameters*:

          graph: pointer to the graph object

          v_num: offset of the field of type int in the vertex data
          block, to which the routine stores the number of a strongly
          connected component containing that vertex - if v_num < 0, no
          component numbers are stored

  *Returns*:

  The routine returns the total number of components found.

  *Example*:

    > glp::strong_comp graph 16;
    4



File: pure-glpk.info,  Node: Minimum cost flow problem,  Next: Maximum flow problem,  Prev: Graph analysis routines,  Up: Graph and network API routines

5.5.3 Minimum cost flow problem
-------------------------------

* Menu:

* Read minimum cost flow problem data in DIMACS format::
* Write minimum cost flow problem data in DIMACS format::
* Convert minimum cost flow problem to LP::
* Solve minimum cost flow problem with out-of-kilter algorithm::
* Klingman's network problem generator::
* Grid-like network problem generator::


File: pure-glpk.info,  Node: Read minimum cost flow problem data in DIMACS format,  Next: Write minimum cost flow problem data in DIMACS format,  Up: Minimum cost flow problem

5.5.3.1 Read minimum cost flow problem data in DIMACS format
............................................................

*Synopsis*:

    glp::read_mincost graph v_rhs a_low a_cap a_cost filename

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, the value is not stored

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, the lower bound is not stored

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0, the upper bound
          is not stored

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, the cost is not stored

          fname: the name of a text file to be read in - if the file
          name name ends with the suffix ‘.gz’, the file is assumed to
          be compressed, in which case the routine decompresses it “on
          the fly”

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::read_mincost graph 0 8 16 24 "graphdata.txt";
    0



File: pure-glpk.info,  Node: Write minimum cost flow problem data in DIMACS format,  Next: Convert minimum cost flow problem to LP,  Prev: Read minimum cost flow problem data in DIMACS format,  Up: Minimum cost flow problem

5.5.3.2 Write minimum cost flow problem data in DIMACS format
.............................................................

*Synopsis*:

    glp::write_mincost graph v_rhs a_low a_cap a_cost fname

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, the value is not stored

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, the lower bound is not stored

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0, the upper bound
          is not stored

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, the cost is not stored

          fname: the name of a text file to be written out - if the
          file name name ends with the suffix ‘.gz’, the file is
          assumed to be compressed, in which case the routine
          compresses it “on the fly”

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

    > glp::write_mincost graph 0 8 16 24 "graphdata.txt";
    0



File: pure-glpk.info,  Node: Convert minimum cost flow problem to LP,  Next: Solve minimum cost flow problem with out-of-kilter algorithm,  Prev: Write minimum cost flow problem data in DIMACS format,  Up: Minimum cost flow problem

5.5.3.3 Convert minimum cost flow problem to LP
...............................................

*Synopsis*:

    glp::mincost_lp lp graph names v_rhs a_low a_cap a_cost

*Parameters*:

          lp: pointer to the LP problem object

          graph: pointer to the graph object

          names: one of the following:

               glp::on: assign symbolic names of the graph object
               components to symbolic names of the LP problem object
               components

               glp::off: no symbolic names are assigned

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, it is assumed lij = 0 for all arcs

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij
          = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

  *Returns*:

     ()

  *Example*:

    > glp::mincost_lp lp graph glp::on 0 8 16 24;
    ()



File: pure-glpk.info,  Node: Solve minimum cost flow problem with out-of-kilter algorithm,  Next: Klingman's network problem generator,  Prev: Convert minimum cost flow problem to LP,  Up: Minimum cost flow problem

5.5.3.4 Solve minimum cost flow problem with out-of-kilter algorithm
....................................................................

*Synopsis*:

    glp::mincost_okalg graph v_rhs a_low a_cap a_cost a_x v_pi

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, it is assumed lij = 0 for all arcs

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij
          = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

          a_x: offset of the field of type double in the arc data block,
          to which the routine stores xij, the arc flow found - if a_x
          < 0, the arc flow value is not stored

          v_pi: specifies an offset of the field of type double in the
          vertex data block, to which the routine stores pi, the node
          potential, which is the Lagrange multiplier for the
          corresponding flow conservation equality constraint

  *Remark*:

     Note that all solution components (the objective value, arc flows,
     and node potentials) computed by the routine are always
     integer-valued.

  *Returns*:

     The function returns a tuple in the form *(code, obj)*, where
     *code* is one of the following

          glp::ok: optimal solution found

          glp::enopfs: no (primal) feasible solution exists

          glp::edata: unable to start the search, because some problem
          data are either not integer-valued or out of range; this code
          is also returned if the total supply, which is the sum of bi
          over all source nodes (nodes with bi > 0), exceeds INT_MAX

          glp::erange: the search was prematurely terminated because of
          integer overflow

          glp::efail: an error has been detected in the program logic -
          if this code is returned for your problem instance, please
          report to <<bug-glpk@gnu.org>>

     and *obj* is value of the objective function.

  *Example*:

    > glp::mincost_okalg graph 0 8 16 24 32 40;
    (glp::ok, 15)



File: pure-glpk.info,  Node: Klingman's network problem generator,  Next: Grid-like network problem generator,  Prev: Solve minimum cost flow problem with out-of-kilter algorithm,  Up: Minimum cost flow problem

5.5.3.5 Klingman's network problem generator
............................................

*Synopsis*:

    glp::netgen graph v_rhs a_cap a_cost parameters

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij
          = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

          parameters: tuple of exactly 15 integer numbers with the
          following meaning:

               parm[1]: iseed 8-digit positive random number seed

               parm[2]: nprob 8-digit problem id number

               parm[3]: nodes total number of nodes

               parm[4]: nsorc total number of source nodes (including
               transshipment nodes)

               parm[5]: nsink total number of sink nodes (including
               transshipment nodes)

               parm[6]: iarcs number of arc

               parm[7]: mincst minimum cost for arcs

               parm[8]: maxcst maximum cost for arcs

               parm[9]: itsup total supply

               parm[10]: ntsorc number of transshipment source nodes

               parm[11]: ntsink number of transshipment sink nodes

               parm[12]: iphic percentage of skeleton arcs to be given
               the maximum cost

               parm[13]: ipcap percentage of arcs to be capacitated

               parm[14]: mincap minimum upper bound for capacitated arcs

               parm[15]: maxcap maximum upper bound for capacitated arcs

  *Returns*:

     *0* if the instance was successfully generated, nonzero otherwise

  *Example*:

    > glp::netgen graph 0 8 16 (12345678, 87654321, 20, 12, 8,
                                25, 5, 20, 300, 6, 5, 15, 100, 1, 30);
    0



File: pure-glpk.info,  Node: Grid-like network problem generator,  Prev: Klingman's network problem generator,  Up: Minimum cost flow problem

5.5.3.6 Grid-like network problem generator
...........................................

*Synopsis*:

    glp::gridgen graph v_rhs a_cap a_cost parameters

*Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand
          value - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij
          = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

          parameters: tuple of exactly 14 integer numbers with the
          following meaning:

               parm[1]: two-ways arcs indicator:

                   *1:* if links in both direction should be generated 
                   *0:* otherwise 

               parm[2]: random number seed (a positive integer)

               parm[3]: number of nodes (the number of nodes generated
               might be slightly different to make the network a grid)

               parm[4]: grid width

               parm[5]: number of sources

               parm[6]: number of sinks

               parm[7]: average degree

               parm[8]: total flow

               parm[9]: distribution of arc costs:

                   *1:* uniform 
                   *2:* exponential 

               parm[10]: lower bound for arc cost (uniform), 100
               lambda¸ (exponential)

               parm[11]: upper bound for arc cost (uniform), not used
               (exponential)

               parm[12]: distribution of arc capacities:

                   *1:* uniform 
                   *2:* exponential 

               parm[13]: lower bound for arc capacity (uniform), 100
               lambda (exponential)

               parm[14]: upper bound for arc capacity (uniform), not
               used (exponential)

  *Returns*:

     *0* if the instance was successfully generated, nonzero otherwise

  *Example*:

    > glp::gridgen graph 0 8 16 (1, 123, 20, 4, 7, 5, 3, 300, 1, 1, 5, 1, 5, 30);
    0



File: pure-glpk.info,  Node: Maximum flow problem,  Prev: Minimum cost flow problem,  Up: Graph and network API routines

5.5.4 Maximum flow problem
--------------------------

* Menu:

* Read maximum cost flow problem data in DIMACS format::
* Write maximum cost flow problem data in DIMACS format::
* Convert maximum flow problem to LP::
* Solve maximum flow problem with Ford-Fulkerson algorithm::
* Goldfarb's maximum flow problem generator::


File: pure-glpk.info,  Node: Read maximum cost flow problem data in DIMACS format,  Next: Write maximum cost flow problem data in DIMACS format,  Up: Maximum flow problem

5.5.4.1 Read maximum cost flow problem data in DIMACS format
............................................................

*Synopsis*:

    glp::read_maxflow graph a_cap filename

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Write maximum cost flow problem data in DIMACS format,  Next: Convert maximum flow problem to LP,  Prev: Read maximum cost flow problem data in DIMACS format,  Up: Maximum flow problem

5.5.4.2 Write maximum cost flow problem data in DIMACS format
.............................................................

*Synopsis*:

    glp::write_maxflow graph s t a_cap filename

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Convert maximum flow problem to LP,  Next: Solve maximum flow problem with Ford-Fulkerson algorithm,  Prev: Write maximum cost flow problem data in DIMACS format,  Up: Maximum flow problem

5.5.4.3 Convert maximum flow problem to LP
..........................................

*Synopsis*:

    glp::maxflow_lp lp graph names s t a_cap

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Solve maximum flow problem with Ford-Fulkerson algorithm,  Next: Goldfarb's maximum flow problem generator,  Prev: Convert maximum flow problem to LP,  Up: Maximum flow problem

5.5.4.4 Solve maximum flow problem with Ford-Fulkerson algorithm
................................................................

*Synopsis*:

    glp::maxflow_ffalg graph s t a_cap a_x v_cut

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Goldfarb's maximum flow problem generator,  Prev: Solve maximum flow problem with Ford-Fulkerson algorithm,  Up: Maximum flow problem

5.5.4.5 Goldfarb's maximum flow problem generator
.................................................

*Synopsis*:

    glp::rmfgen graph a_cap parameters

*Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

    >



File: pure-glpk.info,  Node: Miscellaneous routines,  Prev: Graph and network API routines,  Up: Descriptions of interface functions

5.6 Miscellaneous routines
==========================

* Menu:

* Library environment routines::


File: pure-glpk.info,  Node: Library environment routines,  Up: Miscellaneous routines

5.6.1 Library environment routines
----------------------------------

* Menu:

* Determine library version::
* Enable/disable terminal output::
* Enable/disable the terminal hook routine::
* Get memory usage information::
* Set memory usage limit::
* Free GLPK library environment::


File: pure-glpk.info,  Node: Determine library version,  Next: Enable/disable terminal output,  Up: Library environment routines

5.6.1.1 Determine library version
.................................

*Synopsis*:

    `glp::version

*Parameters*:

     none

  *Returns*:

     GLPK library version

  *Example*:

    > glp::version;
    "4.38"



File: pure-glpk.info,  Node: Enable/disable terminal output,  Next: Enable/disable the terminal hook routine,  Prev: Determine library version,  Up: Library environment routines

5.6.1.2 Enable/disable terminal output
......................................

*Synopsis*:

    glp::term_out switch

*Parameters*:

          switch: one of the following:

               glp::on: enable terminal output from GLPK routines

               glp::off: disable terminal output from GLPK routines

  *Returns*:

     `()'

  *Example*:

    > glp::term_out glp:off;
    ()



File: pure-glpk.info,  Node: Enable/disable the terminal hook routine,  Next: Get memory usage information,  Prev: Enable/disable terminal output,  Up: Library environment routines

5.6.1.3 Enable/disable the terminal hook routine
................................................

*Synopsis*:

    glp::term_hook switch info

*Parameters*:

          switch: one of the following:

               glp::on: use the terminal callback function

               glp::off: don't use the terminal callback function

          info: pointer to a memory block which can be used for passing
          additional information to the terminal callback function

  *Returns*:

     `()'

  *Example*:

    > glp::term_hook glp::on NULL;
    ()



File: pure-glpk.info,  Node: Get memory usage information,  Next: Set memory usage limit,  Prev: Enable/disable the terminal hook routine,  Up: Library environment routines

5.6.1.4 Get memory usage information
....................................

*Synopsis*:

    glp::mem_usage

*Parameters*:

     none

  *Returns*:

     tuple consisting of four numbers:

             * `count' (int) - the number of currently allocated memory
               blocks

             * `cpeak' (int) - the peak value of `count' reached since
               the initialization of the GLPK library environment

             * `total' (bigint) - the total amount, in bytes, of
               currently allocated memory blocks

             * `tpeak' (bigint) - the peak value of `total' reached
               since the initialization of the GLPK library envirionment

  *Example*:

    > glp::mem_usage;
    7,84,10172L,45304L



File: pure-glpk.info,  Node: Set memory usage limit,  Next: Free GLPK library environment,  Prev: Get memory usage information,  Up: Library environment routines

5.6.1.5 Set memory usage limit
..............................

*Synopsis*:

    glp::mem_limit limit

*Parameters*:

          limit: memory limit in megabytes

  *Returns*:

     `()'

  *Example*:

    > glp::mem_limit 200;
    ()



File: pure-glpk.info,  Node: Free GLPK library environment,  Prev: Set memory usage limit,  Up: Library environment routines

5.6.1.6 Free GLPK library environment
.....................................

*Synopsis*:

    glp::free_env

*Parameters*:

     none

  *Returns*:

     `()'

  *Example*:

    > glp_free_env;
    ()



File: pure-glpk.info,  Node: Index,  Prev: Descriptions of interface functions,  Up: Top

Index
*****

 [index ]
* Menu:


Tag Table:
Node: Top294
Node: Installation1782
Ref: installation1872
Ref: 01872
Ref: pure-glpk-glpk-interface-for-the-pure-programming-language1872
Ref: 11872
Node: Error Handling3478
Ref: error handling3597
Ref: 23597
Ref: error-handling3597
Node: Further Information and Examples5297
Ref: further information and examples5425
Ref: 35425
Ref: further-information-and-examples5425
Node: Interface description5692
Ref: interface description5841
Ref: 45841
Ref: interface-description5841
Node: Descriptions of interface functions6428
Ref: descriptions of interface functions6550
Ref: 56550
Ref: descriptions-of-interface-functions6550
Node: Basic API routines6805
Ref: basic api routines6927
Ref: 66927
Ref: basic-api-routines6927
Node: Problem creating and modifying routines7288
Ref: problem creating and modifying routines7421
Ref: 77421
Ref: problem-creating-and-modifying-routines7421
Node: Create the GLPK problem object8282
Ref: create the glpk problem object8420
Ref: 88420
Ref: create-the-glpk-problem-object8420
Node: Set the problem name8697
Ref: set the problem name8862
Ref: 98862
Ref: set-the-problem-name8862
Node: Set objective name9154
Ref: set objective name9316
Ref: a9316
Ref: set-objective-name9316
Node: Set the objective direction9600
Ref: set the objective direction9769
Ref: b9769
Ref: set-the-objective-direction9769
Node: Add new rows to the problem10151
Ref: add new rows to the problem10332
Ref: c10332
Ref: add-new-rows-to-the-problem10332
Node: Add new columns to the problem10690
Ref: add new columns to the problem10860
Ref: d10860
Ref: add-new-columns-to-the-problem10860
Node: Set the row name11230
Ref: set the row name11392
Ref: e11392
Ref: set-the-row-name11392
Node: Set the column name11722
Ref: set the column name11875
Ref: f11875
Ref: set-the-column-name11875
Node: Set change row bounds12220
Ref: set change row bounds12381
Ref: 1012381
Ref: set-change-row-bounds12381
Node: Set change column bounds13229
Ref: set change column bounds13420
Ref: 1113420
Ref: set-change-column-bounds13420
Node: Set change objective coefficient or constant term14299
Ref: set change objective coefficient or constant term14495
Ref: 1214495
Ref: set-change-objective-coefficient-or-constant-term14495
Node: Load or replace matrix row14930
Ref: load or replace matrix row15131
Ref: 1315131
Ref: load-or-replace-matrix-row15131
Node: Load or replace matrix column15665
Ref: load or replace matrix column15857
Ref: 1415857
Ref: load-or-replace-matrix-column15857
Node: Load or replace the whole problem matrix16397
Ref: load or replace the whole problem matrix16608
Ref: 1516608
Ref: load-or-replace-the-whole-problem-matrix16608
Node: Check for duplicate elements in sparse matrix17152
Ref: check for duplicate elements in sparse matrix17372
Ref: 1617372
Ref: check-for-duplicate-elements-in-sparse-matrix17372
Node: Sort elements of the constraint matrix18252
Ref: sort elements of the constraint matrix18459
Ref: 1718459
Ref: sort-elements-of-the-constraint-matrix18459
Node: Delete rows from the matrix18732
Ref: delete rows from the matrix18924
Ref: 1818924
Ref: delete-rows-from-the-matrix18924
Node: Delete columns from the matrix19571
Ref: delete columns from the matrix19789
Ref: 1919789
Ref: delete-columns-from-the-matrix19789
Node: Copy the whole content of the GLPK problem object to another one20457
Ref: copy the whole content of the glpk problem object to another one20691
Ref: 1a20691
Ref: copy-the-whole-content-of-the-glpk-problem-object-to-another-one20691
Node: Erase all data from the GLPK problem object21319
Ref: erase all data from the glpk problem object21553
Ref: 1b21553
Ref: erase-all-data-from-the-glpk-problem-object21553
Node: Delete the GLPK problem object21892
Ref: delete the glpk problem object22053
Ref: 1c22053
Ref: delete-the-glpk-problem-object22053
Node: Problem retrieving routines22370
Ref: problem retrieving routines22545
Ref: 1d22545
Ref: problem-retrieving-routines22545
Node: Get the problem name23099
Ref: get the problem name23217
Ref: 1e23217
Ref: get-the-problem-name23217
Node: Get the objective name23486
Ref: get the objective name23640
Ref: 1f23640
Ref: get-the-objective-name23640
Node: Get the objective direction23909
Ref: get the objective direction24061
Ref: 2024061
Ref: get-the-objective-direction24061
Node: Get number of rows24411
Ref: get number of rows24562
Ref: 2124562
Ref: get-number-of-rows24562
Node: Get number of columns24819
Ref: get number of columns24960
Ref: 2224960
Ref: get-number-of-columns24960
Node: Get name of a row25235
Ref: get name of a row25378
Ref: 2325378
Ref: get-name-of-a-row25378
Node: Get name of a column25681
Ref: get name of a column25815
Ref: 2425815
Ref: get-name-of-a-column25815
Node: Get row type26134
Ref: get row type26270
Ref: 2526270
Ref: get-row-type26270
Node: Get row lower bound26793
Ref: get row lower bound26928
Ref: 2626928
Ref: get-row-lower-bound26928
Node: Get row upper bound27297
Ref: get row upper bound27435
Ref: 2727435
Ref: get-row-upper-bound27435
Node: Get column type27806
Ref: get column type27947
Ref: 2827947
Ref: get-column-type27947
Node: Get column lower bound28481
Ref: get column lower bound28625
Ref: 2928625
Ref: get-column-lower-bound28625
Node: Get column upper bound29029
Ref: get column upper bound29183
Ref: 2a29183
Ref: get-column-upper-bound29183
Node: Get objective coefficient29569
Ref: get objective coefficient29735
Ref: 2b29735
Ref: get-objective-coefficient29735
Node: Get number of nonzero coefficients30140
Ref: get number of nonzero coefficients30321
Ref: 2c30321
Ref: get-number-of-nonzero-coefficients30321
Node: Retrive a row from the problem matrix30634
Ref: retrive a row from the problem matrix30830
Ref: 2d30830
Ref: retrive-a-row-from-the-problem-matrix30830
Node: Retrive a column from the problem matrix31249
Ref: retrive a column from the problem matrix31402
Ref: 2e31402
Ref: retrive-a-column-from-the-problem-matrix31402
Node: Row and column searching routines31833
Ref: row and column searching routines31993
Ref: 2f31993
Ref: row-and-column-searching-routines31993
Node: Create index for searching rows and columns by their names32273
Ref: create index for searching rows and columns by their names32438
Ref: 3032438
Ref: create-index-for-searching-rows-and-columns-by-their-names32438
Node: Find a row number by name32751
Ref: find a row number by name32953
Ref: 3132953
Ref: find-a-row-number-by-name32953
Node: Find a column number by name33370
Ref: find a column number by name33572
Ref: 3233572
Ref: find-a-column-number-by-name33572
Node: Delete index for searching rows and columns by their names34002
Ref: delete index for searching rows and columns by their names34170
Ref: 3334170
Ref: delete-index-for-searching-rows-and-columns-by-their-names34170
Node: Problem scaling routines34483
Ref: problem scaling routines34646
Ref: 3434646
Ref: problem-scaling-routines34646
Node: Set the row scale factor34935
Ref: set the row scale factor35059
Ref: 3535059
Ref: set-the-row-scale-factor35059
Node: Set the column scale factor35404
Ref: set the column scale factor35566
Ref: 3635566
Ref: set-the-column-scale-factor35566
Node: Retrieve the row scale factor35919
Ref: retrieve the row scale factor36089
Ref: 3736089
Ref: retrieve-the-row-scale-factor36089
Node: Retrieve the column scale factor36407
Ref: retrieve the column scale factor36600
Ref: 3836600
Ref: retrieve-the-column-scale-factor36600
Node: Scale the problem data according to supplied flags36929
Ref: scale the problem data according to supplied flags37117
Ref: 3937117
Ref: scale-the-problem-data-according-to-supplied-flags37117
Node: Unscale the problem data37886
Ref: unscale the problem data38033
Ref: 3a38033
Ref: unscale-the-problem-data38033
Node: LP basis constructing routines38278
Ref: lp basis constructing routines38431
Ref: 3b38431
Ref: lp-basis-constructing-routines38431
Node: Set the row status38675
Ref: set the row status38793
Ref: 3c38793
Ref: set-the-row-status38793
Node: Set the column status39717
Ref: set the column status39876
Ref: 3d39876
Ref: set-the-column-status39876
Node: Construct standard problem basis40746
Ref: construct standard problem basis40919
Ref: 3e40919
Ref: construct-standard-problem-basis40919
Node: Construct advanced problem basis41174
Ref: construct advanced problem basis41357
Ref: 3f41357
Ref: construct-advanced-problem-basis41357
Node: Construct Bixby's problem basis41612
Ref: construct bixby's problem basis41754
Ref: 4041754
Ref: construct-bixby-s-problem-basis41754
Node: Simplex method routines42007
Ref: simplex method routines42166
Ref: 4142166
Ref: simplex-method-routines42166
Node: Solve the LP problem using simplex method42795
Ref: solve the lp problem using simplex method42970
Ref: 4242970
Ref: solve-the-lp-problem-using-simplex-method42970
Node: Solve the LP problem using simplex method in exact arithmetics48985
Ref: solve the lp problem using simplex method in exact arithmetics49210
Ref: 4349210
Ref: solve-the-lp-problem-using-simplex-method-in-exact-arithmetics49210
Node: Retrieve generic status of basic solution51429
Ref: retrieve generic status of basic solution51655
Ref: 4451655
Ref: retrieve-generic-status-of-basic-solution51655
Node: Retrieve generic status of primal solution52226
Ref: retrieve generic status of primal solution52430
Ref: 4552430
Ref: retrieve-generic-status-of-primal-solution52430
Node: Retrieve generic status of dual solution52952
Ref: retrieve generic status of dual solution53155
Ref: 4653155
Ref: retrieve-generic-status-of-dual-solution53155
Node: Retrieve value of the objective function53665
Ref: retrieve value of the objective function53867
Ref: 4753867
Ref: retrieve-value-of-the-objective-function53867
Node: Retrieve generic status of a row variable54182
Ref: retrieve generic status of a row variable54369
Ref: 4854369
Ref: retrieve-generic-status-of-a-row-variable54369
Node: Retrieve row primal value54964
Ref: retrieve row primal value55134
Ref: 4955134
Ref: retrieve-row-primal-value55134
Node: Retrieve row dual value55469
Ref: retrieve row dual value55642
Ref: 4a55642
Ref: retrieve-row-dual-value55642
Node: Retrieve generic status of a column variable55966
Ref: retrieve generic status of a column variable56142
Ref: 4b56142
Ref: retrieve-generic-status-of-a-column-variable56142
Node: Retrieve column primal value56748
Ref: retrieve column primal value56927
Ref: 4c56927
Ref: retrieve-column-primal-value56927
Node: Retrieve column dual value57285
Ref: retrieve column dual value57460
Ref: 4d57460
Ref: retrieve-column-dual-value57460
Node: Determine variable causing unboundedness57799
Ref: determine variable causing unboundedness57937
Ref: 4e57937
Ref: determine-variable-causing-unboundedness57937
Node: Interior-point method routines59088
Ref: interior-point method routines59251
Ref: 4f59251
Ref: interior-point-method-routines59251
Node: Solve the LP problem using interior-point method59735
Ref: solve the lp problem using interior-point method59904
Ref: 5059904
Ref: solve-the-lp-problem-using-interior-point-method59904
Node: Retrieve status of interior-point solution62893
Ref: retrieve status of interior-point solution63135
Ref: 5163135
Ref: retrieve-status-of-interior-point-solution63135
Node: Retrieve the objective function value of interior-point solution63676
Ref: retrieve the objective function value of interior-point solution63922
Ref: 5263922
Ref: retrieve-the-objective-function-value-of-interior-point-solution63922
Node: Retrieve row primal value of interior-point solution64306
Ref: retrieve row primal value of interior-point solution64560
Ref: 5364560
Ref: retrieve-row-primal-value-of-interior-point-solution64560
Node: Retrieve row dual value of interior-point solution64957
Ref: retrieve row dual value of interior-point solution65202
Ref: 5465202
Ref: retrieve-row-dual-value-of-interior-point-solution65202
Node: Retrieve column primal value of interior-point solution65598
Ref: retrieve column primal value of interior-point solution65844
Ref: 5565844
Ref: retrieve-column-primal-value-of-interior-point-solution65844
Node: Retrieve column dual value of interior-point solution66253
Ref: retrieve column dual value of interior-point solution66440
Ref: 5666440
Ref: retrieve-column-dual-value-of-interior-point-solution66440
Node: Mixed integer programming routines66849
Ref: mixed integer programming routines67008
Ref: 5767008
Ref: mixed-integer-programming-routines67008
Node: Set column kind67452
Ref: set column kind67570
Ref: 5867570
Ref: set-column-kind67570
Node: Retrieve column kind68048
Ref: retrieve column kind68209
Ref: 5968209
Ref: retrieve-column-kind68209
Node: Retrieve number of integer columns68626
Ref: retrieve number of integer columns68805
Ref: 5a68805
Ref: retrieve-number-of-integer-columns68805
Node: Retrieve number of binary columns69114
Ref: retrieve number of binary columns69322
Ref: 5b69322
Ref: retrieve-number-of-binary-columns69322
Node: Solve the MIP problem using branch-and-cut method69601
Ref: solve the mip problem using branch-and-cut method69806
Ref: 5c69806
Ref: solve-the-mip-problem-using-branch-and-cut-method69806
Node: Retrieve status of mip solution78671
Ref: retrieve status of mip solution78896
Ref: 5d78896
Ref: retrieve-status-of-mip-solution78896
Node: Retrieve the objective function value of mip solution79566
Ref: retrieve the objective function value of mip solution79776
Ref: 5e79776
Ref: retrieve-the-objective-function-value-of-mip-solution79776
Node: Retrieve row value of mip solution80116
Ref: retrieve row value of mip solution80332
Ref: 5f80332
Ref: retrieve-row-value-of-mip-solution80332
Node: Retrieve column value of mip solution80675
Ref: retrieve column value of mip solution80829
Ref: 6080829
Ref: retrieve-column-value-of-mip-solution80829
Node: Additional routines81184
Ref: additional routines81304
Ref: 6181304
Ref: additional-routines81304
Node: Check Karush-Kuhn-Tucker conditions81407
Ref: check karush-kuhn-tucker conditions81501
Ref: 6281501
Ref: check-karush-kuhn-tucker-conditions81501
Node: Utility API routines83792
Ref: utility api routines83944
Ref: 6383944
Ref: utility-api-routines83944
Node: Problem data reading/writing routines84126
Ref: problem data reading/writing routines84260
Ref: 6484260
Ref: problem-data-reading-writing-routines84260
Node: Read LP problem data from a MPS file84610
Ref: read lp problem data from a mps file84769
Ref: 6584769
Ref: read-lp-problem-data-from-a-mps-file84769
Node: Write LP problem data into a MPS file85650
Ref: write lp problem data into a mps file85856
Ref: 6685856
Ref: write-lp-problem-data-into-a-mps-file85856
Node: Read LP problem data from a CPLEX file86690
Ref: read lp problem data from a cplex file86899
Ref: 6786899
Ref: read-lp-problem-data-from-a-cplex-file86899
Node: Write LP problem data into a CPLEX file87552
Ref: write lp problem data into a cplex file87759
Ref: 6887759
Ref: write-lp-problem-data-into-a-cplex-file87759
Node: Read LP problem data in GLPK format88406
Ref: read lp problem data in glpk format88611
Ref: 6988611
Ref: read-lp-problem-data-in-glpk-format88611
Node: Write LP problem data in GLPK format89268
Ref: write lp problem data in glpk format89425
Ref: 6a89425
Ref: write-lp-problem-data-in-glpk-format89425
Node: Routines for MathProg models90076
Ref: routines for mathprog models90260
Ref: 6b90260
Ref: routines-for-mathprog-models90260
Node: Create the MathProg translator object90587
Ref: create the mathprog translator object90733
Ref: 6c90733
Ref: create-the-mathprog-translator-object90733
Node: Read and translate model section91041
Ref: read and translate model section91227
Ref: 6d91227
Ref: read-and-translate-model-section91227
Node: Read and translate data section91918
Ref: read and translate data section92085
Ref: 6e92085
Ref: read-and-translate-data-section92085
Node: Generate the model92557
Ref: generate the model92729
Ref: 6f92729
Ref: generate-the-model92729
Node: Build problem instance from the model93247
Ref: build problem instance from the model93407
Ref: 7093407
Ref: build-problem-instance-from-the-model93407
Node: Postsolve the model93762
Ref: postsolve the model93941
Ref: 7193941
Ref: postsolve-the-model93941
Node: Delete the MathProg translator object94564
Ref: delete the mathprog translator object94697
Ref: 7294697
Ref: delete-the-mathprog-translator-object94697
Node: Problem solution reading/writing routines94996
Ref: problem solution reading/writing routines95134
Ref: 7395134
Ref: problem-solution-reading-writing-routines95134
Node: Write basic solution in printable format95684
Ref: write basic solution in printable format95850
Ref: 7495850
Ref: write-basic-solution-in-printable-format95850
Node: Read basic solution from a text file96281
Ref: read basic solution from a text file96493
Ref: 7596493
Ref: read-basic-solution-from-a-text-file96493
Node: Write basic solution into a text file96941
Ref: write basic solution into a text file97146
Ref: 7697146
Ref: write-basic-solution-into-a-text-file97146
Node: Print sensitivity analysis report97599
Ref: print sensitivity analysis report97817
Ref: 7797817
Ref: print-sensitivity-analysis-report97817
Node: Write interior-point solution in printable format98751
Ref: write interior-point solution in printable format98977
Ref: 7898977
Ref: write-interior-point-solution-in-printable-format98977
Node: Read interior-point solution from a text file99435
Ref: read interior-point solution from a text file99674
Ref: 7999674
Ref: read-interior-point-solution-from-a-text-file99674
Node: Write interior-point solution into a text file100149
Ref: write interior-point solution into a text file100377
Ref: 7a100377
Ref: write-interior-point-solution-into-a-text-file100377
Node: Write MIP solution in printable format100857
Ref: write mip solution in printable format101074
Ref: 7b101074
Ref: write-mip-solution-in-printable-format101074
Node: Read MIP solution from a text file101499
Ref: read mip solution from a text file101705
Ref: 7c101705
Ref: read-mip-solution-from-a-text-file101705
Node: Write MIP solution into a text file102147
Ref: write mip solution into a text file102306
Ref: 7d102306
Ref: write-mip-solution-into-a-text-file102306
Node: Advanced API routines102755
Ref: advanced api routines102916
Ref: 7e102916
Ref: advanced-api-routines102916
Node: LP basis routines103030
Ref: lp basis routines103141
Ref: 7f103141
Ref: lp-basis-routines103141
Node: Check whether basis factorization exists103640
Ref: check whether basis factorization exists103777
Ref: 80103777
Ref: check-whether-basis-factorization-exists103777
Node: Compute the basis factorization104184
Ref: compute the basis factorization104380
Ref: 81104380
Ref: compute-the-basis-factorization104380
Node: Check whether basis factorization has been updated105137
Ref: check whether basis factorization has been updated105327
Ref: 82105327
Ref: check-whether-basis-factorization-has-been-updated105327
Node: Get basis factorization parameters105774
Ref: get basis factorization parameters105970
Ref: 83105970
Ref: get-basis-factorization-parameters105970
Node: Change basis factorization parameters109020
Ref: change basis factorization parameters109203
Ref: 84109203
Ref: change-basis-factorization-parameters109203
Node: Retrieve the basis header information112565
Ref: retrieve the basis header information112752
Ref: 85112752
Ref: retrieve-the-basis-header-information112752
Node: Retrieve row index in the basis header113367
Ref: retrieve row index in the basis header113558
Ref: 86113558
Ref: retrieve-row-index-in-the-basis-header113558
Node: Retrieve column index in the basis header114249
Ref: retrieve column index in the basis header114433
Ref: 87114433
Ref: retrieve-column-index-in-the-basis-header114433
Node: Perform forward transformation115167
Ref: perform forward transformation115344
Ref: 88115344
Ref: perform-forward-transformation115344
Node: Perform backward transformation115928
Ref: perform backward transformation116080
Ref: 89116080
Ref: perform-backward-transformation116080
Node: Warm up LP basis116668
Ref: warm up lp basis116781
Ref: 8a116781
Ref: warm-up-lp-basis116781
Node: Simplex tableau routines117431
Ref: simplex tableau routines117542
Ref: 8b117542
Ref: simplex-tableau-routines117542
Node: Compute row of the tableau117918
Ref: compute row of the tableau118046
Ref: 8c118046
Ref: compute-row-of-the-tableau118046
Node: Compute column of the tableau118848
Ref: compute column of the tableau119019
Ref: 8d119019
Ref: compute-column-of-the-tableau119019
Node: Transform explicitly specified row119878
Ref: transform explicitly specified row120060
Ref: 8e120060
Ref: transform-explicitly-specified-row120060
Node: Transform explicitly specified column120998
Ref: transform explicitly specified column121176
Ref: 8f121176
Ref: transform-explicitly-specified-column121176
Node: Perform primal ratio test122112
Ref: perform primal ratio test122279
Ref: 90122279
Ref: perform-primal-ratio-test122279
Node: Perform dual ratio test123542
Ref: perform dual ratio test123714
Ref: 91123714
Ref: perform-dual-ratio-test123714
Node: Analyze active bound of non-basic variable124970
Ref: analyze active bound of non-basic variable125164
Ref: 92125164
Ref: analyze-active-bound-of-non-basic-variable125164
Node: Analyze objective coefficient at basic variable126888
Ref: analyze objective coefficient at basic variable127050
Ref: 93127050
Ref: analyze-objective-coefficient-at-basic-variable127050
Node: Branch-and-cut API routines130102
Ref: branch-and-cut api routines130273
Ref: 94130273
Ref: branch-and-cut-api-routines130273
Node: Basic routines130560
Ref: basic routines130684
Ref: 95130684
Ref: basic-routines130684
Node: Determine reason for calling the callback routine131135
Ref: determine reason for calling the callback routine131272
Ref: 96131272
Ref: determine-reason-for-calling-the-callback-routine131272
Node: Access the problem object131954
Ref: access the problem object132135
Ref: 97132135
Ref: access-the-problem-object132135
Node: Determine additional row attributes132464
Ref: determine additional row attributes132620
Ref: 98132620
Ref: determine-additional-row-attributes132620
Node: Compute relative MIP gap133747
Ref: compute relative mip gap133910
Ref: 99133910
Ref: compute-relative-mip-gap133910
Node: Access application-specific data134198
Ref: access application-specific data134366
Ref: 9a134366
Ref: access-application-specific-data134366
Node: Select subproblem to continue the search134866
Ref: select subproblem to continue the search135045
Ref: 9b135045
Ref: select-subproblem-to-continue-the-search135045
Node: Provide solution found by heuristic135440
Ref: provide solution found by heuristic135635
Ref: 9c135635
Ref: provide-solution-found-by-heuristic135635
Node: Check whether can branch upon specified variable136478
Ref: check whether can branch upon specified variable136663
Ref: 9d136663
Ref: check-whether-can-branch-upon-specified-variable136663
Node: Choose variable to branch upon137114
Ref: choose variable to branch upon137294
Ref: 9e137294
Ref: choose-variable-to-branch-upon137294
Node: Terminate the solution process137861
Ref: terminate the solution process137984
Ref: 9f137984
Ref: terminate-the-solution-process137984
Node: The search tree exploring routines138251
Ref: the search tree exploring routines138405
Ref: a0138405
Ref: the-search-tree-exploring-routines138405
Node: Determine the search tree size138811
Ref: determine the search tree size138959
Ref: a1138959
Ref: determine-the-search-tree-size138959
Node: Determine current active subproblem139615
Ref: determine current active subproblem139804
Ref: a2139804
Ref: determine-current-active-subproblem139804
Node: Determine next active subproblem140230
Ref: determine next active subproblem140425
Ref: a3140425
Ref: determine-next-active-subproblem140425
Node: Determine previous active subproblem141329
Ref: determine previous active subproblem141523
Ref: a4141523
Ref: determine-previous-active-subproblem141523
Node: Determine parent active subproblem142442
Ref: determine parent active subproblem142630
Ref: a5142630
Ref: determine-parent-active-subproblem142630
Node: Determine subproblem level143130
Ref: determine subproblem level143314
Ref: a6143314
Ref: determine-subproblem-level143314
Node: Determine subproblem local bound143772
Ref: determine subproblem local bound143970
Ref: a7143970
Ref: determine-subproblem-local-bound143970
Node: Find active subproblem with the best local bound144378
Ref: find active subproblem with the best local bound144541
Ref: a8144541
Ref: find-active-subproblem-with-the-best-local-bound144541
Node: The cut pool routines145071
Ref: the cut pool routines145202
Ref: a9145202
Ref: the-cut-pool-routines145202
Node: Determine current size of the cut pool145432
Ref: determine current size of the cut pool145570
Ref: aa145570
Ref: determine-current-size-of-the-cut-pool145570
Node: Add constraint to the cut pool145979
Ref: add constraint to the cut pool146161
Ref: ab146161
Ref: add-constraint-to-the-cut-pool146161
Node: Remove constraint from the cut pool147307
Ref: remove constraint from the cut pool147491
Ref: ac147491
Ref: remove-constraint-from-the-cut-pool147491
Node: Remove all constraints from the cut pool148135
Ref: remove all constraints from the cut pool148280
Ref: ad148280
Ref: remove-all-constraints-from-the-cut-pool148280
Node: Graph and network API routines148567
Ref: graph and network api routines148739
Ref: ae148739
Ref: graph-and-network-api-routines148739
Node: Basic graph routines148928
Ref: basic graph routines149050
Ref: af149050
Ref: basic-graph-routines149050
Node: Create the GLPK graph object149375
Ref: create the glpk graph object149490
Ref: b0149490
Ref: create-the-glpk-graph-object149490
Node: Set the graph name149945
Ref: set the graph name150092
Ref: b1150092
Ref: set-the-graph-name150092
Node: Add vertices to a graph150419
Ref: add vertices to a graph150556
Ref: b2150556
Ref: add-vertices-to-a-graph150556
Node: Add arc to a graph150938
Ref: add arc to a graph151095
Ref: b3151095
Ref: add-arc-to-a-graph151095
Node: Erase content of the GLPK graph object151407
Ref: erase content of the glpk graph object151569
Ref: b4151569
Ref: erase-content-of-the-glpk-graph-object151569
Node: Delete the GLPK graph object152173
Ref: delete the glpk graph object152350
Ref: b5152350
Ref: delete-the-glpk-graph-object152350
Node: Read graph in a plain text format152805
Ref: read graph in a plain text format152978
Ref: b6152978
Ref: read-graph-in-a-plain-text-format152978
Node: Write graph in a plain text format153345
Ref: write graph in a plain text format153481
Ref: b7153481
Ref: write-graph-in-a-plain-text-format153481
Node: Graph analysis routines153852
Ref: graph analysis routines154008
Ref: b8154008
Ref: graph-analysis-routines154008
Node: Find all weakly connected components of a graph154185
Ref: find all weakly connected components of a graph154353
Ref: b9154353
Ref: find-all-weakly-connected-components-of-a-graph154353
Node: Find all strongly connected components of a graph154951
Ref: find all strongly connected components of a graph155119
Ref: ba155119
Ref: find-all-strongly-connected-components-of-a-graph155119
Node: Minimum cost flow problem155724
Ref: minimum cost flow problem155880
Ref: bb155880
Ref: minimum-cost-flow-problem155880
Node: Read minimum cost flow problem data in DIMACS format156260
Ref: read minimum cost flow problem data in dimacs format156439
Ref: bc156439
Ref: read-minimum-cost-flow-problem-data-in-dimacs-format156439
Node: Write minimum cost flow problem data in DIMACS format157932
Ref: write minimum cost flow problem data in dimacs format158159
Ref: bd158159
Ref: write-minimum-cost-flow-problem-data-in-dimacs-format158159
Node: Convert minimum cost flow problem to LP159655
Ref: convert minimum cost flow problem to lp159890
Ref: be159890
Ref: convert-minimum-cost-flow-problem-to-lp159890
Node: Solve minimum cost flow problem with out-of-kilter algorithm161454
Ref: solve minimum cost flow problem with out-of-kilter algorithm161672
Ref: bf161672
Ref: solve-minimum-cost-flow-problem-with-out-of-kilter-algorithm161672
Node: Klingman's network problem generator164428
Ref: klingman's network problem generator164642
Ref: c0164642
Ref: klingman-s-network-problem-generator164642
Node: Grid-like network problem generator166961
Ref: grid-like network problem generator167106
Ref: c1167106
Ref: grid-like-network-problem-generator167106
Node: Maximum flow problem169555
Ref: maximum flow problem169679
Ref: c2169679
Ref: maximum-flow-problem169679
Node: Read maximum cost flow problem data in DIMACS format170005
Ref: read maximum cost flow problem data in dimacs format170179
Ref: c3170179
Ref: read-maximum-cost-flow-problem-data-in-dimacs-format170179
Node: Write maximum cost flow problem data in DIMACS format170456
Ref: write maximum cost flow problem data in dimacs format170673
Ref: c4170673
Ref: write-maximum-cost-flow-problem-data-in-dimacs-format170673
Node: Convert maximum flow problem to LP170957
Ref: convert maximum flow problem to lp171178
Ref: c5171178
Ref: convert-maximum-flow-problem-to-lp171178
Node: Solve maximum flow problem with Ford-Fulkerson algorithm171421
Ref: solve maximum flow problem with ford-fulkerson algorithm171630
Ref: c6171630
Ref: solve-maximum-flow-problem-with-ford-fulkerson-algorithm171630
Node: Goldfarb's maximum flow problem generator171921
Ref: goldfarb's maximum flow problem generator172087
Ref: c7172087
Ref: goldfarb-s-maximum-flow-problem-generator172087
Node: Miscellaneous routines172338
Ref: miscellaneous routines172474
Ref: c8172474
Ref: miscellaneous-routines172474
Node: Library environment routines172572
Ref: library environment routines172662
Ref: c9172662
Ref: library-environment-routines172662
Node: Determine library version172947
Ref: determine library version173079
Ref: ca173079
Ref: determine-library-version173079
Node: Enable/disable terminal output173294
Ref: enable/disable terminal output173475
Ref: cb173475
Ref: enable-disable-terminal-output173475
Node: Enable/disable the terminal hook routine173862
Ref: enable/disable the terminal hook routine174046
Ref: cc174046
Ref: enable-disable-the-terminal-hook-routine174046
Node: Get memory usage information174596
Ref: get memory usage information174772
Ref: cd174772
Ref: get-memory-usage-information174772
Node: Set memory usage limit175511
Ref: set memory usage limit175676
Ref: ce175676
Ref: set-memory-usage-limit175676
Node: Free GLPK library environment175911
Ref: free glpk library environment176039
Ref: cf176039
Ref: free-glpk-library-environment176039
Node: Index176242
Ref: index176334

End Tag Table


Local Variables:
coding: utf-8
End:
