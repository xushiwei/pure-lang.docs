\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-stlmap.info
@documentencoding UTF-8
@copying
Generated by Sphinx
@end copying
@settitle pure-stlmap
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-stlmap: (pure-stlmap.info).    pure-stlmap
@end direntry

@c %**end of header

@titlepage
@title pure-stlmap
@author Albert Gr√§f (Editor)
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-stlmap
@end ifnottex

@c %**start of body
@geindex stlmap module
@anchor{0}@anchor{module-stlmmap}
@geindex stlmmap module
@anchor{1}@anchor{module-stlhmap}
@geindex stlhmap module
Version 0.3, October 05, 2012

@display
Peter Summerland <@email{p.summerland@@gmail.com}>@w{ }
@end display
pure-stlmap is a @uref{http://pure-lang.googlecode.com,Pure} interface to six associative containers provided by
the @uref{http://en.cppreference.com/w/cpp,C++ Standard Library}: map, set, multimap, multiset, unordered_map and
unordered_set.

@anchor{2}@anchor{pure}@anchor{3}@anchor{c-standard-library}
@menu
* Copying::
* Introduction::
* Installation::
* Examples::
* Quick Start::
* Concepts::
* Modules::
* Container Operations::
* Iterators: Iterators<2>.
* Backward Compatibilty::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Supported Containers::
* Interface::

Quick Start

* Example Containers::
* Constructors::
* Ranges::
* Inserting and Replacing Elements::
* Access::
* Erasing Elements::
* Conversions::
* Functional Programming::

Concepts

* Containers and Elements::
* Ranges: Ranges<2>.
* Iterators::
* Selecting Elements Using Keys::
* C++ Implementation::

Modules

* The stlhmap Module::
* The stlmap Module::
* The stlmmap Module::

Container Operations

* Container Construction::
* Information::
* Modification::
* Accessing Elements::
* Conversions: Conversions<2>.
* Functional Programming: Functional Programming<2>.
* Comparison::
* Set Algorithms::
* Direct C Calls::

Iterators

* Concepts: Concepts<2>.
* Exceptions::
* Functions::
* Examples: Examples<2>.

Backward Compatibilty

* pure-stlmap-0 2::
* pure-stlmap-0 3::
@end detailmenu
@end menu


@node Copying,Introduction,Top,Top
@anchor{copying}@anchor{4}@anchor{module-stlmap}@anchor{5}@anchor{6}
@chapter Copying

@display
Copyright (c) 2012 by Peter Summerland <@email{p.summerland@@gmail.com}>.@w{ }
@end display
All rights reserved.

pure-stlmap is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.

pure-stlmap is distributed under a BSD-style license, see the COPYING file
for details.


@node Introduction,Installation,Copying,Top
@anchor{introduction}@anchor{7}
@chapter Introduction
This is pure-stlmap-0.1, the first release of pure-stlmap. It is possible that
some of the functions might be changed slightly or even removed. Comments and
questions would be especially appreciated at this early stage.


@menu
* Supported Containers::
* Interface::
@end menu


@node Supported Containers,Interface,,Introduction
@anchor{supported containers}@anchor{8}@anchor{supported-containers}
@section Supported Containers
The Standard C++ Containers Library, often refered to as the standard template
library ("STL"), provides templates for generic containers and generic
algorithms. pure-stlmap provides six mutable containers, "stlmap", "stlset",
"stlmmap", "stlmset", "stlhmap" and "stlhset", that are thin wrappers around
the corresponding associative containers provided by the STL, map, set,
multimap, multiset, unordered_map and unordered_set, specialized to hold
pure-expressions. pure-stlmap does not provide wrappers for unordered_multimap
and unordered_multiset.


@node Interface,,Supported Containers,Introduction
@anchor{interface}@anchor{9}
@section Interface
pure-stlmap provides a "key-based" interface that can be used to work with the
supported STL containers in a way that should feel natural to Pure
programmers. For example, the (!) function can be used to access values
associated with keys and functions like @pxref{a,,map},
@pxref{b,,foldl}, @pxref{c,,filter} and @pxref{d,,do} can be used
to operate on all or part of a container's elements without using an explict
tail recursive loop. In addition, for the ordered containers, stlmap, stlmmap,
stlset and stlmset, pure-stlmap provides an "interator-based" interface that
corresponds to the C++ interface, mostly on a one-to-one basis.

The interface for the unordered or "hash table" containers, stlhmap and
stlhset, is limited compared to that provided for the ordered containers. In
particular iterators, operations on subsequences (ranges) and set operations
are not supported.

In some cases, the STL's associative containers have different semantics than
the the associative containers provided by the Pure standard library. Where
there is a conflict, pure-stlmap follows the STL.

Many of the functions provided by pure-stlmap, such as the constructors,
equivalence and lexicographical comparison operations, insert and erase
operations, and the set operations are just thin wrappers around the the
corresponding C++ functions. Users can consult the C++ Library documentation
to understand the performance characteristics and corner case behavior of any
pure-stlmap function that has a corresponding function in the STL.

The C++ library is sometimes more complicated than the Pure Standard
Library. For example many of the applicable C++ functions, including set
operations and tests for equality, assume that the containers are
lexicographically ordered. The reward for playing by the rules (which occurs
automatically for stlmap and stlset) is O(n) time complexity for comparison
and set operations.


@node Installation,Examples,Introduction,Top
@anchor{installation}@anchor{e}
@chapter Installation
pure-stlmap-0.3 is included in the "umbrella" addon, @code{pure-stllib}
which is available at @indicateurl{http://code.google.com/p/pure-lang/downloads/list}. After
you have downloaded and installed @code{pure-stllib}, you will be able to use
pure-stlmap (and @code{pure-stlvec}, as well).


@node Examples,Quick Start,Installation,Top
@anchor{examples}@anchor{f}
@chapter Examples
The pure-stlmap/uts subdirectory contains Pure scripts that are used to test
pure-stlmap. These scripts contain simple tests, each of which consists of a
single line of code followed by a comment that contains the expected
output. E.g.,

@example
let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
//- ()

sm1!stl::smbeg, sm1!"a", sm1!"d", sm1!"e"
//- 1,1,4,5

catch id $ sm1!"0";
//- out_of_bounds
@end example

@noindent
You might consider pasting parts of these scripts into a temporary file that
you can play with if you are curious about how something works.

Two short example programs, anagrams.pure and poly.pure, can be found in the
pure-stlmap/examples subdirectory.


@node Quick Start,Concepts,Examples,Top
@anchor{quick start}@anchor{10}@anchor{quick-start}
@chapter Quick Start
This section introduces the basic functions you need to get up and running
with pure-stlmap. For a quick look at the other functions provided by
pure-stlmap, you can refer to pure-stllib-cheatsheet.pdf, which can be found
in the pure-stllib/doc directory.


@menu
* Example Containers::
* Constructors::
* Ranges::
* Inserting and Replacing Elements::
* Access::
* Erasing Elements::
* Conversions::
* Functional Programming::
@end menu


@node Example Containers,Constructors,,Quick Start
@anchor{example containers}@anchor{11}@anchor{example-containers}
@section Example Containers
The code snippets that appear in the examples that follow assume that
six containers have been created by entering the following at the prompt.

@example
$> pure -q
> using stlmap, stlhmap, stlmmap;
> using namespace stl;

> // Make some maps and sets with default characteristics
> let sm  = stlmap  ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
> let shm = stlhmap ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
> let smm = stlmmap ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5];
> let ss  = stlset  ["a","b","c","d","e"];
> let shs = stlhset ["a","b","c","d","e"];
> let sms = stlmset ["a","b","c","c","d"];
@end example

@noindent
The @code{using} statement imports the three modules provided by pure-stlmap:
@pxref{4,,stlmap} provides the interface for the stlmap and stlset containers,
@pxref{0,,stlmmap} provides the interface the stlmmap and stlmset containers, and
@pxref{1,,stlhmap} provides the interface to the stlhmap and stlhset
containers. The @code{let} statements set up an instance of each of the containers
provided by pure-stlmap, loaded with some sample elements.

To save typing you can run readme-data.pure, a file that contains the
corresponding source code. It can be found in in the pure-stlmap/examples
directory.


@node Constructors,Ranges,Example Containers,Quick Start
@anchor{constructors}@anchor{12}
@section Constructors
You can construct empty pure-stlmap containers using the
@pxref{13,,emptystlmap}, @pxref{14,,emptystlset},
@pxref{15,,emptystlmmap}, @pxref{16,,emptystlmset},
@pxref{17,,emptystlhmap} and @pxref{18,,emptystlhset} functions.

@example
> let sm1 = emptystlmap;   // uses (<) to order keys
@end example

@noindent
You can construct a pure-stlmap container and fill it with elements all in one
go using the @pxref{19,,stlmap}, @pxref{1a,,stlset},
@pxref{1b,,stlmmap}, @pxref{1c,,stlmset}, @pxref{1d,,stlhmap} and
@pxref{1e,,stlhset} functions.

@example
> let shm1 = stlhmap ["a"=>1,"b"=>2,"c"=>3];

> members shm1;
["c"=>3,"a"=>1,"b"=>2]

> smh1!"b";
2
@end example

@noindent
As opposed to the hashed containers (stlhmap and stlhset), the ordered
containers (stlmap, stlset, stlmmap and stlmset) keep their elements ordered
by key.

@example
> let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>3]; members sm1;
["a"=>1,"b"=>2,"c"=>3]
@end example

@noindent

@node Ranges,Inserting and Replacing Elements,Constructors,Quick Start
@anchor{ranges}@anchor{1f}
@section Ranges
For the ordered containers (stlmap, stlset, stlmmap and stlmset) you can work
with subsequences, called "ranges", of the containers' elements. A range is
specified by a tuple that consists of a container and two keys. If (sm,
first_key, last_key) designates a range, the elements of the range are
all of elements of the container sm whose keys are equivalent to or
greater than first_key and less than last_key. If first_key and
last_key are left out of the tuple, the range consists of all of sm's
elements.

@example
> members sm;               // no range keys - the whole container
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

> members (sm,"b","e");     // a range from "b" up but not including "e"
["b"=>2,"c"=>3,"d"=>4]

> members (sm,"c1","z");    // keys do not have to be stored
["d"=>4,"e"=>5]

> members shm;              // works on a unordered set (with no range keys)
["c"=>3,"d"=>4,"e"=>5,"a"=>1,"b"=>2]
@end example

@noindent
Two special keys, @pxref{20,,stl smbeg} and @pxref{21,,stl smend} are
reserved for use in ranges to designate the first element in a container and
the imaginary "past-end" element.

@example
> members (sm,smbeg,"d");
["a"=>1,"b"=>2,"c"=>3]

> members (sm,"b",smend);
["b"=>2,"c"=>3,"d"=>4,"e"=>5]
@end example

@noindent
Perhaps it should go without saying, but you cannot use either of these
symbols as the keys of elements stored in a pure-stlmap container.


@node Inserting and Replacing Elements,Access,Ranges,Quick Start
@anchor{inserting and replacing elements}@anchor{22}@anchor{inserting-and-replacing-elements}
@section Inserting and Replacing Elements
You can insert elements and, for the maps (stlmap, stlmmap and stlhmap),
replace the values associated with keys that are already stored in the map,
using the @pxref{23,,insert}, @pxref{24,,replace} and
@pxref{25,,insert_or_replace} functions. For the maps, the elements to
inserted are specified as (key=>value) hash-pairs.

@example
> let sm1 = emptystlmap;

> insert sm1 ("e"=>5);              // returns number of elements inserted
1
> members sm1;
["e"=>5]

> replace sm1 "e" 15;               // returns value
15
> members sm1;
["e"=>15]

> catch id $ replace sm1 "x" 10;    // replace never inserts new elements
out_of_bounds

> insert sm1 ("e"=>25);             // insert never changes existing elements
0
> members sm1;
["e"=>15]

> insert_or_replace sm1 ("e"=>25);  // 1 value changed
1
> members sm1;
["e"=>25]
>
@end example

@noindent
The @pxref{23,,insert} and @pxref{25,,insert_or_replace} functions are
overloaded to insert or replace elements specified in a list, vector, stlvec
or another pure-stlmap container (of the same type). E.g.,

@example
> let sm2 = emptystlmap;

> insert sm2 ["b"=>2,"a"=>1];       // insert from a list
2

> insert sm2 (sm,"c","e");          // insert from a range
2

> members sm2;
["a"=>1,"b"=>2,"c"=>3,"d"=>4]

> insert_or_replace sm2 @{"a"=>11,"e"=>15@};
2

> members sm2;
["a"=>11,"b"=>2,"c"=>3,"d"=>4,"e"=>15]
@end example

@noindent

@node Access,Erasing Elements,Inserting and Replacing Elements,Quick Start
@anchor{access}@anchor{26}
@section Access
If you want to see if a key is stored in a container use the
@pxref{27,,member} function. (A key, k, is considered to be "stored" in a
container if there is an element in the container that is equivalent to k.)

@example
> member sm "x";  // ("x"=>val) is not an element of sm for any val
0

> member sm "a";  // ("a"=>1) is an element with key equivalent to "a"
1
@end example

@noindent
The value (or values for a multi-key container) associated with a key can be
accessed using the (!) function.

@example
> sm!"a";   // return the value associated with "a"
1

> shm!"b";  // try it with a hashed map
2

> smm!"c";  // multimap returns a the list of values associated with "c"
[31,32]

> ss!"a";   // with sets, return the key
"a"

> sms!"c";  // with multisets, return a list of keys
["c","c"]
@end example

@noindent
If the key is not stored in the container, (!) throws an @code{out_of_bounds}
exception.

@example
> catch id $ sm!"x"; // "x" is not stored as a key in sm
out_of_bounds
@end example

@noindent
Please note that all access is strictly by keys. For example you cannot use
the @pxref{27,,member} function to determine if ("a"=>1) is an element
stored in sm; you can only ask if the key "a" is stored in sm.


@node Erasing Elements,Conversions,Access,Quick Start
@anchor{erasing elements}@anchor{28}@anchor{erasing-elements}
@section Erasing Elements
For any pure-stlmap container, you can use the @pxref{29,,erase} function
to remove all the elements associated with a given key in the container, all
of the elements in the container or, unless the container is a stlhmap or
stlhset, all of the elements in a range defined on the container.

@example
> let shm1 = stlhmap shm;       // make some copies of maps
> let smm1 = stlmmap smm;
> let sm1 = stlmap sm;

> members smm1;                 // smm1 has multiple values for "c"
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

> erase (shm1,"c");             // erase "c" keyed elements from a stlmmap
1
> members shm1;                 // all the "c" keyed elements are gone
["d"=>4,"e"=>5,"a"=>1,"b"=>2]

> erase shm1;                   // erase all elements
4
> empty shm1;
1

> erase (sm1,"b","d");         // erase a subsequence
2
> members sm1;
["a"=>1,"d"=>4,"e"=>5]

> erase (sm1,"x");             // attempt to erase something not there
0

> erase (smm1,"c");            // erase all elements with key "c"
2
> members smm1;
["a"=>1,"b"=>2,"d"=>4,"e"=>5]
@end example

@noindent

@node Conversions,Functional Programming,Erasing Elements,Quick Start
@anchor{conversions}@anchor{2a}
@section Conversions
The elements of an associated container be copied into a list, vector or
stlvec using the @pxref{2b,,members}, @pxref{2c,,stl vector} and
@pxref{2d,,stlvec} functions. For ordered containers (stlmap, stlset,
stlmmap and stlmset) the list, vector or stlvec can be built from a range.

@example
> members ss;
["a","b","c","d","e"]

> members (ss,"b","d"); // list subsequence from "b" up to but not "d"
["b","c"]

> members (smm,"c","e");
["c"=>31,"c"=>32,"d"=>4]

> members (shm,"b","d"); // fails - ranges not supported for stlhmaps
stl::members (#<pointer 0x83b4908>,"b","d")

> members shm;          // ok - all elements are copied
["d"=>4,"e"=>5,"a"=>1,"b"=>2,"c"=>3]

> vector (sm,smbeg,"d");
@{"a"=>1,"b"=>2,"c"=>3@}

> using stlvec;
> members $ stlvec sm;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]
@end example

@noindent
You can convert the contents of an ordered container (stlmap, stlset, stlmmap
or stlmset) or a range defined on one to a stream using the
@pxref{2e,,stream} function.

@example
> let ss1 = stlhset (0..100000);

> stats -m

> let xx = drop 99998 $ scanl (+) 0 (stream ss);
0.3s, 18 cells

> list xx;
[704782707,704882705,704982704,705082704]
0s, 17 cells
@end example

@noindent

@node Functional Programming,,Conversions,Quick Start
@anchor{functional programming}@anchor{2f}@anchor{functional-programming}
@section Functional Programming
Most of the Pure list operations, including @pxref{a,,map},
@pxref{d,,do}, @pxref{c,,filter}, @pxref{30,,catmap},
@pxref{b,,foldl} and @pxref{31,,foldl1} can be applied to any of
pure-stlmap's associative containers. E.g.,

@example
> map (\x->x-32) shs;
["D","E","A","B","C"]

> using system;

> do (puts . str) (sm,smbeg,"c");
"a"=>1
"b"=>2
()
@end example

@noindent
List comprehensions also work.

@example
> [k-32=>v+100 | (k=>v) = smm; k>"a" && k<"e"];
["B"=>102,"C"=>131,"C"=>132,"D"=>104]

> @{k-32=>v+100 | (k=>v) = (smm,"b","e")@};
@{"B"=>102,"C"=>131,"C"=>132,"D"=>104@}
@end example

@noindent
It is highly recommended that you use the functional programming operations,
as opposed to recursive loops, whenever possible.


@node Concepts,Modules,Quick Start,Top
@anchor{concepts}@anchor{32}
@chapter Concepts
This section describes pure-stlmap's containers, iterators, ranges, elements,
keys, values and how these objects are related to each other. It also
describes a group of functions associated with containers that help define the
container's behavior. E.g., each ordered container (stlmap, stlset, stlmmap or
stlmset) stores a function that it used to order its keys and to determine if
two keys are equivalent.


@menu
* Containers and Elements::
* Ranges: Ranges<2>.
* Iterators::
* Selecting Elements Using Keys::
* C++ Implementation::
@end menu


@node Containers and Elements,Ranges<2>,,Concepts
@anchor{containers and elements}@anchor{33}@anchor{containers-and-elements}
@section Containers and Elements
The six associative containers supported by pure-stlmap can be grouped
together in terms of certain defining attributes.

The three "maps" provided by pure-stlmap, stlmap, stlmmap and stlhmap,
associate values with keys. If a value v is associated with a key, k, in an
map, m, then we say that (k=>v) is an element of m, k is a key stored in m and
v is a value stored in m.

The three "sets" provided by pure-stlmap, stlset, stlmset and stlhset, hold
single elements, as opposed to key value pairs. If an element e is contained a
set, s, we say that e is simultaneously an element, key and value stored s. In
other words, we sometimes speak of a set as if it were a map where each
element, key and value are the same object.

The "ordered" containers, stlmap, stlset, stlmmap and stlmset, each have a
"key-less-than" function that they use keep their elements in a sequence that
is ordered by keys. The default key-less-than function is @code{(<)},
but this can be changed when the container is created. The elements stored in
a stlmap or stlset have unique keys, i.e., two elements stored in the
container will never have equivalent keys. For these purposes, two keys are
"equivalent" if neither key is key-less-than the other. In contrast, stlmmap
and stlmset do not have unique keys. I.e., it is possible for different
elements stored in a stlmmap or stlmset can have equivalent keys.

The "hashed" containers, sthmap and stlhset do not keep their elements in a
sequence. Instead they store their elments in a hash table using a "key-hash"
function and a "key-equal" function. Currently the key-hash function is always
@code{hash} and the key-equal function is always (===), both of which are
defined in the Prelude. The elements stored in a hashed container have unique
keys. I.e., two elements stored in the container will never by "key-equal". At
times we say that two keys stored in a hashed container are "equivalent" if
they are key-equal.

The "ordered maps", stlmap and stlmmap, each have a "value-less-than" function
and a "value-equal" function that is used for lexicographical comparisons. The
default functions are @code{(<)} and (==) respectively, but these can
customized when the container is created.

As is the case for the underlying C++ functions, set operations (i.e., union,
intersection, etc.) and container equivalence for the ordered containers are
based on lexicographical comparisons. For these purposes one element, e1, is
less than another, e2, if (a) e1's key is less-than e2's key and, (b) if the
ordered container is a stlmap or stlmap, e1's value is value-less-than e2's
value. Finally, for purposes of determining if two ordered containers are
equal, e1 and e2 are considered to be equal if (a) their keys are equivalent
and (b), in the case of stlmap or stlmmap, their values are value-equal.

Set operations are not provided for the hashed containers, stlhmap and
stlhset.


@node Ranges<2>,Iterators,Containers and Elements,Concepts
@anchor{ranges<2>}@anchor{34}@anchor{id1}
@section Ranges
For the ordered containers (stlmap, stlset, stlmmap and stlmset), you can work
with a subsequence or "range" of a container's elements. Given an ordered
container, oc, and keys f and l, the range (oc,f,l) consists of all of the
elements in oc starting with the first element that is not less than f up to
but not including the first element that is greater or equal to l. Note that f
and l do not have to be stored in oc.

@example
> members (sm,"b","e");
["b"=>2,"c"=>3,"d"=>4]

> members (sm,"c1",smend);
["d"=>4,"e"=>5]
@end example

@noindent
When a range is passed to a function provided by pure-stlmap, the keys can be
dropped, in which case the range consists of all of the container's
elements.

@example
> members sm;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]
@end example

@noindent
Please note that support for ranges is not provided for the unordered
containers (stlhmap and stlhset). Most pure-stlmap functions that act on
ranges can, however, operate on stlhmaps or stlhsets as well, except that, for
stlhmaps and stlhsets, they always operate on all of the container's
elements. Accordingly, whenever the documentation of a function refers to a
range, and the container in question is a a stlhmap or stlhset, the range
simply refers to the container itself.


@node Iterators,Selecting Elements Using Keys,Ranges<2>,Concepts
@anchor{iterators}@anchor{35}
@section Iterators
The native STL interface is based on "iterators" that point to elements in
containers. pure-stlmap provides support for iterators defined on its ordered
containers (stlmap, stlmmap, stlset and stlmset) but not for its unordered
containers (stlhmap and stlhset).

Iterators are most useful when dealing with stlmmaps where elements with
different values can have equivalent keys. In most cases, it is recommended
that you avoid using iterators. The functions that operate on or return
iterators are discussed separately at the end of this document.


@node Selecting Elements Using Keys,C++ Implementation,Iterators,Concepts
@anchor{selecting elements using keys}@anchor{36}@anchor{selecting-elements-using-keys}
@section Selecting Elements Using Keys
Throughout pure-stlmap, unless you resort to using iterators, you can only
specify elements and ranges of elements using keys. For example you cannot use
the @pxref{27,,member} function to see if a specific key, value pair is an
element of a stlmap.

@example
> members sm;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

> member sm "a";
1

> catch id $ member sm (a=>1);
bad_argument
@end example

@noindent
In the last line of code, @pxref{27,,member} treats (a=>1) as a
key. Because (a=>1) cannot be compared to a string using @code{(<)},
the ersatz key is treated as a bad argument.

This "key access only" approach can be an issue for stlmmaps and because
multiple elements can have equivalent keys. I.e., given a stlmmap, smm, that
containes multiple element with keys equivalent to, say, k, which element
should (!) return? pure-stlmap dodges this issue by returning all on
them. Thus, for stlmmap and stlmset (!) and @pxref{24,,replace} work with
lists of elements associated with a given key rather than, say, the first
elment with the given key.

@example
> members smm;
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4];

> smm!"c";
"c"=>[31,32]

> replace smm "c" [31,32,33]; members smm;
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>33,"d"=>4]

> replace smm "c" []; members smm;
["a"=>1,"b"=>2,"d"=>4,"e"=>5]
@end example

@noindent
If selecting and replacing lists of elements with the same key is not
convenient, you can always use iterators to track down and modify any specific
element.


@node C++ Implementation,,Selecting Elements Using Keys,Concepts
@anchor{c++ implementation}@anchor{37}@anchor{c-implementation}
@section C++ Implementation
For those that want to refer to the @uref{http://en.cppreference.com/w/cpp,C++ standard library documentation},
stlmap is (essentially) map<px*,px*>, stlmmap is multimap<px*,px*> and stlhmap
is unordered_map<px*,px*>, where px is defined by "typedef pure_expr
px". I.e., in C++ Containers library speak, key_type is px*, mapped_type is
px* and value_type is pair<px*,px*>. This might be a bit confusing because
pure-stlmap's (key=>value) "elements" correspond to C++ value_types, a
pair<key_type,mapped_type>, and pure-stlmap's values correspond to
mapped_types. The C++ objects for stlset, stlmset and stlhset are the same as
stlmap, stmmap and stlhmap except that pure-stlmap ensures that the second
member of the C++ value_type pair is always NULL.

@anchor{38}@anchor{c-standard-library-documentation}
@node Modules,Container Operations,Concepts,Top
@anchor{modules}@anchor{39}
@chapter Modules
pure-stlmap provides three separate modules @pxref{4,,stlmap}, @pxref{0,,stlmmap} and
@pxref{1,,stlhmap}.

Importing any one of these modules defines the stl namespace as well as two
important symbols, @pxref{20,,stl smbeg} and @pxref{21,,stl smend}.

@geindex stl smbeg constructor
@geindex stl smend constructor
@anchor{20}@anchor{stl smbeg/stlmap}
@deffn {constructor} stl::smbeg
@anchor{21}@anchor{stl smend/stlmap}
@deffnx {constructor} stl::smend

These symbols are used to designate the key of the first element in an
ordered container (stlmap, stlset, stlmmap or stlmset) and the key of an
imaginary element that would come immediately after the last element of in
the constainer. They are used to define ranges over the ordered
containers.
@end deffn

E.g.,

@example
> members sm;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

> members (sm,"c",smend);
["c"=>3,"d"=>4,"e"=>5]
@end example

@noindent

@menu
* The stlhmap Module::
* The stlmap Module::
* The stlmmap Module::
@end menu


@node The stlhmap Module,The stlmap Module,,Modules
@anchor{the stlhmap module}@anchor{3a}@anchor{the-stlhmap-module}
@section The stlhmap Module
If all you want is fast insertion and lookup, you don't care about the order
of the elements stored in the container, and you do not want to use set
operations like @pxref{3b,,stl map_intersection}, then @pxref{1,,stlhmap} is
probably your best choice. The supported containers, stlhmap and stlhset are
simpler to use and faster than the other containers provided by pure-stlmap.

The @pxref{1,,stlhmap} module defines stlhmaps and stlhsets and provides functions
for dealing with them. You can import it by adding the following @code{using}
statement to your code.

@example
> using stlhmap;
@end example

@noindent
The @pxref{1,,stlhmap} module defines types two types:

@geindex stlhmap type
@geindex stlhset type
@anchor{3c}@anchor{stlhmap/type}
@deffn {type} stlhmap
@anchor{3d}@anchor{stlhset/type}
@deffnx {type} stlhset
@end deffn

Please note that a stlhset is just a stlhmap where the values associated with
keys cannot be accessed or modified. I.e., a stlhset is a specialized kind of
stlhmap.


@node The stlmap Module,The stlmmap Module,The stlhmap Module,Modules
@anchor{the stlmap module}@anchor{3e}@anchor{the-stlmap-module}
@section The stlmap Module
The @pxref{4,,stlmap} module provides you with stlmaps and stlsets and the
functions that operate on them. Consider using these containers if you want
their elements to be orderd by key, want to use ranges or if you are using any
set operations (@pxref{3f,,stl map_union},
@pxref{3b,,stl map_intersection}, etc).

You can import the stlmap module by adding the following using statement to
your code.

@example
> using stlmap;
@end example

@noindent
Importing the stlmap module introduces types to describe stlmap and stlset,
their iterators and ranges defined on them.

@geindex stlmap type
@geindex stlset type
@anchor{40}@anchor{stlmap/type}
@deffn {type} stlmap
@anchor{41}@anchor{stlset/type}
@deffnx {type} stlset
@end deffn

@geindex stlmap_iter type
@anchor{42}@anchor{stlmap_iter/type}
@deffn {type} stlmap_iter
@end deffn

@geindex stlmap_rng type
@anchor{43}@anchor{stlmap_rng/type}
@deffn {type} stlmap_rng
@end deffn

Please note that a stlset is just a stlmap where the values associated with
keys cannot be accessed or modified. I.e., a stlset is a specialized kind of
stlmap. Accordingly, it is not necessary, for example, to define a separate
type for iterators on stlsets as opposed to iterators on stlmaps.


@node The stlmmap Module,,The stlmap Module,Modules
@anchor{the stlmmap module}@anchor{44}@anchor{the-stlmmap-module}
@section The stlmmap Module
If you need a multi-keyed container, the @pxref{0,,stlmmap} module, which provides
support for stlmaps and stlmsets, is your only choice. Set operations and
ranges are supported, but the semantics are more complicated than is the case
for stlmap and stlset. Because the keys stored in multi-keyed containers are
not unique you might have to resort to using iterators when working with them.

You can import the @pxref{0,,stlmmap} module by adding the following using
statement to your code.

@example
> using stlmmap;
@end example

@noindent
Importing the stlmmap module introduces types to describe stlmmap and stlmset,
along with their iterators and ranges defined on them.

@geindex stlmmap type
@geindex stlmset type
@anchor{45}@anchor{stlmmap/type}
@deffn {type} stlmmap
@anchor{46}@anchor{stlmset/type}
@deffnx {type} stlmset
@end deffn

@geindex stlmmap_iter type
@anchor{47}@anchor{stlmmap_iter/type}
@deffn {type} stlmmap_iter
@end deffn

@geindex stlmmap_rng type
@anchor{48}@anchor{stlmmap_rng/type}
@deffn {type} stlmmap_rng
@end deffn

Please note that a stlmset is just a stlmmap where the values associated with
keys cannot be accessed or modified. I.e., a stlmset is a specialized kind of
stlmmap. Accordingly, it is not necessary, for example, to define a separate
type for iterators on stlmsets as opposed to iterators on stlmmaps.


@node Container Operations,Iterators<2>,Modules,Top
@anchor{container operations}@anchor{49}@anchor{container-operations}
@chapter Container Operations
Each of the six associative containers supported by pure-stlmap has its own
set of unique characteristics. Because of this the description of functions
that operate on more than one type of container can get a little complicated.
When reading this section it might be helpful to consult
pure-stllib-cheatsheet.pdf which can be found in the pure-stlib/doc directory.


@menu
* Container Construction::
* Information::
* Modification::
* Accessing Elements::
* Conversions: Conversions<2>.
* Functional Programming: Functional Programming<2>.
* Comparison::
* Set Algorithms::
* Direct C Calls::
@end menu


@node Container Construction,Information,,Container Operations
@anchor{container construction}@anchor{4a}@anchor{container-construction}
@section Container Construction
New empty ordered containers (stlmap, stlset, stlmmap and stlmset) can be
constructed using optional parameters that allow you to specify customized
key-less-than functions, default values, value-less-than and value-equal
functions.

@geindex mkstlmap function
@geindex mkstlmmap function
@anchor{4b}@anchor{mkstlmap/stlmap}
@deffn {Function} mkstlmap (klt,dflt,vlt,veq)
@anchor{4c}@anchor{mkstlmmap/stlmap}
@deffnx {Function} mkstlmmap (klt,dflt,vlt,veq)

Create a new stlmap or stlmmap where @code{klt} is the map's key-less-than
function. dflt is the maps default value (used by replace_with and
find_with_default). vlt is the map's value-compare function and veq is its
value-equal function.  Only @code{klt} is required, and the default values for
dflt, vlt, veq are [], (<) and (==) respectively.
@end deffn

@geindex mkstlset function
@geindex mkstlmset function
@anchor{4d}@anchor{mkstlset/stlmap}
@deffn {Function} mkstlset klt
@anchor{4e}@anchor{mkstlmset/stlmap}
@deffnx {Function} mkstlmset klt

Create a new stlset or stlmset where @code{klt} is the set's key-less-than
function.
@end deffn

The internal lookup functions for the ordered containers (stlmap, stlset,
stlmmap and stlmset) are optimized to avoid callbacks if the container's
key-less-than function is is @code{(>)} or @code{(<)} and the
keys being compared are a pair of strings, ints, bigints or doubles.

You can create an empty associative container using default values for using
@pxref{13,,emptystlmap} and friends.

@geindex emptystlmap function
@geindex emptystlmmap function
@geindex emptystlset function
@geindex emptystlmset function
@anchor{13}@anchor{emptystlmap/stlmap}
@deffn {Function} emptystlmap
@anchor{15}@anchor{emptystlmmap/stlmap}
@deffnx {Function} emptystlmmap
@anchor{14}@anchor{emptystlset/stlmap}
@deffnx {Function} emptystlset
@anchor{16}@anchor{emptystlmset/stlmap}
@deffnx {Function} emptystlmset

Create a new ordered map or set using default values. I.e., emptystlmap is
the same as mkstlmap @code{(<)}, and so on.
@end deffn

@geindex emptystlhmap function
@geindex emptystlhset function
@anchor{17}@anchor{emptystlhmap/stlmap}
@deffn {Function} emptystlhmap
@anchor{18}@anchor{emptystlhset/stlmap}
@deffnx {Function} emptystlhset

Create a new stlhmap or stlhset with default values. The hash-function is
hash and the value-equal function is (===).
@end deffn

Convenience functions are also provided to construct an empty container and
insert elements into it in one go. The source of the elements can be a list,
vector, a stlvec, or a range defined on another container of the same type as
the new container.

@geindex stlmap function
@geindex stlmmap function
@geindex stlset function
@geindex stlmset function
@geindex stlhmap function
@geindex stlhset function
@anchor{19}@anchor{stlmap/stlmap}
@deffn {Function} stlmap src
@anchor{1b}@anchor{stlmmap/stlmap}
@deffnx {Function} stlmmap src
@anchor{1a}@anchor{stlset/stlmap}
@deffnx {Function} stlset src
@anchor{1c}@anchor{stlmset/stlmap}
@deffnx {Function} stlmset src
@anchor{1d}@anchor{stlhmap/stlmap}
@deffnx {Function} stlhmap src
@anchor{1e}@anchor{stlhset/stlmap}
@deffnx {Function} stlhset src

Create an associative constructor using default values and insert elements
from copied from @code{src}. @code{src} can be a list, vector or stlvec of
elements or a range defined over a container of the same type as the new
container. If the new container is a stlmap, stlmmap or stlhmap, the
elements of src must be (key=>val) pairs. If the new container is a stlset,
stlmset or stlhset they can be any pure expression that can be used as a
key (i.e., anything except for @pxref{20,,stl smbeg} or
@pxref{21,,stl smend}).
@end deffn


@node Information,Modification,Container Construction,Container Operations
@anchor{information}@anchor{4f}
@section Information
This group of functions allows you make inquiries regarding the number of
elments in a container, the number of instances of a given key held by a
container, the upper and lower bounds of a range and other information. In
addition this group includes a function that can be used to change the number
of slots used by a stlhmap or stlhset.

@geindex # prefix function
@anchor{50}@anchor{#/stlmap}
@deffn {Function} # acon

Return the number of elements in @code{acon}.
@end deffn

@geindex stl empty function
@anchor{51}@anchor{stl empty/stlmap}
@deffn {Function} stl::empty acon

Return true if @code{acon} is empty, else false.
@end deffn

@geindex stl distance function
@anchor{52}@anchor{stl distance/stlmap}
@deffn {Function} stl::distance rng

Returns the number of elements contained in @code{rng} where rng is a range
defined on an ordered container (stlmap, stlmmap, stlset, stlmset).
@end deffn

@geindex stl count function
@anchor{53}@anchor{stl count/stlmap}
@deffn {Function} stl::count acon k

Returns the number of elements in an associative container, acon, that have
a key that is equivalent to @code{k}.
@end deffn

@geindex stl bounds function
@anchor{54}@anchor{stl bounds/stlmap}
@deffn {Function} stl::bounds rng

Return a pair of keys, first and last, such that first <= k < last for each
k, where k is the key of an element in @code{rng}. If there is no such last,
the second member of the returned pair will be
@pxref{21,,stl smend}. If first is the key of the first element of
@code{rng's} container, the first member of the returned pair will
@pxref{20,,stl smbeg}.
@end deffn

Here are two examples using the @pxref{54,,stl bounds} function. Notice
that bounds returns @pxref{20,,stl smbeg} instead of "a" in the first
example.

@example
> members sm;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

> bounds sm;
stl::smbeg,stl::smend

> bounds (sm,"a1","e");
"b","e"
@end example

@noindent
@geindex stl container_info function
@anchor{55}@anchor{stl container_info/stlmap}
@deffn {Function} stl::container_info acon

If @code{acon} is a stlmap or stlmmap, returns (0, klt, dflt, vlt, veq) where
klt is @code{acon}'s key-less-than function, dflt is its default value, vlt is
its value-less-than function and veq is its value_equal function. If
@code{acon} is a stlset or stlmset, returns (1,klt,_,_,_) where klt is
@code{acon}'s key-less-than function. If @code{acon} is a stlhmap or stlhset,
returns (is_set, bucket_count, load_factor, max_load_factor).
@end deffn

@geindex stl bucket_size function
@anchor{56}@anchor{stl bucket_size/stlmap}
@deffn {Function} stl::bucket_size hacon n

Returns the number of elements in @code{hacon}'s nth (zero-based) bucket where
@code{hacon} is a stlhmap or stlhset.
@end deffn

@geindex stl hmap_reserve function
@anchor{57}@anchor{stl hmap_reserve/stlmap}
@deffn {Function} stl::hmap_reserve hacon mlf size

Sets @code{hacon}'s max_load_factor to @code{mlf}, sets the number of @code{hacon 's
buckets to ``size}/@code{mlf` and rehashes ``hacon} where @code{hacon} is a
stlhmap or stlhset.
@end deffn


@node Modification,Accessing Elements,Information,Container Operations
@anchor{modification}@anchor{58}
@section Modification
You can insert new items or, for the maps (stlmap, stlmmap and stlhmap),
replace values associated with keys using the @pxref{23,,insert},
@pxref{24,,replace} or @pxref{25,,insert_or_replace} functions.

Please note that when working with the ordered containers (stlmap, stlset,
stlmmap and stlmset) the keys of elements passed to these functions must be
compatible with the container's key-less-than function and keys that are
already inserted. E.g.,

@example
> members ss;
["a","b","c","d","e"]

> catch id $ insert ss 1;   // e.g., 1<"a" is not defined
bad_argument
@end example

@noindent
Currently there is no similar restriction for stlhmaps and stlhsets because
(a) they do not have a key-less-than function and (b) the function they do use
for testing equality, the key-equal function is always (===), a function that
can compare any two objects.

@example
> members shs;
["c","d","e","a","b"]

> insert shs 1;
1
> members shs;
["c",1,"d","e","a","b"]
@end example

@noindent
Elements can be inserted into a pure-stlmap container individually or en masse
from a list, vector, stlvec or another container of the same type. If there is
a key in the container that is equivalent to the key of the element being
inserted, the element will not be inserted (unless the container is a stlmmap
or stlmset, both of which can hold multiple elements with equivalent keys).

@geindex insert function
@anchor{23}@anchor{insert/stlmap}
@deffn {Function} insert acon src

Attempts to copy elements from @code{src} a valid "insert source" into @code{acon}
which can be any pure-stlmap container. A valid insert source is (a) a
single element, (b) a list, vector, stlvec of elements or (c), a range over
an associative container of the same type as @code{acon}. If @code{acon} is an
associative map (stlmap, stlmmap or stlhmap), the @code{src} itself, or all the
elements of @code{src}, must be key value pairs of the form (k=>v). In
contrast, if @code{acon} is a stlset, stlmset or stlhset, @code{src} or all of its
elements can be any pure object (except @pxref{20,,stl smbeg} or
@pxref{21,,stl smend}). If @code{acon} is a stlmap, stlset, stlhmap or
stlhset, the element will not be inserted if its key is already stored in
the target container. Returns the number of elements inserted, if any.
@end deffn

If you are dealing with a stlmap or stlhmap and want to override the values of
elements have keys that equivalent to the keys of the items you wan to insert
you can use the @pxref{25,,insert_or_replace} function.

@geindex insert_or_replace function
@anchor{25}@anchor{insert_or_replace/stlmap}
@deffn {Function} insert_or_replace acon src

The same as @pxref{23,,insert} except that (a) @code{acon} must be a stlmap
or a stlhmap and (b) if an element (key=>newval) is about to be inserted and
the container already contains an element (key=>oldval) the element in the
container will be changed to (key=>newval). Returns the number of elements
inserted or updated.
@end deffn

@geindex replace function
@anchor{24}@anchor{replace/stlmap}
@deffn {Function} replace map key x

@code{map} must be a stlmap, stlmmap or stlhmap. If @code{key} is not stored in
@code{map} this function throws @code{out_of_bounds}. If @code{map} is a stlmap
or stlhmap and (oldkey=>oldval) is an element of @code{map}, where oldkey is
equivalent to @code{key}, change the element to (oldkey=>``x``). If @code{map} is
a stlmmap and @code{key} is stored in @code{map}, change the values of elements
with key eqivalent to @code{key}, one by one, to the elements of @code{x}. Add or
delete elements as necessary so that, when the smoke clears, the values of
@code{map}!``key`` are copies of the elements of @code{x}. In all cases, if
@code{key} is stored in @code{map} returns @code{x}.
@end deffn

Here are some examples using @pxref{24,,replace}.

@example
> members sm1;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

> replace sm1 "e" 50;
50

> members sm1;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>50]

> members smm1;
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

> replace smm1 "c" [31,33,35,36] $$ smm1!"c";
[31,33,35,36]

> replace smm1 "c" [] $$ smm1!"c";
[]

> members smm1;
["a"=>1,"b"=>2,"d"=>4,"e"=>5]
@end example

@noindent
@geindex replace_with function
@anchor{59}@anchor{replace_with/stlmap}
@deffn {Function} replace_with fun map (k=>v)

@code{map} must be a stlmap. The effect of this function is as follows: (a) if
~ @pxref{27,,member} @code{map} @code{k} then @pxref{23,,insert} @code{map}
(@code{k``=>dflt) else (), where dflt is ``map}'s dflt value, (b)
@pxref{24,,replace} @code{map} @code{k} nv when nv = @code{fun} @code{v}
(@code{map}!``k``) end. Returns @code{map}.
@end deffn

Here is an example using @pxref{59,,replace_with} in which a stlmmap is
converted to a stlmap.

@example
> let sm1 = emptystlmap;

> members smm;
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

> do (replace_with (:) sm1) smm;
()

> members sm1;
["a"=>[1],"b"=>[2],"c"=>[32,31],"d"=>[4],"e"=>[5]]
@end example

@noindent
Here is another example in which items are counted.

@example
> let sm1 = mkstlmap ( (<), 0 );

> members sms;
["a","b","c","c","d"]

> do (\x->replace_with (+) sm1 (x=>1)) sms;
()

> members sm1;
["a"=>1,"b"=>1,"c"=>2,"d"=>1]
@end example

@noindent
You can remove all the elements in a container, remove all the elements
equivalent to a given key or a remove a range of elements using the
@pxref{29,,erase} function.

@geindex erase function
@anchor{29}@anchor{erase/stlmap}
@deffn {Function} erase acon

@deffnx {Function} erase (acon,k)

@deffnx {Function} erase (acon,k1,k2)

The first form erases all elements in @code{acon} which can be any container
provided by pure-stlmap. The second erases all elements in @code{acon} with key
equivalent to @code{k}. The third erases the elements in the range
(@code{acon},``k1``,``k2``). The third form only applys to the ordered
containers (stlmap, stlmmap, stlset and stlmset), not stlhmap or stlhset
(because ranges are not defined for stlhmaps or stlhsets). Returns the
number of elements removed from the container.
@end deffn

Here are some examples using @pxref{29,,erase}.

@example
> members smm;
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

> erase (sm,"z");
0

> erase (smm,"c");
2

> members smm;
["a"=>1,"b"=>2,"d"=>4,"e"=>5]

> erase (smm,"b","e");
2

> members smm;;
["a"=>1,"e"=>5]
@end example

@noindent
@geindex stl swap function
@anchor{5a}@anchor{stl swap/stlmap}
@deffn {Function} stl::swap acon1 acon2

Swaps the elements of the two containers, @code{acon1} and @code{acon2} where
@code{acon1} and @code{acon2} are the same type of container (E.g., both are
stlmaps or both are stlmsets).
@end deffn


@node Accessing Elements,Conversions<2>,Modification,Container Operations
@anchor{accessing elements}@anchor{5b}@anchor{accessing-elements}
@section Accessing Elements
You can test if a key is stored in a container and access the value associated
with a key using the familiar @pxref{27,,member} and (!) functions.

@geindex member function
@anchor{27}@anchor{member/stlmap}
@deffn {Function} member acon k

Returns true if @code{acon}, any container provided by pure-stlmap, contains
an element that has a key that is equivalent to @code{k}.
@end deffn

@geindex infix function
@anchor{5c}@anchor{!/stlmap}
@deffn {Function} acon ! k

If @code{acon} is not a stlmmap then (a) if @code{acon} has an element with key
equivalent to @code{k} return its value, otherwise (b) throw an
@code{out_of_bounds} exception. If @code{acon} is a stlmmap then (a) if acon
has as least one element with key equivalent to @code{k} return a list of
values of all the elements with key equivalent to @code{k}, otherwise (b)
return an null list.
@end deffn

E.g.:

@example
> sm!"c";
3

> catch id $ sm!"f";    // "f" is not stored in sm
out_of_bounds

> catch id $ sm!100;    // 100 cannot be compared to strings using (<)
bad_argument

> smm!"c";              // for stlmmap, return list of values
[31,32]

> smm!"f";              // stlmmap returns null list if key is not stored
[]
@end example

@noindent
You can access a sequence of elements in an ordered container (stlmap, stlset,
stlmmap or stlmset) without resorting to iterators using the next_key and
prev_key functions.

@geindex stl next_key function
@geindex stl prev_key function
@anchor{5d}@anchor{stl next_key/stlmap}
@deffn {Function} stl::next_key acon k
@anchor{5e}@anchor{stl prev_key/stlmap}
@deffnx {Function} stl::prev_key acon k

@code{acon} must be a stlmap, stlset, stlmmap or stlmmap. Also if @code{k} is not
@pxref{20,,stl smbeg}, @pxref{21,,stl smend} or an element of acon
an @code{out_of_bounds} exception will be throw.  @pxref{5d,,next_key}
returns the key of the first element in acon that has a key that is greater
than @code{k}. If no such element exists or if @code{k} is
@pxref{21,,stl smend}, returns @pxref{21,,stl smend}.
@pxref{5e,,prev_key} returns the last element in acon that has a key
that is less that @code{k}, or, if no such element exists, throws an
@code{out_of_bounds} exception.
@end deffn

For various reasons, it is very common to see a call to (!) or
@pxref{24,,replace} preceded by a call to @pxref{27,,member} with the
same container and key. E.g.,

@example
> bump_wc sm w = if member sm w then replace sm w (sm!w + 1)
                 else insert sm (w=>1);
@end example

@noindent
In general, this function would require two lookups to add a new word and
three lookups to bump the count for an existing word. For the ordered
containers, lookups have O(log N) complexity which can be relatively slow for
large containers.

To speed things up, each stlmap or stlset maintains a small cache of (key, C++
iterator) pairs for recently accessed keys. During lookup, the cache is
checked for a matching key, and if the key is found, the element pointed to by
the C++ iterator is used immediately. Thus, when applied to a stlmap or
stlset bump_wc will use only one O(log N) search, rather than two or
three. For these purposes, a key matches a key in the cache only if it is the
same Pure object (i.e., the test is C++ pointer equality, not Pure's (===) or
(==) functions). For example, the following will result in two O(log N)
lookups.

@example
> if member sm "a" then sm!"a" else insert sm ("a"=>10);
@end example

@noindent
Here each "a" is a distinct Pure object. The two "a"s satisfy (==) and even
(===) but they are not the same internally and the caching mechanism will not
help.

Almost any pure-stlmap function that accepts a stlmap or stlset as an argument
will check the container's cache before doing an O(log N) lookup.  Currently
the cache is limited to hold only the most recently used key.

Here are some examples produced by compiling pure-stlmap with a trace function
that shows caching in action.

@example
> let a_key = "a";

> members sm;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

> member sm a_key;           // a_key is not yet in the cache
1

> sm!a_key;                  // a_key is found in the cache
found iterator for: "a"
1

> replace sm a_key 10;
found iterator for: "a"
10

> sm!"a";                    // "a" is a new key, not same C++ pointer as k or a_key
1

> let k = next_key sm a_key; // now k is in the cache, in front of a_key
found iterator for: "a"

> let k1 = next_key sm k;    // now k1 is at the head of the queue
found iterator for: "b"

> replace sm k1 30;
found iterator for: "c"
30

> members sm;
["a"=>10,"b"=>2,"c"=>30,"d"=>4,"e"=>5]
@end example

@noindent
These examples show that caching can be effective wnen visiting elements of a
stlmap or stlset in order using @code{next_key} or
@code{prev_key}.


@node Conversions<2>,Functional Programming<2>,Accessing Elements,Container Operations
@anchor{conversions<2>}@anchor{5f}@anchor{id2}
@section Conversions
The contents of a pure-stlmap container can be copied to a list, vector,
stlvec. For stlmaps, stlsets, stlmmaps and stlmsets, these operations
act on ranges as well as on the entire container.

@geindex members function
@anchor{2b}@anchor{members/stlmap}
@deffn {Function} members rng

Returns a list of the elments in the range, @code{rng}.
@end deffn

@geindex keys function
@geindex vals function
@anchor{60}@anchor{keys/stlmap}
@deffn {Function} keys rng
@anchor{61}@anchor{vals/stlmap}
@deffnx {Function} vals rng

Return the keys and vals of the range's elements.
@end deffn

Here are some examples using the @pxref{2b,,members}, @pxref{60,,keys}
and @pxref{61,,vals} functions.

@example
 > members shm;   // must do all of shm elements because shm is a stlhmap
["d"=>4,"e"=>5,"a"=>1,"b"=>2,"c"=>3]

> keys (sm,"b","e"); // can ask for a range - sm is an ordered container
["b","c","d"]

> vals (sm,"b","e");
[2,3,4]
@end example

@noindent
@geindex stl vector function
@anchor{2c}@anchor{stl vector/stlmap}
@deffn {Function} stl::vector rng

Return a vector containing the elments of in the range, rng.
@end deffn

@geindex stlvec function
@anchor{2d}@anchor{stlvec/stlmap}
@deffn {Function} stlvec rng

returns a stlvec containing the elments of in the range, rng.
@end deffn

You can also convert an ordered container (stlmap, stlset, stlmmap or stlmset)
into a stream of elements.

@geindex stream function
@anchor{2e}@anchor{stream/stlmap}
@deffn {Function} stream rng

Returns a stream consisting of the range's elements.
@end deffn

Here is an example using the stream function on a stlmmap.

@example
> members smm;
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

> take 3 $ stream smm;
("a"=>1):#<thunk 0xb70f438c>

> list ans;
["a"=>1,"b"=>2,"c"=>31]
@end example

@noindent

@node Functional Programming<2>,Comparison,Conversions<2>,Container Operations
@anchor{functional programming<2>}@anchor{62}@anchor{id3}
@section Functional Programming
pure-stlmap provides the most commonly used functional programming operations,
implemented to act on ranges as if they were lists.

@geindex do function
@geindex map function
@geindex filter function
@geindex foldl function
@geindex foldl1 function
@geindex foldr function
@geindex foldr1 function
@anchor{d}@anchor{do/stlmap}
@deffn {Function} do fun rng
@anchor{a}@anchor{map/stlmap}
@deffnx {Function} map fun rng
@anchor{c}@anchor{filter/stlmap}
@deffnx {Function} filter pred rng
@anchor{b}@anchor{foldl/stlmap}
@deffnx {Function} foldl fun x rng
@anchor{31}@anchor{foldl1/stlmap}
@deffnx {Function} foldl1 fun rng
@anchor{63}@anchor{foldr/stlmap}
@deffnx {Function} foldr fun x rng
@anchor{64}@anchor{foldr1/stlmap}
@deffnx {Function} foldr1 fun rng

These functions are the same as the corresponding functions provided in the
Prelude for lists. @code{rng} is a rng defined on a stlmap, stlset, stlmmap or
stlmset or @code{rng} is simply a stlhmap or stlhset. @pxref{63,,foldr} and
@pxref{64,,foldr1} are not defined for stlhmaps or stlhsets.
@end deffn

Here are some examples.

@example
> members sm;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

> map (\(k=>v)->k+str v) (sm,"b","e");
["b2","c3","d4"]

> foldr1 (\(k=>v) (ks=>sum)-> (k+ks=>v+sum)) (sm,"b","e");
"bcd"=>9

> filter (\(k=>v)->v mod 2) sm;
["a"=>1,"c"=>3,"e"=>5]
@end example

@noindent
@geindex listmap function
@geindex catmap function
@geindex rowmap function
@geindex rowcatmap function
@geindex colmap function
@geindex colcatmap function
@anchor{65}@anchor{listmap/stlmap}
@deffn {Function} listmap fun rng
@anchor{30}@anchor{catmap/stlmap}
@deffnx {Function} catmap fun rng
@anchor{66}@anchor{rowmap/stlmap}
@deffnx {Function} rowmap fun rng
@anchor{67}@anchor{rowcatmap/stlmap}
@deffnx {Function} rowcatmap fun rng
@anchor{68}@anchor{colmap/stlmap}
@deffnx {Function} colmap fun rng
@anchor{69}@anchor{colcatmap/stlmap}
@deffnx {Function} colcatmap fun rng

These functions are the same as the corresponding functions provided in the
Prelude for lists. @code{rng} is a rng defined on a stlmap, stlset, stlmmap or
stlmset or simply a stlhmap or stlhset.
@end deffn

These functions are provided primarily to enable the use of list and matrix
comprehensions over pure-stlmap's containers. E.g.,

@example
> [ k + str v | (k=>v) = (sm,"b","e")];
["b2","c3","d4"]

> [ k=>v | (k=>v) = sm; v mod 2];
["a"=>1,"c"=>3,"e"=>5]

> @{ @{k;v@} |  (k=>v) = sm; v mod 2@};
@{"a","c","e";1,3,5@}
@end example

@noindent
The functional programming operations work directly on the underlying data
structure.

@example
> let ints = 0..10000;

stats -m
> filter (==99) ints;
[99]
0s, 6 cells
@end example

@noindent

@node Comparison,Set Algorithms,Functional Programming<2>,Container Operations
@anchor{comparison}@anchor{6a}
@section Comparison
Two associative containers of the same type are considered to be equal if they
contain the same number of elements and if each pair of their corresponding
elements are equal. Two elements are equal if their keys are equivalent and,
if the container is a stlmap, stlmap or stlhmap, the values associated with
equal keys are equal (using the container's value-equal function).

@geindex stl map_equal function
@anchor{6b}@anchor{stl map_equal/stlmap}
@deffn {Function} stl::map_equal rng1 rng2
@end deffn

@geindex == infix function
@geindex ~= infix function
@anchor{6c}@anchor{==/stlmap}
@deffn {Function} rng1 == rng2
@anchor{6d}@anchor{~=/stlmap}
@deffnx {Function} rng1 ~= rng2

Test @code{rng1} and @code{rng2} for equality or nonequality where @code{rng1} and
@code{rng2} are ranges defined over containers of the same type.
@end deffn

You need to be careful when using these operators. E.g.,

@example
> members ss;
["a","b","c","d","e"]

> let xx = stlset ss;

> xx == ss;
1

> (xx,"a","c") == (ss,"a","c");  // oops!
0
@end example

@noindent
The second comparison was intended to compare identical ranges and return
true. It failed to do so because (==) is defined in the Prelude to compare
tuples element by element, long before it is defined in the stlmap module to
compare ranges. The tuple operation take precedence and determines that the
tuples are not equal because @code{xx} and @code{ss} are different (pointers) for
purposes of this comparison. To avoid this issue when using ranges, you can
use the @pxref{6b,,stl map_equal} function.

@quotation
> map_equal (xx,"a","c") (ss,"a","c");
1
@end quotation

The other comparison operators @code{(<)}, @code{(<=)},
@code{(>)} and @code{(>=)} are provided only for the ordered
containers (stlmap, stlset, stlmmap and stlmset). These operators reflect
lexicographical comparisons of keys and, then if the keys are equal,
lexicographical comparisons of values. I.e., this is not set inclusion - order
matters. Accordingly, these comparison operators are not defined for a stlhmap
or stlhset.

@geindex < infix function
@anchor{6e}@anchor{</stlmap}
@deffn {Function} rng1 < rng2

Traverse the ranges comparing pairs of elements e1 and e2. If e1 is less
than e2, stop and return true; if e2 is less than e1 then stop and return
false. If rng1 is exhausted but rng2 is not, return true, else return false.
The two ranges must be defined on ordered associative containers of the
same type.
@end deffn

@geindex > infix function
@geindex <= infix function
@geindex >= infix function
@anchor{6f}@anchor{>/stlmap}
@deffn {Function} rng1 > rng2
@anchor{70}@anchor{<=/stlmap}
@deffnx {Function} rng1 <= rng2
@anchor{71}@anchor{>=/stlmap}
@deffnx {Function} rng1 >= rng2

The these three operators are the same as @code{rng2} < @code{rng1},
~(@code{rng1}>``rng2`) and ~(@code{rng1``<``rng2}) respectively.
@end deffn

You also have to be careful when using equivalence and comparison operators
with stlmmaps because elements with the same key and different values are not
necessarily ordered by values.

@example
> let smm2 = stlmmap ["a"=>1,"b"=>2,"c"=>32,"c"=>31,"d"=>4];

> members smm;
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4]

> members smm2;
["a"=>1,"b"=>2,"c"=>32,"c"=>31,"d"=>4]

> smm == smm2; // probably not what you want
0
@end example

@noindent
These operations do not make much sense for a stlmmap unless elements with
equivalent keys are stored by value, in the order enforced by the stlmmap's
value-comp function. In this regard it is worth noting that, depending on your
implementation, the @pxref{23,,insert} function may or may not preserve the
order of insertion of elements with equivalent keys (C++11 does preserve the
order).


@node Set Algorithms,Direct C Calls,Comparison,Container Operations
@anchor{set algorithms}@anchor{72}@anchor{set-algorithms}
@section Set Algorithms
pure-stlmap provides wrappers for the STL set algorithms that apply to ranges
defined on the four ordered associative containers (stlmap, stlset, stlmmap
and stlmset). These algorithms are very efficient, with linear time
complexity, but they do require that the elements of the two ranges be
ordered. Accordingly, the set algorithms are not applicable to stlhmap or
stlhset. Also, when dealing with stlmmaps, care must be taken to ensure that
items with the equivalent keys are ordered by their values.

@geindex stl map_merge function
@anchor{73}@anchor{stl map_merge/stlmap}
@deffn {Function} stl::map_merge rng1 rng2

Constructs a new ordered container from @code{rng1} and then insert the elments
of @code{rng2} into the new container and return it. @code{rng1} and @code{rng2} must
be defined on the same type of ordered container.
@end deffn

@geindex stl map_union function
@geindex stl map_difference function
@geindex stl map_intersection function
@geindex stl map_symmetric_difference function
@geindex stl map_includes function
@anchor{3f}@anchor{stl map_union/stlmap}
@deffn {Function} stl::map_union rng1 rng2
@anchor{74}@anchor{stl map_difference/stlmap}
@deffnx {Function} stl::map_difference rng1 rng2
@anchor{3b}@anchor{stl map_intersection/stlmap}
@deffnx {Function} stl::map_intersection rng1 rng2
@anchor{75}@anchor{stl map_symmetric_difference/stlmap}
@deffnx {Function} stl::map_symmetric_difference rng1 rng2
@anchor{76}@anchor{stl map_includes/stlmap}
@deffnx {Function} stl::map_includes rng1 rng2

Returns a new ordered associative container of the same type as the ordered
containers underlying @code{rng1} and @code{rng2}. If the ranges are defined over
a stlmap or stlmmap elements of @code{rng1} have priority over the elments of
@code{rng2}. Uses @code{rng1}'s key-less-than, value-less-than and value-equal
functions.
@end deffn

pure-stlmap's set functions do not necessarily produce the same results as
their Pure standard library counterparts. In particular, when applied to
multi-keyed contaners, @pxref{3f,,stl map_union} Produces the multiset
union of its arguments while (+) in the Pure standard library produces the
multiset sum. If you want the multiset sum of a stlmmap or stlhmap, use
@pxref{73,,stl map_merge}. Also, in pure-stlmap, as in the STL, the left
hand map or set has priority of elements while in the Pure standard library
the right hand set has priority of elements. This can make a difference when
applying set operations to a pair of stlmaps or stlmmaps. E.g.,

@example
> let smm1 = stlmmap ["a"=>1,"b"=>2,"c"=>31,"c"=>32];
> let smm2 = stlmmap ["c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5];

> members $ map_merge smm1 smm2; // three "c"=>32
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5]

> members $ map_union smm1 smm2;  // two "c"=>32
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5]

> let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>31];
> let sm2 = stlmap ["c"=>32,"d"=>4,"e"=>5];

> members $ map_union sm1 sm2; // "c"=>31 from sm1, not "c"=>32 from sm2
["a"=>1,"b"=>2,"c"=>31,"d"=>4,"e"=>5]

> members $ map_intersection sm1 sm2; // "c"=>31 from sm1
["c"=>31]
@end example

@noindent

@node Direct C Calls,,Set Algorithms,Container Operations
@anchor{direct c calls}@anchor{77}@anchor{direct-c-calls}
@section Direct C Calls
It is common to encounter code that (a) tests if a key is stored in a
container using @pxref{27,,member} and (b) in the case of maps, retreives
the value or values associated with the key using (!) and/or (c) changes the
value or values using @pxref{24,,replace}. Depending on what modules have
been loaded, these functions may be heavily overloaded which can cause a small
delay when the functions are called. To avoid this, pure-stlmap exposes the
corresponding C functions so that they can be called directly. The C functions
have the same name as the overloaded functions except for a prefix. E.g.,

@geindex stl sm_member function
@geindex stl sm_get function
@geindex stl sm_put function
@anchor{78}@anchor{stl sm_member/stlmap}
@deffn {Function} stl::sm_member sm key
@anchor{79}@anchor{stl sm_get/stlmap}
@deffnx {Function} stl::sm_get sm key
@anchor{7a}@anchor{stl sm_put/stlmap}
@deffnx {Function} stl::sm_put sm key val

The first two functions are the direct C call equivalents of
(@pxref{27,,member} @code{sm} @code{key}) and (@code{sm!key}). The third is like
(@pxref{24,,replace} @code{sm} @code{key} @code{val}) except that it will insert
(key=>val) if key is not already stored in @code{sm}. Here, @code{sm} is a stlmap
or a stlset (except that sm_put is not defined for stlsets).
@end deffn

@geindex stl shm_member function
@geindex stl shm_get function
@geindex stl shm_put function
@anchor{7b}@anchor{stl shm_member/stlmap}
@deffn {Function} stl::shm_member shm key
@anchor{7c}@anchor{stl shm_get/stlmap}
@deffnx {Function} stl::shm_get shm key
@anchor{7d}@anchor{stl shm_put/stlmap}
@deffnx {Function} stl::shm_put shm key val

The first two functions are the direct C call equivalents of
(@pxref{27,,member} @code{shm} @code{key}) and (@code{shm!key}). The third is
like (@pxref{24,,replace} @code{shm} @code{key} @code{val}) except that it will
insert (key=>val) if key is not already stored in @code{shm}. Here, @code{shm} is
a stlhmap or a stlhset (except that shm_put is not defined for stlhsets).
@end deffn

@geindex stl smm_member function
@geindex stl smm_get function
@geindex stl smm_put function
@anchor{7e}@anchor{stl smm_member/stlmap}
@deffn {Function} stl::smm_member smm key
@anchor{7f}@anchor{stl smm_get/stlmap}
@deffnx {Function} stl::smm_get smm key
@anchor{80}@anchor{stl smm_put/stlmap}
@deffnx {Function} stl::smm_put smm key vals

The first two functions are the direct C call equivalents of
(@pxref{27,,member} @code{smm} @code{key}) and (@code{smm!key}). The third is
like (@pxref{24,,replace} @code{smm} @code{key} @code{val}) except that it will
insert (key=>val1, key=>val2, ...) if key is not already stored in @code{smm}.
Here, @code{smm} is a stlmmap or a stlmset (except that smm_put is not defined
for stlmsets).
@end deffn


@node Iterators<2>,Backward Compatibilty,Container Operations,Top
@anchor{iterators<2>}@anchor{81}@anchor{id4}
@chapter Iterators
This section provides a quick overview of pure-stlmap's "iterator-based"
interface.


@menu
* Concepts: Concepts<2>.
* Exceptions::
* Functions::
* Examples: Examples<2>.
@end menu


@node Concepts<2>,Exceptions,,Iterators<2>
@anchor{concepts<2>}@anchor{82}@anchor{id5}
@section Concepts
Given a valid iterator you can access, modify or erase the element it points
to.

@example
> let sm1 = stlmap sm; members sm1;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];

> let i = find sm1 "b";   // use find to get an iterator - like C++

> get_elm i;
"b"=>2

> get_val i;
2

> put_val i 20;
20

> members sm1;
["a"=>1,"b"=>20,"c"=>3,"d"=>4,"e"=>5]
@end example

@noindent
Please note that you can never modify an element's key, only its value. If you
want to change both key and value, you have to erase the element and insert a
new element.

@example
> erase (sm1,i) $$ insert sm1 ("b1"=>21);
1

> members sm1;
["a"=>1,"b1"=>21,"c"=>3,"d"=>4,"e"=>5]
@end example

@noindent
Given two iterators, i and j, pointing into a ordered container oc, the
range (i,j), denotes oc's elements starting with "oc[i]", the element pointed
to by i, up to but not including oc[j]. In pure-stlmap, this range is denoted
by the tuple (i,j).

@example
> members sm;
["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

> let i = stl::find sm1 "b"; // get the iterator

> let j = stl::find sm1 "e";

> members (i,j);             // get the elements in the range
["b"=>2,"c"=>3,"d"=>4]
@end example

@noindent
Perhaps it is worth mentioning that functions that act on ranges do not care
if the range is specified by a pair of iterators or by keys.

@example
> members ss;
["a","b","c","d","e"]

> map (+21) (ss,"c",smend);
["x","y","z"]

> let i = find ss "c";
> let j = pastend ss;
> map (+21) (i,j);
["x","y","z"]
@end example

@noindent

@node Exceptions,Functions,Concepts<2>,Iterators<2>
@anchor{exceptions}@anchor{83}
@section Exceptions
In pure-stlmap functions that accept iterators throw a @code{bad_argument}
exception if called with an invalid iterator. An iterator remains valid until
the element it was pointing to has been erased. These functions also attempt
to throw bad argument exceptions for invalid usage that would otherwise result
in undefined behavior. An example of an invalid use would be a range specified
by iterators from different containers. Here are some examples of iterator
errors.

@example
> let i,j = find sm "a", find sm "d";

> get_elm i, get_elm j;
"a"=>1,"d"=>4

> members (i,j);
["a"=>1,"b"=>2,"c"=>3]

> catch id $ members (j,i); // j and i transposed, C++ would segfault
bad_argument

> erase (sm,"b");  // erase "b"=>2, leaving i and j valid
1

> get_elm i; // still valid
"a"=>1

> erase (sm,"a");  // erase "a"=>1 - invalidating i
1

> catch id $ get_elm i; // bad iterator exception
bad_argument
@end example

@noindent

@node Functions,Examples<2>,Exceptions,Iterators<2>
@anchor{functions}@anchor{84}
@section Functions
In this section "acon" always denotes one of the containers that supports
interators (stlmap, stlset, stlmmap and stlmset).

@geindex stl iterator function
@anchor{85}@anchor{stl iterator/stlmap}
@deffn {Function} stl::iterator i

Returns a new iterator that points to the same element as @code{i}.
@end deffn

@geindex stl begin function
@geindex stl pastend function
@anchor{86}@anchor{stl begin/stlmap}
@deffn {Function} stl::begin acon
@anchor{87}@anchor{stl pastend/stlmap}
@deffnx {Function} stl::pastend acon

Returns @code{acon}'s begin or past-end iterator.
@end deffn

@geindex stl find function
@anchor{88}@anchor{stl find/stlmap}
@deffn {Function} stl::find acon k

Creates a new iterator that points to an element in @code{acon} with key
equivalent to @code{k} (if any) or @code{acon}'s past-end iterator if no such
element exists.
@end deffn

@geindex stl find_with_default function
@anchor{89}@anchor{stl find_with_default/stlmap}
@deffn {Function} stl::find_with_default map k

Returns an iterator pointing to the element in @code{map}, a stlmap, with key
equivalent to @code{k}. If no such element existed before the call, one is
created and inserted using @code{k} and @code{map}'s default value. This function
is pure-stlmap's version of C++'s [] operator for associative containers.
@end deffn

@geindex stl insert_elm function
@anchor{8a}@anchor{stl insert_elm/stlmap}
@deffn {Function} stl::insert_elm acon elm

Attempts to insert @code{elm} into @code{acon}. (If @code{acon} is a stlmap or
stlmmap, then elm must be a key value pair, (k=>v)). If acon is a stlmap or
stlset (i.e., with unique keys) @pxref{8a,,insert_elm} returns a pair,
the first of which is an iterator pointing to the element with key k that
was just inserted (or the pre-existing element that blocked the
insertion). The second element in the pair is a boolean value that is true
if a new element was inserted. In contrast, if @code{acon} is a multi-keyed
container (stlmmap or stlmset) the insert will always be successful and
@pxref{8a,,insert_elm} returns an iterator pointing to the element with
key k that was just inserted, instead of an (iterator, boolean) tuple.
@end deffn

@geindex stl insert_elm function
@deffn {Function} stl::insert_elm acon (elm,i)

This is the same as the previous function except that (a) @code{i} is passed in
as a hint to where the new element should be inserted and (b) a single
iterator is returned rather than a iterator,boolean pair. If the new element
is inserted just after @code{i}, the insertion can have constant time
complexity.
@end deffn

@geindex stl l_bound function
@anchor{8b}@anchor{stl l_bound/stlmap}
@deffn {Function} stl::l_bound acon k

Return a new iterator that points to the first element in @code{acon}, a
stlmap, stlset, stlmmap or stlmset, that is not less than @code{k}, or
@code{acon}'s past-end iterator if none exists.
@end deffn

@geindex stl u_bound function
@anchor{8c}@anchor{stl u_bound/stlmap}
@deffn {Function} stl::u_bound acon k

Return a new iterator that points to the first element in @code{acon}, a
stlmap, stlset, stlmmap or stlmset, that is greater than @code{k}, or
@code{acon}'s past-end iterator if none exists.
@end deffn

@geindex stl lu_bounds function
@anchor{8d}@anchor{stl lu_bounds/stlmap}
@deffn {Function} stl::lu_bounds acon k

Return the pair l_bound @code{acon} @code{k}, u_bound @code{acon} @code{k}.
@end deffn

@c function range_info /stlmap rng
@c 
@c Returns a tuple (ok, sac, first, last) where ok is true if ``rng`` is a
@c valid range defined on a stlmap, stlset, stlmmap or stlmset, ac is the
@c container that the range points into, and first and last are iterators that
@c define the range.
E.g.,

@example
> let ok, smx, f, l = stl::range_info (sm1,"b","e");

> ok, smx === sm1, stl::members (f,l);
1,1,["b"=>2,"c"=>3,"d"=>4]
@end example

@noindent
@geindex stl inc function
@geindex stl dec function
@geindex stl move function
@anchor{8e}@anchor{stl inc/stlmap}
@deffn {Function} stl::inc i
@anchor{8f}@anchor{stl dec/stlmap}
@deffnx {Function} stl::dec i
@anchor{90}@anchor{stl move/stlmap}
@deffnx {Function} stl::move i n::int

Move the iterator @code{i} forward one, back one or forward @code{n} elements
respectively, where n can be negative.  The iterator is mutated by these
operations, provided the move is successful. An attempt to move to a
position before the first element's position causes an @code{out_of_bounds}
exception. Moves past the last element return the past-end iterator for the
container that @code{i} is defined on.
@end deffn

@geindex stl get_elm function
@geindex stl get_key function
@geindex stl get_val function
@anchor{91}@anchor{stl get_elm/stlmap}
@deffn {Function} stl::get_elm i
@anchor{92}@anchor{stl get_key/stlmap}
@deffnx {Function} stl::get_key i
@anchor{93}@anchor{stl get_val/stlmap}
@deffnx {Function} stl::get_val i

Return the element pointed to by the iterator @code{i}, or the element's key
or value. For maps the element is returned as a key=>value hash rocket
pair. For sets, get_elem, get_key and get_val all return the element (which
is the same as its key).
@end deffn

@geindex stl put_val function
@anchor{94}@anchor{stl put_val}
@deffn {Function} stl::put_val i newvalue

Change the value of the element pointed to by the iterator @code{i} to
@code{newvalue}. The element's key cannot be changed. The iterator must point
into a stlmap or stlmmap.
@end deffn

@geindex stl beginp function
@geindex stl pastendp function
@anchor{95}@anchor{stl beginp/stlmap}
@deffn {Function} stl::beginp i
@anchor{96}@anchor{stl pastendp/stlmap}
@deffnx {Function} stl::pastendp i

Returns true if the iterator @code{i} is the begin iterator or pastend
iterator of the container it is defined on.
@end deffn

@geindex stl get_info function
@anchor{97}@anchor{stl get_info/stlmap}
@deffn {Function} stl::get_info i

Returns a tuple (is_valid,acon,key,val) where is_valid is true if the
iterator @code{i} is valid or false if not, acon is the container that i is
defined on, and key, val are the key and value of the element @code{i} points
to, if any. If @code{i} is the past-end iterator, key and val are set to
@pxref{21,,stl smend} and @code{[]}, respectively.
@end deffn

@geindex == infix function
@deffn {Function} i == j

Returns true if the iterators @code{i} and @code{j} point to the same element.
@end deffn

@geindex erase function
@deffn {Function} erase (acon,i)

@deffnx {Function} erase (acon,i,j)

Erases the element pointed to by @code{i} or the elements in the range
(@code{i}, @code{j}). Both @code{i} and @code{j} must be iterators defined on
@code{acon} (or a @code{bad_argument} exception will be thrown).
@end deffn


@node Examples<2>,,Functions,Iterators<2>
@anchor{examples<2>}@anchor{98}@anchor{id6}
@section Examples
Here are some examples using iterators.

@example
> let b,e = begin smm, pastend smm;

> members (b,e);
["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

> let i,j = lu_bounds smm "c";

> members (b,i);
["a"=>1,"b"=>2]

> members (i,j);
["c"=>31,"c"=>32]

> members (j,e);
["d"=>4,"e"=>5]

> get_elm i;
"c"=>31

> get_elm (inc i);
"c"=>32

> put_val i 132;
132

> map (\(k=>_)->k=>ord k) (b,i);
["a"=>97,"b"=>98,"c"=>99]

> let is_set, smm1, k, v = get_info i; is_set, members smm1, k, v;
1,["a"=>1,"b"=>2,"c"=>31,"c"=>132,"d"=>4,"e"=>5],"c",132

> get_elm (dec j);
"c"=>132

> inc j $$ inc j $$ get_elm j;
"e"=>5

> inc j $$ endp j;
1
@end example

@noindent

@node Backward Compatibilty,Index,Iterators<2>,Top
@anchor{backward compatibilty}@anchor{99}@anchor{backward-compatibilty}
@chapter Backward Compatibilty
This section documents changes in pure-stlmap.


@menu
* pure-stlmap-0 2::
* pure-stlmap-0 3::
@end menu


@node pure-stlmap-0 2,pure-stlmap-0 3,,Backward Compatibilty
@anchor{9a}@anchor{pure-stlmap-0-2}
@section pure-stlmap-0.2
Optimized common predicates, such as (<) and (>)


@node pure-stlmap-0 3,,pure-stlmap-0 2,Backward Compatibilty
@anchor{9b}@anchor{pure-stlmap-0-3}
@section pure-stlmap-0.3
Fixed (>) comparisons on plain old data.


@node Index,,Backward Compatibilty,Top
@anchor{index}
@unnumbered Index
@printindex ge

@c %**end of body
@bye
