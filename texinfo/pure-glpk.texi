\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-glpk.info
@documentencoding UTF-8
@copying
Generated by Sphinx
@end copying
@settitle pure-glpk
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-glpk: (pure-glpk.info).    Pure-GLPK - GLPK interface for the Pure programming language
@end direntry

@c %**end of header

@titlepage
@title pure-glpk
@author Albert Gr√§f (Editor)
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-glpk
@end ifnottex

@c %**start of body
Version 0.2, June 26, 2012

Jiri Spitz <@email{jiri.spitz@@bluetone.cz}>

This module provides a feature complete GLPK interface for the Pure programming
language, which lets you use all capabilities of the GNU Linear Programming Kit
(GLPK) directly from Pure.

GLPK (see @indicateurl{http://www.gnu.org/software/glpk}) contains an efficient simplex
LP solver, a simplex LP solver in exact arithmetics, an interior-point solver,
a branch-and-cut solver for mixed integer programming and some specialized
algorithms for net/grid problems. Using this interface you can build, modify
and solve the problem, retrieve the solution, load and save the problem and
solution data in standard formats and use any of advanced GLPK features.

The interface uses native Pure data types - lists and tuples - so that you
need not perform any data conversions to/from GLPK internal data structures.

To make this module work, you must have a GLPK installation on your system,
the version 4.42 or higher is required.

@c Note: If you're wondering about the funny formatting, this README
@c simultaneously serves to generate the documentation for this module
@c in a variety of formats, using the docutils text formatting system
@c (http://docutils.sourceforge.net/).

@menu
* Installation::
* Error Handling::
* Further Information and Examples::
* Interface description::
* Descriptions of interface functions::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Descriptions of interface functions

* Basic API routines::
* Utility API routines::
* Advanced API routines::
* Branch-and-cut API routines::
* Graph and network API routines::
* Miscellaneous routines::
@end detailmenu
@end menu


@node Installation,Error Handling,Top,Top
@anchor{installation}@anchor{0}@anchor{pure-glpk-glpk-interface-for-the-pure-programming-language}@anchor{1}
@chapter Installation
Get the latest source from
@indicateurl{http://pure-lang.googlecode.com/files/pure-glpk-0.2.tar.gz}.

Run @code{make} to compile the module and @code{make install} (as root) to install
it in the Pure library directory. This requires GNU make, and of course you
need to have Pure installed.

The default make options suppose that GLPK was configured with the following
options:
@code{--enable-dl --enable-odbc --enable-mysql --with-gmp --with-zlib}

Using the given options the depndencies are:

@itemize -
@item
GNU Multiprecision Library (GMP) - serves for the exact simplex solver.
When disabled, the exact solver still works but it is much slower.
@item
ODBC library - serves for reading data directly from database tables
within the GNU MathProg language translator through the ODBC interface.
@item
zlib compression library - enables reading and writing gzip compressed
problem and solution files.
@item
MySQL client library - serves for reading data directly from MySQL tables
within the GNU MathProg language translator.
@item
ltdl dlopen library - must be enabled together with any of ODBC, zlib or
MySQL.
@end itemize

@code{make} tries to guess your Pure installation directory and platform-specific
setup. If it gets this wrong, you can set some variables manually. In
particular, @code{make install prefix=/usr} sets the installation prefix, and
@code{make PIC=-fPIC} or some similar flag might be needed for compilation on 64
bit systems. The variable @code{ODBCLIB} specifies the ODBC library to be linked
with. The default value is @code{ODBCLIB=-lodbc}. Please see the Makefile for
details.


@node Error Handling,Further Information and Examples,Installation,Top
@anchor{error handling}@anchor{2}@anchor{error-handling}
@chapter Error Handling
When an error condition occurs, the GLPK library itself prints an error mesage
and terminates the application. This behaviour is not pleasant when working
within an interpreter. Therefore, the Pure - GLPK bindings catches at least
the most common errors like indices out of bounds. On such an error an
appropriate message is returned to the interpreter. The less common errors
are still trapped by the GLPK library.

When one of the most common errors occurs, an error term of the form
@code{glp::error message} will be returned, which specifies what kind of error
happend. For instance, an index out of boundsd will cause a report like the
following:

@code{glp::error "[Pure GLPK error] row index out of bounds"}

You can check for such return values and take some appropriate action. By
redefining @code{glp::error} accordingly, you can also have it generate exceptions
or print an error message. For instance:

@code{glp::error message = fprintf stderr "%s\n" message $$ ();}

@strong{NOTE:} When redefining @code{glp::error} in this manner, you should be aware
that the return value of @code{glp::error} is what will be returned by the other
operations of this module in case of an error condition. These return values
are checked by other functions. Thus the return value should still indicate
that an error has happened, and not be something that might be interpreted
as a legal return value, such as an integer or a nonempty tuple. It is usually
safe to have @code{glp::error} return an empty tuple or throw an exception, but
other types of return values should be avoided.

@strong{IMPORTANT:} It is really good to define a @code{glp::error} function,
otherwise the errors might remain unnoticed.


@node Further Information and Examples,Interface description,Error Handling,Top
@anchor{further information and examples}@anchor{3}@anchor{further-information-and-examples}
@chapter Further Information and Examples
For further details about the operations provided by this module please see
the GLPK Reference Manual. Sample scripts illustrating the usage of the module
can be found in the examples directory.


@node Interface description,Descriptions of interface functions,Further Information and Examples,Top
@anchor{interface description}@anchor{4}@anchor{interface-description}
@chapter Interface description
Most GLPK functions and symbols live in the namespace @code{glp}. There are a few
functions and symbols in the namespace @code{lpx}. These functions and symbols
are likely to be removed and replaced by new ones in the future.

In general, when you replace the @code{glp_} prefix from the GLPK Reference Manual
with the namespace specification @code{glp::} then you receive the function name
in this module. The same is valid for @code{lpx_} and @code{lpx::}. The symbolic
constants are converted into lower case in this module, again obeying the
same prefix rules.


@node Descriptions of interface functions,Index,Interface description,Top
@anchor{descriptions of interface functions}@anchor{5}@anchor{descriptions-of-interface-functions}
@chapter Descriptions of interface functions

@menu
* Basic API routines::
* Utility API routines::
* Advanced API routines::
* Branch-and-cut API routines::
* Graph and network API routines::
* Miscellaneous routines::
@end menu


@node Basic API routines,Utility API routines,,Descriptions of interface functions
@anchor{basic api routines}@anchor{6}@anchor{basic-api-routines}
@section Basic API routines

@menu
* Problem creating and modifying routines::
* Problem retrieving routines::
* Row and column searching routines::
* Problem scaling routines::
* LP basis constructing routines::
* Simplex method routines::
* Interior-point method routines::
* Mixed integer programming routines::
* Additional routines::
@end menu


@node Problem creating and modifying routines,Problem retrieving routines,,Basic API routines
@anchor{problem creating and modifying routines}@anchor{7}@anchor{problem-creating-and-modifying-routines}
@subsection Problem creating and modifying routines

@menu
* Create the GLPK problem object::
* Set the problem name::
* Set objective name::
* Set the objective direction::
* Add new rows to the problem::
* Add new columns to the problem::
* Set the row name::
* Set the column name::
* Set change row bounds::
* Set change column bounds::
* Set change objective coefficient or constant term::
* Load or replace matrix row::
* Load or replace matrix column::
* Load or replace the whole problem matrix::
* Check for duplicate elements in sparse matrix::
* Sort elements of the constraint matrix::
* Delete rows from the matrix::
* Delete columns from the matrix::
* Copy the whole content of the GLPK problem object to another one::
* Erase all data from the GLPK problem object::
* Delete the GLPK problem object::
@end menu


@node Create the GLPK problem object,Set the problem name,,Problem creating and modifying routines
@anchor{create the glpk problem object}@anchor{8}@anchor{create-the-glpk-problem-object}
@subsubsection Create the GLPK problem object
@strong{Synopsis}:

@example
glp::create_prob
@end example

@noindent
@strong{Parameters}:

@quotation
none
@end quotation

@strong{Returns}:

@quotation
pointer to the LP problem object
@end quotation

@strong{Example}:

@example
> let lp = glp::create_prob;
> lp;
#<pointer 0x9de7168>
@end example

@noindent

@node Set the problem name,Set objective name,Create the GLPK problem object,Problem creating and modifying routines
@anchor{set the problem name}@anchor{9}@anchor{set-the-problem-name}
@subsubsection Set the problem name
@strong{Synopsis}:

@example
glp::set_prob_name lp name
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item name:
problem name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_prob_name lp "Testing problem";
()
@end example

@noindent

@node Set objective name,Set the objective direction,Set the problem name,Problem creating and modifying routines
@anchor{set objective name}@anchor{a}@anchor{set-objective-name}
@subsubsection Set objective name
@strong{Synopsis}:

@example
glp::set_obj_name lp name
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item name:
objective name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_obj_name lp "Total costs";
()
@end example

@noindent

@node Set the objective direction,Add new rows to the problem,Set objective name,Problem creating and modifying routines
@anchor{set the objective direction}@anchor{b}@anchor{set-the-objective-direction}
@subsubsection Set the objective direction
@strong{Synopsis}:

@example
glp::set_obj_dir lp direction
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item direction:
one of the following:


@itemize @w
@item glp::min:
minimize

@item glp::max:
maximize
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_obj_dir lp glp::min;
()
@end example

@noindent

@node Add new rows to the problem,Add new columns to the problem,Set the objective direction,Problem creating and modifying routines
@anchor{add new rows to the problem}@anchor{c}@anchor{add-new-rows-to-the-problem}
@subsubsection Add new rows to the problem
@strong{Synopsis}:

@example
glp::add_rows lp count
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item count:
number of rows to add
@end itemize
@end quotation

@strong{Returns}:

@quotation
index of the first row added
@end quotation

@strong{Example}:

@example
> let first_added_row = glp_add_rows lp 3;
> first_added_row;
6
@end example

@noindent

@node Add new columns to the problem,Set the row name,Add new rows to the problem,Problem creating and modifying routines
@anchor{add new columns to the problem}@anchor{d}@anchor{add-new-columns-to-the-problem}
@subsubsection Add new columns to the problem
@strong{Synopsis}:

@example
glp::add_cols lp count
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item count:
number of columns to add
@end itemize
@end quotation

@strong{Returns}:

@quotation
index of the first column added
@end quotation

@strong{Example}:

@example
> let first_added_col = glp_add_cols lp 3;
> first_added_col;
5
@end example

@noindent

@node Set the row name,Set the column name,Add new columns to the problem,Problem creating and modifying routines
@anchor{set the row name}@anchor{e}@anchor{set-the-row-name}
@subsubsection Set the row name
@strong{Synopsis}:

@example
glp::set_row_name lp (rowindex, rowname)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index

@item rowname:
row name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_row_name lp (3, "The third row");
()
@end example

@noindent

@node Set the column name,Set change row bounds,Set the row name,Problem creating and modifying routines
@anchor{set the column name}@anchor{f}@anchor{set-the-column-name}
@subsubsection Set the column name
@strong{Synopsis}:

@example
glp::set_col_name lp (colindex, colname)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index

@item colname:
column name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_col_name lp (3, "The third column");
()
@end example

@noindent

@node Set change row bounds,Set change column bounds,Set the column name,Problem creating and modifying routines
@anchor{set change row bounds}@anchor{10}@anchor{set-change-row-bounds}
@subsubsection Set (change) row bounds
@strong{Synopsis}:

@example
glp::set_row_bnds lp (rowindex, rowtype, lowerbound, upperbound)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index

@item rowtype:
one of the following:


@itemize @w
@item glp::fr:
free variable (both bounds are ignored)

@item glp::lo:
variable with lower bound (upper bound is ignored)

@item glp::up:
variable with upper bound (lower bound is ignored)

@item glp::db:
double bounded variable

@item glp::fx:
fixed variable (lower bound applies, upper bound is ignored)
@end itemize

@item lowerbound:
lower row bound

@item upperbound:
upper row bound
@end itemize
@end quotation


@table @asis
@item @strong{Returns}:
@code{()}

@item @strong{Example}::
@code{glp::set_row_bnds lp (3, glp::up, 0.0, 150.0);}
@end table


@node Set change column bounds,Set change objective coefficient or constant term,Set change row bounds,Problem creating and modifying routines
@anchor{set change column bounds}@anchor{11}@anchor{set-change-column-bounds}
@subsubsection Set (change) column bounds
@strong{Synopsis}:

@example
glp::set_col_bnds lp (colindex, coltype, lowerbound, upperbound)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index

@item coltype:
one of the following:


@itemize @w
@item glp::fr:
free variable (both bounds are ignored)

@item glp::lo:
variable with lower bound (upper bound is ignored)

@item glp::up:
variable with upper bound (lower bound is ignored)

@item glp::db:
double bounded variable

@item glp::fx:
fixed variable (lower bound applies, upper bound is ignored)
@end itemize

@item lowerbound:
lower column bound

@item upperbound:
upper column bound
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_col_bnds lp (3, glp::db, 100.0, 150.0);
()
@end example

@noindent

@node Set change objective coefficient or constant term,Load or replace matrix row,Set change column bounds,Problem creating and modifying routines
@anchor{set change objective coefficient or constant term}@anchor{12}@anchor{set-change-objective-coefficient-or-constant-term}
@subsubsection Set (change) objective coefficient or constant term
@strong{Synopsis}:

@example
glp::set_obj_coef lp (colindex, coefficient)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index, zero index denotes the constant term
(objective shift)
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_obj_coef lp (3, 15.8);
()
@end example

@noindent

@node Load or replace matrix row,Load or replace matrix column,Set change objective coefficient or constant term,Problem creating and modifying routines
@anchor{load or replace matrix row}@anchor{13}@anchor{load-or-replace-matrix-row}
@subsubsection Load or replace matrix row
@strong{Synopsis}:

@example
glp::set_mat_row lp (rowindex, rowvector)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index

@item rowvector:
list of tuples (colindex, coefficient); only non-zero
coefficients have to be specified, the order of column
indices is not important, duplicates are @strong{not} allowed
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_mat_row lp (3, [(1, 3.0), (4, 5.2)]);
()
@end example

@noindent

@node Load or replace matrix column,Load or replace the whole problem matrix,Load or replace matrix row,Problem creating and modifying routines
@anchor{load or replace matrix column}@anchor{14}@anchor{load-or-replace-matrix-column}
@subsubsection Load or replace matrix column
@strong{Synopsis}:

@example
glp::set_mat_col lp (colindex, colvector)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index

@item colvector:
list of tuples (rowindex, coefficient); only non-zero
coefficients have to be specified, the order of row
indices is not important, duplicates are @strong{not} allowed
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_mat_col lp (2, [(4, 2.0), (2, 1.5)]);
()
@end example

@noindent

@node Load or replace the whole problem matrix,Check for duplicate elements in sparse matrix,Load or replace matrix column,Problem creating and modifying routines
@anchor{load or replace the whole problem matrix}@anchor{15}@anchor{load-or-replace-the-whole-problem-matrix}
@subsubsection Load or replace the whole problem matrix
@strong{Synopsis}:

@example
glp::load_matrix lp matrix
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item matrix:
list of tuples (rowindex, colindex, coefficient); only non-zero
coefficients have to be specified, the order of indices is not
important, duplicates are @strong{not} allowed
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::load_matrix lp [(1, 3, 5.0), (2, 2, 3.5), (3, 1, -2.0), (3, 2, 1.0)];
()
@end example

@noindent

@node Check for duplicate elements in sparse matrix,Sort elements of the constraint matrix,Load or replace the whole problem matrix,Problem creating and modifying routines
@anchor{check for duplicate elements in sparse matrix}@anchor{16}@anchor{check-for-duplicate-elements-in-sparse-matrix}
@subsubsection Check for duplicate elements in sparse matrix
@strong{Synopsis}:

@example
glp::check_dup numrows numcols indices
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item numrows:
number of rows

@item numcols:
number of columns

@item indices:
list of tuples (rowindex, colindex); indices of only non-zero
coefficients have to be specified, the order of indices is not
important
@end itemize
@end quotation

@strong{Returns}:

@quotation
returns one of the following:

@quotation

@itemize @w
@item 0:
the matrix has no duplicate elements

@item -k:
rowindex or colindex of the k-th element in indices is out of range

@item +k:
the k-th element in indices is duplicate
@end itemize
@end quotation
@end quotation

@strong{Remark:}

@quotation
Notice, that @code{k} counts from 1, whereas list members are counted from 0.
@end quotation

@strong{Example}:

@example
> glp::check_dup 3 3  [(1, 3), (2, 2), (3, 1), (2, 2)];
4
@end example

@noindent

@node Sort elements of the constraint matrix,Delete rows from the matrix,Check for duplicate elements in sparse matrix,Problem creating and modifying routines
@anchor{sort elements of the constraint matrix}@anchor{17}@anchor{sort-elements-of-the-constraint-matrix}
@subsubsection Sort elements of the constraint matrix
@strong{Synopsis}:

@example
glp::sort_matrix lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::sort_matrix lp;
()
@end example

@noindent

@node Delete rows from the matrix,Delete columns from the matrix,Sort elements of the constraint matrix,Problem creating and modifying routines
@anchor{delete rows from the matrix}@anchor{18}@anchor{delete-rows-from-the-matrix}
@subsubsection Delete rows from the matrix
@strong{Synopsis}:

@example
glp::del_rows lp rows
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rows:
list of indices of rows to be deleted; the order of indices is not
important, duplicates are @strong{not} allowed
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Remark:}

@quotation
Deleting rows involves changing ordinal numbers of other rows
remaining in the problem object. New ordinal numbers of the remaining
rows are assigned under the assumption that the original order of rows is
not changed.
@end quotation

@strong{Example}:

@example
> glp::del_rows lp [3, 4, 7];
()
@end example

@noindent

@node Delete columns from the matrix,Copy the whole content of the GLPK problem object to another one,Delete rows from the matrix,Problem creating and modifying routines
@anchor{delete columns from the matrix}@anchor{19}@anchor{delete-columns-from-the-matrix}
@subsubsection Delete columns from the matrix
@strong{Synopsis}:

@example
glp::del_cols lp cols
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item cols:
list of indices of columns to be deleted; the order of indices is not
important, duplicates are @strong{not} allowed
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Remark:}

@quotation
Deleting columns involves changing ordinal numbers of other columns
remaining in the problem object. New ordinal numbers of the remaining
columns are assigned under the assumption that the original order of
columns is not changed.
@end quotation

@strong{Example}:

@example
> glp::del_cols lp [6, 4, 5];
()
@end example

@noindent

@node Copy the whole content of the GLPK problem object to another one,Erase all data from the GLPK problem object,Delete columns from the matrix,Problem creating and modifying routines
@anchor{copy the whole content of the glpk problem object to another one}@anchor{1a}@anchor{copy-the-whole-content-of-the-glpk-problem-object-to-another-one}
@subsubsection Copy the whole content of the GLPK problem object to another one
@strong{Synopsis}:

@example
glp::copy_prob destination source names
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item destination:
pointer to the destination LP problem object (must already
exist)

@item source:
pointer to the source LP problem object

@item names:
one of the following:


@itemize @w
@item glp::on:
copy all symbolic names as well

@item glp::off:
do not copy the symbolic names
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::copy_prob lp_dest lp_src glp::on;
()
@end example

@noindent

@node Erase all data from the GLPK problem object,Delete the GLPK problem object,Copy the whole content of the GLPK problem object to another one,Problem creating and modifying routines
@anchor{erase all data from the glpk problem object}@anchor{1b}@anchor{erase-all-data-from-the-glpk-problem-object}
@subsubsection Erase all data from the GLPK problem object
@strong{Synopsis}:

@example
glp::erase_prob lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object, it remains still valid after
the function call
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::erase_prob lp;
()
@end example

@noindent

@node Delete the GLPK problem object,,Erase all data from the GLPK problem object,Problem creating and modifying routines
@anchor{delete the glpk problem object}@anchor{1c}@anchor{delete-the-glpk-problem-object}
@subsubsection Delete the GLPK problem object
@strong{Synopsis}:

@example
glp::delete_prob lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object, it is not valid any more after
the function call
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::delete_prob lp;
()
@end example

@noindent

@node Problem retrieving routines,Row and column searching routines,Problem creating and modifying routines,Basic API routines
@anchor{problem retrieving routines}@anchor{1d}@anchor{problem-retrieving-routines}
@subsection Problem retrieving routines

@menu
* Get the problem name::
* Get the objective name::
* Get the objective direction::
* Get number of rows::
* Get number of columns::
* Get name of a row::
* Get name of a column::
* Get row type::
* Get row lower bound::
* Get row upper bound::
* Get column type::
* Get column lower bound::
* Get column upper bound::
* Get objective coefficient::
* Get number of nonzero coefficients::
* Retrive a row from the problem matrix::
* Retrive a column from the problem matrix::
@end menu


@node Get the problem name,Get the objective name,,Problem retrieving routines
@anchor{get the problem name}@anchor{1e}@anchor{get-the-problem-name}
@subsubsection Get the problem name
@strong{Synopsis}:

@example
glp::get_prob_name lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
name of the problem
@end quotation

@strong{Example}:

@example
> glp::get_prob_name lp;
"Testing problem"
@end example

@noindent

@node Get the objective name,Get the objective direction,Get the problem name,Problem retrieving routines
@anchor{get the objective name}@anchor{1f}@anchor{get-the-objective-name}
@subsubsection Get the objective name
@strong{Synopsis}:

@example
glp::get_obj_name lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
name of the objective
@end quotation

@strong{Example}:

@example
> glp::get_obj_name lp;
"Total costs"
@end example

@noindent

@node Get the objective direction,Get number of rows,Get the objective name,Problem retrieving routines
@anchor{get the objective direction}@anchor{20}@anchor{get-the-objective-direction}
@subsubsection Get the objective direction
@strong{Synopsis}:

@example
glp::get_obj_dir lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
returns one of the following:

@quotation

@itemize @w
@item glp::min:
minimize

@item glp::max:
maximize
@end itemize
@end quotation
@end quotation

@strong{Example}:

@example
> glp::get_obj_dir lp;
glp::min
@end example

@noindent

@node Get number of rows,Get number of columns,Get the objective direction,Problem retrieving routines
@anchor{get number of rows}@anchor{21}@anchor{get-number-of-rows}
@subsubsection Get number of rows
@strong{Synopsis}:

@example
glp::get_num_rows lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
number of rows (constraints)
@end quotation

@strong{Example}:

@example
> glp::get_num_rows lp;
58
@end example

@noindent

@node Get number of columns,Get name of a row,Get number of rows,Problem retrieving routines
@anchor{get number of columns}@anchor{22}@anchor{get-number-of-columns}
@subsubsection Get number of columns
@strong{Synopsis}:

@example
glp::get_num_cols lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
number of columns (structural variables)
@end quotation

@strong{Example}:

@example
> glp::get_num_cols lp;
65
@end example

@noindent

@node Get name of a row,Get name of a column,Get number of columns,Problem retrieving routines
@anchor{get name of a row}@anchor{23}@anchor{get-name-of-a-row}
@subsubsection Get name of a row
@strong{Synopsis}:

@example
glp::get_row_name lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
name of the given row
@end quotation

@strong{Example}:

@example
> glp::get_row_name lp 3;
"The third row"
@end example

@noindent

@node Get name of a column,Get row type,Get name of a row,Problem retrieving routines
@anchor{get name of a column}@anchor{24}@anchor{get-name-of-a-column}
@subsubsection Get name of a column
@strong{Synopsis}:

@example
glp::get_col_name lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
name of the given column
@end quotation

@strong{Example}:

@example
> glp::get_col_name lp 2;
"The second column"
@end example

@noindent

@node Get row type,Get row lower bound,Get name of a column,Problem retrieving routines
@anchor{get row type}@anchor{25}@anchor{get-row-type}
@subsubsection Get row type
@strong{Synopsis}:

@example
glp::get_row_type lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
returns one of the following:

@quotation

@itemize @w
@item glp::fr:
free variable

@item glp::lo:
variable with lower bound

@item glp::up:
variable with upper bound

@item glp::db:
double bounded variable

@item glp::fx:
fixed variable
@end itemize
@end quotation
@end quotation

@strong{Example}:

@example
> glp::get_row_type lp 3;
glp::db
@end example

@noindent

@node Get row lower bound,Get row upper bound,Get row type,Problem retrieving routines
@anchor{get row lower bound}@anchor{26}@anchor{get-row-lower-bound}
@subsubsection Get row lower bound
@strong{Synopsis}:

@example
glp::get_row_lb lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
the row lower bound; if the row has no lower bound then it returns
the smallest double number
@end quotation

@strong{Example}:

@example
> glp::get_row_lb lp 3;
50.0
@end example

@noindent

@node Get row upper bound,Get column type,Get row lower bound,Problem retrieving routines
@anchor{get row upper bound}@anchor{27}@anchor{get-row-upper-bound}
@subsubsection Get row upper bound
@strong{Synopsis}:

@example
glp::get_row_ub lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
the row upper bound; if the row has no upper bound then it returns
the biggest double number
@end quotation

@strong{Example}:

@example
> glp::get_row_ub lp 3;
150.0
@end example

@noindent

@node Get column type,Get column lower bound,Get row upper bound,Problem retrieving routines
@anchor{get column type}@anchor{28}@anchor{get-column-type}
@subsubsection Get column type
@strong{Synopsis}:

@example
glp::get_col_type lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
returns one of the following:

@quotation

@itemize @w
@item glp::fr:
free variable

@item glp::lo:
variable with lower bound

@item glp::up:
variable with upper bound

@item glp::db:
double bounded variable

@item glp::fx:
fixed variable
@end itemize
@end quotation
@end quotation

@strong{Example}:

@example
> glp::get_col_type lp 2;
glp::up
@end example

@noindent

@node Get column lower bound,Get column upper bound,Get column type,Problem retrieving routines
@anchor{get column lower bound}@anchor{29}@anchor{get-column-lower-bound}
@subsubsection Get column lower bound
@strong{Synopsis}:

@example
glp::get_col_lb lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
the column lower bound; if the column has no lower bound then it returns
the smallest double number
@end quotation

@strong{Example}:

@example
> glp::get_col_lb lp 3;
-1.79769313486232e+308
@end example

@noindent

@node Get column upper bound,Get objective coefficient,Get column lower bound,Problem retrieving routines
@anchor{get column upper bound}@anchor{2a}@anchor{get-column-upper-bound}
@subsubsection Get column upper bound
@strong{Synopsis}:

@example
glp::get_col_ub lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
the column upper bound; if the column has no upper bound then it returns
the biggest double number
@end quotation

@strong{Example}:

@example
> glp::get_col_lb lp 3;
150.0
@end example

@noindent

@node Get objective coefficient,Get number of nonzero coefficients,Get column upper bound,Problem retrieving routines
@anchor{get objective coefficient}@anchor{2b}@anchor{get-objective-coefficient}
@subsubsection Get objective coefficient
@strong{Synopsis}:

@example
glp::get_obj_coef lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index; zero index denotes the constant term
(objective shift)
@end itemize
@end quotation

@strong{Returns}:

@quotation
the coefficient of given column in the objective
@end quotation

@strong{Example}:

@example
> glp::get_obj_coef lp 3;
5.8
@end example

@noindent

@node Get number of nonzero coefficients,Retrive a row from the problem matrix,Get objective coefficient,Problem retrieving routines
@anchor{get number of nonzero coefficients}@anchor{2c}@anchor{get-number-of-nonzero-coefficients}
@subsubsection Get number of nonzero coefficients
@strong{Synopsis}:

@example
glp::get_num_nz lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
number of non-zero coefficients in the problem matrix
@end quotation

@strong{Example}:

@example
> glp::get_num_nz lp;
158
@end example

@noindent

@node Retrive a row from the problem matrix,Retrive a column from the problem matrix,Get number of nonzero coefficients,Problem retrieving routines
@anchor{retrive a row from the problem matrix}@anchor{2d}@anchor{retrive-a-row-from-the-problem-matrix}
@subsubsection Retrive a row from the problem matrix
@strong{Synopsis}:

@example
glp::get_mat_row lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
non-zero coefficients of the given row in a list form of tuples
(colindex, coefficient)
@end quotation

@strong{Example}:

@example
> get_mat_row lp 3;
[(3,6.0),(2,2.0),(1,2.0)]
@end example

@noindent

@node Retrive a column from the problem matrix,,Retrive a row from the problem matrix,Problem retrieving routines
@anchor{retrive a column from the problem matrix}@anchor{2e}@anchor{retrive-a-column-from-the-problem-matrix}
@subsubsection Retrive a column from the problem matrix
@strong{Synopsis}:

@example
glp::get_mat_col lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
non-zero coefficients of the given column in a list form of tuples
(rowindex, coefficient)
@end quotation

@strong{Example}:

@example
> get_mat_col lp 2;
[(3,2.0),(2,4.0),(1,1.0)]
@end example

@noindent

@node Row and column searching routines,Problem scaling routines,Problem retrieving routines,Basic API routines
@anchor{row and column searching routines}@anchor{2f}@anchor{row-and-column-searching-routines}
@subsection Row and column searching routines

@menu
* Create index for searching rows and columns by their names::
* Find a row number by name::
* Find a column number by name::
* Delete index for searching rows and columns by their names::
@end menu


@node Create index for searching rows and columns by their names,Find a row number by name,,Row and column searching routines
@anchor{create index for searching rows and columns by their names}@anchor{30}@anchor{create-index-for-searching-rows-and-columns-by-their-names}
@subsubsection Create index for searching rows and columns by their names
@strong{Synopsis}:

@example
glp::create_index lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::create_index lp;
()
@end example

@noindent

@node Find a row number by name,Find a column number by name,Create index for searching rows and columns by their names,Row and column searching routines
@anchor{find a row number by name}@anchor{31}@anchor{find-a-row-number-by-name}
@subsubsection Find a row number by name
@strong{Synopsis}:

@example
glp::find_row lp rowname
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowname:
row name
@end itemize
@end quotation

@strong{Returns}:

@quotation
ordinal number (index) of the row
@end quotation

@strong{Remark}:

@quotation
The search index is automatically created if it does not already exists.
@end quotation

@strong{Example}:

@example
> glp::find_row lp "The third row";
3
@end example

@noindent

@node Find a column number by name,Delete index for searching rows and columns by their names,Find a row number by name,Row and column searching routines
@anchor{find a column number by name}@anchor{32}@anchor{find-a-column-number-by-name}
@subsubsection Find a column number by name
@strong{Synopsis}:

@example
glp::find_col lp colname
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colname:
column name
@end itemize
@end quotation

@strong{Returns}:

@quotation
ordinal number (index) of the column
@end quotation

@strong{Remark}:

@quotation
The search index is automatically created if it does not already exists.
@end quotation

@strong{Example}:

@example
> glp::find_col lp "The second row";
2
@end example

@noindent

@node Delete index for searching rows and columns by their names,,Find a column number by name,Row and column searching routines
@anchor{delete index for searching rows and columns by their names}@anchor{33}@anchor{delete-index-for-searching-rows-and-columns-by-their-names}
@subsubsection Delete index for searching rows and columns by their names
@strong{Synopsis}:

@example
glp::delete_index lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::delete:index lp;
()
@end example

@noindent

@node Problem scaling routines,LP basis constructing routines,Row and column searching routines,Basic API routines
@anchor{problem scaling routines}@anchor{34}@anchor{problem-scaling-routines}
@subsection Problem scaling routines

@menu
* Set the row scale factor::
* Set the column scale factor::
* Retrieve the row scale factor::
* Retrieve the column scale factor::
* Scale the problem data according to supplied flags::
* Unscale the problem data::
@end menu


@node Set the row scale factor,Set the column scale factor,,Problem scaling routines
@anchor{set the row scale factor}@anchor{35}@anchor{set-the-row-scale-factor}
@subsubsection Set the row scale factor
@strong{Synopsis}:

@example
glp::set_rii lp (rowindex, coefficient)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index

@item coefficient:
scaling coefficient
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_rii lp (3, 258.6);
()
@end example

@noindent

@node Set the column scale factor,Retrieve the row scale factor,Set the row scale factor,Problem scaling routines
@anchor{set the column scale factor}@anchor{36}@anchor{set-the-column-scale-factor}
@subsubsection Set the column scale factor
@strong{Synopsis}:

@example
glp::set_sjj lp (colindex, coefficient)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index

@item coefficient:
scaling coefficient
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_sjj lp (2, 12.8);
()
@end example

@noindent

@node Retrieve the row scale factor,Retrieve the column scale factor,Set the column scale factor,Problem scaling routines
@anchor{retrieve the row scale factor}@anchor{37}@anchor{retrieve-the-row-scale-factor}
@subsubsection Retrieve the row scale factor
@strong{Synopsis}:

@example
glp::get_rii lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
scaling coefficient of given row
@end quotation

@strong{Example}:

@example
> glp::get_rii lp 3;
258.6
@end example

@noindent

@node Retrieve the column scale factor,Scale the problem data according to supplied flags,Retrieve the row scale factor,Problem scaling routines
@anchor{retrieve the column scale factor}@anchor{38}@anchor{retrieve-the-column-scale-factor}
@subsubsection Retrieve the column scale factor
@strong{Synopsis}:

@example
glp::get_sjj lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
scaling coefficient of given column
@end quotation

@strong{Example}:

@example
> glp::get_sjj lp 2;
12.8
@end example

@noindent

@node Scale the problem data according to supplied flags,Unscale the problem data,Retrieve the column scale factor,Problem scaling routines
@anchor{scale the problem data according to supplied flags}@anchor{39}@anchor{scale-the-problem-data-according-to-supplied-flags}
@subsubsection Scale the problem data according to supplied flags
@strong{Synopsis}:

@example
glp::scale_prob lp flags
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item flags:
symbolic integer constants which can be combined together
by arithmetic @strong{or}; the possible constants are:


@itemize @w
@item glp::sf_gm:
perform geometric mean scaling

@item glp::sf_eq:
perform equilibration scaling

@item glp::sf_2n:
round scale factors to power of two

@item glp::sf_skip:
skip if problem is well scaled

@item glp::sf_auto:
choose scaling options automatically
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::scale_prob lp (glp::sf_gm || glp::sf_2n);
()
@end example

@noindent

@node Unscale the problem data,,Scale the problem data according to supplied flags,Problem scaling routines
@anchor{unscale the problem data}@anchor{3a}@anchor{unscale-the-problem-data}
@subsubsection Unscale the problem data
@strong{Synopsis}:

@example
glp::unscale_prob lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::unscale_prob lp;
()
@end example

@noindent

@node LP basis constructing routines,Simplex method routines,Problem scaling routines,Basic API routines
@anchor{lp basis constructing routines}@anchor{3b}@anchor{lp-basis-constructing-routines}
@subsection LP basis constructing routines

@menu
* Set the row status::
* Set the column status::
* Construct standard problem basis::
* Construct advanced problem basis::
* Construct Bixby's problem basis::
@end menu


@node Set the row status,Set the column status,,LP basis constructing routines
@anchor{set the row status}@anchor{3c}@anchor{set-the-row-status}
@subsubsection Set the row status
@strong{Synopsis}:

@example
glp::set_row_stat lp (rowindex, status)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index

@item status:
one of the following:


@itemize @w
@item glp::bs:
make the row basic (make the constraint inactive)

@item glp::nl:
make the row non-basic (make the constraint active)

@item glp::nu:
make the row non-basic and set it to the upper bound;
if the row is not double-bounded, this status is
equivalent to glp::nl (only in the case of this routine)

@item glp::nf:
the same as glp::nl (only in the case of this routine)

@item glp::ns:
the same as glp::nl (only in the case of this routine)
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_row_stat lp (3, glp::nu);
()
@end example

@noindent

@node Set the column status,Construct standard problem basis,Set the row status,LP basis constructing routines
@anchor{set the column status}@anchor{3d}@anchor{set-the-column-status}
@subsubsection Set the column status
@strong{Synopsis}:

@example
glp::set_col_stat lp (colindex, status)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index

@item status:
one of the following:


@itemize @w
@item glp::bs:
make the column basic

@item glp::nl:
make the column non-basic

@item glp::nu:
make the column non-basic and set it to the upper bound;
if the column is not double-bounded, this status is
equivalent to glp::nl (only in the case of this routine)

@item glp::nf:
the same as glp::nl (only in the case of this routine)

@item glp::ns:
the same as glp::nl (only in the case of this routine)
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_col_stat lp (2, glp::bs);
()
@end example

@noindent

@node Construct standard problem basis,Construct advanced problem basis,Set the column status,LP basis constructing routines
@anchor{construct standard problem basis}@anchor{3e}@anchor{construct-standard-problem-basis}
@subsubsection Construct standard problem basis
@strong{Synopsis}:

@example
glp::std_basis lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::std_basis lp;
()
@end example

@noindent

@node Construct advanced problem basis,Construct Bixby's problem basis,Construct standard problem basis,LP basis constructing routines
@anchor{construct advanced problem basis}@anchor{3f}@anchor{construct-advanced-problem-basis}
@subsubsection Construct advanced problem basis
@strong{Synopsis}:

@example
glp::adv_basis lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::adv_basis lp;
()
@end example

@noindent

@node Construct Bixby's problem basis,,Construct advanced problem basis,LP basis constructing routines
@anchor{construct bixby's problem basis}@anchor{40}@anchor{construct-bixby-s-problem-basis}
@subsubsection Construct Bixby's problem basis
@strong{Synopsis}:

@example
glp::cpx_basis lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::cpx_basis lp;
()
@end example

@noindent

@node Simplex method routines,Interior-point method routines,LP basis constructing routines,Basic API routines
@anchor{simplex method routines}@anchor{41}@anchor{simplex-method-routines}
@subsection Simplex method routines

@menu
* Solve the LP problem using simplex method::
* Solve the LP problem using simplex method in exact arithmetics::
* Retrieve generic status of basic solution::
* Retrieve generic status of primal solution::
* Retrieve generic status of dual solution::
* Retrieve value of the objective function::
* Retrieve generic status of a row variable::
* Retrieve row primal value::
* Retrieve row dual value::
* Retrieve generic status of a column variable::
* Retrieve column primal value::
* Retrieve column dual value::
* Determine variable causing unboundedness::
@end menu


@node Solve the LP problem using simplex method,Solve the LP problem using simplex method in exact arithmetics,,Simplex method routines
@anchor{solve the lp problem using simplex method}@anchor{42}@anchor{solve-the-lp-problem-using-simplex-method}
@subsubsection Solve the LP problem using simplex method
@strong{Synopsis}:

@example
glp::simplex lp options
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item options:
list of solver options in the form of tuples (option_name, value):


@itemize @w
@item glp::msg_lev:

@table @asis
@item (default: glp::msg_all) - message level for
terminal output:
@end table

@display
@strong{glp::msg_off:} no output@w{ }
@strong{glp::msg_err:} error and warning messages only@w{ }
@strong{glp::msg_on:}  normal output;@w{ }
@strong{glp::msg_all:} full output (including informational messages)@w{ }
@end display
@item glp::meth:
(default: glp::primal) - simplex method option

@display
@strong{glp::primal:} use two-phase primal simplex@w{ }
@strong{glp::dual:} use two-phase dual simplex;@w{ }
@strong{glp::dualp:} use two-phase dual simplex, and if it fails, switch to the primal simplex@w{ }
@end display
@item glp::pricing:
(default: glp::pt_pse) - pricing technique

@display
@strong{glp::pt_std:} standard (textbook)@w{ }
@strong{glp::pt_pse:} projected steepest edge@w{ }
@end display
@item glp::r_test:
(default: glp::rt_har) - ratio test technique

@display
@strong{glp::rt_std:} standard (textbook)@w{ }
@strong{glp::rt_har:} Harris' two-pass ratio test@w{ }
@end display
@item glp::tol_bnd:
(default: 1e-7) - tolerance used to check if the
basic solution is primal feasible

@item glp::tol_dj:
(default: 1e-7) - tolerance used to check if the
basic solution is dual feasible

@item glp::tol_piv:
(default: 1e-10) - tolerance used to choose
eligble pivotal elements of the simplex table

@item glp::obj_ll:
(default: -DBL_MAX) - lower limit of the objective
function - if the objective function reaches this
limit and continues decreasing, the solver
terminates the search - used in the dual simplex
only

@item glp::obj_ul:
(default: +DBL_MAX) - upper limit of the objective
function. If the objective function reaches
this limit and continues increasing, the solver
terminates the search - used in the dual simplex
only

@item glp::it_lim:
(default: INT_MAX) - simplex iteration limit

@item glp::tm lim:
(default: INT_MAX) - searching time limit, in
milliseconds

@item glp::out_frq:
(default: 200) - output frequency, in
iterations - this parameter specifies how
frequently the solver sends information about
the solution process to the terminal

@item glp::out_dly:
(default: 0) - output delay, in milliseconds
- this parameter specifies how long the solver
should delay sending information about the
solution process to the terminal

@item glp::presolve:
(default: glp::off) - LP presolver option:

@display
@strong{glp::on:} enable using the LP presolver@w{ }
@strong{glp::off:} disable using the LP presolver@w{ }
@end display
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::ok:
the LP problem instance has been successfully solved; this code
does not necessarily mean that the solver has found optimal
solution, it only means that the solution process was successful

@item glp::ebadb:
unable to start the search, because the initial basis
specified in the problem object is invalid - the number
of basic (auxiliary and structural) variables is not the same
as the number of rows in the problem object

@item glp::esing:
unable to start the search, because the basis matrix
corresponding to the initial basis is singular within the
working precision

@item glp::econd:
unable to start the search, because the basis matrix
corresponding to the initial basis is ill-conditioned,
i.e. its condition number is too large

@item glp::ebound:
unable to start the search, because some double-bounded
(auxiliary or structural) variables have incorrect bounds

@item glp::efail:
the search was prematurely terminated due to the solver
failure

@item glp::eobjll:
the search was prematurely terminated, because the objective
function being maximized has reached its lower limit and
continues decreasing (the dual simplex only)

@item glp::eobjul:
the search was prematurely terminated, because the objective
function being minimized has reached its upper limit and
continues increasing (the dual simplex only)

@item glp::eitlim:
the search was prematurely terminated, because the simplex
iteration limit has been exceeded

@item glp::etmlim:
the search was prematurely terminated, because the time
limit has been exceeded

@item glp::enopfs:
the LP problem instance has no primal feasible solution
(only if the LP presolver is used)

@item glp::enodfs:
the LP problem instance has no dual feasible solution
(only if the LP presolver is used)
@end itemize

When the list of options contains some bad option(s) then a list of bad
options is returned instead.
@end quotation

@strong{Remark}:

@quotation
Options not mentioned in the option list are set to their default values.
@end quotation

@strong{Example}:

@example
> glp::simplex lp [(glp::presolve, glp::on), (glp::msg_lev, glp::msg_all)];
glp_simplex: original LP has 3 rows, 3 columns, 9 non-zeros
glp_simplex: presolved LP has 3 rows, 3 columns, 9 non-zeros
Scaling...
 A: min|aij| = 1,000e+000  max|aij| = 1,000e+001  ratio = 1,000e+001
Problem data seem to be well scaled
Crashing...
Size of triangular part = 3
*     0: obj =  0,000000000e+000  infeas = 0,000e+000 (0)
*     2: obj =  7,333333333e+002  infeas = 0,000e+000 (0)
OPTIMAL SOLUTION FOUND
glp::ok
@end example

@noindent

@node Solve the LP problem using simplex method in exact arithmetics,Retrieve generic status of basic solution,Solve the LP problem using simplex method,Simplex method routines
@anchor{solve the lp problem using simplex method in exact arithmetics}@anchor{43}@anchor{solve-the-lp-problem-using-simplex-method-in-exact-arithmetics}
@subsubsection Solve the LP problem using simplex method in exact arithmetics
@strong{Synopsis}:

@example
glp::exact lp options
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item options:
list of solver options in the form of tuples (option_name, value):


@itemize @w
@item glp::it_lim:
(default: INT_MAX) - simplex iteration limit

@item glp::tm lim:
(default: INT_MAX) - searching time limit, in
milliseconds
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::ok:
the LP problem instance has been successfully solved; this code
does not necessarily mean that the solver has found optimal
solution, it only means that the solution process was successful

@item glp::ebadb:
unable to start the search, because the initial basis
specified in the problem object is invalid - the number
of basic (auxiliary and structural) variables is not the same
as the number of rows in the problem object

@item glp::esing:
unable to start the search, because the basis matrix
corresponding to the initial basis is singular within the
working precision

@item glp::ebound:
unable to start the search, because some double-bounded
(auxiliary or structural) variables have incorrect bounds

@item glp::efail:
the search was prematurely terminated due to the solver
failure

@item glp::eitlim:
the search was prematurely terminated, because the simplex
iteration limit has been exceeded

@item glp::etmlim:
the search was prematurely terminated, because the time
limit has been exceeded
@end itemize

When the list of options contains some bad option(s) then a list of bad
options is returned instead.
@end quotation

@strong{Remark}:

@quotation
Options not mentioned in the option list are set to their default values.
@end quotation

@strong{Example}:

@example
> glp::exact lp [];
glp_exact: 3 rows, 3 columns, 9 non-zeros
GNU MP bignum library is being used
*     2:   objval =                      0   (0)
*     4:   objval =       733,333333333333   (0)
OPTIMAL SOLUTION FOUND
glp::ok
@end example

@noindent

@node Retrieve generic status of basic solution,Retrieve generic status of primal solution,Solve the LP problem using simplex method in exact arithmetics,Simplex method routines
@anchor{retrieve generic status of basic solution}@anchor{44}@anchor{retrieve-generic-status-of-basic-solution}
@subsubsection Retrieve generic status of basic solution
@strong{Synopsis}:

@example
glp::get_status lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::undef:
solution is undefined

@item glp::feas:
solution is feasible

@item glp::infeas:
solution is infeasible

@item glp::nofeas:
no feasible solution exists

@item glp::opt:
solution is optimal

@item glp::unbnd:
solution is unbounded
@end itemize
@end quotation

@strong{Example}:

@example
> glp::get_status lp;
glp::opt
@end example

@noindent

@node Retrieve generic status of primal solution,Retrieve generic status of dual solution,Retrieve generic status of basic solution,Simplex method routines
@anchor{retrieve generic status of primal solution}@anchor{45}@anchor{retrieve-generic-status-of-primal-solution}
@subsubsection Retrieve generic status of primal solution
@strong{Synopsis}:

@example
glp::get_prim_stat lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::undef:
primal solution is undefined

@item glp::feas:
primal solution is feasible

@item glp::infeas:
primal solution is infeasible

@item glp::nofeas:
no primal feasible solution exists
@end itemize
@end quotation

@strong{Example}:

@example
> glp::get_prim_stat lp;
glp::feas
@end example

@noindent

@node Retrieve generic status of dual solution,Retrieve value of the objective function,Retrieve generic status of primal solution,Simplex method routines
@anchor{retrieve generic status of dual solution}@anchor{46}@anchor{retrieve-generic-status-of-dual-solution}
@subsubsection Retrieve generic status of dual solution
@strong{Synopsis}:

@example
glp::get_dual_stat lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::undef:
dual solution is undefined

@item glp::feas:
dual solution is feasible

@item glp::infeas:
dual solution is infeasible

@item glp::nofeas:
no dual feasible solution exists
@end itemize
@end quotation

@strong{Example}:

@example
> glp::get_dual_stat lp;
glp::feas
@end example

@noindent

@node Retrieve value of the objective function,Retrieve generic status of a row variable,Retrieve generic status of dual solution,Simplex method routines
@anchor{retrieve value of the objective function}@anchor{47}@anchor{retrieve-value-of-the-objective-function}
@subsubsection Retrieve value of the objective function
@strong{Synopsis}:

@example
glp::get_obj_val lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
value of the objective function
@end quotation

@strong{Example}:

@example
> glp::get_obj_val lp
733.333333333333
@end example

@noindent

@node Retrieve generic status of a row variable,Retrieve row primal value,Retrieve value of the objective function,Simplex method routines
@anchor{retrieve generic status of a row variable}@anchor{48}@anchor{retrieve-generic-status-of-a-row-variable}
@subsubsection Retrieve generic status of a row variable
@strong{Synopsis}:

@example
glp::get_row_stat lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::bs:
basic variable

@item glp::nl:
non-basic variable on its lower bound

@item glp::nu:
non-basic variable on its upper bound

@item glp::nf:
non-basic free (unbounded) variable

@item glp::ns:
non-basic fixed variable
@end itemize
@end quotation

@strong{Example}:

@example
> glp::get_row_stat lp 3;
glp::bs
@end example

@noindent

@node Retrieve row primal value,Retrieve row dual value,Retrieve generic status of a row variable,Simplex method routines
@anchor{retrieve row primal value}@anchor{49}@anchor{retrieve-row-primal-value}
@subsubsection Retrieve row primal value

@table @asis
@item @strong{Synopsis}::
glp::get_row_prim lp rowindex
@end table

@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
primal value of the row (auxiliary) variable
@end quotation

@strong{Example}:

@example
> glp::get_row_prim lp 3;
200.0
@end example

@noindent

@node Retrieve row dual value,Retrieve generic status of a column variable,Retrieve row primal value,Simplex method routines
@anchor{retrieve row dual value}@anchor{4a}@anchor{retrieve-row-dual-value}
@subsubsection Retrieve row dual value
@strong{Synopsis}:

@example
glp::get_row_dual lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
dual value of the row (auxiliary) variable
@end quotation

@strong{Example}:

@example
> glp::get_row_dual lp 3;
0.0
@end example

@noindent

@node Retrieve generic status of a column variable,Retrieve column primal value,Retrieve row dual value,Simplex method routines
@anchor{retrieve generic status of a column variable}@anchor{4b}@anchor{retrieve-generic-status-of-a-column-variable}
@subsubsection Retrieve generic status of a column variable
@strong{Synopsis}:

@example
glp::get_col_stat lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::bs:
basic variable

@item glp::nl:
non-basic variable on its lower bound

@item glp::nu:
non-basic variable on its upper bound

@item glp::nf:
non-basic free (unbounded) variable

@item glp::ns:
non-basic fixed variable
@end itemize
@end quotation

@strong{Example}:

@example
> glp::get_col_stat lp 2;
glp::bs
@end example

@noindent

@node Retrieve column primal value,Retrieve column dual value,Retrieve generic status of a column variable,Simplex method routines
@anchor{retrieve column primal value}@anchor{4c}@anchor{retrieve-column-primal-value}
@subsubsection Retrieve column primal value
@strong{Synopsis}:

@example
glp::get_col_prim lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
primal value of the column (structural) variable
@end quotation

@strong{Example}:

@example
> glp::get_col_prim lp 2;
66.6666666666667
@end example

@noindent

@node Retrieve column dual value,Determine variable causing unboundedness,Retrieve column primal value,Simplex method routines
@anchor{retrieve column dual value}@anchor{4d}@anchor{retrieve-column-dual-value}
@subsubsection Retrieve column dual value
@strong{Synopsis}:

@example
glp::get_col_dual lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
dual value of the column (structural) variable
@end quotation

@strong{Example}:

@example
> glp::get_col_dual lp 2;
0.0
@end example

@noindent

@node Determine variable causing unboundedness,,Retrieve column dual value,Simplex method routines
@anchor{determine variable causing unboundedness}@anchor{4e}@anchor{determine-variable-causing-unboundedness}
@subsubsection Determine variable causing unboundedness
@strong{Synopsis}:

@example
glp::get_unbnd_ray lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine glp_get_unbnd_ray returns the number k of a variable, which
causes primal or dual unboundedness. If 1 <= k <= m, it is k-th auxiliary
variable, and if m + 1 <= k <= m + n, it is (k - m)-th structural variable,
where m is the number of rows, n is the number of columns in the problem
object. If such variable is not defined, the routine returns 0.
@end quotation

@strong{Remark}:

@quotation
If it is not exactly known which version of the simplex solver detected
unboundedness, i.e. whether the unboundedness is primal or dual, it is
sufficient to check the status of the variable with the routine
glp::get_row_stat or glp::get_col_stat. If the variable is non-basic,
the unboundedness is primal, otherwise, if the variable is basic,
the unboundedness is dual (the latter case means that the problem has
no primal feasible dolution).
@end quotation

@strong{Example}:

@example
> glp::get_unbnd_ray lp;
0
@end example

@noindent

@node Interior-point method routines,Mixed integer programming routines,Simplex method routines,Basic API routines
@anchor{interior-point method routines}@anchor{4f}@anchor{interior-point-method-routines}
@subsection Interior-point method routines

@menu
* Solve the LP problem using interior-point method::
* Retrieve status of interior-point solution::
* Retrieve the objective function value of interior-point solution::
* Retrieve row primal value of interior-point solution::
* Retrieve row dual value of interior-point solution::
* Retrieve column primal value of interior-point solution::
* Retrieve column dual value of interior-point solution::
@end menu


@node Solve the LP problem using interior-point method,Retrieve status of interior-point solution,,Interior-point method routines
@anchor{solve the lp problem using interior-point method}@anchor{50}@anchor{solve-the-lp-problem-using-interior-point-method}
@subsubsection Solve the LP problem using interior-point method
@strong{Synopsis}:

@example
glp::interior lp options
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item options:
list of solver options in the form of tuples (option_name, value):


@itemize @w
@item glp::msg_lev:

@table @asis
@item (default: glp::msg_all) - message level for
terminal output:
@end table

@display
@strong{glp::msg_off:} no output@w{ }
@strong{glp::msg_err:} error and warning messages only@w{ }
@strong{glp::msg_on:} normal output;@w{ }
@strong{glp::msg_all:} full output (including informational messages)@w{ }
@end display
@item glp::ord_alg:
(default: glp::ord_amd) - ordering algorithm option

@display
@strong{glp::ord_none:} use natural (original) ordering@w{ }
@strong{glp::ord_qmd:} quotient minimum degree (QMD)@w{ }
@strong{glp::ord_amd:} approximate minimum degree (AMD)@w{ }
@strong{glp::ord_sysamd:} approximate minimum degree (SYSAMD)@w{ }
@end display
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::ok:
the LP problem instance has been successfully solved;
this code does not necessarily mean that the solver has
found optimal solution, it only means that the solution
process was successful

@item glp::efail:
the problem has no rows/columns

@item glp::enocvg:
very slow convergence or divergence

@item glp::eitlim:
iteration limit exceeded

@item glp::einstab:
numerical instability on solving Newtonian system
@end itemize
@end quotation

@strong{Example}:

@example
> glp::interior lp [(glp::ord_alg, glp::ord_amd)];
Original LP has 3 row(s), 3 column(s), and 9 non-zero(s)
Working LP has 3 row(s), 6 column(s), and 12 non-zero(s)
Matrix A has 12 non-zeros
Matrix S = A*A' has 6 non-zeros (upper triangle)
Approximate minimum degree ordering (AMD)...
Computing Cholesky factorization S = L*L'...
Matrix L has 6 non-zeros
Guessing initial point...
Optimization begins...
  0: obj = -8,218489503e+002; rpi = 3,6e-001; rdi = 6,8e-001; gap = 2,5e-001
  1: obj = -6,719060895e+002; rpi = 3,6e-002; rdi = 1,9e-001; gap = 1,4e-002
  2: obj = -6,917210389e+002; rpi = 3,6e-003; rdi = 9,3e-002; gap = 3,0e-002
  3: obj = -7,267557732e+002; rpi = 2,1e-003; rdi = 9,3e-003; gap = 4,4e-002
  4: obj = -7,323038146e+002; rpi = 2,1e-004; rdi = 1,1e-003; gap = 4,8e-003
  5: obj = -7,332295932e+002; rpi = 2,1e-005; rdi = 1,1e-004; gap = 4,8e-004
  6: obj = -7,333229585e+002; rpi = 2,1e-006; rdi = 1,1e-005; gap = 4,8e-005
  7: obj = -7,333322959e+002; rpi = 2,1e-007; rdi = 1,1e-006; gap = 4,8e-006
  8: obj = -7,333332296e+002; rpi = 2,1e-008; rdi = 1,1e-007; gap = 4,8e-007
  9: obj = -7,333333230e+002; rpi = 2,1e-009; rdi = 1,1e-008; gap = 4,8e-008
 10: obj = -7,333333323e+002; rpi = 2,1e-010; rdi = 1,1e-009; gap = 4,8e-009
OPTIMAL SOLUTION FOUND
glp::ok
@end example

@noindent

@node Retrieve status of interior-point solution,Retrieve the objective function value of interior-point solution,Solve the LP problem using interior-point method,Interior-point method routines
@anchor{retrieve status of interior-point solution}@anchor{51}@anchor{retrieve-status-of-interior-point-solution}
@subsubsection Retrieve status of interior-point solution
@strong{Synopsis}:

@example
glp::ipt_status lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following


@itemize @w
@item glp::undef:
interior-point solution is undefined

@item glp::opt:
interior-point solution is optimal

@item glp::infeas:
interior-point solution is infeasible

@item glp::nofeas:
no feasible primal-dual solution exists
@end itemize
@end quotation

@strong{Example}:

@example
> glp::ipt_status lp;
glp::opt
@end example

@noindent

@node Retrieve the objective function value of interior-point solution,Retrieve row primal value of interior-point solution,Retrieve status of interior-point solution,Interior-point method routines
@anchor{retrieve the objective function value of interior-point solution}@anchor{52}@anchor{retrieve-the-objective-function-value-of-interior-point-solution}
@subsubsection Retrieve the objective function value of interior-point solution
@strong{Synopsis}:

@example
glp::ipt_obj_val lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
objective function value of interior-point solution
@end quotation

@strong{Example}:

@example
> glp::ipt_obj_val lp;
733.333332295849
@end example

@noindent

@node Retrieve row primal value of interior-point solution,Retrieve row dual value of interior-point solution,Retrieve the objective function value of interior-point solution,Interior-point method routines
@anchor{retrieve row primal value of interior-point solution}@anchor{53}@anchor{retrieve-row-primal-value-of-interior-point-solution}
@subsubsection Retrieve row primal value of interior-point solution
@strong{Synopsis}:

@example
glp::ipt_row_prim lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
primal value of the row (auxiliary) variable
@end quotation

@strong{Example}:

@example
> glp::ipt_row_prim lp 3;
200.000000920688
@end example

@noindent

@node Retrieve row dual value of interior-point solution,Retrieve column primal value of interior-point solution,Retrieve row primal value of interior-point solution,Interior-point method routines
@anchor{retrieve row dual value of interior-point solution}@anchor{54}@anchor{retrieve-row-dual-value-of-interior-point-solution}
@subsubsection Retrieve row dual value of interior-point solution
@strong{Synopsis}:

@example
glp::ipt_row_dual lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
dual value of the row (auxiliary) variable
@end quotation

@strong{Example}:

@example
> glp::ipt_row_dual lp 3;
2.50607466186742e-008
@end example

@noindent

@node Retrieve column primal value of interior-point solution,Retrieve column dual value of interior-point solution,Retrieve row dual value of interior-point solution,Interior-point method routines
@anchor{retrieve column primal value of interior-point solution}@anchor{55}@anchor{retrieve-column-primal-value-of-interior-point-solution}
@subsubsection Retrieve column primal value of interior-point solution
@strong{Synopsis}:

@example
glp::ipt_col_prim lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
primal value of the column (structural) variable
@end quotation

@strong{Example}:

@example
> glp::ipt_col_prim lp 2;
66.666666406779
@end example

@noindent

@node Retrieve column dual value of interior-point solution,,Retrieve column primal value of interior-point solution,Interior-point method routines
@anchor{retrieve column dual value of interior-point solution}@anchor{56}@anchor{retrieve-column-dual-value-of-interior-point-solution}
@subsubsection Retrieve column dual value of interior-point solution
@strong{Synopsis}:

@example
glp::ipt_col_dual lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
dual value of the column (structural) variable
@end quotation

@strong{Example}:

@example
> glp::ipt_col_dual lp 2;
2.00019467655466e-009
@end example

@noindent

@node Mixed integer programming routines,Additional routines,Interior-point method routines,Basic API routines
@anchor{mixed integer programming routines}@anchor{57}@anchor{mixed-integer-programming-routines}
@subsection Mixed integer programming routines

@menu
* Set column kind::
* Retrieve column kind::
* Retrieve number of integer columns::
* Retrieve number of binary columns::
* Solve the MIP problem using branch-and-cut method::
* Retrieve status of mip solution::
* Retrieve the objective function value of mip solution::
* Retrieve row value of mip solution::
* Retrieve column value of mip solution::
@end menu


@node Set column kind,Retrieve column kind,,Mixed integer programming routines
@anchor{set column kind}@anchor{58}@anchor{set-column-kind}
@subsubsection Set column kind
@strong{Synopsis}:

@example
glp::set_col_kind lp (colindex, colkind)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index

@item colkind:
column kind - one of the following:


@itemize @w
@item glp::cv:
continuous variable

@item glp::iv:
integer variable

@item glp::bv:
binary variable
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::set_col_kind lp (1, glp::iv);
()
@end example

@noindent

@node Retrieve column kind,Retrieve number of integer columns,Set column kind,Mixed integer programming routines
@anchor{retrieve column kind}@anchor{59}@anchor{retrieve-column-kind}
@subsubsection Retrieve column kind
@strong{Synopsis}:

@example
glp::get_col_kind lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::cv:
continuous variable

@item glp::iv:
integer variable

@item glp::bv:
binary variable
@end itemize
@end quotation

@strong{Example}:

@example
> glp::get_col_kind lp 1;
glp::iv
@end example

@noindent

@node Retrieve number of integer columns,Retrieve number of binary columns,Retrieve column kind,Mixed integer programming routines
@anchor{retrieve number of integer columns}@anchor{5a}@anchor{retrieve-number-of-integer-columns}
@subsubsection Retrieve number of integer columns
@strong{Synopsis}:

@example
glp::get_num_int lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
number of integer columns (including binary columns)
@end quotation

@strong{Example}:

@example
> glp_get_num_int lp;
1
@end example

@noindent

@node Retrieve number of binary columns,Solve the MIP problem using branch-and-cut method,Retrieve number of integer columns,Mixed integer programming routines
@anchor{retrieve number of binary columns}@anchor{5b}@anchor{retrieve-number-of-binary-columns}
@subsubsection Retrieve number of binary columns
@strong{Synopsis}:

@example
glp::get_num_bin lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
number of binary columns
@end quotation

@strong{Example}:

@example
> glp::get_num_bin lp
0
@end example

@noindent

@node Solve the MIP problem using branch-and-cut method,Retrieve status of mip solution,Retrieve number of binary columns,Mixed integer programming routines
@anchor{solve the mip problem using branch-and-cut method}@anchor{5c}@anchor{solve-the-mip-problem-using-branch-and-cut-method}
@subsubsection Solve the MIP problem using branch-and-cut method
@strong{Synopsis}:

@example
glp::intopt lp options
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item options:
list of solver options in the form of tuples (option_name, value):


@itemize @w
@item glp::msg_lev:

@table @asis
@item (default: glp::msg_all) - message level for
terminal output:
@end table

@display
@strong{glp::msg_off:} no output@w{ }
@strong{glp::msg_err:} error and warning messages only@w{ }
@strong{glp::msg_on:} normal output;@w{ }
@strong{glp::msg_all:} full output (including informational messages)@w{ }
@end display
@item glp::br_tech:
(default: glp::bt::blb) - branching technique

@display
@strong{glp::br_ffv:} first fractional variable@w{ }
@strong{glp::br_lfv:} last fractional variable@w{ }
@strong{glp::br_mfv:} most fractional variable@w{ }
@strong{glp::br_dth:} heuristic by Driebeck and Tomlin@w{ }
@strong{glp::br_pch:} hybrid pseudocost heuristic@w{ }
@end display
@item glp::bt_tech:
(default: glp::pt_pse) - backtracking technique

@display
@strong{glp::bt_dfs:} depth first search;@w{ }
@strong{glp::bt_bfs:} breadth first search;@w{ }
@strong{glp::bt_blb:} best local bound;@w{ }
@strong{glp::bt_bph:} best projection heuristic.@w{ }
@end display
@item glp::pp_tech:
(default: glp::pp_all) - preprocessing technique

@display
@strong{glp::pp_none:} disable preprocessing;@w{ }
@strong{glp::pp_root:} perform preprocessing only on the root level@w{ }
@strong{glp::pp_all:} perform preprocessing on all levels@w{ }
@end display
@item glp::fp_heur:
(default: glp::off) - feasibility pump heuristic:

@display
@strong{glp::on:} enable applying the feasibility pump heuristic@w{ }
@strong{glp::off:} disable applying the feasibility pump heuristic@w{ }
@end display
@item glp::gmi_cuts:

@table @asis
@item (default: glp::off) - Gomory‚Äôs mixed integer
cuts:
@end table

@display
@strong{glp::on:} enable generating Gomory‚Äôs cuts;@w{ }
@strong{glp::off:} disable generating Gomory‚Äôs cuts.@w{ }
@end display
@item glp::mir_cuts:

@table @asis
@item (default: glp::off) - mixed integer rounding
(MIR) cuts:
@end table

@display
@strong{glp::on:} enable generating MIR cuts;@w{ }
@strong{glp::off:} disable generating MIR cuts.@w{ }
@end display
@item glp::cov_cuts:
(default: glp::off) - mixed cover cuts:

@display
@strong{glp::on:} enable generating mixed cover cuts;@w{ }
@strong{glp::off:} disable generating mixed cover cuts.@w{ }
@end display
@item glp::clq_cuts (default:
glp::off) - clique cuts:

@display
@strong{glp::on:} enable generating clique cuts;@w{ }
@strong{glp::off:} disable generating clique cuts.@w{ }
@end display
@item glp::tol_int:
(default: 1e-5) - absolute tolerance used to
check if optimal solution to the current LP
relaxation is integer feasible

@item glp::tol_obj:
(default: 1e-7) - relative tolerance used to
check if the objective value in optimal solution
to the current LP relaxation is not better than
in the best known integer feasible solution

@item glp::mip_gap:
(default: 0.0) - the relative mip gap tolerance;
if the relative mip gap for currently known best
integer feasible solution falls below this
tolerance, the solver terminates the search -
this allows obtainig suboptimal integer feasible
solutions if solving the problem to optimality
takes too long time

@item glp::tm lim:
(default: INT_MAX) - searching time limit, in
milliseconds

@item glp::out_frq:
(default: 5000) - output frequency, in
miliseconds - this parameter specifies how
frequently the solver sends information about
the solution process to the terminal

@item glp::out_dly:
(default: 10000) - output delay, in milliseconds
- this parameter specifies how long the solver
should delay sending information about the
solution of the current LP relaxation with the
simplex method to the terminal

@item glp::cb_func:

@table @asis
@item (default: glp::off) - specifies whether to use
the user-defined callback routine
@end table

@display
@strong{glp::on:} use user-defined callback function - the function @code{glp::mip_cb tree info} @strong{must} be defined by the user@w{ }
@strong{glp::off:} do not use user-defined callback function@w{ }
@end display
@item glp::cb_info:
(default: NULL) - transit pointer passed to the
routine @code{glp::mip_cb tree info} (see above)

@item glp::cb_size:
(default: 0) - the number of extra (up to 256)
bytes allocated for each node of the
branch-and-bound tree to store
application-specific data - on creating a
node these bytes are initialized by binary zeros

@item glp::presolve:
(default: glp::off) - LP presolver option:

@display
@strong{glp::on:} enable using the MIP presolver@w{ }
@strong{glp::off:} disable using the MIP presolver@w{ }
@end display
@item glp::binarize:

@table @asis
@item (default: glp::off) - binarization (used only if
the presolver is enabled):
@end table

@display
@strong{glp::on:} replace general integer variables by binary ones@w{ }
@strong{glp::off:} do not use binarization@w{ }
@end display
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::ok:
the MIP problem instance has been successfully solved; this code
does not necessarily mean that the solver has found optimal
solution, it only means that the solution process was successful

@item glp::ebound:
unable to start the search, because some double-bounded
(auxiliary or structural) variables have incorrect bounds
or some integer variables have non-integer (fractional)
bounds

@item glp::eroot:
unable to start the search, because optimal basis for initial
LP relaxation is not provided - this code may appear only
if the presolver is disabled

@item glp::enopfs:
unable to start the search, because LP relaxation of the
MIP problem instance has no primal feasible solution -
this code may appear only if the presolver is enabled

@item glp::enodfs:
unable to start the search, because LP relaxation of the
MIP problem instance has no dual feasible solution; in
other word, this code means that if the LP relaxation has
at least one primal feasible solution, its optimal solution
is unbounded, so if the MIP problem has at least one integer
feasible solution, its (integer) optimal solution is also
unbounded - this code may appear only if the presolver is
enabled

@item glp::efail:
the search was prematurely terminated due to the solver
failure

@item glp::emipgap:
the search was prematurely terminated, because the
relative mip gap tolerance has been reached

@item glp::etmlim:
the search was prematurely terminated, because the time
limit has been exceeded

@item glp::estop:
the search was prematurely terminated by application -
this code may appear only if the advanced solver
interface is used
@end itemize

When the list of options contains some bad option(s) then a list of bad
options is returned instead.
@end quotation

@strong{Remark}:

@quotation
Options not mentioned in the option list are set to their default values.
@end quotation

@strong{Example}:

@example
> glp::intopt lp [(glp::presolve, glp::on)];
ipp_basic_tech:  0 row(s) and 0 column(s) removed
ipp_reduce_bnds: 2 pass(es) made, 3 bound(s) reduced
ipp_basic_tech:  0 row(s) and 0 column(s) removed
ipp_reduce_coef: 1 pass(es) made, 0 coefficient(s) reduced
glp_intopt: presolved MIP has 3 rows, 3 columns, 9 non-zeros
glp_intopt: 3 integer columns, none of which are binary
Scaling...
 A: min|aij| =  1,000e+00  max|aij| =  1,000e+01  ratio =  1,000e+01
Problem data seem to be well scaled
Crashing...
Size of triangular part = 3
Solving LP relaxation...
*     2: obj =   0,000000000e+00  infeas =  0,000e+00 (0)
*     5: obj =   7,333333333e+02  infeas =  0,000e+00 (0)
OPTIMAL SOLUTION FOUND
Integer optimization begins...
+     5: mip =     not found yet <=              +inf        (1; 0)
+     6: >>>>>   7,320000000e+02 <=   7,320000000e+02   0.0% (2; 0)
+     6: mip =   7,320000000e+02 <=     tree is empty   0.0% (0; 3)
INTEGER OPTIMAL SOLUTION FOUND
glp::ok
@end example

@noindent

@node Retrieve status of mip solution,Retrieve the objective function value of mip solution,Solve the MIP problem using branch-and-cut method,Mixed integer programming routines
@anchor{retrieve status of mip solution}@anchor{5d}@anchor{retrieve-status-of-mip-solution}
@subsubsection Retrieve status of mip solution
@strong{Synopsis}:

@example
glp::mip_status lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::undef:
MIP solution is undefined

@item glp::opt:
MIP solution is integer optimal

@item glp::feas:
MIP solution is integer feasible, however, its optimality
(or non-optimality) has not been proven, perhaps due
to premature termination of the search

@item glp::nofeas:
problem has no integer feasible solution (proven by the
solver)
@end itemize
@end quotation

@strong{Example}:

@example
> glp::mip_status lp;
glp::opt
@end example

@noindent

@node Retrieve the objective function value of mip solution,Retrieve row value of mip solution,Retrieve status of mip solution,Mixed integer programming routines
@anchor{retrieve the objective function value of mip solution}@anchor{5e}@anchor{retrieve-the-objective-function-value-of-mip-solution}
@subsubsection Retrieve the objective function value of mip solution
@strong{Synopsis}:

@example
glp::mip_obj_val lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
objective function value of mip solution
@end quotation

@strong{Example}:

@example
> glp::mip_obj_val lp;
732.0
@end example

@noindent

@node Retrieve row value of mip solution,Retrieve column value of mip solution,Retrieve the objective function value of mip solution,Mixed integer programming routines
@anchor{retrieve row value of mip solution}@anchor{5f}@anchor{retrieve-row-value-of-mip-solution}
@subsubsection Retrieve row value of mip solution
@strong{Synopsis}:

@example
glp::mip_row_val lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
row value (value of auxiliary variable)
@end quotation

@strong{Example}:

@example
> glp::mip_row_val lp 3;
200.0
@end example

@noindent

@node Retrieve column value of mip solution,,Retrieve row value of mip solution,Mixed integer programming routines
@anchor{retrieve column value of mip solution}@anchor{60}@anchor{retrieve-column-value-of-mip-solution}
@subsubsection Retrieve column value of mip solution
@strong{Synopsis}:

@example
glp::mip_col_val lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
column value (value of structural variable)
@end quotation

@strong{Example}:

@example
> glp::mip_col_val lp 2;
67.0
@end example

@noindent

@node Additional routines,,Mixed integer programming routines,Basic API routines
@anchor{additional routines}@anchor{61}@anchor{additional-routines}
@subsection Additional routines

@menu
* Check Karush-Kuhn-Tucker conditions::
@end menu


@node Check Karush-Kuhn-Tucker conditions,,,Additional routines
@anchor{check karush-kuhn-tucker conditions}@anchor{62}@anchor{check-karush-kuhn-tucker-conditions}
@subsubsection Check Karush-Kuhn-Tucker conditions
@strong{Synopsis}:

@example
lpx::check_kkt lp scaled
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item scaled:
one of the following:


@itemize @w
@item true:
test the scaled problem

@item false:
test the unscaled problem
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
list of four tuples with five mebers (see GLPK reference manual):

@multitable {xxxxxxxxxxxxx} {xxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}
@headitem Condition
@tab Member
@tab Comment
@item (KKT.PE)
@tab pe_ae_max
@tab Largest absolute error
@item
@tab pe_ae_row
@tab Number of row with largest absolute error
@item
@tab pe_re_max
@tab Largest relative error
@item
@tab pe_re_row
@tab Number of row with largest relative error
@item
@tab pe_quality
@tab Quality of primal solution
@item (KKT.PB)
@tab pb_ae_max
@tab Largest absolute error
@item
@tab pb_ae_ind
@tab Number of variable with largest absolute error
@item
@tab pb_re_max
@tab Largest relative error
@item
@tab pb_re_ind
@tab Number of variable with largest relative error
@item
@tab pb_quality
@tab Quality of primal feasibility
@item (KKT.DE)
@tab de_ae_max
@tab Largest absolute error
@item
@tab de_ae_col
@tab Number of column with largest absolute error
@item
@tab de_re_max
@tab Largest relative error
@item
@tab de_re_col
@tab Number of column with largest relative error
@item
@tab de_quality
@tab Quality of dual solution
@item (KKT.DB)
@tab db_ae_max
@tab Largest absolute error
@item
@tab db_ae_ind
@tab Number of variable with largest absolute error
@item
@tab db_re_max
@tab Largest relative error
@item
@tab db_re_ind
@tab Number of variable with largest relative error
@item
@tab db_quality
@tab Quality of dual feasibility
@end multitable

where number of variable is (1 <= k <= m) for auxiliary variable
and (m+1 <= k <= m+n) for structural variable
@end quotation

@strong{Example}:

@example
> lpx::check_kkt lp true;
[(1.4210854715202e-14,2,3.54385404369127e-17,3,"H"),(0.0,0,0.0,0,"H"),
(4.44089209850063e-16,1,2.11471052309554e-17,1,"H"),(0.0,0,0.0,0,"H")]
@end example

@noindent

@node Utility API routines,Advanced API routines,Basic API routines,Descriptions of interface functions
@anchor{utility api routines}@anchor{63}@anchor{utility-api-routines}
@section Utility API routines

@menu
* Problem data reading/writing routines::
* Routines for MathProg models::
* Problem solution reading/writing routines::
@end menu


@node Problem data reading/writing routines,Routines for MathProg models,,Utility API routines
@anchor{problem data reading/writing routines}@anchor{64}@anchor{problem-data-reading-writing-routines}
@subsection Problem data reading/writing routines

@menu
* Read LP problem data from a MPS file::
* Write LP problem data into a MPS file::
* Read LP problem data from a CPLEX file::
* Write LP problem data into a CPLEX file::
* Read LP problem data in GLPK format::
* Write LP problem data in GLPK format::
@end menu


@node Read LP problem data from a MPS file,Write LP problem data into a MPS file,,Problem data reading/writing routines
@anchor{read lp problem data from a mps file}@anchor{65}@anchor{read-lp-problem-data-from-a-mps-file}
@subsubsection Read LP problem data from a MPS file
@strong{Synopsis}:

@example
glp::read_mps lp format filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item format:
one of the following


@itemize @w
@item glp::mps_deck:
fixed (ancient) MPS file format

@item glp::mps_file:
free (modern) MPS file format
@end itemize

@item filename:
file name - if the file name ends with suffix @strong{.gz},
the file is assumed to be compressed, in which case
the routine glp::read_mps decompresses it ‚Äúon the fly‚Äù
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::read_mps lp glp::mps_deck "examples/plan.mps";
Reading problem data from `examples/plan.mps'...
Problem PLAN
Objective R0000000
8 rows, 7 columns, 55 non-zeros
63 records were read
0
@end example

@noindent

@node Write LP problem data into a MPS file,Read LP problem data from a CPLEX file,Read LP problem data from a MPS file,Problem data reading/writing routines
@anchor{write lp problem data into a mps file}@anchor{66}@anchor{write-lp-problem-data-into-a-mps-file}
@subsubsection Write LP problem data into a MPS file
@strong{Synopsis}:

@example
glp::write_mps lp format filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item format:
one of the following


@itemize @w
@item glp::mps_deck:
fixed (ancient) MPS file format

@item glp::mps_file:
free (modern) MPS file format
@end itemize

@item filename:
file name - if the file name ends with suffix @strong{.gz},
the file is assumed to be compressed, in which case
the routine glp_write_mps performs automatic
compression on writing it
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::write_mps lp glp::mps_file "examples/plan1.mps";
Writing problem data to `examples/plan1.mps'...
63 records were written
0
@end example

@noindent

@node Read LP problem data from a CPLEX file,Write LP problem data into a CPLEX file,Write LP problem data into a MPS file,Problem data reading/writing routines
@anchor{read lp problem data from a cplex file}@anchor{67}@anchor{read-lp-problem-data-from-a-cplex-file}
@subsubsection Read LP problem data from a CPLEX file
@strong{Synopsis}:

@example
glp::read_lp lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name - if the file name ends with suffix @strong{.gz},
the file is assumed to be compressed, in which case
the routine glp::read_lp decompresses it ‚Äúon the fly‚Äù
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::read_lp lp "examples/plan.lp";
reading problem data from `examples/plan.lp'...
8 rows, 7 columns, 48 non-zeros
39 lines were read
0
@end example

@noindent

@node Write LP problem data into a CPLEX file,Read LP problem data in GLPK format,Read LP problem data from a CPLEX file,Problem data reading/writing routines
@anchor{write lp problem data into a cplex file}@anchor{68}@anchor{write-lp-problem-data-into-a-cplex-file}
@subsubsection Write LP problem data into a CPLEX file
@strong{Synopsis}:

@example
glp::write_lp lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name - if the file name ends with suffix @strong{.gz},
the file is assumed to be compressed, in which case
the routine glp::write_lp performs automatic
compression on writing it
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::write_lp lp "examples/plan1.lp";
writing problem data to `examples/plan1.lp'...
29 lines were written
0
@end example

@noindent

@node Read LP problem data in GLPK format,Write LP problem data in GLPK format,Write LP problem data into a CPLEX file,Problem data reading/writing routines
@anchor{read lp problem data in glpk format}@anchor{69}@anchor{read-lp-problem-data-in-glpk-format}
@subsubsection Read LP problem data in GLPK format
@strong{Synopsis}:

@example
glp::read_prob lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name - if the file name ends with suffix @strong{.gz},
the file is assumed to be compressed, in which case
the routine glp::read_prob decompresses it ‚Äúon the fly‚Äù
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::read_prob lp "examples/plan.glpk";
reading problem data from `examples/plan.glpk'...
8 rows, 7 columns, 48 non-zeros
86 lines were read
0
@end example

@noindent

@node Write LP problem data in GLPK format,,Read LP problem data in GLPK format,Problem data reading/writing routines
@anchor{write lp problem data in glpk format}@anchor{6a}@anchor{write-lp-problem-data-in-glpk-format}
@subsubsection Write LP problem data in GLPK format
@strong{Synopsis}:

@example
glp::write_prob lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name - if the file name ends with suffix @strong{.gz},
the file is assumed to be compressed, in which case
the routine glp::write_prob performs automatic
compression on writing it
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::write_prob lp "examples/plan1.glpk";
writing problem data to `examples/plan1.glpk'...
86 lines were written
0
@end example

@noindent

@node Routines for MathProg models,Problem solution reading/writing routines,Problem data reading/writing routines,Utility API routines
@anchor{routines for mathprog models}@anchor{6b}@anchor{routines-for-mathprog-models}
@subsection Routines for MathProg models

@menu
* Create the MathProg translator object::
* Read and translate model section::
* Read and translate data section::
* Generate the model::
* Build problem instance from the model::
* Postsolve the model::
* Delete the MathProg translator object::
@end menu


@node Create the MathProg translator object,Read and translate model section,,Routines for MathProg models
@anchor{create the mathprog translator object}@anchor{6c}@anchor{create-the-mathprog-translator-object}
@subsubsection Create the MathProg translator object
@strong{Synopsis}:

@example
glp::mpl_alloc_wksp
@end example

@noindent
@strong{Parameters}:

@quotation
none
@end quotation

@strong{Returns}:

@quotation
pointer to the MathProg translator object
@end quotation

@strong{Example}:

@example
> let mpt = glp::mpl_alloc_wksp;
> mpt;
#<pointer 0xa0d0180>
@end example

@noindent

@node Read and translate model section,Read and translate data section,Create the MathProg translator object,Routines for MathProg models
@anchor{read and translate model section}@anchor{6d}@anchor{read-and-translate-model-section}
@subsubsection Read and translate model section
@strong{Synopsis}:

@example
glp::mpl_read_model tranobject filename skip
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tranobject:
pointer to the MathProg translator object

@item filename:
file name

@item skip:
if @strong{0} then the data section from the model file is read;
if non-zero, the data section in the data model is skipped
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> mpl_read_model mpt "examples/sudoku.mod" 1;
Reading model section from examples/sudoku.mod...
examples/sudoku.mod:69: warning: data section ignored
69 lines were read
0
@end example

@noindent

@node Read and translate data section,Generate the model,Read and translate model section,Routines for MathProg models
@anchor{read and translate data section}@anchor{6e}@anchor{read-and-translate-data-section}
@subsubsection Read and translate data section
@strong{Synopsis}:

@example
glp::mpl_read_data tranobject filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tranobject:
pointer to the MathProg translator object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::mpl_read_data mpt "examples/sudoku.dat";
Reading data section from examples/sudoku.dat...
16 lines were read
0
@end example

@noindent

@node Generate the model,Build problem instance from the model,Read and translate data section,Routines for MathProg models
@anchor{generate the model}@anchor{6f}@anchor{generate-the-model}
@subsubsection Generate the model
@strong{Synopsis}:

@example
glp::mpl_generate tranobject filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tranobject:
pointer to the MathProg translator object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if generating went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::mpl_generate mpt "examples/sudoku.lst";
Generating fa...
Generating fb...
Generating fc...
Generating fd...
Generating fe...
Model has been successfully generated
0
@end example

@noindent

@node Build problem instance from the model,Postsolve the model,Generate the model,Routines for MathProg models
@anchor{build problem instance from the model}@anchor{70}@anchor{build-problem-instance-from-the-model}
@subsubsection Build problem instance from the model
@strong{Synopsis}:

@example
glp::mpl_build_prob tranobject lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tranobject:
pointer to the MathProg translator object

@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::mpl_build_prob mpt lp;
()
@end example

@noindent

@node Postsolve the model,Delete the MathProg translator object,Build problem instance from the model,Routines for MathProg models
@anchor{postsolve the model}@anchor{71}@anchor{postsolve-the-model}
@subsubsection Postsolve the model
@strong{Synopsis}:

@example
glp::mpl_postsolve tran lp solution
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tranobject:
pointer to the MathProg translator object

@item lp:
pointer to the LP problem object

@item solution:
one of the following:


@itemize @w
@item glp::sol:
use the basic solution

@item glp::ipt:
use the interior-point solution

@item glp::mip:
use mixed integer solution
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if postsolve went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::mpl_postsolve mpt lp glp::sol;
Model has been successfully processed
0
@end example

@noindent

@node Delete the MathProg translator object,,Postsolve the model,Routines for MathProg models
@anchor{delete the mathprog translator object}@anchor{72}@anchor{delete-the-mathprog-translator-object}
@subsubsection Delete the MathProg translator object
@strong{Synopsis}:

@example
glp::mpl_free_wksp tranobject
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tranobject:
pointer to the MathProg translator object
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::mpl_free_wksp mpt;
()
@end example

@noindent

@node Problem solution reading/writing routines,,Routines for MathProg models,Utility API routines
@anchor{problem solution reading/writing routines}@anchor{73}@anchor{problem-solution-reading-writing-routines}
@subsection Problem solution reading/writing routines

@menu
* Write basic solution in printable format::
* Read basic solution from a text file::
* Write basic solution into a text file::
* Print sensitivity analysis report::
* Write interior-point solution in printable format::
* Read interior-point solution from a text file::
* Write interior-point solution into a text file::
* Write MIP solution in printable format::
* Read MIP solution from a text file::
* Write MIP solution into a text file::
@end menu


@node Write basic solution in printable format,Read basic solution from a text file,,Problem solution reading/writing routines
@anchor{write basic solution in printable format}@anchor{74}@anchor{write-basic-solution-in-printable-format}
@subsubsection Write basic solution in printable format
@strong{Synopsis}:

@example
glp::print_sol lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::print_sol lp "examples/test.txt";
Writing basic solution to `examples/test.txt'...
0
@end example

@noindent

@node Read basic solution from a text file,Write basic solution into a text file,Write basic solution in printable format,Problem solution reading/writing routines
@anchor{read basic solution from a text file}@anchor{75}@anchor{read-basic-solution-from-a-text-file}
@subsubsection Read basic solution from a text file
@strong{Synopsis}:

@example
glp::read_sol lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::read_sol lp "examples/test.txt";
Reading basic solution from `examples/test.txt'...
1235 lines were read
0
@end example

@noindent

@node Write basic solution into a text file,Print sensitivity analysis report,Read basic solution from a text file,Problem solution reading/writing routines
@anchor{write basic solution into a text file}@anchor{76}@anchor{write-basic-solution-into-a-text-file}
@subsubsection Write basic solution into a text file
@strong{Synopsis}:

@example
glp::write_sol lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::write_sol lp "examples/test.txt";
Writing basic solution to `examples/test.txt'...
1235 lines were written
0
@end example

@noindent

@node Print sensitivity analysis report,Write interior-point solution in printable format,Write basic solution into a text file,Problem solution reading/writing routines
@anchor{print sensitivity analysis report}@anchor{77}@anchor{print-sensitivity-analysis-report}
@subsubsection Print sensitivity analysis report
@strong{Synopsis}:

@example
glp::print_ranges lp indices filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item indices:
list indices k of of rows and columns to be included in the report.
If 1 ‚â§ k ‚â§ m, the basic variable is k-th auxiliary variable,
and if m + 1 ‚â§ k ‚â§ m + n, the non-basic variable is (k ‚àí m)-th
structural variable, where m is the number of rows and n is the
number of columns in the specified problem object. An empty lists
means printing report for all rows and columns.

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation

@itemize @w
@item 0:
if the operation was successful

@item non-zero:
if the operation failed
@end itemize
@end quotation

@strong{Example}:

@example
> glp::print_ranges lp [] "sensitivity.rpt";
Write sensitivity analysis report to `sensitivity.rpt'...
0
@end example

@noindent

@node Write interior-point solution in printable format,Read interior-point solution from a text file,Print sensitivity analysis report,Problem solution reading/writing routines
@anchor{write interior-point solution in printable format}@anchor{78}@anchor{write-interior-point-solution-in-printable-format}
@subsubsection Write interior-point solution in printable format
@strong{Synopsis}:

@example
glp::print_ipt lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::print_ipt lp "examples/test.txt";
Writing interior-point solution to `examples/test.txt'...
0
@end example

@noindent

@node Read interior-point solution from a text file,Write interior-point solution into a text file,Write interior-point solution in printable format,Problem solution reading/writing routines
@anchor{read interior-point solution from a text file}@anchor{79}@anchor{read-interior-point-solution-from-a-text-file}
@subsubsection Read interior-point solution from a text file
@strong{Synopsis}:

@example
glp::read_ipt lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::read_ipt lp "examples/test.txt";
Reading interior-point solution from `examples/test.txt'...
1235 lines were read
0
@end example

@noindent

@node Write interior-point solution into a text file,Write MIP solution in printable format,Read interior-point solution from a text file,Problem solution reading/writing routines
@anchor{write interior-point solution into a text file}@anchor{7a}@anchor{write-interior-point-solution-into-a-text-file}
@subsubsection Write interior-point solution into a text file
@strong{Synopsis}:

@example
glp::write_ipt lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::write_ipt lp "examples/test.txt";
Writing interior-point solution to `examples/test.txt'...
1235 lines were written
0
@end example

@noindent

@node Write MIP solution in printable format,Read MIP solution from a text file,Write interior-point solution into a text file,Problem solution reading/writing routines
@anchor{write mip solution in printable format}@anchor{7b}@anchor{write-mip-solution-in-printable-format}
@subsubsection Write MIP solution in printable format
@strong{Synopsis}:

@example
glp::print_mip lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::print_mip lp "examples/test.txt";
Writing MIP solution to `examples/test.txt'...
0
@end example

@noindent

@node Read MIP solution from a text file,Write MIP solution into a text file,Write MIP solution in printable format,Problem solution reading/writing routines
@anchor{read mip solution from a text file}@anchor{7c}@anchor{read-mip-solution-from-a-text-file}
@subsubsection Read MIP solution from a text file
@strong{Synopsis}:

@example
glp::read_mip lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::read_mip lp "examples/test.txt";
Reading MIP solution from `examples/test.txt'...
1235 lines were read
0
@end example

@noindent

@node Write MIP solution into a text file,,Read MIP solution from a text file,Problem solution reading/writing routines
@anchor{write mip solution into a text file}@anchor{7d}@anchor{write-mip-solution-into-a-text-file}
@subsubsection Write MIP solution into a text file
@strong{Synopsis}:

@example
glp::write_mip lp filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if writing went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::write_mip lp "examples/test.txt";
Writing MIP solution to `examples/test.txt'...
1235 lines were written
0
@end example

@noindent

@node Advanced API routines,Branch-and-cut API routines,Utility API routines,Descriptions of interface functions
@anchor{advanced api routines}@anchor{7e}@anchor{advanced-api-routines}
@section Advanced API routines

@menu
* LP basis routines::
* Simplex tableau routines::
@end menu


@node LP basis routines,Simplex tableau routines,,Advanced API routines
@anchor{lp basis routines}@anchor{7f}@anchor{lp-basis-routines}
@subsection LP basis routines

@menu
* Check whether basis factorization exists::
* Compute the basis factorization::
* Check whether basis factorization has been updated::
* Get basis factorization parameters::
* Change basis factorization parameters::
* Retrieve the basis header information::
* Retrieve row index in the basis header::
* Retrieve column index in the basis header::
* Perform forward transformation::
* Perform backward transformation::
* Warm up LP basis::
@end menu


@node Check whether basis factorization exists,Compute the basis factorization,,LP basis routines
@anchor{check whether basis factorization exists}@anchor{80}@anchor{check-whether-basis-factorization-exists}
@subsubsection Check whether basis factorization exists
@strong{Synopsis}:

@example
glp::bf_exists lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation

@itemize @w
@item non-zero:
the basis factorization exists and can be used for calculations

@item 0:
the basis factorization does not exist
@end itemize
@end quotation

@strong{Example}:

@example
> glp::bf:exists lp;
1
@end example

@noindent

@node Compute the basis factorization,Check whether basis factorization has been updated,Check whether basis factorization exists,LP basis routines
@anchor{compute the basis factorization}@anchor{81}@anchor{compute-the-basis-factorization}
@subsubsection Compute the basis factorization
@strong{Synopsis}:

@example
glp::factorize lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::ok:
the basis factorization has been successfully computed

@item glp::ebadb:
the basis matrix is invalid, because the number of basic
(auxiliary and structural) variables is not the same as the
number of rows in the problem object

@item glp::esing:
the basis matrix is singular within the working precision

@item glp::exond:
the basis matrix is ill-conditioned, i.e. its condition
number is too large
@end itemize
@end quotation

@strong{Example}:

@example
> glp::factorize lp;
glp::ok
@end example

@noindent

@node Check whether basis factorization has been updated,Get basis factorization parameters,Compute the basis factorization,LP basis routines
@anchor{check whether basis factorization has been updated}@anchor{82}@anchor{check-whether-basis-factorization-has-been-updated}
@subsubsection Check whether basis factorization has been updated
@strong{Synopsis}:

@example
glp::bf_updated lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation

@itemize @w
@item 0:
if the basis factorization has been just computed from ‚Äúscratch‚Äù

@item non-zero:
if the factorization has been updated at least once
@end itemize
@end quotation

@strong{Example}:

@example
> glp::bf_updated lp;
0
@end example

@noindent

@node Get basis factorization parameters,Change basis factorization parameters,Check whether basis factorization has been updated,LP basis routines
@anchor{get basis factorization parameters}@anchor{83}@anchor{get-basis-factorization-parameters}
@subsubsection Get basis factorization parameters
@strong{Synopsis}:

@example
glp::get_bfcp lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
complete list of options in a form of tuples (option_name, value):


@itemize @w
@item glp::fact_type:
basis factorization type:


@itemize @w
@item glp::bf_ft:
LU + Forrest‚ÄìTomlin update

@item glp::bf_bg:
LU + Schur complement + Bartels‚ÄìGolub update

@item glp::bf_gr:
LU + Schur complement + Givens rotation update
@end itemize

@item glp::lu_size:
the initial size of the Sparse Vector Area, in non-zeros,
used on computing LU-factorization of the basis matrix for
the first time - if this parameter is set to 0, the initial
SVA size is determined automatically

@item glp::piv_tol:
threshold pivoting (Markowitz) tolerance, 0 < piv_tol < 1,
used on computing LU-factorization of the basis matrix

@item glp::piv_lim:
this parameter is used on computing
LU-factorization of the basis matrix and specifies how many
pivot candidates needs to be considered on choosing a pivot
element, piv_lim ‚â• 1

@item glp::suhl:
this parameter is used on computing LU-factorization of
the basis matrix


@itemize @w
@item glp::on:
enables applying the heuristic proposed by Uwe Suhl

@item glp::off:
disables this heuristic
@end itemize

@item glp::eps_tol:
epsilon tolerance, eps_tol ‚â• 0, used on computing
LU-factorization of the basis matrix

@item glp::max_gro:
maximal growth of elements of factor U, max_gro ‚â• 1,
allowable on computing LU-factorization of the basis matrix

@item glp::nfs_max:
maximal number of additional row-like factors (entries of
the eta file), nfs_max ‚â• 1, which can be added to
LU-factorization of the basis matrix on updating it with
the Forrest‚ÄìTomlin technique

@item glp::upd_tol:
update tolerance, 0 < upd_tol < 1, used on updating
LU-factorization of the basis matrix with the Forrest‚ÄìTomlin
technique

@item glp::nrs_max:
maximal number of additional rows and columns, nrs_max ‚â• 1,
which can be added to LU-factorization of the basis matrix
on updating it with the Schur complement technique

@item glp::rs_size:
the initial size of the Sparse Vector Area, in non-zeros,
used to store non-zero elements of additional rows and
columns introduced on updating LU-factorization of the basis
matrix with the Schur complement technique - if this
parameter is set to 0, the initial SVA size is determined
automatically
@end itemize
@end quotation

@strong{Example}:

@example
> glp::get_bfcp lp;
[(glp::fact_type,glp::bf_ft),(glp::lu_size,0),(glp::piv_tol,0.1),
(glp::piv_lim,4),(glp::suhl,glp::on),(glp::eps_tol,1e-15),
(glp::max_gro,10000000000.0),(glp::nfs_max,50),(glp::upd_tol,1e-06),
(glp::nrs_max,50),(glp::rs_size,0)]
@end example

@noindent

@node Change basis factorization parameters,Retrieve the basis header information,Get basis factorization parameters,LP basis routines
@anchor{change basis factorization parameters}@anchor{84}@anchor{change-basis-factorization-parameters}
@subsubsection Change basis factorization parameters
@strong{Synopsis}:

@example
glp::set_bfcp lp options
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item options:
list of options in a form of tuples (option_name, value):

@item glp::fact_type:
(default: glp::bf_ft) - basis factorization type:


@itemize @w
@item glp::bf_ft:
LU + Forrest‚ÄìTomlin update

@item glp::bf_bg:
LU + Schur complement + Bartels‚ÄìGolub update

@item glp::bf_gr:
LU + Schur complement + Givens rotation update
@end itemize

@item glp::lu_size:
(default: 0) - the initial size of the Sparse Vector Area,
in non-zeros, used on computing LU-factorization of the
basis matrix for the first time - if this parameter is set
to 0, the initial SVA size is determined automatically

@item glp::piv_tol:
(default: 0.10) - threshold pivoting (Markowitz) tolerance,
0 < piv_tol < 1, used on computing LU-factorization of the
basis matrix.

@item glp::piv_lim:
(default: 4) - this parameter is used on computing
LU-factorization of the basis matrix and specifies how many
pivot candidates needs to be considered on choosing a pivot
element, piv_lim ‚â• 1

@item glp::suhl:
(default: glp::on) - this parameter is used on computing
LU-factorization of the basis matrix.


@itemize @w
@item glp::on:
enables applying the heuristic proposed by Uwe Suhl

@item glp::off:
disables this heuristic
@end itemize

@item glp::eps_tol:
(default: 1e-15) - epsilon tolerance, eps_tol ‚â• 0, used on
computing LU -factorization of the basis matrix.

@item glp::max_gro:
(default: 1e+10) - maximal growth of elements of factor U,
max_gro ‚â• 1, allowable on computing LU-factorization of the
basis matrix.

@item glp::nfs_max:
(default: 50) - maximal number of additional row-like
factors (entries of the eta file), nfs_max ‚â• 1, which can
be added to LU-factorization of the basis matrix
on updating it with the Forrest‚ÄìTomlin technique.

@item glp::upd_tol:
(default: 1e-6) - update tolerance, 0 < upd_tol < 1,
used on updating LU -factorization of the basis matrix
with the Forrest‚ÄìTomlin technique.

@item glp::nrs_max:
(default: 50) - maximal number of additional rows and
columns, nrs_max ‚â• 1, which can be added to LU-factorization
of the basis matrix on updating it with the Schur complement
technique.

@item glp::rs_size:
(default: 0) - the initial size of the Sparse Vector Area,
in non-zeros, used to store non-zero elements of additional
rows and columns introduced on updating LU-factorization
of the basis matrix with the Schur complement technique -
if this parameter is set to 0, the initial SVA size is
determined automatically
@end itemize
@end quotation

@strong{Remarks}:

@quotation
Options not mentioned in the option list are left unchanged.

All options will be reset to their default values when an empty option list
is supplied.
@end quotation

@strong{Returns}:

@quotation
@code{()} if all options are OK, otherwise returns a list of bad options
@end quotation

@strong{Example}:

@example
> glp_set_bfcp lp [(glp::fact_type, glp::bf_ft), (glp::piv_tol, 0.15)];
()
@end example

@noindent

@node Retrieve the basis header information,Retrieve row index in the basis header,Change basis factorization parameters,LP basis routines
@anchor{retrieve the basis header information}@anchor{85}@anchor{retrieve-the-basis-header-information}
@subsubsection Retrieve the basis header information
@strong{Synopsis}:

@example
glp::get_bhead lp k
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item k:
variable index in the basis matrix
@end itemize
@end quotation

@strong{Returns}:

@quotation
If basic variable (xB )k , 1 ‚â§ k ‚â§ m, is i-th auxiliary variable (1 ‚â§ i ‚â§ m), the
routine returns i. Otherwise, if (xB )k is j-th structural variable (1 ‚â§ j ‚â§ n),
the routine returns m+j. Here m is the number of rows and n is the number
of columns in the problem object.
@end quotation

@strong{Example}:

@example
> glp::get_bhead lp 3;
5
@end example

@noindent

@node Retrieve row index in the basis header,Retrieve column index in the basis header,Retrieve the basis header information,LP basis routines
@anchor{retrieve row index in the basis header}@anchor{86}@anchor{retrieve-row-index-in-the-basis-header}
@subsubsection Retrieve row index in the basis header
@strong{Synopsis}:

@example
glp::get_row_bind lp rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
This routine returns the index k of basic variable (xB )k, 1 ‚â§ k ‚â§ m,
which is i-th auxiliary variable (that is, the auxiliary variable
corresponding to i-th row), 1 ‚â§ i ‚â§ m, in the current basis associated with
the specified problem object, where m is the number of rows. However, if
i-th auxiliary variable is non-basic, the routine returns zero.
@end quotation

@strong{Example}:

@example
> glp::get_row_bind lp 3;
1
@end example

@noindent

@node Retrieve column index in the basis header,Perform forward transformation,Retrieve row index in the basis header,LP basis routines
@anchor{retrieve column index in the basis header}@anchor{87}@anchor{retrieve-column-index-in-the-basis-header}
@subsubsection Retrieve column index in the basis header
@strong{Synopsis}:

@example
glp::get_col_bind lp colindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colindex:
column index
@end itemize
@end quotation

@strong{Returns}:

@quotation
This routine returns the index k of basic variable (xB )k, 1 ‚â§ k ‚â§ m,
which is j-th structural variable (that is, the structural variable
corresponding to j-th column), 1 ‚â§ j ‚â§ n, in the current basis associated
with the specified problem object, where m is the number of rows, n is the
number of columns. However, if j-th structural variable is non-basic, the
routine returns zero.
@end quotation

@strong{Example}:

@example
> glp::get_col_bind lp 2;
3
@end example

@noindent

@node Perform forward transformation,Perform backward transformation,Retrieve column index in the basis header,LP basis routines
@anchor{perform forward transformation}@anchor{88}@anchor{perform-forward-transformation}
@subsubsection Perform forward transformation
@strong{Synopsis}:

@example
glp::ftran lp vector
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item vector:
vector to be transformed - a dense vector in a form of a list of
double numbers has to be supplied and the number of its members
must exactly correspond to the number of LP problem constraints
@end itemize
@end quotation

@strong{Returns}:

@quotation
the transformed vector in the same format
@end quotation

@strong{Example}:

@example
> glp::ftran lp [1.5, 3.2, 4.8];
[1.8,0.466666666666667,-1.96666666666667]
@end example

@noindent

@node Perform backward transformation,Warm up LP basis,Perform forward transformation,LP basis routines
@anchor{perform backward transformation}@anchor{89}@anchor{perform-backward-transformation}
@subsubsection Perform backward transformation
@strong{Synopsis}:

@example
glp::btran lp vector
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item vector:
vector to be transformed - a dense vector in a form of a list of
double numbers has to be supplied and the number of its members
must exactly correspond to the number of LP problem constraints
@end itemize
@end quotation

@strong{Returns}:

@quotation
the transformed vector in the same format
@end quotation

@strong{Example}:

@example
> glp::btran lp [1.5, 3.2, 4.8];
[-8.86666666666667,0.266666666666667,1.5]
@end example

@noindent

@node Warm up LP basis,,Perform backward transformation,LP basis routines
@anchor{warm up lp basis}@anchor{8a}@anchor{warm-up-lp-basis}
@subsubsection Warm up LP basis
@strong{Synopsis}:

@example
glp::warm_up lp
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::ok:
the LP basis has been successfully ‚Äúwarmed up‚Äù

@item glp::ebadb:
the LP basis is invalid, because the number of basic
variables is not the same as the number of rows

@item glp::esing:
the basis matrix is singular within the working precision

@item glp::econd:
the basis matrix is ill-conditioned, i.e. its condition
number is too large
@end itemize
@end quotation

@strong{Example}:

@example
> glp::warm_up lp;
glp::e_ok
@end example

@noindent

@node Simplex tableau routines,,LP basis routines,Advanced API routines
@anchor{simplex tableau routines}@anchor{8b}@anchor{simplex-tableau-routines}
@subsection Simplex tableau routines

@menu
* Compute row of the tableau::
* Compute column of the tableau::
* Transform explicitly specified row::
* Transform explicitly specified column::
* Perform primal ratio test::
* Perform dual ratio test::
* Analyze active bound of non-basic variable::
* Analyze objective coefficient at basic variable::
@end menu


@node Compute row of the tableau,Compute column of the tableau,,Simplex tableau routines
@anchor{compute row of the tableau}@anchor{8c}@anchor{compute-row-of-the-tableau}
@subsubsection Compute row of the tableau
@strong{Synopsis}:

@example
glp::eval_tab_row lp k
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item k:
variable index such that it corresponds to some basic variable:
if 1 ‚â§ k ‚â§ m, the basic variable is k-th auxiliary variable,
and if m + 1 ‚â§ k ‚â§ m + n, the basic variable is (k ‚àí m)-th structural
variable, where m is the number of rows and n is the number of columns
in the specified problem object (the basis factorization must exist)
@end itemize
@end quotation

@strong{Returns}:

@quotation
simplex tableau row in a sparse form as a list of tuples (index, value),
where index has the same meaning as k in parameters
@end quotation

@strong{Example}:

@example
> glp::eval_tab_row lp 3;
[(1,2.0),(6,4.0)]
@end example

@noindent

@node Compute column of the tableau,Transform explicitly specified row,Compute row of the tableau,Simplex tableau routines
@anchor{compute column of the tableau}@anchor{8d}@anchor{compute-column-of-the-tableau}
@subsubsection Compute column of the tableau
@strong{Synopsis}:

@example
glp::eval_tab_col lp k
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item k:
variable index such that it corresponds to some non-basic variable:
if 1 ‚â§ k ‚â§ m, the non-basic variable is k-th auxiliary variable,
and if m + 1 ‚â§ k ‚â§ m + n, the non-basic variable is (k ‚àí m)-th
structural variable, where m is the number of rows and n is the
number of columns in the specified problem object (the basis
factorization must exist)
@end itemize
@end quotation

@strong{Returns}:

@quotation
simplex tableau column in a sparse form as a list of tuples (index, value),
where index has the same meaning as k in parameters
@end quotation

@strong{Example}:

@example
> glp::eval_tab_col lp 1;
[(3,2.0),(4,-0.666666666666667),(5,1.66666666666667)]
@end example

@noindent

@node Transform explicitly specified row,Transform explicitly specified column,Compute column of the tableau,Simplex tableau routines
@anchor{transform explicitly specified row}@anchor{8e}@anchor{transform-explicitly-specified-row}
@subsubsection Transform explicitly specified row
@strong{Synopsis}:

@example
glp::transform_row lp rowvector
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowvector:
row vector to be transformed in a sparse form as a list of tuples
(k, value): if 1 ‚â§ k ‚â§ m, the non-basic variable is k-th
auxiliary variable, and if m + 1 ‚â§ k ‚â§ m + n, the non-basic
variable is (k ‚àí m)-th structural variable, where m is the number
of rows and n is the number of columns in the specified problem
object (the basis factorization must exist)
@end itemize
@end quotation

@strong{Returns}:

@quotation
the transformed row in a sparse form as a list of tuples (index, value),
where index has the same meaning as k in parameters
@end quotation

@strong{Example}:

@example
> glp::transform_row lp [(1, 3.0), (2, 3.5)];
[(1,3.83333333333333),(2,-0.0833333333333333),(6,-3.41666666666667)]
@end example

@noindent

@node Transform explicitly specified column,Perform primal ratio test,Transform explicitly specified row,Simplex tableau routines
@anchor{transform explicitly specified column}@anchor{8f}@anchor{transform-explicitly-specified-column}
@subsubsection Transform explicitly specified column
@strong{Synopsis}:

@example
glp::transform_col lp colvector
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colvector:
column vector to be transformed in a sparse form as a list of
tuples (k, value): if 1 ‚â§ k ‚â§ m, the non-basic variable is k-th
auxiliary variable, and if m + 1 ‚â§ k ‚â§ m + n, the non-basic
variable is (k ‚àí m)-th structural variable, where m is the number
of rows and n is the number of columns in the specified problem
object (the basis factorization must exist)
@end itemize
@end quotation

@strong{Returns}:

@quotation
the transformed column in a sparse form as a list of tuples (index, value),
where index has the same meaning as k in parameters
@end quotation

@strong{Example}:

@example
> glp::transform_col lp [(2, 1.0), (3, 2.3)];
[(3,2.3),(4,-0.166666666666667),(5,0.166666666666667)]
@end example

@noindent

@node Perform primal ratio test,Perform dual ratio test,Transform explicitly specified column,Simplex tableau routines
@anchor{perform primal ratio test}@anchor{90}@anchor{perform-primal-ratio-test}
@subsubsection Perform primal ratio test
@strong{Synopsis}:

@example
glp::prim_rtest lp colvector dir eps
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item colvector:
simplex tableau column in a sparse form as a list of
tuples (k, value): if 1 ‚â§ k ‚â§ m, the basic variable is k-th
auxiliary variable, and if m + 1 ‚â§ k ‚â§ m + n, the basic variable
is (k ‚àí m)-th structural variable, where m is the number
of rows and n is the number of columns in the specified problem
object (the basis factorization must exist and the primal
solution must be feasible)

@item dir:
specifies in which direction the variable y changes on entering the
basis: +1 means increasing, ‚àí1 means decreasing

@item eps:
relative tolerance (small positive number) used to skip small
values in the column
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the index, piv, in the colvector corresponding to the
pivot element chosen, 1 ‚â§ piv ‚â§ len. If the adjacent basic solution is primal
unbounded, and therefore the choice cannot be made, the routine returns zero.
@end quotation

@strong{Example}:

@example
> glp::prim_rtest lp [(3, 2.5), (5, 7.0)] 1 1.0e-5;
3
@end example

@noindent

@node Perform dual ratio test,Analyze active bound of non-basic variable,Perform primal ratio test,Simplex tableau routines
@anchor{perform dual ratio test}@anchor{91}@anchor{perform-dual-ratio-test}
@subsubsection Perform dual ratio test
@strong{Synopsis}:

@example
glp::dual_rtest lp rowvector dir eps
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item rowvector:
simplex tableau row in a sparse form as a list of
tuples (k, value): if 1 ‚â§ k ‚â§ m, the non-basic variable is k-th
auxiliary variable, and if m + 1 ‚â§ k ‚â§ m + n, the non-basic
variable is (k ‚àí m)-th structural variable, where m is the number
of rows and n is the number of columns in the specified problem
object (the basis factorization must exist and the dual
solution must be feasible)

@item dir:
specifies in which direction the variable y changes on leaving
the basis: +1 means increasing, ‚àí1 means decreasing

@item eps:
relative tolerance (small positive number) used to skip small
values in the row
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the index, piv, in the rowvector corresponding to the
pivot element chosen, 1 ‚â§ piv ‚â§ len. If the adjacent basic solution is dual
unbounded, and therefore the choice cannot be made, the routine returns zero.
@end quotation

@strong{Example}:

@example
> glp::dual_rtest lp [(1, 1.5), (6, 4.0)] 1 1.0e-5;
6
@end example

@noindent

@node Analyze active bound of non-basic variable,Analyze objective coefficient at basic variable,Perform dual ratio test,Simplex tableau routines
@anchor{analyze active bound of non-basic variable}@anchor{92}@anchor{analyze-active-bound-of-non-basic-variable}
@subsubsection Analyze active bound of non-basic variable
@strong{Synopsis}:

@example
glp::analyze_bound lp k
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item k:
if 1 ‚â§ k ‚â§ m, the non-basic variable is k-th auxiliary variable,
and if m + 1 ‚â§ k ‚â§ m + n, the non-basic variable is (k ‚àí m)-th
structural variable, where m is the number of rows and n is the
number of columns in the specified problem object (the basis
factorization must exist and the solution must be optimal)
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns a tuple (limit1, var1, limit2 var2) where:


@itemize @w
@item value1:
the minimal value of the active bound, at which the basis still
remains primal feasible and thus optimal. -DBL_MAX means that the
active bound has no lower limit.

@item var1:
the ordinal number of an auxiliary (1 to m) or structural
(m + 1 to m + n) basic variable, which reaches its bound first
and thereby limits further decreasing the active bound being
analyzed. If value1 = -DBL_MAX, var1 is set to 0.

@item value2:
the maximal value of the active bound, at which the basis still
remains primal feasible and thus optimal. +DBL_MAX means that the
active bound has no upper limit.

@item var2:
the ordinal number of an auxiliary (1 to m) or structural
(m + 1 to m + n) basic variable, which reaches its bound first
and thereby limits further increasing the active bound being
analyzed. If value2 = +DBL_MAX, var2 is set to 0.
@end itemize
@end quotation

@strong{Example}:

@example
> analyze_bound lp 2;
1995.06864446899,12,2014.03478832467,4
@end example

@noindent

@node Analyze objective coefficient at basic variable,,Analyze active bound of non-basic variable,Simplex tableau routines
@anchor{analyze objective coefficient at basic variable}@anchor{93}@anchor{analyze-objective-coefficient-at-basic-variable}
@subsubsection Analyze objective coefficient at basic variable
@strong{Synopsis}:

@example
glp::analyze_coef lp k
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item k:
if 1 ‚â§ k ‚â§ m, the basic variable is k-th auxiliary variable,
and if m + 1 ‚â§ k ‚â§ m + n, the non-basic variable is (k ‚àí m)-th
structural variable, where m is the number of rows and n is the
number of columns in the specified problem object (the basis
factorization must exist and the solution must be optimal)
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns a tuple (coef1, var1, value1, coef2 var2, value2) where:


@itemize @w
@item coef1:
the minimal value of the objective coefficient, at which the
basis still remains dual feasible and thus optimal.
-DBL_MAX means that the objective coefficient has no lower limit.

@item var1:
is the ordinal number of an auxiliary (1 to m) or structural
(m + 1 to m + n) non-basic variable, whose reduced cost reaches
its zero bound first and thereby limits further decreasing the
objective coefficient being analyzed. If coef1 = -DBL_MAX,
var1 is set to 0.

@item value1:
value of the basic variable being analyzed in an adjacent basis,
which is defined as follows. Let the objective coefficient reaches
its minimal value (coef1) and continues decreasing. Then the
reduced cost of the limiting non-basic variable (var1) becomes dual
infeasible and the current basis becomes non-optimal that forces
the limiting non-basic variable to enter the basis replacing there
some basic variable that leaves the basis to keep primal
feasibility. Should note that on determining the adjacent basis
current bounds of the basic variable being analyzed are ignored
as if it were free (unbounded) variable, so it cannot leave the
basis. It may happen that no dual feasible adjacent basis exists,
in which case value1 is set to -DBL_MAX or +DBL_MAX.

@item coef2:
the maximal value of the objective coefficient, at which the
basis still remains dual feasible and thus optimal. +DBL_MAX
means that the objective coefficient has no upper limit.

@item var2:
the ordinal number of an auxiliary (1 to m) or structural
(m + 1 to m + n) non-basic variable, whose reduced cost reaches
its zero bound first and thereby limits further increasing the
objective coefficient being analyzed. If coef2 = +DBL_MAX, var2
is set to 0.

@item value2:
value of the basic variable being analyzed in an adjacent basis,
which is defined exactly in the same way as value1 above with
exception that now the objective coefficient is increasing.
@end itemize
@end quotation

@strong{Example}:

@example
> analyze_coef lp 1;
-1.0,3,306.771624713959,1.79769313486232e+308,0,296.216606498195
@end example

@noindent

@node Branch-and-cut API routines,Graph and network API routines,Advanced API routines,Descriptions of interface functions
@anchor{branch-and-cut api routines}@anchor{94}@anchor{branch-and-cut-api-routines}
@section Branch-and-cut API routines

@quotation
All branch-and-cut API routines are supposed to be called from the callback
routine. They cannot be called directly.
@end quotation


@menu
* Basic routines::
* The search tree exploring routines::
* The cut pool routines::
@end menu


@node Basic routines,The search tree exploring routines,,Branch-and-cut API routines
@anchor{basic routines}@anchor{95}@anchor{basic-routines}
@subsection Basic routines

@menu
* Determine reason for calling the callback routine::
* Access the problem object::
* Determine additional row attributes::
* Compute relative MIP gap::
* Access application-specific data::
* Select subproblem to continue the search::
* Provide solution found by heuristic::
* Check whether can branch upon specified variable::
* Choose variable to branch upon::
* Terminate the solution process::
@end menu


@node Determine reason for calling the callback routine,Access the problem object,,Basic routines
@anchor{determine reason for calling the callback routine}@anchor{96}@anchor{determine-reason-for-calling-the-callback-routine}
@subsubsection Determine reason for calling the callback routine
@strong{Synopsis}:

@example
glp::ios_reason tree
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
one of the following:


@itemize @w
@item glp::irowgen:
request for row generation

@item glp::ibingo:
better integer solution found

@item glp::iheur:
request for heuristic solution

@item glp::icutgen:
request for cut generation

@item glp::ibranch:
request for branching

@item glp::iselect:
request for subproblem selection

@item glp::iprepro:
request for preprocessing
@end itemize
@end quotation

@strong{Example}:

@example
glp::ios:reason tree;
@end example

@noindent

@node Access the problem object,Determine additional row attributes,Determine reason for calling the callback routine,Basic routines
@anchor{access the problem object}@anchor{97}@anchor{access-the-problem-object}
@subsubsection Access the problem object
@strong{Synopsis}:

@example
glp::ios_get_prob tree
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns a pointer to the problem object used by the MIP solver.
@end quotation

@strong{Example}:

@example
glp::ios_get_prob tree;
@end example

@noindent

@node Determine additional row attributes,Compute relative MIP gap,Access the problem object,Basic routines
@anchor{determine additional row attributes}@anchor{98}@anchor{determine-additional-row-attributes}
@subsubsection Determine additional row attributes
@strong{Synopsis}:

@example
glp::ios_row_attr tree rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item rowindex:
row index
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns a tuple consisting of three values
(level, origin, klass):


@itemize @w
@item level:
subproblem level at which the row was created

@item origin:
the row origin flag - one of the following:


@itemize @w
@item glp::rf_reg:
regular constraint

@item glp::rf_lazy:
‚Äúlazy‚Äù constraint

@item glp::rf_cut:
cutting plane constraint
@end itemize

@item klass:
the row class descriptor, which is a number passed to the routine
glp_ios_add_row as its third parameter - if the row is a cutting
plane constraint generated by the solver, its class may be the
following:


@itemize @w
@item glp::rf_gmi:
Gomory‚Äôs mixed integer cut

@item glp::rf_mir:
mixed integer rounding cut

@item glp::rf_cov:
mixed cover cut

@item glp::rf_clq:
clique cut
@end itemize
@end itemize
@end quotation

@strong{Example}:

@example
glp::ios_row_attr tree 3;
@end example

@noindent

@node Compute relative MIP gap,Access application-specific data,Determine additional row attributes,Basic routines
@anchor{compute relative mip gap}@anchor{99}@anchor{compute-relative-mip-gap}
@subsubsection Compute relative MIP gap
@strong{Synopsis}:

@example
glp::ios_mip_gap tree
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the relative MIP gap.
@end quotation

@strong{Example}:

@example
> glp::ios_mip_gap tree;
@end example

@noindent

@node Access application-specific data,Select subproblem to continue the search,Compute relative MIP gap,Basic routines
@anchor{access application-specific data}@anchor{9a}@anchor{access-application-specific-data}
@subsubsection Access application-specific data
@strong{Synopsis}:

@example
glp::ios_node_data tree node
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine glp_ios_node_data returns a pointer to the memory block for
the specified subproblem. Note that if cb_size = 0 was specified in the
call of the @strong{intopt} function, the routine returns a null pointer.
@end quotation

@strong{Example}:

@example
> glp::ios_node_data tree 23;
@end example

@noindent

@node Select subproblem to continue the search,Provide solution found by heuristic,Access application-specific data,Basic routines
@anchor{select subproblem to continue the search}@anchor{9b}@anchor{select-subproblem-to-continue-the-search}
@subsubsection Select subproblem to continue the search
@strong{Synopsis}:

@example
glp::ios_select_node tree node
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item node:
reference number of the subproblem from which the search will continue
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Example}:

@example
> glp::ios_select_node tree 23;
@end example

@noindent

@node Provide solution found by heuristic,Check whether can branch upon specified variable,Select subproblem to continue the search,Basic routines
@anchor{provide solution found by heuristic}@anchor{9c}@anchor{provide-solution-found-by-heuristic}
@subsubsection Provide solution found by heuristic
@strong{Synopsis}:

@example
glp::ios_heur_sol tree colvector
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item colvector:
solution found by a primal heuristic. Primal values of all
variables (columns) found by the heuristic should be placed
in the list, i. e. the list must contain n numbers where
n is the number of columns in the original problem object.
Note that the routine does not check primal feasibility
of the solution provided.
@end itemize
@end quotation

@strong{Returns}:

@quotation
If the provided solution is accepted, the routine returns zero.
Otherwise, if the provided solution is rejected, the routine returns
non-zero.
@end quotation

@strong{Example}:

@example
> glp::ios_heur_sol tree [15.7, (-3.1), 2.2];
@end example

@noindent

@node Check whether can branch upon specified variable,Choose variable to branch upon,Provide solution found by heuristic,Basic routines
@anchor{check whether can branch upon specified variable}@anchor{9d}@anchor{check-whether-can-branch-upon-specified-variable}
@subsubsection Check whether can branch upon specified variable
@strong{Synopsis}:

@example
glp::ios_can_branch tree j
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item j:
variable (column) index
@end itemize
@end quotation

@strong{Returns}:

@quotation
The function returns non-zero if j-th variable can be used for branching.
Otherwise, it returns zero.
@end quotation

@strong{Example}:

@example
> glp::ios_can_branch tree 23;
@end example

@noindent

@node Choose variable to branch upon,Terminate the solution process,Check whether can branch upon specified variable,Basic routines
@anchor{choose variable to branch upon}@anchor{9e}@anchor{choose-variable-to-branch-upon}
@subsubsection Choose variable to branch upon
@strong{Synopsis}:

@example
glp::ios_branch_upon tree j selection
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item j:
ordinal number of the selected branching variable

@item selection:
one of the following:


@itemize @w
@item glp::dn_brnch:
select down-branch

@item glp::up_brnch:
select up-branch

@item glp::no_brnch:
use general selection technique
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Example}:

@example
> glp::ios_branch_upon tree 23 glp::up_brnch;
@end example

@noindent

@node Terminate the solution process,,Choose variable to branch upon,Basic routines
@anchor{terminate the solution process}@anchor{9f}@anchor{terminate-the-solution-process}
@subsubsection Terminate the solution process
@strong{Synopsis}:

@example
glp::ios_terminate tree
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Example}:

@example
> glp::ios_terminate tree;
@end example

@noindent

@node The search tree exploring routines,The cut pool routines,Basic routines,Branch-and-cut API routines
@anchor{the search tree exploring routines}@anchor{a0}@anchor{the-search-tree-exploring-routines}
@subsection The search tree exploring routines

@menu
* Determine the search tree size::
* Determine current active subproblem::
* Determine next active subproblem::
* Determine previous active subproblem::
* Determine parent active subproblem::
* Determine subproblem level::
* Determine subproblem local bound::
* Find active subproblem with the best local bound::
@end menu


@node Determine the search tree size,Determine current active subproblem,,The search tree exploring routines
@anchor{determine the search tree size}@anchor{a1}@anchor{determine-the-search-tree-size}
@subsubsection Determine the search tree size
@strong{Synopsis}:

@example
glp::ios_tree_size tree
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns a tuple (a_cnt, n_cnt, t_cnt), where


@itemize @w
@item a_cnt:
the current number of active nodes

@item n_cnt:
the current number of all (active and inactive) nodes

@item t_cnt:
the total number of nodes including those which have been
already removed from the tree. This count is increased
whenever a new node appears in the tree and never decreased.
@end itemize
@end quotation

@strong{Example}:

@example
> glp::ios_tree_size tree;
@end example

@noindent

@node Determine current active subproblem,Determine next active subproblem,Determine the search tree size,The search tree exploring routines
@anchor{determine current active subproblem}@anchor{a2}@anchor{determine-current-active-subproblem}
@subsubsection Determine current active subproblem
@strong{Synopsis}:

@example
glp::ios_curr_node tree
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the reference number of the current active subproblem.
If the current subproblem does not exist, the routine returns zero.
@end quotation

@strong{Example}:

@example
> glp::ios_curr_node tree;
@end example

@noindent

@node Determine next active subproblem,Determine previous active subproblem,Determine current active subproblem,The search tree exploring routines
@anchor{determine next active subproblem}@anchor{a3}@anchor{determine-next-active-subproblem}
@subsubsection Determine next active subproblem
@strong{Synopsis}:

@example
glp::ios_next_node tree node
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item node:
reference number of an active subproblem or zero
@end itemize
@end quotation

@strong{Returns}:

@quotation
If the parameter p is zero, the routine returns the reference number
of the first active subproblem. If the tree is empty, zero is returned.
If the parameter p is not zero, it must specify the reference number of
some active subproblem, in which case the routine returns the reference
number of the next active subproblem. If there is no next active subproblem
in the list, zero is returned. All subproblems in the active list are
ordered chronologically, i.e. subproblem A precedes subproblem B if A
was created before B.
@end quotation

@strong{Example}:

@example
> glp::ios_next_node tree 23;
@end example

@noindent

@node Determine previous active subproblem,Determine parent active subproblem,Determine next active subproblem,The search tree exploring routines
@anchor{determine previous active subproblem}@anchor{a4}@anchor{determine-previous-active-subproblem}
@subsubsection Determine previous active subproblem
@strong{Synopsis}:

@example
glp::ios_prev_node tree node
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item node:
reference number of an active subproblem or zero
@end itemize
@end quotation

@strong{Returns}:

@quotation
If the parameter p is zero, the routine returns the reference number
of the last active subproblem. If the tree is empty, zero is returned.
If the parameter p is not zero, it must specify the reference number of
some active subproblem, in which case the routine returns the reference
number of the previous active subproblem. If there is no previous
active subproblem in the list, zero is returned. All subproblems in the
active list are ordered chronologically, i.e. subproblem A precedes
subproblem B if A was created before B.
@end quotation

@strong{Example}:

@example
> glp::ios_prev_node tree 23;
@end example

@noindent

@node Determine parent active subproblem,Determine subproblem level,Determine previous active subproblem,The search tree exploring routines
@anchor{determine parent active subproblem}@anchor{a5}@anchor{determine-parent-active-subproblem}
@subsubsection Determine parent active subproblem
@strong{Synopsis}:

@example
glp::ios_up_node tree node
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item node:
reference number of an active or inactive subproblem
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the reference number of its parent subproblem.
If the specified subproblem is the root of the tree, the routine
returns zero.
@end quotation

@strong{Example}:

@example
> glp::ios_up_node tree 23;
@end example

@noindent

@node Determine subproblem level,Determine subproblem local bound,Determine parent active subproblem,The search tree exploring routines
@anchor{determine subproblem level}@anchor{a6}@anchor{determine-subproblem-level}
@subsubsection Determine subproblem level
@strong{Synopsis}:

@example
glp::ios_node_level tree node
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item node:
reference number of an active or inactive subproblem
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the level of the given subproblem in the
branch-and-bound tree. (The root subproblem has level 0.)
@end quotation

@strong{Example}:

@example
> glp::ios_node_level tree 23;
@end example

@noindent

@node Determine subproblem local bound,Find active subproblem with the best local bound,Determine subproblem level,The search tree exploring routines
@anchor{determine subproblem local bound}@anchor{a7}@anchor{determine-subproblem-local-bound}
@subsubsection Determine subproblem local bound
@strong{Synopsis}:

@example
glp::ios_node_bound tree node
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item node:
reference number of an active or inactive subproblem
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the local bound for the given subproblem.
@end quotation

@strong{Example}:

@example
> glp::ios_node_bound tree 23;
@end example

@noindent

@node Find active subproblem with the best local bound,,Determine subproblem local bound,The search tree exploring routines
@anchor{find active subproblem with the best local bound}@anchor{a8}@anchor{find-active-subproblem-with-the-best-local-bound}
@subsubsection Find active subproblem with the best local bound
@strong{Synopsis}:

@example
glp::ios_best_node tree
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the reference number of the active subproblem, whose
local bound is best (i.e. smallest in case of minimization or largest
in case of maximization). If the tree is empty, the routine returns zero.
@end quotation

@strong{Example}:

@example
> glp::ios_best_node tree;
@end example

@noindent

@node The cut pool routines,,The search tree exploring routines,Branch-and-cut API routines
@anchor{the cut pool routines}@anchor{a9}@anchor{the-cut-pool-routines}
@subsection The cut pool routines

@menu
* Determine current size of the cut pool::
* Add constraint to the cut pool::
* Remove constraint from the cut pool::
* Remove all constraints from the cut pool::
@end menu


@node Determine current size of the cut pool,Add constraint to the cut pool,,The cut pool routines
@anchor{determine current size of the cut pool}@anchor{aa}@anchor{determine-current-size-of-the-cut-pool}
@subsubsection Determine current size of the cut pool
@strong{Synopsis}:

@example
glp::ios_pool_size tree
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the current size of the cut pool, that is, the number
of cutting plane constraints currently added to it.
@end quotation

@strong{Example}:

@example
> glp::ios_pool_size tree;
@end example

@noindent

@node Add constraint to the cut pool,Remove constraint from the cut pool,Determine current size of the cut pool,The cut pool routines
@anchor{add constraint to the cut pool}@anchor{ab}@anchor{add-constraint-to-the-cut-pool}
@subsubsection Add constraint to the cut pool
@strong{Synopsis}:

@example
glp::ios_add_row tree (name, klass, flags, row, rowtype, rhs)
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item name:
symbolic name of the constraint

@item klass:
specifies the constraint class, which must be either zero or a number
in the range from 101 to 200. The application may use this attribute
to distinguish between cutting plane constraints of different classes.

@item flags:
currently is not used and must be zero

@item row:
list of pairs (colindex, coefficient)

@item rowtype:
one of the following:


@itemize @w
@item glp::lo:
‚àë(aj.xj) ‚â• RHS constraint

@item glp::up:
‚àë(aj.xj) ‚â§ RHS constraint
@end itemize

@item rhs:
right hand side of the constraint
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the ordinal number of the cutting plane constraint
added, which is the new size of the cut pool.
@end quotation

@strong{Example}:

@example
> glp::ios_add_row tree ("new_constraint", 101, 0,
                         [(3, 15.0), (4, 6.7), (8, 1.25)], glp::up, 152.7);
@end example

@noindent

@node Remove constraint from the cut pool,Remove all constraints from the cut pool,Add constraint to the cut pool,The cut pool routines
@anchor{remove constraint from the cut pool}@anchor{ac}@anchor{remove-constraint-from-the-cut-pool}
@subsubsection Remove constraint from the cut pool
@strong{Synopsis}:

@example
glp::ios_del_row tree rowindex
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree

@item rowindex:
index of row to be deleted from the cut pool
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Remark}:

@quotation
Note that deleting a constraint from the cut pool leads to changing
ordinal numbers of other constraints remaining in the pool. New ordinal
numbers of the remaining constraints are assigned under assumption that
the original order of constraints is not changed.
@end quotation

@strong{Example}:

@example
> glp::ios_del_row tree 5;
@end example

@noindent

@node Remove all constraints from the cut pool,,Remove constraint from the cut pool,The cut pool routines
@anchor{remove all constraints from the cut pool}@anchor{ad}@anchor{remove-all-constraints-from-the-cut-pool}
@subsubsection Remove all constraints from the cut pool
@strong{Synopsis}:

@example
glp::ios_clear_pool tree
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item tree:
pointer to the branch-and-cut search tree
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Example}:

@example
> glp::ios_clear_pool tree;
@end example

@noindent

@node Graph and network API routines,Miscellaneous routines,Branch-and-cut API routines,Descriptions of interface functions
@anchor{graph and network api routines}@anchor{ae}@anchor{graph-and-network-api-routines}
@section Graph and network API routines

@menu
* Basic graph routines::
* Graph analysis routines::
* Minimum cost flow problem::
* Maximum flow problem::
@end menu


@node Basic graph routines,Graph analysis routines,,Graph and network API routines
@anchor{basic graph routines}@anchor{af}@anchor{basic-graph-routines}
@subsection Basic graph routines

@menu
* Create the GLPK graph object::
* Set the graph name::
* Add vertices to a graph::
* Add arc to a graph::
* Erase content of the GLPK graph object::
* Delete the GLPK graph object::
* Read graph in a plain text format::
* Write graph in a plain text format::
@end menu


@node Create the GLPK graph object,Set the graph name,,Basic graph routines
@anchor{create the glpk graph object}@anchor{b0}@anchor{create-the-glpk-graph-object}
@subsubsection Create the GLPK graph object
@strong{Synopsis}:

@example
glp::create_graph v_size a_size
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item v_size:
size of vertex data blocks, in bytes, 0 ‚â§ v size ‚â§ 256

@item a_size:
size of arc data blocks, in bytes, 0 ‚â§ a size ‚â§ 256.
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns a pointer to the graph created.
@end quotation

@strong{Example}:

@example
> let g = glp::create_graph 32 64;
> g;
#<pointer 0x9de7168>
@end example

@noindent

@node Set the graph name,Add vertices to a graph,Create the GLPK graph object,Basic graph routines
@anchor{set the graph name}@anchor{b1}@anchor{set-the-graph-name}
@subsubsection Set the graph name
@strong{Synopsis}:

@example
glp::set_graph_name graph name
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item name:
the graph name, an empty string erases the current name
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Example}:

@example
> glp::set_graph_name graph "MyGraph";
()
@end example

@noindent

@node Add vertices to a graph,Add arc to a graph,Set the graph name,Basic graph routines
@anchor{add vertices to a graph}@anchor{b2}@anchor{add-vertices-to-a-graph}
@subsubsection Add vertices to a graph
@strong{Synopsis}:

@example
glp::add_vertices graph count
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item count:
number of vertices to add
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the ordinal number of the first new
vertex added to the graph.
@end quotation

@strong{Example}:

@example
> glp::add_vertices graph 5;
18
@end example

@noindent

@node Add arc to a graph,Erase content of the GLPK graph object,Add vertices to a graph,Basic graph routines
@anchor{add arc to a graph}@anchor{b3}@anchor{add-arc-to-a-graph}
@subsubsection Add arc to a graph
@strong{Synopsis}:

@example
glp::add_arc graph i j
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item i:
index of the tail vertex

@item j:
index of the head vertex
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Example}:

@example
> glp::add_arc graph 7 12;
()
@end example

@noindent

@node Erase content of the GLPK graph object,Delete the GLPK graph object,Add arc to a graph,Basic graph routines
@anchor{erase content of the glpk graph object}@anchor{b4}@anchor{erase-content-of-the-glpk-graph-object}
@subsubsection Erase content of the GLPK graph object
@strong{Synopsis}:

@example
glp::erase_graph graph v_size a_size
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item v_size:
size of vertex data blocks, in bytes, 0 ‚â§ v size ‚â§ 256

@item a_size:
size of arc data blocks, in bytes, 0 ‚â§ a size ‚â§ 256.
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Remark}:

@quotation
The routine reinitialises the graph object. Its efect is equivalent to
calling delete_graph followed by a call to create_graph.
@end quotation

@strong{Example}:

@example
> glp::erase_graph graph 16 34;
()
@end example

@noindent

@node Delete the GLPK graph object,Read graph in a plain text format,Erase content of the GLPK graph object,Basic graph routines
@anchor{delete the glpk graph object}@anchor{b5}@anchor{delete-the-glpk-graph-object}
@subsubsection Delete the GLPK graph object
@strong{Synopsis}:

@example
glp::delete_graph graph
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Remark}:

@quotation
The routine destroys the graph object and invalidates the pointer.
This is done automatically when the graph is not needed anymore,
the routine need not be usually called.
@end quotation

@strong{Example}:

@example
> glp::delete_graph graph
()
@end example

@noindent

@node Read graph in a plain text format,Write graph in a plain text format,Delete the GLPK graph object,Basic graph routines
@anchor{read graph in a plain text format}@anchor{b6}@anchor{read-graph-in-a-plain-text-format}
@subsubsection Read graph in a plain text format
@strong{Synopsis}:

@example
glp::read_graph graph filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::read_graph graph "graph_data.txt";
0
@end example

@noindent

@node Write graph in a plain text format,,Read graph in a plain text format,Basic graph routines
@anchor{write graph in a plain text format}@anchor{b7}@anchor{write-graph-in-a-plain-text-format}
@subsubsection Write graph in a plain text format
@strong{Synopsis}:

@example
glp::write_graph graph filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item filename:
file name
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::write_graph graph "graph_data.txt";
0
@end example

@noindent

@node Graph analysis routines,Minimum cost flow problem,Basic graph routines,Graph and network API routines
@anchor{graph analysis routines}@anchor{b8}@anchor{graph-analysis-routines}
@subsection Graph analysis routines

@menu
* Find all weakly connected components of a graph::
* Find all strongly connected components of a graph::
@end menu


@node Find all weakly connected components of a graph,Find all strongly connected components of a graph,,Graph analysis routines
@anchor{find all weakly connected components of a graph}@anchor{b9}@anchor{find-all-weakly-connected-components-of-a-graph}
@subsubsection Find all weakly connected components of a graph
@strong{Synopsis}:

@example
glp::weak_comp graph v_num
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item v_num:
offset of the field of type int in the vertex data block, to which
the routine stores the number of a weakly connected component
containing that vertex - if v_num < 0, no component numbers are
stored
@end itemize
@end quotation

@strong{Returns}:

@quotation
The routine returns the total number of components found.
@end quotation

@strong{Example}:

@example
> glp::weak_comp graph 16;
3
@end example

@noindent

@node Find all strongly connected components of a graph,,Find all weakly connected components of a graph,Graph analysis routines
@anchor{find all strongly connected components of a graph}@anchor{ba}@anchor{find-all-strongly-connected-components-of-a-graph}
@subsubsection Find all strongly connected components of a graph
@strong{Synopsis}:

@example
glp::strong_comp graph v_num
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item v_num:
offset of the field of type int in the vertex data block, to which
the routine stores the number of a strongly connected component
containing that vertex - if v_num < 0, no component numbers are
stored
@end itemize
@end quotation

@strong{Returns}:

The routine returns the total number of components found.

@strong{Example}:

@example
> glp::strong_comp graph 16;
4
@end example

@noindent

@node Minimum cost flow problem,Maximum flow problem,Graph analysis routines,Graph and network API routines
@anchor{minimum cost flow problem}@anchor{bb}@anchor{minimum-cost-flow-problem}
@subsection Minimum cost flow problem

@menu
* Read minimum cost flow problem data in DIMACS format::
* Write minimum cost flow problem data in DIMACS format::
* Convert minimum cost flow problem to LP::
* Solve minimum cost flow problem with out-of-kilter algorithm::
* Klingman's network problem generator::
* Grid-like network problem generator::
@end menu


@node Read minimum cost flow problem data in DIMACS format,Write minimum cost flow problem data in DIMACS format,,Minimum cost flow problem
@anchor{read minimum cost flow problem data in dimacs format}@anchor{bc}@anchor{read-minimum-cost-flow-problem-data-in-dimacs-format}
@subsubsection Read minimum cost flow problem data in DIMACS format
@strong{Synopsis}:

@example
glp::read_mincost graph v_rhs a_low a_cap a_cost filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item v_rhs:
offset of the field of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs < 0, the value is not stored

@item a_low:
offset of the field of type double in the arc data block,
to which the routine stores lij, the lower bound to the
arc flow - if a_low < 0, the lower bound is not stored

@item a_cap:
offset of the field of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc flow (the arc capacity) - if a_cap < 0, the upper bound
is not stored

@item a_cost:
offset of the field of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc flow - if a_cost < 0, the cost is not stored

@item fname:
the name of a text file to be read in - if the file name name
ends with the suffix ‚Äò.gz‚Äô, the file is assumed to be compressed,
in which case the routine decompresses it ‚Äúon the fly‚Äù
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::read_mincost graph 0 8 16 24 "graphdata.txt";
0
@end example

@noindent

@node Write minimum cost flow problem data in DIMACS format,Convert minimum cost flow problem to LP,Read minimum cost flow problem data in DIMACS format,Minimum cost flow problem
@anchor{write minimum cost flow problem data in dimacs format}@anchor{bd}@anchor{write-minimum-cost-flow-problem-data-in-dimacs-format}
@subsubsection Write minimum cost flow problem data in DIMACS format
@strong{Synopsis}:

@example
glp::write_mincost graph v_rhs a_low a_cap a_cost fname
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item v_rhs:
offset of the field of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs < 0, the value is not stored

@item a_low:
offset of the field of type double in the arc data block,
to which the routine stores lij, the lower bound to the
arc flow - if a_low < 0, the lower bound is not stored

@item a_cap:
offset of the field of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc flow (the arc capacity) - if a_cap < 0, the upper bound
is not stored

@item a_cost:
offset of the field of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc flow - if a_cost < 0, the cost is not stored

@item fname:
the name of a text file to be written out - if the file name name
ends with the suffix ‚Äò.gz‚Äô, the file is assumed to be compressed,
in which case the routine compresses it ‚Äúon the fly‚Äù
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if reading went OK; non-zero in case of an error
@end quotation

@strong{Example}:

@example
> glp::write_mincost graph 0 8 16 24 "graphdata.txt";
0
@end example

@noindent

@node Convert minimum cost flow problem to LP,Solve minimum cost flow problem with out-of-kilter algorithm,Write minimum cost flow problem data in DIMACS format,Minimum cost flow problem
@anchor{convert minimum cost flow problem to lp}@anchor{be}@anchor{convert-minimum-cost-flow-problem-to-lp}
@subsubsection Convert minimum cost flow problem to LP
@strong{Synopsis}:

@example
glp::mincost_lp lp graph names v_rhs a_low a_cap a_cost
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item lp:
pointer to the LP problem object

@item graph:
pointer to the graph object

@item names:
one of the following:


@itemize @w
@item glp::on:
assign symbolic names of the graph object components
to symbolic names of the LP problem object components

@item glp::off:
no symbolic names are assigned
@end itemize

@item v_rhs:
offset of the field of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs < 0, it is assumed bi = 0 for all nodes

@item a_low:
offset of the field of type double in the arc data block,
to which the routine stores lij, the lower bound to the
arc flow - if a_low < 0, it is assumed lij = 0 for all arcs

@item a_cap:
offset of the field of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc flow (the arc capacity) - if a_cap < 0,it is assumed
uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

@item a_cost:
offset of the field of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc flow - if a_cost < 0, it is assumed cij = 0 for all arcs
@end itemize
@end quotation

@strong{Returns}:

@quotation
()
@end quotation

@strong{Example}:

@example
> glp::mincost_lp lp graph glp::on 0 8 16 24;
()
@end example

@noindent

@node Solve minimum cost flow problem with out-of-kilter algorithm,Klingman's network problem generator,Convert minimum cost flow problem to LP,Minimum cost flow problem
@anchor{solve minimum cost flow problem with out-of-kilter algorithm}@anchor{bf}@anchor{solve-minimum-cost-flow-problem-with-out-of-kilter-algorithm}
@subsubsection Solve minimum cost flow problem with out-of-kilter algorithm
@strong{Synopsis}:

@example
glp::mincost_okalg graph v_rhs a_low a_cap a_cost a_x v_pi
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item v_rhs:
offset of the field of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs < 0, it is assumed bi = 0 for all nodes

@item a_low:
offset of the field of type double in the arc data block,
to which the routine stores lij, the lower bound to the
arc flow - if a_low < 0, it is assumed lij = 0 for all arcs

@item a_cap:
offset of the field of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc flow (the arc capacity) - if a_cap < 0,it is assumed
uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

@item a_cost:
offset of the field of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc flow - if a_cost < 0, it is assumed cij = 0 for all arcs

@item a_x:
offset of the field of type double in the arc data block,
to which the routine stores xij, the arc flow found - if a_x < 0,
the arc flow value is not stored

@item v_pi:
specifies an offset of the field of type double in the vertex data block,
to which the routine stores pi, the node potential, which is the
Lagrange multiplier for the corresponding flow conservation
equality constraint
@end itemize
@end quotation

@strong{Remark}:

@quotation
Note that all solution components (the objective value, arc flows, and
node potentials) computed by the routine are always integer-valued.
@end quotation

@strong{Returns}:

@quotation
The function returns a tuple in the form @strong{(code, obj)}, where
@strong{code} is one of the following


@itemize @w
@item glp::ok:
optimal solution found

@item glp::enopfs:
no (primal) feasible solution exists

@item glp::edata:
unable to start the search, because some problem data are
either not integer-valued or out of range; this code is also
returned if the total supply, which is the sum of bi over all
source nodes (nodes with bi > 0), exceeds INT_MAX

@item glp::erange:
the search was prematurely terminated because of integer
overflow

@item glp::efail:
an error has been detected in the program logic -  if this
code is returned for your problem instance, please report
to <@email{bug-glpk@@gnu.org}>
@end itemize

and @strong{obj} is value of the objective function.
@end quotation

@strong{Example}:

@example
> glp::mincost_okalg graph 0 8 16 24 32 40;
(glp::ok, 15)
@end example

@noindent

@node Klingman's network problem generator,Grid-like network problem generator,Solve minimum cost flow problem with out-of-kilter algorithm,Minimum cost flow problem
@anchor{klingman's network problem generator}@anchor{c0}@anchor{klingman-s-network-problem-generator}
@subsubsection Klingman's network problem generator
@strong{Synopsis}:

@example
glp::netgen graph v_rhs a_cap a_cost parameters
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item v_rhs:
offset of the field of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs < 0, it is assumed bi = 0 for all nodes

@item a_cap:
offset of the field of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc flow (the arc capacity) - if a_cap < 0,it is assumed
uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

@item a_cost:
offset of the field of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc flow - if a_cost < 0, it is assumed cij = 0 for all arcs

@item parameters:
tuple of exactly 15 integer numbers with the following meaning:


@itemize @w
@item parm[1]:
iseed 8-digit positive random number seed

@item parm[2]:
nprob 8-digit problem id number

@item parm[3]:
nodes total number of nodes

@item parm[4]:
nsorc total number of source nodes
(including transshipment nodes)

@item parm[5]:
nsink total number of sink nodes
(including transshipment nodes)

@item parm[6]:
iarcs number of arc

@item parm[7]:
mincst minimum cost for arcs

@item parm[8]:
maxcst maximum cost for arcs

@item parm[9]:
itsup total supply

@item parm[10]:
ntsorc number of transshipment source nodes

@item parm[11]:
ntsink number of transshipment sink nodes

@item parm[12]:
iphic percentage of skeleton arcs to be given the
maximum cost

@item parm[13]:
ipcap percentage of arcs to be capacitated

@item parm[14]:
mincap minimum upper bound for capacitated arcs

@item parm[15]:
maxcap maximum upper bound for capacitated arcs
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if the instance was successfully generated, nonzero otherwise
@end quotation

@strong{Example}:

@example
> glp::netgen graph 0 8 16 (12345678, 87654321, 20, 12, 8,
                            25, 5, 20, 300, 6, 5, 15, 100, 1, 30);
0
@end example

@noindent

@node Grid-like network problem generator,,Klingman's network problem generator,Minimum cost flow problem
@anchor{grid-like network problem generator}@anchor{c1}@anchor{grid-like-network-problem-generator}
@subsubsection Grid-like network problem generator
@strong{Synopsis}:

@example
glp::gridgen graph v_rhs a_cap a_cost parameters
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object

@item v_rhs:
offset of the field of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs < 0, it is assumed bi = 0 for all nodes

@item a_cap:
offset of the field of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc flow (the arc capacity) - if a_cap < 0,it is assumed
uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc

@item a_cost:
offset of the field of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc flow - if a_cost < 0, it is assumed cij = 0 for all arcs

@item parameters:
tuple of exactly 14 integer numbers with the following meaning:


@itemize @w
@item parm[1]:
two-ways arcs indicator:

@display
@strong{1:} if links in both direction should be generated@w{ }
@strong{0:} otherwise@w{ }
@end display
@item parm[2]:
random number seed (a positive integer)

@item parm[3]:
number of nodes (the number of nodes generated might be
slightly different to make the network a grid)

@item parm[4]:
grid width

@item parm[5]:
number of sources

@item parm[6]:
number of sinks

@item parm[7]:
average degree

@item parm[8]:
total flow

@item parm[9]:
distribution of arc costs:

@display
@strong{1:} uniform@w{ }
@strong{2:} exponential@w{ }
@end display
@item parm[10]:
lower bound for arc cost (uniform),
100 lambda¬∏ (exponential)

@item parm[11]:
upper bound for arc cost (uniform),
not used (exponential)

@item parm[12]:
distribution of arc capacities:

@display
@strong{1:} uniform@w{ }
@strong{2:} exponential@w{ }
@end display
@item parm[13]:
lower bound for arc capacity (uniform),
100 lambda (exponential)

@item parm[14]:
upper bound for arc capacity (uniform),
not used (exponential)
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@strong{0} if the instance was successfully generated, nonzero otherwise
@end quotation

@strong{Example}:

@example
> glp::gridgen graph 0 8 16 (1, 123, 20, 4, 7, 5, 3, 300, 1, 1, 5, 1, 5, 30);
0
@end example

@noindent

@node Maximum flow problem,,Minimum cost flow problem,Graph and network API routines
@anchor{maximum flow problem}@anchor{c2}@anchor{maximum-flow-problem}
@subsection Maximum flow problem

@menu
* Read maximum cost flow problem data in DIMACS format::
* Write maximum cost flow problem data in DIMACS format::
* Convert maximum flow problem to LP::
* Solve maximum flow problem with Ford-Fulkerson algorithm::
* Goldfarb's maximum flow problem generator::
@end menu


@node Read maximum cost flow problem data in DIMACS format,Write maximum cost flow problem data in DIMACS format,,Maximum flow problem
@anchor{read maximum cost flow problem data in dimacs format}@anchor{c3}@anchor{read-maximum-cost-flow-problem-data-in-dimacs-format}
@subsubsection Read maximum cost flow problem data in DIMACS format
@strong{Synopsis}:

@example
glp::read_maxflow graph a_cap filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object
@end itemize
@end quotation

@strong{Returns}:

@strong{Example}:

@example
>
@end example

@noindent

@node Write maximum cost flow problem data in DIMACS format,Convert maximum flow problem to LP,Read maximum cost flow problem data in DIMACS format,Maximum flow problem
@anchor{write maximum cost flow problem data in dimacs format}@anchor{c4}@anchor{write-maximum-cost-flow-problem-data-in-dimacs-format}
@subsubsection Write maximum cost flow problem data in DIMACS format
@strong{Synopsis}:

@example
glp::write_maxflow graph s t a_cap filename
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object
@end itemize
@end quotation

@strong{Returns}:

@strong{Example}:

@example
>
@end example

@noindent

@node Convert maximum flow problem to LP,Solve maximum flow problem with Ford-Fulkerson algorithm,Write maximum cost flow problem data in DIMACS format,Maximum flow problem
@anchor{convert maximum flow problem to lp}@anchor{c5}@anchor{convert-maximum-flow-problem-to-lp}
@subsubsection Convert maximum flow problem to LP
@strong{Synopsis}:

@example
glp::maxflow_lp lp graph names s t a_cap
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object
@end itemize
@end quotation

@strong{Returns}:

@strong{Example}:

@example
>
@end example

@noindent

@node Solve maximum flow problem with Ford-Fulkerson algorithm,Goldfarb's maximum flow problem generator,Convert maximum flow problem to LP,Maximum flow problem
@anchor{solve maximum flow problem with ford-fulkerson algorithm}@anchor{c6}@anchor{solve-maximum-flow-problem-with-ford-fulkerson-algorithm}
@subsubsection Solve maximum flow problem with Ford-Fulkerson algorithm
@strong{Synopsis}:

@example
glp::maxflow_ffalg graph s t a_cap a_x v_cut
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object
@end itemize
@end quotation

@strong{Returns}:

@strong{Example}:

@example
>
@end example

@noindent

@node Goldfarb's maximum flow problem generator,,Solve maximum flow problem with Ford-Fulkerson algorithm,Maximum flow problem
@anchor{goldfarb's maximum flow problem generator}@anchor{c7}@anchor{goldfarb-s-maximum-flow-problem-generator}
@subsubsection Goldfarb's maximum flow problem generator
@strong{Synopsis}:

@example
glp::rmfgen graph a_cap parameters
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item graph:
pointer to the graph object
@end itemize
@end quotation

@strong{Returns}:

@strong{Example}:

@example
>
@end example

@noindent

@node Miscellaneous routines,,Graph and network API routines,Descriptions of interface functions
@anchor{miscellaneous routines}@anchor{c8}@anchor{miscellaneous-routines}
@section Miscellaneous routines

@menu
* Library environment routines::
@end menu


@node Library environment routines,,,Miscellaneous routines
@anchor{library environment routines}@anchor{c9}@anchor{library-environment-routines}
@subsection Library environment routines

@menu
* Determine library version::
* Enable/disable terminal output::
* Enable/disable the terminal hook routine::
* Get memory usage information::
* Set memory usage limit::
* Free GLPK library environment::
@end menu


@node Determine library version,Enable/disable terminal output,,Library environment routines
@anchor{determine library version}@anchor{ca}@anchor{determine-library-version}
@subsubsection Determine library version
@strong{Synopsis}:

@example
`glp::version
@end example

@noindent
@strong{Parameters}:

@quotation
none
@end quotation

@strong{Returns}:

@quotation
GLPK library version
@end quotation

@strong{Example}:

@example
> glp::version;
"4.38"
@end example

@noindent

@node Enable/disable terminal output,Enable/disable the terminal hook routine,Determine library version,Library environment routines
@anchor{enable/disable terminal output}@anchor{cb}@anchor{enable-disable-terminal-output}
@subsubsection Enable/disable terminal output
@strong{Synopsis}:

@example
glp::term_out switch
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item switch:
one of the following:


@itemize @w
@item glp::on:
enable terminal output from GLPK routines

@item glp::off:
disable terminal output from GLPK routines
@end itemize
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::term_out glp:off;
()
@end example

@noindent

@node Enable/disable the terminal hook routine,Get memory usage information,Enable/disable terminal output,Library environment routines
@anchor{enable/disable the terminal hook routine}@anchor{cc}@anchor{enable-disable-the-terminal-hook-routine}
@subsubsection Enable/disable the terminal hook routine
@strong{Synopsis}:

@example
glp::term_hook switch info
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item switch:
one of the following:


@itemize @w
@item glp::on:
use the terminal callback function

@item glp::off:
don't use the terminal callback function
@end itemize

@item info:
pointer to a memory block which can be used for passing
additional information to the terminal callback function
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::term_hook glp::on NULL;
()
@end example

@noindent

@node Get memory usage information,Set memory usage limit,Enable/disable the terminal hook routine,Library environment routines
@anchor{get memory usage information}@anchor{cd}@anchor{get-memory-usage-information}
@subsubsection Get memory usage information
@strong{Synopsis}:

@example
glp::mem_usage
@end example

@noindent
@strong{Parameters}:

@quotation
none
@end quotation

@strong{Returns}:

@quotation
tuple consisting of four numbers:

@quotation

@itemize *
@item
@code{count} (int) - the number of currently allocated memory blocks
@item
@code{cpeak} (int) - the peak value of @code{count} reached since the
initialization of the GLPK library environment
@item
@code{total} (bigint) - the total amount, in bytes, of currently
allocated memory blocks
@item
@code{tpeak} (bigint) - the peak value of @code{total} reached since the
initialization of the GLPK library envirionment
@end itemize
@end quotation
@end quotation

@strong{Example}:

@example
> glp::mem_usage;
7,84,10172L,45304L
@end example

@noindent

@node Set memory usage limit,Free GLPK library environment,Get memory usage information,Library environment routines
@anchor{set memory usage limit}@anchor{ce}@anchor{set-memory-usage-limit}
@subsubsection Set memory usage limit
@strong{Synopsis}:

@example
glp::mem_limit limit
@end example

@noindent
@strong{Parameters}:

@quotation

@itemize @w
@item limit:
memory limit in megabytes
@end itemize
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp::mem_limit 200;
()
@end example

@noindent

@node Free GLPK library environment,,Set memory usage limit,Library environment routines
@anchor{free glpk library environment}@anchor{cf}@anchor{free-glpk-library-environment}
@subsubsection Free GLPK library environment
@strong{Synopsis}:

@example
glp::free_env
@end example

@noindent
@strong{Parameters}:

@quotation
none
@end quotation

@strong{Returns}:

@quotation
@code{()}
@end quotation

@strong{Example}:

@example
> glp_free_env;
()
@end example

@noindent

@node Index,,Descriptions of interface functions,Top
@anchor{index}
@unnumbered Index
@printindex ge

@c %**end of body
@bye
