This is pure-stldict.info, produced by makeinfo version 4.13 from
pure-stldict.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-stldict: (pure-stldict.info).    pure-stldict
END-INFO-DIR-ENTRY


File: pure-stldict.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-stldict
************

  Version 0.3, March 03, 2012

  Albert Graef <<Dr.Graef@t-online.de>>

  This package provides a light-weight, no frills interface to the C++
dictionary containers `map' and `unordered_map'. The *note stldict: 2.
module makes these data structures available in Pure land and equips
them with a (more or less) idiomatic Pure container interface.

  The C++ containers are part of the standard C++ library, see the C++
standard library documentation (http://en.cppreference.com/w/cpp) for
details. They were originally based on the Standard Template Library
(http://www.sgi.com/tech/stl/), so they are also sometimes referred to
as "STL containers"; hence the name of this package.

* Menu:

* Copying::
* Installation::
* Usage::
* Types::
* Operations::
* Examples::
* Index::

 --- The Detailed Node Listing ---

Operations

* Basic Operations::
* Comparisons::
* Set-Like Operations::
* List-Like Operations::
* Iterators::
* Low-Level Operations::
* Pretty-Printing::


File: pure-stldict.info,  Node: Copying,  Next: Installation,  Prev: Top,  Up: Top

1 Copying
*********

Copyright (c) 2011 by Albert Graef.

  pure-stldict is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

  pure-stldict is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
License along with this program.  If not, see
<<http://www.gnu.org/licenses/>>.


File: pure-stldict.info,  Node: Installation,  Next: Usage,  Prev: Copying,  Up: Top

2 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-stldict-0.3.tar.gz>.

  Run `make' to compile the modules and `make install' (as root) to
install them in the Pure library directory. This requires GNU make, and
of course you need to have Pure (and a C++ library which includes the
STL) installed.

  `make' tries to guess your Pure installation directory and
platform-specific setup. If it gets this wrong, you can set some
variables manually, please check the Makefile for details.

     Note: This module requires Pure 0.50 or later and a recent version
     of the C++ library (GNU libstdc++ v3 has been tested). All proper
     C++11 libraries should work out of the box, while (recent) C++0x
     implementations may require some fiddling with the sources and/or
     the compilation options. Pre C++0x library versions surely require
     considerably more work, especially in the hashdict module.


File: pure-stldict.info,  Node: Usage,  Next: Types,  Prev: Installation,  Up: Top

3 Usage
*******

After installation, you can use the operations of this package by
placing the following import declaration in your Pure programs:

    using stldict;

This imports the whole shebang. If you only need either the hashed or
the ordered dictionaries, you can also import the corresponding modules
separately, i.e.:

    using hashdict;

or:

    using orddict;



File: pure-stldict.info,  Node: Types,  Next: Operations,  Prev: Usage,  Up: Top

4 Types
*******

In Pure land, the C++ `map' and `unordered_map' containers and their
`multimap' variants are made available as a collection of four data
structures:

 -- type: hashdict
 -- type: hashmdict
     Hashed (unordered) dictionary data structures. These work with
     arbitrary key (and value) types, like the hashed dictionary and
     set data structures in the standard library, and can be found in
     the `hashdict.pure' module.

 -- type: orddict
 -- type: ordmdict
     Ordered dictionary data structures. These require the keys to be
     ordered by the standard `<' predicate, like the ordered dictionary
     and set data structures in the standard library, and can be found
     in the `orddict.pure' module.

  Note that *note hashdict: a. and *note hashmdict: b. differ in that
the former has exactly one key-value association for each key in the
dictionary, while the latter is a "multidict" which allows multiple
values to be associated with a key. The same applies to the *note
orddict: c. and *note ordmdict: d. types.

  In addition, there are various supertypes which correspond to
different unions of the hashed and ordered dictionary types. These are:

 -- type: hashxdict
 -- type: ordxdict
     Denotes any kind of hashed or ordered dictionary, respectively.

 -- type: stldict
 -- type: stlmdict
     Denotes any kind of singled-valued or multi-valued dictionary,
     respectively.

 -- type: stlxdict
     Denotes any kind of dictionary.

  For instance, you can use *note hashxdict: e. to match both *note
hashdict: a. and *note hashmdict: b. values. Likewise, *note stlmdict:
11. matches both *note hashmdict: b. and *note ordmdict: d. values. To
match any kind of dictionary, use the *note stlxdict: 12. type.

  These data structures are very thin wrappers around the C++ container
types; in fact, they are just pointers to the C++ containers. Memory
management of these objects is automatic, and customizable *note
pretty-printing: 13. is provided as well.

  All data structures offer most of the usual Pure container interface
(as well as some extensions). In contrast to the standard library
dictionaries, they can be used both as dictionaries (holding key =>
value pairs) and sets (holding only keys, without associated values),
even at the same time.

  The other important difference to the standard library containers is
that the stldict containers are _mutable_ data structures; inserting
and deleting members really modifies the underlying C++ containers.
(However, it is possible to take copies of the containers in situations
where it's necessary to preserve value semantics.)


File: pure-stldict.info,  Node: Operations,  Next: Examples,  Prev: Types,  Up: Top

5 Operations
************

All types of dictionaries are simply pointers to the corresponding C++
containers which hold key-value associations where both keys and values
may be arbitrary Pure expressions. The *note basic operations: 15.
described below can be used to create, query and modify these objects.
*note Comparisons: 16. of dictionaries are implemented as well, and the
*note set-like operations: 17. let you combine dictionaries in
different ways. These operations provide an interface similar to the
usual Pure container API.

  In addition, the *note stldict: 2. module provides some *note
list-like operations: 18.  on dictionaries, so that the member data can
be processed and aggregated in a convenient fashion (including the
ability to use dictionaries as generators in list and matrix
comprehensions), and there's also an interface to C++ *note iterators:
19. which enables you to traverse, inspect and modify the containers in
a more C++-like way. Some *note low-level operations: 1a. are available
to access information about the underlying hash table of a hashed
dictionary. Last but not least, the module also offers some operations
to customize the *note pretty-printing: 13. of dictionary values.

  When working with these data structures, please note the following
special properties of this implementation:

   * All dictionary types are _mutable_. Inserting and deleting members
     really modifies the underlying C++ data structure as a side effect
     of the operation. If you need value semantics, you should probably
     use one of the dictionary or set data structures from the standard
     Pure library instead. Another possibility is to take a copy of a
     hashdict using the *note copy: 1b. function if you need to
     preserve the original value.

   * Keys in a hashed dictionary may be stored in an apparently random
     order (not necessarily in the order in which they were inserted),
     while they are guaranteed to be in ascending order (by key) for
     ordered dictionaries.  However, note that even in the latter case,
     the order of different members for the same key in a multi-valued
     dictionary is not specified. This must be taken into account when
     comparing dictionaries, see below. The order of members in a
     dictionary also matters when listing data from a container using,
     e.g., the *note members: 1c, *note keys: 1d. and *note vals: 1e.
     operations.

   * Two dictionaries are considered syntactically equal iff they
     contain the same elements in exactly the same order, using
     syntactic equality on both the keys and the associated values.
     This test can always be done in linear time, but is of limited
     usefulness for most kinds of dictionaries, since the exact order
     of members in the dictionary may vary depending on how the
     dictionary was constructed. Semantic equality operations are
     provided which check (albeit at the cost of increased running
     time) whether two containers contain the same members irrespective
     of element order, using semantic equality on the members. Various
     subset comparisons are provided as well, please check the *note
     Comparisons: 16. section for details.

   * Values in a dictionary can be omitted, so that a dictionary can
     also be used as a set data structure. This obviates the need for a
     separate set data structure at the cost of some (small) increase
     in memory usage. Also note that you can't really have a hash pair
     `x=>y' as a member of a set, since it always denotes a key-value
     association. As a remedy, you may use ordinary pairs `(x,y)'
     instead.

* Menu:

* Basic Operations::
* Comparisons::
* Set-Like Operations::
* List-Like Operations::
* Iterators::
* Low-Level Operations::
* Pretty-Printing::


File: pure-stldict.info,  Node: Basic Operations,  Next: Comparisons,  Up: Operations

5.1 Basic Operations
====================

 -- Function: hashdict xs
 -- Function: hashmdict xs
 -- Function: orddict xs
 -- Function: ordmdict xs
     Create a dictionary of the corresponding type from a list, tuple
     or vector of its members. Members can be specified as hash pairs
     `x=>y' to denote a key-value association. Any other kind of value
     denotes a singleton key without associated value. Note that the
     ordered dictionaries require that the keys be ordered, i.e., the
     `<' predicate must be defined on them.

     The same operations can also be used to construct a dictionary
     from another dictionary of any type. If the given dictionary is
     already of the corresponding type, this is a no-op (if you want to
     copy the dictionary instead, use the *note copy: 1b. function
     below). Otherwise the given dictionary is converted to a new
     dictionary of the desired target type.

 -- Function: mkhashdict y xs
 -- Function: mkhashmdict y xs
 -- Function: mkorddict y xs
 -- Function: mkordmdict y xs
     Create a dictionary from a list of keys and a constant value. The
     resulting dictionary has the given keys and `y' as the value for
     each key.

 -- Function: copy m
     Create a new dictionary with the same type and content as `m'.
     This is useful if you want to preserve value semantics when using
     destructive update operations such as *note insert: 27. and *note
     delete: 28.  In such a case, *note copy: 1b. can be used to take a
     copy of the dictionary beforehand, so that the original dictionary
     remains unmodified.

          Note: This operation needs linear time with respect to the
          size of the dictionary (i.e., its number of members). If
          logarithmic update times are needed while still preserving
          value semantics, you should use the dictionary and set data
          structures from the standard library instead.

 -- Function: hashdictp m
 -- Function: hashmdictp m
 -- Function: orddictp m
 -- Function: ordmdictp m
     Check whether the argument is a dictionary of the corresponding
     type.

 -- Function: hashxdictp m
 -- Function: ordxdictp m
 -- Function: stldictp m
 -- Function: stlmdictp m
 -- Function: stlxdictp m
     Check whether the argument is a dictionary of the corresponding
     supertype.

 -- Function: # m
     The size of a dictionary (the number of members it contains).

 -- Function: m ! x
     Get the value stored under key `x' in the dictionary `m'. This may
     be `x' itself if `x' is a member of `m' but has no associated
     value. In the case of a multidict this actually returns a list of
     values (which may be empty if `m' doesn't contain `x'). Otherwise
     an `out_of_bounds' exception is thrown if `m' doesn't contain `x'.

 -- Function: null m
     Test whether `m' is empty, i.e., has zero members.

 -- Function: member m x
     Test whether `m' contains a member with key `x'.

 -- Function: members m
 -- Function: list m
     Return the list of members of `m'. The member list will be in an
     apparently random order in the hashed dictionary case, while it is
     guaranteed to be in ascending order (by key) for ordered
     dictionaries. The same order is also used for the other inspection
     operations below.

 -- Function: stream m
     Like *note list: 36, but the member list is returned as a lazy list
     (cf. _Lazy Evaluation and Streams_) whose members will be computed
     on the fly as the list is being traversed; cf. *note Iterators: 19.

 -- Function: tuple m
 -- Function: vector m
     Return the members as a tuple or vector.

 -- Function: keys m
     Return the list of keys in the dictionary.

 -- Function: vals m
     Return the list of corresponding values. In the case of a
     singleton key `x' without associated value, `x' itself is returned
     instead.

  As already mentioned, the following modification operations are
destructive, i.e., they actually modify the underlying dictionary data
structure. If this is not desired, you'll first have to take a copy of
the target dictionary, see *note copy: 1b.

 -- Function: insert m x
 -- Function: insert m (x=>y)
 -- Function: update m x y
     Insert a singleton key `x' or a key-value pair `x=>y' into `m' and
     return the modified dictionary. This always adds a new member in a
     multidict, otherwise it replaces an existing value if there is
     one. *note update: 3b. is provided as a fully curried version of
     *note insert: 3a, so `update m x y' behaves exactly like `insert m
     (x=>y)'.

 -- Function: delete m x
 -- Function: delete m (x=>y)
     Remove the key `x' or the specific key-value pair `x=>y' from `m'
     (if present) and return the modified dictionary. In the multidict
     case, only the first member with the given key `x' or key-value
     pair `x=>y' is removed.

 -- Function: clear m
     Remove all members from `m', making `m' an empty dictionary.
     Returns `()'.


File: pure-stldict.info,  Node: Comparisons,  Next: Set-Like Operations,  Prev: Basic Operations,  Up: Operations

5.2 Comparisons
===============

The usual comparison predicates (`==', `~=', `<=', `<' etc.) are
defined on all dictionary types, where two dictionaries are considered
"equal" (`m1==m2') if they both contain the same `key=>value' pairs,
and `m1<=m2' means that `m1' is a sub-dictionary of `m2', i.e., all
`key=>value' pairs of `m1' are also contained in `m2' (taking into
account multiplicities in the multidict case). Ordered dictionaries
compare keys using equality (assuming two keys `a' and `b' to be equal
if neither `a<b' nor `b<a' holds), while hashed dictionaries check for
syntactical equality (using `==='). The associated values are compared
using the `==' predicate if it is defined, falling back to syntactic
equality otherwise.

  The module also defines syntactic equality on all dictionary types,
so that two dictionaries of the same type are considered syntactically
equal iff they contain the same (syntactically equal) members in the
same order. This is always guaranteed if two dictionaries are
"identical" (the same C++ pointer), but generally the member order will
depend on how the dictionary was constructed. Thus if you need to check
that two dictionaries contain the same members irrespective of the
order in which the members are listed, the semantic equality operation
`==' should be used instead; this will also handle the case of mixed
operand types.

  Note that if you really need to check whether two dictionaries are
the same object rather than just syntactically equal, you'll have to
cast them to generic C pointers before comparing them with `==='. This
can be done with the following little helper function:

    same_dict x y = pointer_cast "void*" x === pointer_cast "void*" y;



File: pure-stldict.info,  Node: Set-Like Operations,  Next: List-Like Operations,  Prev: Comparisons,  Up: Operations

5.3 Set-Like Operations
=======================

These operations work with mixed operand types, promoting less general
types to more general ones (i.e., ordered to hashed, and single-valued
to multi-valued dictionaries). The result is always a new dictionary,
leaving the operands unmodified.

 -- Function: m1 + m2
     Sum: `m1+m2' adds the members of `m2' to `m1'.

 -- Function: m1 - m2
     Difference: `m1-m2' removes the members of `m2' from `m1'.

 -- Function: m1 * m2
     Intersection: `m1*m2' removes the members _not_ in `m2' from `m1'.


File: pure-stldict.info,  Node: List-Like Operations,  Next: Iterators,  Prev: Set-Like Operations,  Up: Operations

5.4 List-Like Operations
========================

The following operations are all overloaded so that they work like
their list counterparts, treating their dictionary argument as if it
was the member list of the dictionary:

   * `do', `map', `catmap', `listmap', `rowmap', `rowcatmap', `colmap',
     `colcatmap'

   * `all', `any', `filter', `foldl', `foldl1', `foldr', `foldr1',
     `scanl', `scanl1', `scanr', `scanr1', `sort'

  Note that this includes the generic comprehension helpers `listmap',
`catmap' et al, so that dictionaries can be used as generators in list
and matrix comprehensions as usual (see below for some *note examples:
41.).


File: pure-stldict.info,  Node: Iterators,  Next: Low-Level Operations,  Prev: List-Like Operations,  Up: Operations

5.5 Iterators
=============

These operations give direct access to C++ iterators on dictionaries
which let you query the elements and do basic manipulations of the
container. The operations are available in the `stldict' namespace.

  The iterator concept is somewhat alien to Pure and there are some
pitfalls (most notably, destructive updates may render iterators
invalid), but the operations described here are still useful in some
situations, especially if you need to speed up sequential accesses to
large containers or modify values stored in a container in a direct
way. They are also used internally to compute lazy member lists of
containers (*note stream: 37. function).

  You should only use these directly if you know what you are doing. In
particular, make sure to consult the C++ standard library documentation
(http://en.cppreference.com/w/cpp) for further details on C++ iterator
usage.

  The following operations are provided to create an iterator for a
given dictionary.

 -- Function: stldict::begin m
 -- Function: stldict::end m
     Return iterators pointing to the beginning and the end of the
     container.  (Note that *note stldict end: 43. _must_ always be
     specified in qualified form since `end' is a keyword in the Pure
     language.)

 -- Function: stldict::find m x
     Locates a key or specific key=>value pair `x' in the container and
     returns an iterator pointing to the corresponding member (or
     `stldict::end m' if `m' doesn't contain `x').

  Note that these operations return a new iterator object for each
invocation.  Also, the created iterator object keeps track of the
container it belongs to, so that the container isn't garbage-collected
while the iterator is still being used. However, removing a member from
the container (using either *note delete: 28. or *note stldict erase:
45.) invalidates all iterators pointing to that member; the result of
trying to access such an invalidated iterator is undefined (most likely
your program will crash).

  Similar caveats also apply to the *note stream: 37. function which, as
already mentioned, uses iterators internally to implement lazy list
traversal of the members of a dictionary. Thus, if you delete a member
of a dictionary while traversing it using *note stream: 37, you better
make sure that this member is not the next stream element remaining to
be visited; otherwise bad things will happen.

  The following operations on iterators let you query and modify the
contents of the underlying container:

 -- Function: stldict::dict i
     Return the dictionary to which `i' belongs.

 -- Function: stldict::endp i
     Check whether the iterator `i' points to the end of the container
     (i.e., past the last element).

 -- Function: stldict::next i
     Advance the iterator to the next element. Note that for
     convenience, in contrast to the corresponding C++ operation this
     operation is non-destructive. Thus it actually creates a _new_
     iterator object, leaving the original iterator `i' unmodified. The
     operation fails if `i' is already at the end of the container.

 -- Function: stldict::get i
     Retrieve the key=>val pair stored in the member pointed to by `i'
     (or just the key if there is no associated value). The operation
     fails if `i' is at the end of the container.

 -- Function: stldict::put i y
     Change the value associated with the member pointed to by `i' to
     `y', and return the new value `y'. The operation fails if `i' is
     at the end of the container. Note that *note stldict put: 4a. only
     allows you to set the associated value, _not_ the key of the
     member.

 -- Function: stldict::erase i
     Remove the member pointed to by `i' (this invalidates `i' and all
     other iterators pointing to this member). The operation fails if
     `i' is at the end of the container.

 -- Function: i == j
 -- Function: i ~= j
     Semantic equality of iterators. Two iterators are considered equal
     (`i == j') if `i' and `j' point to the same element in the same
     container, and unequal (`i ~= j') if they don't. (In contrast,
     note that iterators are in fact just pointers to a corresponding
     C++ data structure, and thus _syntactical_ equality (`i === j')
     holds only if two iterators are the same object.)


File: pure-stldict.info,  Node: Low-Level Operations,  Next: Pretty-Printing,  Prev: Iterators,  Up: Operations

5.6 Low-Level Operations
========================

The *note hashdict: 0. module also provides a few specialized low-level
operations dealing with the layouts of buckets and the hash policy of
the *note hashdict: a. and *note hashmdict: b. containers, such as
`bucket_count', `load_factor', `rehash' etc. These operations, which are
all kept in their own separate `hashdict' namespace, are useful to
obtain performance-related information and modify the setup of the
underlying hash table. Please check the `hashdict.pure' module and the
C++ standard library documentation (http://en.cppreference.com/w/cpp)
for further details.


File: pure-stldict.info,  Node: Pretty-Printing,  Prev: Low-Level Operations,  Up: Operations

5.7 Pretty-Printing
===================

By default, dictionaries are pretty-printed in the format `somedict xs',
where `somedict' is the actual construction function such as `hashdict',
`orddict', etc., and `xs' is the member list of the dictionary. This is
usually convenient, as the printed expression will evaluate to an equal
container when reentered as Pure code. However, it is also possible to
define your own custom pretty-printing with the following function.

 -- Function: hashdict_symbol f
 -- Function: hashmdict_symbol f
 -- Function: orddict_symbol f
 -- Function: ordmdict_symbol f
     Makes the pretty-printer use the format `f xs' (where `xs' is the
     member list) for printing the corresponding type of dictionary.

  Note that `f' may also be an operator symbol (nonfix and unary
symbols work best). In the case of an outfix symbol the list brackets
around the members are removed; this makes it possible to render the
container in a format similar to Pure's list syntax. For instance:

    > using stldict;
    > outfix {$ $};
    > orddict_symbol ({$ $});
    ()
    > orddict (1..5);
    {$1,2,3,4,5$}

See `orddict_examp.pure' included in the distribution for a complete
example which also discusses how to make such a custom print
representation reparsable.


File: pure-stldict.info,  Node: Examples,  Next: Index,  Prev: Operations,  Up: Top

6 Examples
**********

Some basic examples showing *note hashdict: a. in action:

    > using stldict;
    > let m = hashdict [foo=>99, bar=>bar 4711L, baz=>1..5]; m;
    hashdict [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
    > m!bar;
    bar 4711L
    > keys m;
    [foo,bar,baz]
    > vals m;
    [99,bar 4711L,[1,2,3,4,5]]
    > list m;
    [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
    > member m foo, member m bar;
    1,1

Hashed multidicts (*note hashmdict: b.):

    > let m = hashmdict [foo=>99,baz=>1..5,baz=>bar 4711L]; m;
    hashmdict [foo=>99,baz=>[1,2,3,4,5],baz=>bar 4711L]
    > m!baz;
    [[1,2,3,4,5],bar 4711L]
    > m!foo;
    [99]

The following example illustrates how to employ ordered dictionaries
(*note orddict: c.) as a set data structure:

    > let m1 = orddict [5,1,3,11,3];
    > let m2 = orddict (3..6);
    > m1;m2;
    orddict [1,3,5,11]
    orddict [3,4,5,6]
    > m1+m2;
    orddict [1,3,4,5,6,11]
    > m1-m2;
    orddict [1,11]
    > m1*m2;
    orddict [3,5]
    > m1*m2 <= m1, m1*m2 <= m2;
    1,1
    > m1 < m1+m2, m2 < m1+m2;
    1,1

Of course, the same works with ordered multidicts (*note ordmdict: d.):

    > let m1 = ordmdict [5,1,3,11,3];
    > let m2 = ordmdict (3..6);
    > m1;m2;
    ordmdict [1,3,3,5,11]
    ordmdict [3,4,5,6]
    > m1+m2;
    ordmdict [1,3,3,3,4,5,5,6,11]
    > m1-m2;
    ordmdict [1,3,11]
    > m1*m2;
    ordmdict [3,5]
    > m1*m2 <= m1, m1*m2 <= m2;
    1,1
    > m1 < m1+m2, m2 < m1+m2;
    1,1

In fact, the binary operations (comparisons as well as the set
operations `+', `-' and `*') work with any combination of dictionary
operands:

    > let m1 = hashdict (1..5);
    > let m2 = ordmdict (3..7);
    > m1+m2;
    hashmdict [1,2,3,3,4,4,5,5,6,7]

Note that the operands are always promoted to the more general operand
type, where hashed beats ordered and multi-valued beats single-valued
dictionaries.  If this is not what you want, you can also specify the
desired conversions explicitly:

    > m1+orddict m2;
    hashdict [1,2,3,4,5,6,7]
    > orddict m1+m2;
    ordmdict [1,2,3,3,4,4,5,5,6,7]

Also note that the "set" operations not only work with proper sets, but
also with general dictionaries:

    > hashdict [i=>i+1|i=1..4]+hashdict [i=>i-1|i=3..5];
    hashdict [1=>2,2=>3,3=>2,4=>3,5=>4]

All dictionary containers can be used as generators in list and matrix
comprehensions:

    > let m = hashmdict [foo=>99,baz=>1..5,baz=>bar 4711L];
    > [x y | x=>y = m];
    [foo 99,baz [1,2,3,4,5],baz (bar 4711L)]
    > {{x;y} | x=>y = m};
    {foo,baz,baz;99,[1,2,3,4,5],bar 4711L}

Note that in the current implementation this always computes the full
member list of the dictionary as an intermediate value, which will need
considerable extra memory in the case of large dictionaries. As a
remedy, you can also use the *note stream: 37. function to convert the
dictionary to a lazy list instead. This will often be slower, but in
the case of big dictionaries the tradeoff between memory usage and
execution speed might be worth considering. For instance:

    > let m = hashdict [foo i => i | i = 1..10000];
    > stream m;
    (foo 1512=>1512):#<thunk 0x7fa1718350a8>
    > stats -m
    > #list m;
    10000
    0.01s, 40001 cells
    > #stream m;
    10000
    0.1s, 16 cells
    > #[y | x=>y = m; gcd y 767~=1];
    925
    0.05s, 61853 cells
    > #[y | x=>y = stream m; gcd y 767~=1];
    925
    0.15s, 10979 cells



File: pure-stldict.info,  Node: Index,  Prev: Examples,  Up: Top

Index
*****

 [index ]
* Menu:

* # prefix function:                     Basic Operations.    (line  61)
* * infix function:                      Set-Like Operations. (line  17)
* + infix function:                      Set-Like Operations. (line  11)
* - infix function:                      Set-Like Operations. (line  14)
* == infix function:                     Iterators.           (line  88)
* clear function:                        Basic Operations.    (line 124)
* copy function:                         Basic Operations.    (line  32)
* delete function:                       Basic Operations.    (line 117)
* hashdict function:                     Basic Operations.    (line   6)
* hashdict module:                       Top.                 (line   6)
* hashdict type:                         Types.               (line  10)
* hashdict_symbol function:              Pretty-Printing.     (line  13)
* hashdictp function:                    Basic Operations.    (line  46)
* hashmdict function:                    Basic Operations.    (line   6)
* hashmdict type:                        Types.               (line  10)
* hashmdict_symbol function:             Pretty-Printing.     (line  13)
* hashmdictp function:                   Basic Operations.    (line  46)
* hashxdict type:                        Types.               (line  33)
* hashxdictp function:                   Basic Operations.    (line  53)
* infix function:                        Basic Operations.    (line  64)
* insert function:                       Basic Operations.    (line 107)
* keys function:                         Basic Operations.    (line  94)
* list function:                         Basic Operations.    (line  77)
* member function:                       Basic Operations.    (line  74)
* members function:                      Basic Operations.    (line  77)
* mkhashdict function:                   Basic Operations.    (line  24)
* mkhashmdict function:                  Basic Operations.    (line  24)
* mkorddict function:                    Basic Operations.    (line  24)
* mkordmdict function:                   Basic Operations.    (line  24)
* null function:                         Basic Operations.    (line  71)
* orddict function:                      Basic Operations.    (line   6)
* orddict module:                        Top.                 (line   6)
* orddict type:                          Types.               (line  17)
* orddict_symbol function:               Pretty-Printing.     (line  13)
* orddictp function:                     Basic Operations.    (line  46)
* ordmdict function:                     Basic Operations.    (line   6)
* ordmdict type:                         Types.               (line  17)
* ordmdict_symbol function:              Pretty-Printing.     (line  13)
* ordmdictp function:                    Basic Operations.    (line  46)
* ordxdict type:                         Types.               (line  33)
* ordxdictp function:                    Basic Operations.    (line  53)
* stldict begin function:                Iterators.           (line  26)
* stldict dict function:                 Iterators.           (line  57)
* stldict end function:                  Iterators.           (line  26)
* stldict endp function:                 Iterators.           (line  60)
* stldict erase function:                Iterators.           (line  83)
* stldict find function:                 Iterators.           (line  33)
* stldict get function:                  Iterators.           (line  71)
* stldict module:                        Top.                 (line   6)
* stldict next function:                 Iterators.           (line  64)
* stldict put function:                  Iterators.           (line  76)
* stldict type:                          Types.               (line  37)
* stldictp function:                     Basic Operations.    (line  53)
* stlmdict type:                         Types.               (line  37)
* stlmdictp function:                    Basic Operations.    (line  53)
* stlxdict type:                         Types.               (line  42)
* stlxdictp function:                    Basic Operations.    (line  53)
* stream function:                       Basic Operations.    (line  85)
* tuple function:                        Basic Operations.    (line  90)
* update function:                       Basic Operations.    (line 107)
* vals function:                         Basic Operations.    (line  97)
* vector function:                       Basic Operations.    (line  90)
* ~= infix function:                     Iterators.           (line  88)



Tag Table:
Node: Top258
Ref: 0352
Ref: module-hashdict352
Ref: 1352
Ref: module-orddict352
Ref: 31034
Ref: c-standard-library-documentation1034
Ref: 41034
Ref: standard-template-library1034
Node: Copying1325
Ref: copying1411
Ref: 21411
Ref: module-stldict1411
Ref: 51411
Ref: 61411
Node: Installation2111
Ref: installation2199
Ref: 72199
Node: Usage3157
Ref: usage3243
Ref: 83243
Node: Types3619
Ref: types3703
Ref: 93703
Ref: a3870
Ref: hashdict/type3870
Ref: b3889
Ref: hashmdict/type3889
Ref: c4150
Ref: orddict/type4150
Ref: d4168
Ref: ordmdict/type4168
Ref: e4889
Ref: hashxdict/type4889
Ref: f4909
Ref: ordxdict/type4909
Ref: 104998
Ref: stldict/type4998
Ref: 115016
Ref: stlmdict/type5016
Ref: 125123
Ref: stlxdict/type5123
Node: Operations6335
Ref: operations6422
Ref: 146422
Node: Basic Operations10241
Ref: basic operations10330
Ref: 1510330
Ref: basic-operations10330
Ref: 1f10373
Ref: hashdict10373
Ref: 2010399
Ref: hashmdict10399
Ref: 2110426
Ref: orddict10426
Ref: 2210451
Ref: ordmdict10451
Ref: 2311259
Ref: mkhashdict11259
Ref: 2411289
Ref: mkhashmdict11289
Ref: 2511320
Ref: mkorddict11320
Ref: 2611349
Ref: mkordmdict11349
Ref: 1b11536
Ref: copy/stldict11536
Ref: 2912269
Ref: hashdictp12269
Ref: 2a12295
Ref: hashmdictp12295
Ref: 2b12322
Ref: orddictp12322
Ref: 2c12347
Ref: ordmdictp12347
Ref: 2d12454
Ref: hashxdictp12454
Ref: 2e12481
Ref: ordxdictp12481
Ref: 2f12507
Ref: stldictp12507
Ref: 3012532
Ref: stlmdictp12532
Ref: 3112558
Ref: stlxdictp12558
Ref: 3212670
Ref: #/stldict12670
Ref: 3312756
Ref: !/stldict12756
Ref: 3413130
Ref: null/stldict13130
Ref: 3513208
Ref: member/stldict13208
Ref: 1c13288
Ref: members/stldict13288
Ref: 3613312
Ref: list/stldict13312
Ref: 3713633
Ref: stream/stldict13633
Ref: 3813875
Ref: tuple/stldict13875
Ref: 3913897
Ref: vector/stldict13897
Ref: 1d13967
Ref: keys/stldict13967
Ref: 1e14037
Ref: vals/stldict14037
Ref: 2714460
Ref: insert/stldict14460
Ref: 3a14485
Ref: insert/stldict214485
Ref: 3b14515
Ref: update/stldict14515
Ref: 2814911
Ref: delete/stldict14911
Ref: 3c14936
Ref: delete/stldict214936
Ref: 3d15207
Ref: clear/stldict15207
Node: Comparisons15315
Ref: comparisons15432
Ref: 1615432
Node: Set-Like Operations17153
Ref: set-like operations17274
Ref: 1717274
Ref: set-like-operations17274
Ref: 3e17569
Ref: +/stldict17569
Ref: 3f17644
Ref: -/stldict17644
Ref: 4017731
Ref: */stldict17731
Node: List-Like Operations17826
Ref: list-like operations17945
Ref: 1817945
Ref: list-like-operations17945
Node: Iterators18600
Ref: iterators18720
Ref: 1918720
Ref: 4219713
Ref: stldict begin19713
Ref: 4319744
Ref: stldict end19744
Ref: 4419995
Ref: stldict find19995
Ref: 4621241
Ref: stldict dict21241
Ref: 4721321
Ref: stldict endp21321
Ref: 4821459
Ref: stldict next21459
Ref: 4921829
Ref: stldict get21829
Ref: 4a22050
Ref: stldict put22050
Ref: 4522373
Ref: stldict erase22373
Ref: 4b22587
Ref: ==/stldict_iterator22587
Ref: 4c22608
Ref: ~=/stldict_iterator22608
Node: Low-Level Operations23033
Ref: low-level operations23148
Ref: 1a23148
Ref: low-level-operations23148
Node: Pretty-Printing23778
Ref: pretty-printing23875
Ref: 1323875
Ref: 4d24346
Ref: hashdict_symbol24346
Ref: 4e24378
Ref: hashmdict_symbol24378
Ref: 4f24411
Ref: orddict_symbol24411
Ref: 5024442
Ref: ordmdict_symbol24442
Node: Examples25164
Ref: examples25251
Ref: 4125251
Node: Index28665
Ref: index28733

End Tag Table


Local Variables:
coding: utf-8
End:
