This is pure-stlvec.info, produced by makeinfo version 4.13 from
pure-stlvec.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-stlvec: (pure-stlvec.info).    pure-stlvec
END-INFO-DIR-ENTRY


File: pure-stlvec.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-stlvec
***********

  Version 0.1, September 22, 2011

    Peter Summerland <<p.summerland@gmail.com>> 
  Pure's interface to C++ vectors, specialized to hold pointers to
arbitrary Pure expressions, and the C++ Standard Template Library
algorithms that act on them.

* Menu:

* Copying::
* Installation::
* Overview::
* Error Handling::
* Basic Operations::
* STL Nonmodifying Algorithms::
* STL Modifying Algorithms::
* STL Sort Algorithms::
* STL Merge Algorithms::
* STL Heap Algorithms::
* Min/Max STL Algorithms::
* STL Numeric Algorithms::
* Trace Mode::
* Index::

 --- The Detailed Node Listing ---

Overview

* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Documentation::
* Parameter Names::

Error Handling

* Exception Symbols::
* Examples::

Basic Operations

* Imports::
* Data Structure::
* Types::
* Support for Copy-On-Write Semantics::
* Operations::
* Convenience Functions::
* Examples: Examples<2>.

STL Nonmodifying Algorithms

* Imports: Imports<2>.
* Operations: Operations<2>.
* Examples: Examples<3>.

STL Modifying Algorithms

* Imports: Imports<3>.
* Operations: Operations<3>.
* Examples: Examples<4>.

STL Sort Algorithms

* Imports: Imports<4>.
* Operations: Operations<4>.
* Examples: Examples<5>.

STL Merge Algorithms

* Imports: Imports<5>.
* Operations: Operations<5>.
* Examples: Examples<6>.

STL Heap Algorithms

* Imports: Imports<6>.
* Operations: Operations<6>.
* Examples: Examples<7>.

Min/Max STL Algorithms

* Imports: Imports<7>.
* Operations: Operations<7>.
* Examples: Examples<8>.

STL Numeric Algorithms

* Imports: Imports<8>.
* Operations: Operations<8>.
* Examples: Examples<9>.


File: pure-stlvec.info,  Node: Copying,  Next: Installation,  Prev: Top,  Up: Top

1 Copying
*********

    Copyright (c) 2011 by Peter Summerland <<p.summerland@gmail.com>>. 
All rights reserved.

  pure-stlvec is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  pure-stlvec is distributed under a BSD-style license, see the COPYING
file for details.


File: pure-stlvec.info,  Node: Installation,  Next: Overview,  Prev: Copying,  Up: Top

2 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-stlvec-0.1.tar.gz>.

  To install pure-stlvec (on Linux), extract the source code (e.g., tar
-xzf pure-stlvec-0.1.tar.gz), cd to the pure-stlvec-0.1 directory, and
run `make'. After this you can (and should) also run `make test' to run
a few unit tests to make sure that pure-stlvec works properly on your
system. If `make test' works, run `sudo make install' to install
pure-stlvec on your system.  `make' tries to guess your Pure
installation directory and platform-specific setup. If it gets this
wrong, you can set some variables manually. In particular, `make
install prefix=/usr' sets the installation prefix. Please see the
Makefile for details.


File: pure-stlvec.info,  Node: Overview,  Next: Error Handling,  Prev: Installation,  Up: Top

3 Overview
**********

The C++ Standard Template Library ("STL") is a library of generic
containers (data structures designed for storing other objects) and a
rich set of generic algorithms that operate on them. pure-stlvec
provides an interface to one of its most useful containers, "vector",
adopted to hold pointers to Pure expressions. The interface provides
Pure programmers with a mutable container "stlvec", that, like the
STL's vector, holds a sequence of objects that can be accessed in
constant time according to their position in the sequence.

* Menu:

* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Documentation::
* Parameter Names::


File: pure-stlvec.info,  Node: Modules,  Next: Simple Examples,  Up: Overview

3.1 Modules
===========

The usual operations for creating, accessing and modifying stlvecs are
provided by the stlvec module. The operations are similar in name and
function to those provided by the Pure Library for other containers. As
is the case for their Pure Library counterparts, these operations are
in the global namespace.

  In addition to the stlvec module, pure-stlvec provides a group of
modules, stlvec::modifying, stlvec::nonmodifying, stlvec::sort,
stlvec::merge, stlvec::heap, stlvec::minmax and stlvec::numeric, that
are straight wrappers the STL algorithms (specialized to work with STL
vectors of pointers to Pure expressions). This grouping of the STL
algorithms follows that found at
http://www.cplusplus.com/reference/algorithm/. This web page contains a
table that summarizes of all of the algorithms in one place.

  pure-stlvec provides an "umbrella" module, stlvec::algorithms, that
pulls in all of the STL algorithm interface modules in one go. The STL
algorithm wrapper functions reside in the stl namespace and have the
same names as their counterparts in the STL.


File: pure-stlvec.info,  Node: Simple Examples,  Next: Members and Sequences of Members,  Prev: Modules,  Up: Overview

3.2 Simple Examples
===================

Here are some examples that use the basic operations provided by the
stlvec module.

    > using stlvec;

    > let sv1 = stlvec (0..4); members sv1;
    [0,1,2,3,4]

    > insert (sv1,stl::svend) (5..7); members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,3,4,5,6,7]

    > sv1!3;
    3

    > sv1!![2,4,6];
    [2,4,6]

    > update sv1 3 33; members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,33,4,5,6,7]

    > stlvec_erase (sv1,2,5); members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,5,6,7]

    > insert (sv1,2) [2,3,4];  members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,3,4,5,6,7]

    > let pure_vector = stlvec_vector (sv1,1,5); pure_vector;
    {1,2,3,4}

    > stlvec pure_vector;
    STLVEC #<pointer 0x9145a38>

    > members ans;
    [1,2,3,4]

     > map (+10) sv1;
    [10,11,12,13,14,15,16,17]

    > map (+10) (sv1,2,5);
    [12,13,14]

    > foldl (+) 0 sv1;
    28

    > [x+10 | x = sv1; x mod 2];
    [11,13,15,17]

    > {x+10 | x = (sv1,2,6); x mod 2};
    {13,15}

Here are some examples that use STL algorithms.

    > using stlvec::algorithms;

    > stl::reverse (sv1,2,6); members sv1;
    ()
    [0,1,5,4,3,2,6,7]

    > stl::stable_sort sv1 (>); members sv1;
    ()
    [7,6,5,4,3,2,1,0]

    > stl::random_shuffle sv1; members sv1;
    ()
    [1,3,5,4,0,7,6,2]

    > stl::partition sv1 (<3); members (sv1,0,ans); members sv1;
    3
    [1,2,0]
    [1,2,0,4,5,7,6,3]

    > stl::transform sv1 (sv1,0) (*2); members sv1;
    -1
    [2,4,0,8,10,14,12,6]

    > let sv2 = emptystlvec;

    > stl::transform sv1 (sv2,stl::svback) (div 2); members sv2;
    -1
    [1,2,0,4,5,7,6,3]

Many more examples can be found in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Members and Sequences of Members,  Next: STL Iterators and Value Semantics,  Prev: Simple Examples,  Up: Overview

3.3 Members and Sequences of Members
====================================

Throughout the documentation for pure-stlvec, the member of a stlvec
that is at the nth position in the sequence of expressions stored in
the stlvec is referred to as its nth member or nth element. The nth
member of a stlvec, sv, is sometimes denoted by sv!n.  The sequence of
members of sv starting at position i up to but not including j is
denoted by sv[i,j). There is a "past-the-end" symbol, stl::svend, that
denotes the position after that occupied by the last member contained
by a stlvec.

  For example, if sv contains the sequence "a", "b", "c" "d" and "e",
sv!0 is "a", sv[1,3) is the sequence consisting of "b" followed by "c"
and v[3,stl::svend) denotes the sequence consisting of "d" followed by
"e".


File: pure-stlvec.info,  Node: STL Iterators and Value Semantics,  Next: Iterator Tuples,  Prev: Members and Sequences of Members,  Up: Overview

3.4 STL Iterators and Value Semantics
=====================================

In C++ a programmer accesses a STL container's elements by means of
"iterators", which can be thought of as pointers to the container's
elements. A single iterator can be used to access a specific element,
and a pair of iterators can be used to access a "range" of elements. By
convention, such a range includes the member pointed to by the first
iterator and all succeeding members up to but not including the member
pointed to by the second iterator. Each container has a past-the-end
iterator that can be used to specifiy ranges that include the
container's last member.

  In the case of vectors there is an obvious correspondence between an
iterator that points to an element and the element's position (starting
at zero) in the vector.  pure-stlvec uses this correspondence to
designate a stlvec's members in a way that makes it relatively easy to
see how pure-stlvec's functions are acting on the stlvec's underlying
STL vector by referencing the STL's documentation. Thus, if sv is a
stlvec, and j is an int, "update sv j x" uses the STL to replace the
element pointed to by the iterator for position j of sv's underlying
STL vector. If, in addition, k is an int, stl::sort (sv,j,k) (<) uses
the STL to sort the elements in the range designated by the "jth" and
"kth" iterators for sv's underlying STL vector. This range, written as
sv[j,k), is the subsequence of sv that begins with the element at
position j and ends with the element at position (k-1).

  Besides iterators, another cornerstone of the STL is its "value
semantics", i.e., all of the STL containers are mutable and if a
container is copied, all of its elements are copied. pure-stlvec deals
with the STL's value semantics by introducing mutable and nonmutable
stlvecs, and by storing smart pointers to objects (which have cheap
copies) rather than the actual objects.


File: pure-stlvec.info,  Node: Iterator Tuples,  Next: Predefined Iterator Tuple Indexes,  Prev: STL Iterators and Value Semantics,  Up: Overview

3.5 Iterator Tuples
===================

As mentioned in the previous section, in C++ ranges are specified by a
pair of STL iterators.

  In pure-stlvec ranges of elements in a stlvec are specified by
"iterator tuples" rather than, say, actual pointers to STL iterators.
Iterator tuples consist of the name of a stlvec followed by one of more
ints that indicate positions (starting from zero) of the stlvec's
elements.

  To illustrate how iterator tuples are used, consider the STL
stable_sort function, which sorts objects in the range [first, last) in
the order imposed by comp. Its C++ signature looks like this:

     void stable_sort ( RandomAccessIterator first,
     RandomAccessIterator last, Compare comp )

  The corresponding pure-stlvec function, from the stlvec::sort module,
looks like this:

     stable_sort (msv, first, last) comp

  where msv is a mutable stlvec, and first and last are ints. The first
thing that the Pure stable_sort does is create a pair of C++ iterators
that point to the elements in msv's underlying STL vector that occupy
the positions designated by first and last.  Next it wraps the Pure
comp function in a C++ function object that, along with the two
iterators, is passed to the C++ stable_sort function.

  For convenience, (sv,stl::svbeg, stl::svend) can be written simply as
sv. Thus, if first were stl::svbeg (or 0), and last were stl::svend (or
#msv, the number of elements in msv), the last Pure call could be
written:

     stable_sort msv comp

  It should be noted that often the STL library provides a default
version of functions, which like stable_sort, use a comparator or other
callback function provided by the caller. E.g., the C++ stable_sort has
a default version that assumes the "<" operator can be used on the
elements held by the container in question:

     void stable_sort ( RandomAccessIterator first,
     RandomAccessIterator last)

  The corresponding functions provided by the pure-stlvec modules
rarely, if ever, supply a default version. A typical example is
stlvec::sort's stable_sort which must be called with a comparator
callback function:

     stable_sort msv (<);

  Note also that the comparator (e.g., (<)), or other function being
passed to a pure-stlvec algorithm wrapper is almost always the last
parameter. This is the opposite of what is required for similar Pure
functions, but is consistent with the STL calling conventions.


File: pure-stlvec.info,  Node: Predefined Iterator Tuple Indexes,  Next: Back Insert Iterators,  Prev: Iterator Tuples,  Up: Overview

3.6 Predefined Iterator Tuple Indexes
=====================================

The following integer constants are defined in the stl namespace for use
in iterator tuples.

 -- constant: stl::svbeg = 0
 -- constant: stl::svend = -1
 -- constant: stl::svback = -2

  `svend' corresponds to STL's past-end iterator for STL vectors. It
makes it possible to specify ranges that include the last element of an
stlvec. I.e., the iterator tuple (sv,stl::svbeg,stl::svend) would
specify sv[0,n), where n is the number of elements in sv. In order to
understand the purpose of `svback', it is necessary to understand a bit
about STL's "back insert iterators."


File: pure-stlvec.info,  Node: Back Insert Iterators,  Next: Documentation,  Prev: Predefined Iterator Tuple Indexes,  Up: Overview

3.7 Back Insert Iterators
=========================

Many of the STL algorithms insert members into a target range
designated by an iterator that points to the first member of the target
range. Consistent with raw C usage, it is ok to copy over existing
elements the target stlvec. E.g.,:

    > using stlvec::modifying;

    > let v1 = stlvec (0..2);

    > let v2 = stlvec ("a".."g");

    > stl::copy v1 (v2,2) $$ members v2;
    ["a","b",0,1,2,"f","g"]

This is great for C++ programmers, but for Pure programmers it is almost
always preferable to append the copied items to the end of a target
stlvec, rather than overwriting all or part or part of it. This can be
accomplished using stl::svback. E.g.,:

    > stl::copy v1 (v2,stl::svback) $$ members v2;
    ["a","b",0,1,2,"f","g",0,1,2]

In short, when a pure-stlvec function detects "stl::svback" in a target
iterator tuple, it constructs a STL "back inserter iterator" and passes
it on to the corresponding wrapped STL function.


File: pure-stlvec.info,  Node: Documentation,  Next: Parameter Names,  Prev: Back Insert Iterators,  Up: Overview

3.8 Documentation
=================

The documentation of the functions provided by the stlvec module are
reasonably complete.  In contrast, the descriptions of functions
provided by the STL algorithm modules are purposely simplified (and may
not, therefore, be technically accurate). This reflects that fact that
the functions provided by pure-stlvec have an obvious correspondence to
the functions provided by the STL, and the STL is extremely well
documented. Furthermore, using the Pure interpreter, it is very easy to
simply play around with with any of the pure-stlvec functions if there
are doubts, especially with respect to "corner cases."  Often this
leads to a deeper understanding compared to reading a precise technical
description.

  A good book on the STL is STL Tutorial and Reference Guide, Second
Edition, by David R. Musser, Gillmer J. Derge and Atul Saini. A summary
of all of the STL algorithms can be found at
<http://www.cplusplus.com/reference/stl/>.


File: pure-stlvec.info,  Node: Parameter Names,  Prev: Documentation,  Up: Overview

3.9 Parameter Names
===================

In the descriptions of functions that follow, parameter names used in
function descriptions represent specific types of Pure objects:

sv
     stlvec (mutable or immutable)

csv
     const (i.e., immutable) stlvec

msv
     mutable stlvec

x
     an arbitrary Pure expression

xs
     a list of arbitrary Pure expressions

count, sz, n
     whole numbers to indicate a number of elements, size of a vector,
     etc

i,j
     whole numbers used to designate indexes into a stlvec

f,m,l
     whole numbers (or stl::beg or stl::svend) designating the "first",
     "middle" or "last" iterators in a stlvec iterator tuple

p
     a whole number (or other iterator constant such as stl::svend or
     stl::svback) used in a two element iterator tuple (e.g., (sv,p))

(sv,p)
     an iterator tuple that will be mapped to an iterator that points
     to the pth position of sv's underlying STL vector, v, (or to a
     back iterator on v if p is stl::svback)

(sv,f,l)
     an iterator tuple that will be mapped to the pair of iterators
     that are designated by (sv,f) and (sv,l)

(sv,f,m,l)
     an iterator tuple that will be mapped to the iterators that are
     designated by (sv,f), (sv,m) and (sv,l)

sv[f,l)
     the range of members beginning with that at (sv,f) up to but not
     including that at (con,l)

comp
     a function that accepts two objects and returns true if the first
     argument is less than the second (in the strict weak ordering
     defined by comp), and false otherwise

unary_pred
     a function that accepts one object and returns true or false

bin_pred
     a function that accepts two objects and returns true or false

unary_fun
     a function that accepts one objects and returns another

bin_fun
     a function that accepts two objects and returns another

gen_fun
     a function of one parameter that produces a sequence of objects,
     one for each call

  For readability, and to correspond with the STL documentation, the
words "first", "middle", and "last", or variants such as "first1" are
often used instead of f,m,l.


File: pure-stlvec.info,  Node: Error Handling,  Next: Basic Operations,  Prev: Overview,  Up: Top

4 Error Handling
****************

The functions provided this module handle errors by throwing exceptions.

* Menu:

* Exception Symbols::
* Examples::


File: pure-stlvec.info,  Node: Exception Symbols,  Next: Examples,  Up: Error Handling

4.1 Exception Symbols
=====================

 -- constructor: bad_argument
     This exception is thrown when a function is passed an unexpected
     value. A subtle error to watch for is a malformed iterator tuple
     (e.g., one with the wrong number of elements).

 -- constructor: bad_function
     This exception is thrown when a purported Pure call-back function
     is not even callable.

 -- constructor: failed_cond
     This exception is thrown when a Pure call-back predicate returns a
     value that is not an int.

 -- constructor: out_of_bounds
     This exception is thrown if the specified index is out of bounds.

 -- constructor: range_overflow
     This exception is thrown by functions that write over part of a
     target stlvec (e.g., copy) when the target range too small to
     accommodate the result.

 -- constructor: range_overlap
     This exception is thrown by algorithm functions that write over
     part of a target stlvec when the target and source ranges overlap
     in a way that is not allowed.

  In addition, any exception thrown by a Pure callback function passed
to a pure-stlvec function will be caught and be rethrown by the
pure-stlvec function.


File: pure-stlvec.info,  Node: Examples,  Prev: Exception Symbols,  Up: Error Handling

4.2 Examples
============

    > using stlvec, stlvec::modifying;

    > let sv1 = stlvec (0..4); members sv1;
    [0,1,2,3,4]

    > let sv2 = stlvec ("a".."e"); members sv2;
    ["a","b","c","d","e"]

    > sv1!10;
    <stdin>, line 25: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,10);
    <stdin>, line 26: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,2,3); // sb (sv2,pos)
    <stdin>, line 22: unhandled exception 'bad_argument' ...

    > stl::copy sv1 (sv2,2);
    <stdin>, line 23: unhandled exception 'range_overflow' ...

    > stl::copy sv2 (sv2,2);
    <stdin>, line 24: unhandled exception 'range_overlap' ...

    > stl::copy (sv1,1,3) (sv2,0); members sv2; // ok
    2
    [1,2,"c","d","e"]

    > stl::sort sv2 (>); // apples and oranges
    <stdin>, line 31: unhandled exception 'failed_cond'

    > listmap (\x->throw DOA) sv1; // callback function throws exception
    <stdin>, line 34: unhandled exception 'DOA' ...



File: pure-stlvec.info,  Node: Basic Operations,  Next: STL Nonmodifying Algorithms,  Prev: Error Handling,  Up: Top

5 Basic Operations
******************

The stlvec module provides functions for creating, accessing and
modifying stlvecs. They are all in the global namespace.

* Menu:

* Imports::
* Data Structure::
* Types::
* Support for Copy-On-Write Semantics::
* Operations::
* Convenience Functions::
* Examples: Examples<2>.


File: pure-stlvec.info,  Node: Imports,  Next: Data Structure,  Up: Basic Operations

5.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec;



File: pure-stlvec.info,  Node: Data Structure,  Next: Types,  Prev: Imports,  Up: Basic Operations

5.2 Data Structure
==================

Currently, stlvecs are of the form (STLVEC x) or (CONST_STLVEC x),
where x is a pointer to the underlying STL vector. E.g.:

    > let v1 = stlvec (0..3); v1;
    STLVEC #<pointer 0x915c8e0>

    > members v1;
    [0,1,2,3]

    > let v2 = stlvec_const $ stlvec (0..3); v2;
    CONST_STLVEC #<pointer 0x8c1dbf0>

This representation may change in the future, and must not be relied
upon by client modules. In particular, one must never attempt to use the
embedded pointer directly.

  Functions that modify a stlvec will simply fail unless the stlvec is
mutable:

    > update v2 0 100;
    update (CONST_STLVEC #<pointer 0x9f07690>) 0 100



File: pure-stlvec.info,  Node: Types,  Next: Support for Copy-On-Write Semantics,  Prev: Data Structure,  Up: Basic Operations

5.3 Types
=========

Three type tags are provided for stlvecs:

 -- type: mutable_stlvec
     The type for a mutable stlvec. The stlvec must have been
     constructed with STLVEC.

 -- type: const_stlvec
     The type for an immutable stlvec. The stlvec must have been
     constructed with CONST_STLVEC.

 -- type: stlvec
     The type for a stlvec, mutable or immutable. The stvec can be
     constructed with STLVEC or CONST_STLVEC.

  In addition there are three type tags for stlvec iterator tuples:

 -- type: mutable_svit
          The type for an iterator tuple whose underlying stlvec is
          mutable.

      -- type: const_svit
          The type for an iterator tuple whose underlying stlvec is
          immutable.

 -- type: svit
     The type for an iterator tuple. The underlying stlvec can be
     mutable or immutable.


File: pure-stlvec.info,  Node: Support for Copy-On-Write Semantics,  Next: Operations,  Prev: Types,  Up: Basic Operations

5.4 Support for Copy-On-Write Semantics
=======================================

The functions that create new stlvecs (emptystlvec, stlvec, and
mkstlvec) all return mutable stlvecs. For those that prefer immutable
data structures, stlvecs can be converted to immutable stlvecs (usually
after they have been created and modified within a function) by the
`stlvec_const' function. This function converts a mutable stlvec to an
immutable stlvec without changing the underlying STL vector.

  Using a copy-on-write strategy it is possible to use stlvecs in a
manner that is consistent with functional programming.  Typically, a
function that "updates" a stlvec passed to it as an argument will copy
the input stlvec to a new locally scoped mutable stlvec, modify the new
stlvec and use stlvec_const to make the new stlvec immutable before it
is returned. It should be noted that several of the STL algorithms have
"copy" versions which place their results directly into a new stlvec,
which can eliminate the need to copy the input stlvec. E.g.:

    > let sv1 = stlvec ("a".."e");

    > let sv2 = emptystlvec;

    > stl::reverse_copy sv1 (sv2,stl::svback) $$ members sv2;
    ["e","d","c","b","a"]

Without reverse_copy, one have to copy sv1 into sv2 and then reverse
sv2.


File: pure-stlvec.info,  Node: Operations,  Next: Convenience Functions,  Prev: Support for Copy-On-Write Semantics,  Up: Basic Operations

5.5 Operations
==============

When reading the function descriptions that follow, please bear in mind
that whenever a function is passed an iterator tuple of the form
(sv,first, last), first and last can be dropped, leaving (sv), or
simply sv. The function will treat the "unary" iterator tuple (sv) as
(sv, stl::svbeg, stl::svend). You might notice that some of the
function names are prefixed with "*note stlvec: 27.". These denote
functions that do not have a corresponding function in the Pure
Standard Library. Thus, map does not have a "*note stlvec: 27." prefix,
while stlvec_reserve does. This was done primarily to avoid polluting
the global namespace with new function names.

 -- Function: emptystlvec
     return an empty stlvec

 -- Function: stlvec source
     create a new stlvec that contains the elements of source. source
     can be a stlvec, an iterator tuple(sv,first,last), a list or a
     vector (i.e., a matrix consisting of a single row or column)

 -- Function: mkstlvec x count
     create a new stlvec consisting of count x's.

 -- Function: stlvec_const sv
     create an immutable stlvec that shares the same underlying STL
     vector with sv

 -- Function: stlvec_vector (sv,first,last)
     create a Pure vector that contains the members of sv[first,last)

 -- Function: # sv
     return the number of elements in sv.

  Note that # applied to an iterator tuple like (sv,b,e) will just
return the number of elements in the tuple. Use stlvec_bounds if you
need to know the number of elements in the range denoted by a tuple.

 -- Function: stlvec_bounds (sv,first,last)
     throws out-of-bounds if first or last is out of bounds. returns
     the tuple (sv,first,last) except that if first is stl::begin it
     will be replaced by 0 and if last is stl::svend it will be
     replaced by the number of elements in sv.

 -- Function: stlvec_reserve msv count
     modify the underlying STL vector to have at least count slots,
     useful for packing data into a fixed size vector and possibly to
     speed up the addition of new members

 -- Function: stlvec_capacity sv
     return the total amount of slots held by the underlying STL vector

 -- Function: null sv
     test whether sv is empty

 -- Function: sv ! i
     return the ith member of sv

  Note that !k applied to an iterator tuple like (sv,b,e) will just
return the kth element of the tuple. In addition, in stlvec, integers
used to denote postions (as in !k) or in iterators, _always_, are
relative to the beginning of the underlying vector. So it makes no
sense to apply ! to an iterator tuple.

 -- Function: first sv
 -- Function: last sv
     first and last member of sv

 -- Function: members (sv, first, last)
     return a list of values stored in sv[first,last)

 -- Function: list sv
     return a list of values stored in sv.

  Note that if list is applied to an iterator tuple, it will return a
list holding the elements of the tuple not the elements of the range
denoted by the tuple. It is recommended that you use members instead.

 -- Function: update msv i x
     replace the ith member of msv by x and return msv

 -- Function: append sv x
     append x to the end of sv

 -- Function: insert (msv,p) xs
 -- Function: insert (msv,p) (sv,first,last)
     insert members of the list xs or the range sv[first, last) into
     msv, all preceding the pth member of msv. Members are shifted to
     make room for the inserted members

 -- Function: rmfirst msv
 -- Function: rmlast msv
     remove the first or last member from msv

 -- Function: stlvec_erase (msv,first,last)
 -- Function: stlvec_erase (msv,p)
 -- Function: stlvec_erase msv
     remove msv[first,last) from msv, remove msv!p from msv, or make msv
     empty. Members are shifted to occupy vacated slots

 -- Function: stlvec_equal comp (sv1, first1, last1) (sv2, first2,
          last2)
     returns true if comp returns true for all corresponding members of
     sv1[first1, last1) and sv1[first1, last1)

 -- Function: sv1 == sv2
 -- Function: sv1 ~= sv2
     (x == y) is the same as stlvec_equal x y and x ~= y is simply
     ~(stlvec_equal x y)

  Note that `==' and `~==' are not defined for iterator tuples (the
rules would never be executed because == is defined on tuples in the
Prelude)


File: pure-stlvec.info,  Node: Convenience Functions,  Next: Examples<2>,  Prev: Operations,  Up: Basic Operations

5.6 Convenience Functions
=========================

The stlvec module provides convenience functions that apply map, catmap,
foldl, etc, to directly access Pure expressions stored in a stlvec.

 -- Function: map unary_fun (sv, first, last)
     one pass equivalent of map unary_fun $ members (sv, first, last)

 -- Function: listmap unary_fun (sv, first, last)
     same as map, used in list comprehensions

 -- Function: catmap unary_fun (sv, first, last)
     one pass equivalent of catmap unary_fun $ members (sv, first, last)

 -- Function: do unary_fun (sv, first, last)
     one pass equivalent of do unary_fun $ members (sv, first, last)

 -- Function: foldl bin_fun x (sv, first, last)
     one pass equivalent of foldl bin_fun x $ members (sv, first, last)

 -- Function: foldl1 bin_fun (sv, first, last)
     one pass equivalent of foldl1 bin_fun $ members (sv, first, last)

 -- Function: filter unary_pred (sv, first, last)
     one pass equivalent of filter unary_pred $ members (sv, first,
     last)

  The following four functions map (or catmap) stlvecs onto row and col
matrixes, primarily for use in matrix comprehensions.

 -- Function: rowmap unary_fun (sv, first, last)

 -- Function: rowcatmap unary_fun (sv, first, last)

 -- Function: colmap unary_fun (sv, first, last)

 -- Function: colcatmap unary_fun (sv, first, last)

  Please note that "stlvec to stlvec" functions are provided by the
pure-stl algorithm modules. Thus, for example, the stlvec module does
not provide a function that maps one stlvec onto a new stlvec. That
functionality, and more, is provided by stl::transform, which can be
found in the stlvec::modifying module.


File: pure-stlvec.info,  Node: Examples<2>,  Prev: Convenience Functions,  Up: Basic Operations

5.7 Examples
============

See ut_stvec in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Nonmodifying Algorithms,  Next: STL Modifying Algorithms,  Prev: Basic Operations,  Up: Top

6 STL Nonmodifying Algorithms
*****************************

The stlvec::nonmodifying module provides an interface to the STL's
non-modifying sequence operations.

* Menu:

* Imports: Imports<2>.
* Operations: Operations<2>.
* Examples: Examples<3>.


File: pure-stlvec.info,  Node: Imports<2>,  Next: Operations<2>,  Up: STL Nonmodifying Algorithms

6.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::nonmodifying;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<2>,  Next: Examples<3>,  Prev: Imports<2>,  Up: STL Nonmodifying Algorithms

6.2 Operations
==============

 -- Function: stl::for_each (sv, first, last) unary_fun
     applies unary_fun to each of the elements in sv[first,last)

 -- Function: stl::find (sv, first, last) x
     returns the position of the first element in sv[first,last) for
     which (==x) is true (or stl::svend if not found)

 -- Function: stl::find_if (sv, first, last) unary_pred
     returns the position of the first element in sv[first,last) for
     which unary_pred is true (or stl::svend if not found)

 -- Function: stl::find_first_of (sv1, first1, last1) (sv2, first2,
          last2) bin_pred
     Returns the position of the first element, x, in sv1[first1,last1)
     for which there exists y in sv2[first2,last2) and (bin_pred x y)
     is true (or stl::svend if no such x exists).

 -- Function: stl::adjacent_find (sv, first, last) bin_pred
     search sv[first,last) for the first occurrence of two consecutive
     elements (x,y) for which (bin_pred x y) is true. Returns the
     position of x, if found, or stl::svend if not found)

 -- Function: stl::count (sv, first, last) x
     returns the number of elements in the range sv[first,last) for
     which (x==) is true

 -- Function: stl::count_if (sv, first, last) unary_pred
     returns the number of elements in the range sv[first,last) for
     which unary_pred is true

 -- Function: stl::mismatch (sv1, first1, last1) (sv2, first2) bin_pred
     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1 until it
     finds i and j such that bin_pred (sv1!i) (sv2!j) is false and
     returns (i,j). If bin_pred is true for all of the pairs of
     elements, i will be stl::svend and j will be first2 + n (or
     stl::svend)

 -- Function: stl::equal (sv1, first1, last1) (sv2, first2) bin_pred
     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1, and returns
     true if bin_pred is true for each pair

 -- Function: stl::search (sv1, first1, last1) (sv2, first2) bin_pred
     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the first occurrence of the sequence defined
     by sv2[first2,last2), and returns the position in sv1 of its first
     element (or stl::svend if not found)

 -- Function: stl::search_n (sv, first, last) count x bin_pred
     using bin_pred to determine equality of the elements, searches
     sv[first,last) for a sequence of count elements that equal x. If
     such a sequence is found, it returns the position of the first of
     its elements, otherwise it returns stl::svend

 -- Function: stl::find_end (sv1, first1, last1) (sv2, first2, last2)
          bin_pred
     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the last occurrence of sv2[first2,last2).
     Returns the position of the first element in sv1 of the occurrence
     (or stl::svend if not found).


File: pure-stlvec.info,  Node: Examples<3>,  Prev: Operations<2>,  Up: STL Nonmodifying Algorithms

6.3 Examples
============

See ut_nonmodifying.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Modifying Algorithms,  Next: STL Sort Algorithms,  Prev: STL Nonmodifying Algorithms,  Up: Top

7 STL Modifying Algorithms
**************************

The stlvec::modifying module provides an interface to the STL's
modifying algorithms.

* Menu:

* Imports: Imports<3>.
* Operations: Operations<3>.
* Examples: Examples<4>.


File: pure-stlvec.info,  Node: Imports<3>,  Next: Operations<3>,  Up: STL Modifying Algorithms

7.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::modifying;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<3>,  Next: Examples<4>,  Prev: Imports<3>,  Up: STL Modifying Algorithms

7.2 Operations
==============

 -- Function: stl::copy (sv, first1, last1) (msv, first2)
     copies the elements in sv[first1,last1) into the range whose first
     element is (msv,first2)

 -- Function: stl::copy_backward (sv,first1,last1) (msv,last2)
     copies the elements in sv[first1,last1), moving backward from
     (last1), into the range msv[first2,last2) where first2 is last2
     minus the number of elements in sv[first1,last1)

 -- Function: stl::swap_ranges (sv,first,last) (msv, p)
     exchanges the elements in sv[first, last) with those in msv[p,
     p+n) where n is last - first

 -- Function: stl::transform (sv,first,last) (msv, p) unary_fun
     applies unary_fun to the elements of sv[first,last) and places the
     resulting sequence in msv[p, p+n) where n is last - first. If sv
     is mutable, msv and sv can be the same stlvec. Returns (msv,p+n)

 -- Function: stl::transform_2 (sv1,first1,last1) (sv2,first2) (msv, p)
          bin_fun
     applies bin_fun to corresponding pairs of elements of
     sv1[first1,last1) sv2[first2,n) and and places the resulting
     sequence in msv[p, p+n) where n is last1 - first1. Returns
     (msv,p+n)

 -- Function: stl::replace (msv,first,last) x y
     same as *note replace_if: 66. (msv,first,last) (x==) y

 -- Function: stl::replace_if (msv,first,last) unary_pred x
     replace the elements of msv[first,last) that satistfy unary_pred
     with x

 -- Function: stl::replace_copy (sv,first,last) (msv,p) x y
     same as *note replace: 65. (msv,first,last) x y except that the
     modified sequence is placed in msv[p,p+last-first)

 -- Function: stl::replace_copy_if (sv,first,last) (msv,p) unary_pred x
     same as *note replace_if: 66. except that the modified sequence is
     placed in msv[p,p+last-first)

 -- Function: stl::fill (msv,first,last) x
     replace all elements in msv[first,last) with x

 -- Function: stl::fill_n (msv,first) n x
     replace the elements of msv[first,first+n) with x

 -- Function: stl::generate (msv,first,last) gen_fun
     replace the elements in msv[first,last) with the sequence
     generated by successive calls to gen_fun (), E.g.,:

         > let count = ref 0;

     > g _ = n when n = get count + 1; put count n; end;

     > let sv = mkstlvec 0 10;

     > stl::generate sv g $$ members sv; [1,2,3,4,5,6,7,8,9,10]

 -- Function: stl::generate_n (msv,first) n gen_fun
     replace all elements in msv[first,first+n) with the sequence
     generated by successive calls to gen_fen

 -- Function: stl::remove (msv,first,last) x
     same as *note remove_if: 6e. (msv,first,last) (==x).

 -- Function: stl::remove_if (msv,first,last) unary_pred
     remove elements in msv[first,last) that satisfy unary_pred. If n
     elements do not satisfy unary_pred, they are moved to
     msv[first,first+n), preserving their relative order. The content
     of msv[first+n,svend) is undefined. Returns first+n, or stl::svend
     if first+n is greater than the number of elements in msv

 -- Function: stl::remove_copy (sv,first,last) (msv,first) x
     same as *note remove: 6d. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::remove_copy_if (sv,first,last) (msv,first) unary_pred
     same as *note remove_if: 6e. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::unique (msv,first,last) bin_pred
     eliminates consecutive duplicates from sv[first,last), using
     bin_pred to test for equality. The purged sequence is moved to
     sv[first,first+n) preserving their relative order, where n is the
     size of the purged sequence. Returns first+n or stl::svend if
     first+n is greater than the number of elements in msv

 -- Function: stl::unique_copy (sv,first,last) (msv,first) bin_pred
     same as *note unique: 71. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::reverse (msv,first,last)
     Reverses the order of the elements in sv[first,last).

 -- Function: stl::reverse_copy (sv,first,last) (msv,first)
     same as *note reverse: 73. except that the reversed sequence is
     copied to (msv,first) and sv[first,last) is not changed.

 -- Function: stl::rotate (msv,first,middle,last)
     rotates the elements of msv[first,middle,last] so that middle
     becomes the first element of msv[first,last].

 -- Function: stl::rotate_copy (msv,first,middle,last) (msv,first)
     same as rotate except that the rotated sequence is copied to
     (msv,first) and sv[first,last) is not changed.

 -- Function: stl::random_shuffle (msv,first,last)
     randomly reorders the elements in msv[first,last)

 -- Function: stl::partition (msv,first,last) unary_pred
     places the elements in msv[first,last) that satisfy unary_pred
     before those that don't. Returns middle, where msv [first,middle)
     contains all of the elements that satisfy unary_pre, and msv
     [middle, last) contains those that do not

 -- Function: stl::stable_partition (msv,first,last) unary_pred
     same as partition except that the relative positions of the
     elements in each group are preserved


File: pure-stlvec.info,  Node: Examples<4>,  Prev: Operations<3>,  Up: STL Modifying Algorithms

7.3 Examples
============

See ut_modifying.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Sort Algorithms,  Next: STL Merge Algorithms,  Prev: STL Modifying Algorithms,  Up: Top

8 STL Sort Algorithms
*********************

The stlvec::sort module provides an interface to the STL's sorting and
binary search algorithms.

* Menu:

* Imports: Imports<4>.
* Operations: Operations<4>.
* Examples: Examples<5>.


File: pure-stlvec.info,  Node: Imports<4>,  Next: Operations<4>,  Up: STL Sort Algorithms

8.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::sort;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<4>,  Next: Examples<5>,  Prev: Imports<4>,  Up: STL Sort Algorithms

8.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering function, comp. The functions (<) and (>) are commonly passed
as comp.

 -- Function: stl::sort (msv, first, last) comp
     sorts msv[first, last)

 -- Function: stl::stable_sort (msv, first, last) comp
     sorts msv[first, last), preserving the relative order of equal
     members

 -- Function: stl::partial_sort (msv, first, middle, last) comp
     fills msv[first, middle) with the elements of msv[first,last) that
     would appear there if msv[first,last) were sorted using comp and
     fills msv[middle,last) with the remaining elements in unspecified
     order

 -- Function: stl::partial_sort_copy (sv, first1, last1) (msv, first2,
          last2) comp
     let n be the number of elements in sv[first1, last1) and r be the
     number of elements in msv[first2, last2). If r < n, *note
     partial_sort_copy: 81. fills msv[first2, last2) with the first r
     elements of what sv[first1, last1) would be if it had been sorted.
     If r >= n, it fills msv[first2, first2+n) with the elements of
     sv[first1, last1) in sorted order. sv[first1,last1) is unchanged

 -- Function: stl::nth_element (msv, first, middle, last) comp
     rearranges the elements of msv[first, last) as follows. Let n be
     middle - first, and let x be the nth smallest element of
     msv[first, last). After the function is called, sv!middle will be
     x. All of the elements of msv[first, middle) will be less than x
     and all of the elements of msv[middle+1, last) will be greater
     than x

  The next four functions assume that sv[first, last) is ordered by
comp.

 -- Function: stl::lower_bound (sv, first, last) x comp
     returns an int designating the first position into which x can be
     inserted into sv[first, last) while maintaining the sorted ordering

 -- Function: stl::upper_bound (sv, first, last) x comp
     returns an int designating the last position into which x can be
     inserted into sv[first, last) while maintaining the sorted ordering

 -- Function: stl::equal_range (sv, first, last) x comp
     returns a pair of ints, (lower, upper) where lower and upper would
     have been returned by separate calls to lower_bound and
     upper_bound.

 -- Function: stl::binary_search (sv, first, last) x comp
     returns true if x is an element of sv[first, last)


File: pure-stlvec.info,  Node: Examples<5>,  Prev: Operations<4>,  Up: STL Sort Algorithms

8.3 Examples
============

See ut_sort.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Merge Algorithms,  Next: STL Heap Algorithms,  Prev: STL Sort Algorithms,  Up: Top

9 STL Merge Algorithms
**********************

The stlvec::merge module provides an interface to the STL's merge
algorithms. These algorithms operate on sorted ranges.

* Menu:

* Imports: Imports<5>.
* Operations: Operations<5>.
* Examples: Examples<6>.


File: pure-stlvec.info,  Node: Imports<5>,  Next: Operations<5>,  Up: STL Merge Algorithms

9.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::merge;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<5>,  Next: Examples<6>,  Prev: Imports<5>,  Up: STL Merge Algorithms

9.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering functions, comp (as for the Pure library sort function). They
only work properly on input ranges that have been previously sorted
using comp. The set operations generally do not check for range
overflow because it is not generally possible to determine the length
of the result of a set operation until after it is completed. In most
cases you will get a nasty segmentation fault if the result is bigger
than the target range. The best way to avoid this possibility it to use
a back iterator to specifify the target range.

  See parameter naming conventions at ..

 -- Function: stl::merge (sv1,first1,last1) (sv2,first2,last2) (msv,p)
          comp
     merges the two sorted ranges into the sorted range msv[p,p+n)
     where n is the total length of the merged sequence

 -- Function: stl::inplace_merge (msv,first, middle, last) comp
     merges msv[first,middle) and msv[middle,last) into the sorted range
     msv[first,last)

 -- Function: stl::includes (sv1,first1,last1) (sv2,first2,last2) comp
     returns true if every element of sv2[first2,last2) is an element
     of sv1[first1,last1)

 -- Function: stl::set_union (sv1,first1,last1) (sv2,first2,last2)
          (msv,p) comp
     places the sorted union of sv1[first1,last1) and sv2[first2,last2)
     into msv[p,p+n) where n is the number of elements in the sorted
     union, and returns the past-the-end position of the sorted union

 -- Function: stl::set_intersection (sv1,first1,last1)
          (sv2,first2,last2) (msv,p) comp
     places the sorted intersection of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of
     elements in the sorted intersection, and returns p+n (or
     stl::svend, if applicable)

 -- Function: stl::set_difference (sv1,first1,last1) (sv2,first2,last2)
          (msv,p) comp
     places the sorted difference of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of
     elements in the sorted difference, and returns p+n (or stl::svend,
     if applicable)

 -- Function: stl::set_symmetric_difference (sv1,first1,last1)
          (sv2,first2,last2) (msv,p) comp
     places the sorted symmetric_difference of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of
     elements in the sorted symmetric_difference, and returns returns
     p+n (or stl::svend, if applicable)


File: pure-stlvec.info,  Node: Examples<6>,  Prev: Operations<5>,  Up: STL Merge Algorithms

9.3 Examples
============

See ut_merge.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Heap Algorithms,  Next: Min/Max STL Algorithms,  Prev: STL Merge Algorithms,  Up: Top

10 STL Heap Algorithms
**********************

The stlvec::heap module provides an interface to the STL's heap
operations.

* Menu:

* Imports: Imports<6>.
* Operations: Operations<6>.
* Examples: Examples<7>.


File: pure-stlvec.info,  Node: Imports<6>,  Next: Operations<6>,  Up: STL Heap Algorithms

10.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::heap;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<6>,  Next: Examples<7>,  Prev: Imports<6>,  Up: STL Heap Algorithms

10.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering functions, comp (as for the Pure library sort function). The
functions (<) and (>) are commonly passed as comp.

 -- Function: stl::make_heap (msv,first,last) comp
     rearranges the elements of msv[first,last) so that they are a
     heap, i.e., after this msv!first will be the largest element in
     msv[first,last), and push_heap and pop_heap will work properly

 -- Function: stl::push_heap (msv,first,last) comp
     makes msv[first,last) a heap (assuming that msv[first,last-1) was
     a heap)

 -- Function: stl::pop_heap (msv,first,last) comp
     swaps msv!first with msv!(last-1), and makes msv[first,last-1) a
     heap (assuming that msv[first,last) was a heap)

 -- Function: stl::sort_heap (msv,first,last) comp
     sorts the elements in msv[first,last)


File: pure-stlvec.info,  Node: Examples<7>,  Prev: Operations<6>,  Up: STL Heap Algorithms

10.3 Examples
=============

See ut_heap.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Min/Max STL Algorithms,  Next: STL Numeric Algorithms,  Prev: STL Heap Algorithms,  Up: Top

11 Min/Max STL Algorithms
*************************

The stlvec::minmax module provides an interface to a few additional STL
algorithms.

* Menu:

* Imports: Imports<7>.
* Operations: Operations<7>.
* Examples: Examples<8>.


File: pure-stlvec.info,  Node: Imports<7>,  Next: Operations<7>,  Up: Min/Max STL Algorithms

11.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::minmax;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<7>,  Next: Examples<8>,  Prev: Imports<7>,  Up: Min/Max STL Algorithms

11.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering functions, comp (as for the Pure library sort function). The
functions (<) and (>) are commonly passed as comp.

 -- Function: stl::min_element (sv,first,last) comp
     returns the position of the minimal element of sv[first,last)
     under the ordering defined by comp

 -- Function: stl::max_element (sv,first,last) comp
     returns the position of the maximal element of sv[first,last)
     under the ordering defined by comp

 -- Function: stl::lexicographical_compare (sv1,first1,last1)
          (sv2,first2,last2) comp
     compares sv1[first1,last1) and sv2[first2,last2) element by element
     according to the ordering defined by comp, and returns true if the
     first sequence is less than the second

  Algorithms are provided for stepping through all the permutations the
elements of a stlvec. For these purposes, the first permutation has the
elements of msv[first,last) sorted in ascending order and the last has
the elements sorted in descending order.

 -- Function: stl::next_permutation (msv,first,last) comp
     rearranges msv[first,last) to produce the next permutation, in the
     ordering imposed by comp. If msv[first,last) is not the last
     permutation, change msv[first,last) to the next permutation and
     return true. Otherwise, change it to the first permutation and
     return true

 -- Function: stl::prev_permutation (msv,first,last) comp
     next_permutation in reverse


File: pure-stlvec.info,  Node: Examples<8>,  Prev: Operations<7>,  Up: Min/Max STL Algorithms

11.3 Examples
=============

See ut_minmax.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Numeric Algorithms,  Next: Trace Mode,  Prev: Min/Max STL Algorithms,  Up: Top

12 STL Numeric Algorithms
*************************

The stlvec::numeric module provides an interface to the STL's numeric
algorithms.

* Menu:

* Imports: Imports<8>.
* Operations: Operations<8>.
* Examples: Examples<9>.


File: pure-stlvec.info,  Node: Imports<8>,  Next: Operations<8>,  Up: STL Numeric Algorithms

12.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::numeric;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<8>,  Next: Examples<9>,  Prev: Imports<8>,  Up: STL Numeric Algorithms

12.2 Operations
===============

 -- Function: stl::accumulate (sv,first,last) x bin_fun
     accumulate bin_fun over x and the members of sv[first,last), like
     foldl

 -- Function: stl::inner_product (sv1,first1,last1) (sv2,first2,last2)
          x bin_fun1 bin_fun2
     initialize ret with x. Traverse pairs of elements of
     sv1[first1,last1) and sv2[first2,last2), denoted by (e1, e2),
     replacing ret with (bin_fun1 ret $ bin_fun2 e1 e2). The number
     pairs traversed is equal to the size of sv1[first1,last1)

 -- Function: stl::partial_sum (sv,first,last) (msv, p) bin_fun
     accumulate bin_fun f over the elements of sv1[first1,last1),
     placing itermediate results in msv[p,p+n), where n is last -
     first, and returns q where m is q - n and msv[m,q) is the
     intermediate sequence

 -- Function: stl::adjacent_difference (sv,first,last) (msv, p) bin_fun
     produce a sequence of new elements by applying bin_fun to adjacent
     elements of sv[first,last), placing the new elements in
     msv[p,p+n), where n is last - first, with the intermediate
     results, and returns q where m is q - n and msv[m,q) is the new
     sequence


File: pure-stlvec.info,  Node: Examples<9>,  Prev: Operations<8>,  Up: STL Numeric Algorithms

12.3 Examples
=============

See ut_numeric.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Trace Mode,  Next: Index,  Prev: STL Numeric Algorithms,  Up: Top

13 Trace Mode
*************

If the pure-stlvec dlls are built using 'make debug' (as opposed to
'make', 'make all' or 'make dlls'), the pure-stlvec tracing functions
will be enabled. These functions, all of which are defined in the stl
namespace, can be used to trace the creation and deletion of stlvecs as
well as the changes in ref counts that occur as Pure objects are moved
and copied. In addition to being useful for maintaining the pure-stlvec
modules, these functions can be used to observe the STL copy semantics.

 -- Function: stl::set_sv_trace on_off::int
     enables or disables tracing the creation and deletion of stlvecs

 -- Function: stl::sv_trace_enabled
     returns 1 if stlvec tracing is enabled, else 0

 -- Function: stl::set_px_trace on_off::int
     enables or disables tracing 'copying' of Pure expressions

 -- Function: stl::px_trace_enabled
     returns 1 if Pure expression tracing is enabled, else 0

  In addition, the following function, also in the stl namespace, is
available whether or not debug is passed to make.

 -- Function: stl::refc x
     returns the x's reference count (maintained by the Pure runtime for
     garbage collection purposes)


File: pure-stlvec.info,  Node: Index,  Prev: Trace Mode,  Up: Top

Index
*****

 [index ]
* Menu:

* # prefix function:                     Operations.          (line  35)
* == infix function:                     Operations.          (line 109)
* append function:                       Operations.          (line  85)
* bad_argument constructor:              Exception Symbols.   (line   6)
* bad_function constructor:              Exception Symbols.   (line  11)
* catmap function:                       Convenience Functions.
                                                              (line  15)
* colcatmap function:                    Convenience Functions.
                                                              (line  40)
* colmap function:                       Convenience Functions.
                                                              (line  38)
* const_stlvec type:                     Types.               (line  12)
* const_svit type:                       Types.               (line  26)
* do function:                           Convenience Functions.
                                                              (line  18)
* emptystlvec function:                  Operations.          (line  17)
* failed_cond constructor:               Exception Symbols.   (line  15)
* filter function:                       Convenience Functions.
                                                              (line  27)
* first function:                        Operations.          (line  68)
* foldl function:                        Convenience Functions.
                                                              (line  21)
* foldl1 function:                       Convenience Functions.
                                                              (line  24)
* infix function:                        Operations.          (line  59)
* insert function:                       Operations.          (line  88)
* last function:                         Operations.          (line  68)
* list function:                         Operations.          (line  75)
* listmap function:                      Convenience Functions.
                                                              (line  12)
* map function:                          Convenience Functions.
                                                              (line   9)
* members function:                      Operations.          (line  72)
* mkstlvec function:                     Operations.          (line  25)
* mutable_stlvec type:                   Types.               (line   8)
* mutable_svit type:                     Types.               (line  22)
* null function:                         Operations.          (line  56)
* out_of_bounds constructor:             Exception Symbols.   (line  19)
* range_overflow constructor:            Exception Symbols.   (line  22)
* range_overlap constructor:             Exception Symbols.   (line  27)
* rmfirst function:                      Operations.          (line  94)
* rmlast function:                       Operations.          (line  94)
* rowcatmap function:                    Convenience Functions.
                                                              (line  36)
* rowmap function:                       Convenience Functions.
                                                              (line  34)
* stl accumulate function:               Operations<8>.       (line   6)
* stl adjacent_difference function:      Operations<8>.       (line  23)
* stl adjacent_find function:            Operations<2>.       (line  23)
* stl binary_search function:            Operations<4>.       (line  56)
* stl copy function:                     Operations<3>.       (line   6)
* stl copy_backward function:            Operations<3>.       (line  10)
* stl count function:                    Operations<2>.       (line  28)
* stl count_if function:                 Operations<2>.       (line  32)
* stl equal function:                    Operations<2>.       (line  44)
* stl equal_range function:              Operations<4>.       (line  51)
* stl fill function:                     Operations<3>.       (line  46)
* stl fill_n function:                   Operations<3>.       (line  49)
* stl find function:                     Operations<2>.       (line   9)
* stl find_end function:                 Operations<2>.       (line  61)
* stl find_first_of function:            Operations<2>.       (line  17)
* stl find_if function:                  Operations<2>.       (line  13)
* stl for_each function:                 Operations<2>.       (line   6)
* stl generate function:                 Operations<3>.       (line  52)
* stl generate_n function:               Operations<3>.       (line  64)
* stl includes function:                 Operations<5>.       (line  27)
* stl inner_product function:            Operations<8>.       (line  10)
* stl inplace_merge function:            Operations<5>.       (line  23)
* stl lexicographical_compare function:  Operations<7>.       (line  18)
* stl lower_bound function:              Operations<4>.       (line  43)
* stl make_heap function:                Operations<6>.       (line  10)
* stl max_element function:              Operations<7>.       (line  14)
* stl merge function:                    Operations<5>.       (line  18)
* stl min_element function:              Operations<7>.       (line  10)
* stl mismatch function:                 Operations<2>.       (line  36)
* stl next_permutation function:         Operations<7>.       (line  29)
* stl nth_element function:              Operations<4>.       (line  32)
* stl partial_sort function:             Operations<4>.       (line  17)
* stl partial_sort_copy function:        Operations<4>.       (line  23)
* stl partial_sum function:              Operations<8>.       (line  17)
* stl partition function:                Operations<3>.       (line 115)
* stl pop_heap function:                 Operations<6>.       (line  19)
* stl prev_permutation function:         Operations<7>.       (line  36)
* stl push_heap function:                Operations<6>.       (line  15)
* stl px_trace_enabled function:         Trace Mode.          (line  23)
* stl random_shuffle function:           Operations<3>.       (line 112)
* stl refc function:                     Trace Mode.          (line  29)
* stl remove function:                   Operations<3>.       (line  68)
* stl remove_copy function:              Operations<3>.       (line  78)
* stl remove_copy_if function:           Operations<3>.       (line  82)
* stl remove_if function:                Operations<3>.       (line  71)
* stl replace function:                  Operations<3>.       (line  31)
* stl replace_copy function:             Operations<3>.       (line  38)
* stl replace_copy_if function:          Operations<3>.       (line  42)
* stl replace_if function:               Operations<3>.       (line  34)
* stl reverse function:                  Operations<3>.       (line  97)
* stl reverse_copy function:             Operations<3>.       (line 100)
* stl rotate function:                   Operations<3>.       (line 104)
* stl rotate_copy function:              Operations<3>.       (line 108)
* stl search function:                   Operations<2>.       (line  49)
* stl search_n function:                 Operations<2>.       (line  55)
* stl set_difference function:           Operations<5>.       (line  44)
* stl set_intersection function:         Operations<5>.       (line  37)
* stl set_px_trace function:             Trace Mode.          (line  20)
* stl set_sv_trace function:             Trace Mode.          (line  14)
* stl set_symmetric_difference function: Operations<5>.       (line  51)
* stl set_union function:                Operations<5>.       (line  31)
* stl sort function:                     Operations<4>.       (line  10)
* stl sort_heap function:                Operations<6>.       (line  23)
* stl stable_partition function:         Operations<3>.       (line 121)
* stl stable_sort function:              Operations<4>.       (line  13)
* stl sv_trace_enabled function:         Trace Mode.          (line  17)
* stl svback constant:                   Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl svbeg constant:                    Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl svend constant:                    Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl swap_ranges function:              Operations<3>.       (line  15)
* stl transform function:                Operations<3>.       (line  19)
* stl transform_2 function:              Operations<3>.       (line  24)
* stl unique function:                   Operations<3>.       (line  86)
* stl unique_copy function:              Operations<3>.       (line  93)
* stl upper_bound function:              Operations<4>.       (line  47)
* stlvec function:                       Operations.          (line  20)
* stlvec module:                         Top.                 (line   6)
* stlvec type:                           Types.               (line  16)
* stlvec_bounds function:                Operations.          (line  42)
* stlvec_capacity function:              Operations.          (line  53)
* stlvec_const function:                 Operations.          (line  28)
* stlvec_equal function:                 Operations.          (line 104)
* stlvec_erase function:                 Operations.          (line  98)
* stlvec_reserve function:               Operations.          (line  48)
* stlvec_vector function:                Operations.          (line  32)
* svit type:                             Types.               (line  30)
* update function:                       Operations.          (line  82)
* ~= infix function:                     Operations.          (line 109)



Tag Table:
Node: Top253
Ref: 0591
Ref: pure591
Node: Copying2103
Ref: copying2188
Ref: 12188
Ref: module-stlvec2188
Ref: 22188
Ref: 32188
Node: Installation2576
Ref: installation2666
Ref: 42666
Node: Overview3422
Ref: overview3519
Ref: 53519
Node: Modules4314
Ref: modules4395
Ref: 64395
Node: Simple Examples5492
Ref: simple examples5614
Ref: 75614
Ref: simple-examples5614
Node: Members and Sequences of Members7351
Ref: members and sequences of members7499
Ref: 87499
Ref: members-and-sequences-of-members7499
Node: STL Iterators and Value Semantics8290
Ref: stl iterators and value semantics8438
Ref: 98438
Ref: stl-iterators-and-value-semantics8438
Node: Iterator Tuples10359
Ref: iterator tuples10508
Ref: a10508
Ref: iterator-tuples10508
Node: Predefined Iterator Tuple Indexes12926
Ref: predefined iterator tuple indexes13063
Ref: b13063
Ref: predefined-iterator-tuple-indexes13063
Ref: c13234
Ref: stl svbeg13234
Ref: d13263
Ref: stl svend13263
Ref: e13293
Ref: stl svback13293
Node: Back Insert Iterators13712
Ref: back insert iterators13847
Ref: f13847
Ref: back-insert-iterators13847
Node: Documentation14837
Ref: documentation14954
Ref: 1014954
Node: Parameter Names15931
Ref: parameter names16018
Ref: 1116018
Ref: parameter-names16018
Node: Error Handling18129
Ref: error handling18230
Ref: 1218230
Ref: error-handling18230
Node: Exception Symbols18384
Ref: exception symbols18474
Ref: 1318474
Ref: exception-symbols18474
Ref: 1418519
Ref: bad_argument18519
Ref: 1518742
Ref: bad_function18742
Ref: 1618871
Ref: failed_cond18871
Ref: 1719004
Ref: out_of_bounds19004
Ref: 1819107
Ref: range_overflow19107
Ref: 1919305
Ref: range_overlap19305
Node: Examples19670
Ref: examples19760
Ref: 1a19760
Node: Basic Operations20741
Ref: basic operations20861
Ref: 1b20861
Ref: basic-operations20861
Node: Imports21180
Ref: imports21268
Ref: 1c21268
Node: Data Structure21406
Ref: data structure21508
Ref: 1d21508
Ref: data-structure21508
Node: Types22189
Ref: types22319
Ref: 1e22319
Ref: 1f22383
Ref: mutable_stlvec/type22383
Ref: 2022501
Ref: const_stlvec/type22501
Ref: 2122626
Ref: stlvec/type22626
Ref: 2222826
Ref: mutable_svit/type22826
Ref: 2322937
Ref: const_svit/type22937
Ref: 2423053
Ref: svit/type23053
Node: Support for Copy-On-Write Semantics23162
Ref: support for copy-on-write semantics23288
Ref: 2523288
Ref: support-for-copy-on-write-semantics23288
Node: Operations24561
Ref: operations24703
Ref: 2624703
Ref: 2825391
Ref: emptystlvec25391
Ref: 2725446
Ref: stlvec25446
Ref: 2925679
Ref: mkstlvec25679
Ref: 2a25761
Ref: stlvec_const25761
Ref: 2b25880
Ref: stlvec_vector25880
Ref: 2c25995
Ref: #/stlvec25995
Ref: 2d26263
Ref: stlvec_bounds26263
Ref: 2e26557
Ref: stlvec_reserve26557
Ref: 2f26777
Ref: stlvec_capacity26777
Ref: 3026883
Ref: null/stlvec26883
Ref: 3126936
Ref: !/stlvec26936
Ref: 3227302
Ref: first/stlvec27302
Ref: 3327325
Ref: last/stlvec27325
Ref: 3427381
Ref: members/stlvec27381
Ref: 3527476
Ref: list/stlvec27476
Ref: 3627752
Ref: update/stlvec27752
Ref: 3727837
Ref: append/stlvec27837
Ref: 3827895
Ref: insert/stlvec27895
Ref: 3927927
Ref: insert27927
Ref: 3a28152
Ref: rmfirst/stlvec28152
Ref: 3b28178
Ref: rmlast/stlvec28178
Ref: 3c28250
Ref: stlvec_erase28250
Ref: 3d28490
Ref: stlvec_equal28490
Ref: 3e28694
Ref: ==/stlvec28694
Ref: 3f28719
Ref: ~=/stlvec28719
Node: Convenience Functions28984
Ref: convenience functions29102
Ref: 4029102
Ref: convenience-functions29102
Ref: 4129297
Ref: map/stlvec29297
Ref: 4229414
Ref: listmap/stlvec29414
Ref: 4329511
Ref: catmap/stlvec29511
Ref: 4429634
Ref: do/stlvec29634
Ref: 4529749
Ref: foldl/stlvec29749
Ref: 4629870
Ref: foldl1/stlvec29870
Ref: 4729989
Ref: filter/stlvec29989
Ref: 4830246
Ref: rowmap/stlvec30246
Ref: 4930296
Ref: rowcatmap/stlvec30296
Ref: 4a30349
Ref: colmap/stlvec30349
Ref: 4b30399
Ref: colcatmap/stlvec30399
Node: Examples<2>30767
Ref: examples<2>30866
Ref: 4c30866
Ref: id130866
Node: STL Nonmodifying Algorithms30940
Ref: stl nonmodifying algorithms31070
Ref: 4d31070
Ref: stl-nonmodifying-algorithms31070
Node: Imports<2>31321
Ref: imports<2>31422
Ref: 4e31422
Ref: id231422
Node: Operations<2>31621
Ref: operations<2>31742
Ref: 4f31742
Ref: id331742
Ref: 5031773
Ref: stl for_each31773
Ref: 5131895
Ref: stl find31895
Ref: 5232063
Ref: stl find_if32063
Ref: 5332248
Ref: stl find_first_of32248
Ref: 5432535
Ref: stl adjacent_find32535
Ref: 5532791
Ref: stl count32791
Ref: 5632930
Ref: stl count_if32930
Ref: 5733086
Ref: stl mismatch33086
Ref: 5833512
Ref: stl equal33512
Ref: 5933770
Ref: stl search33770
Ref: 5a34095
Ref: stl search_n34095
Ref: 5b34419
Ref: stl find_end34419
Node: Examples<3>34753
Ref: examples<3>34855
Ref: 5c34855
Ref: id434855
Node: STL Modifying Algorithms34941
Ref: stl modifying algorithms35074
Ref: 5d35074
Ref: stl-modifying-algorithms35074
Node: Imports<3>35303
Ref: imports<3>35401
Ref: 5e35401
Ref: id535401
Node: Operations<3>35597
Ref: operations<3>35715
Ref: 5f35715
Ref: id635715
Ref: 6035746
Ref: stl copy35746
Ref: 6135906
Ref: stl copy_backward35906
Ref: 6236160
Ref: stl swap_ranges36160
Ref: 6336319
Ref: stl transform36319
Ref: 6436596
Ref: stl transform_236596
Ref: 6536891
Ref: stl replace36891
Ref: 6637000
Ref: stl replace_if37000
Ref: 6737143
Ref: stl replace_copy37143
Ref: 6837329
Ref: stl replace_copy_if37329
Ref: 6937509
Ref: stl fill37509
Ref: 6a37605
Ref: stl fill_n37605
Ref: 6b37703
Ref: stl generate37703
Ref: 6c38063
Ref: stl generate_n38063
Ref: 6d38228
Ref: stl remove38228
Ref: 6e38332
Ref: stl remove_if38332
Ref: 6f38723
Ref: stl remove_copy38723
Ref: 7038912
Ref: stl remove_copy_if38912
Ref: 7139116
Ref: stl unique39116
Ref: 7239500
Ref: stl unique_copy39500
Ref: 7339696
Ref: stl reverse39696
Ref: 7439800
Ref: stl reverse_copy39800
Ref: 7539992
Ref: stl rotate39992
Ref: 7640161
Ref: stl rotate_copy40161
Ref: 7740347
Ref: stl random_shuffle40347
Ref: 7840454
Ref: stl partition40454
Ref: 7940764
Ref: stl stable_partition40764
Node: Examples<4>40936
Ref: examples<4>41035
Ref: 7a41035
Ref: id741035
Node: STL Sort Algorithms41118
Ref: stl sort algorithms41244
Ref: 7b41244
Ref: stl-sort-algorithms41244
Node: Imports<4>41474
Ref: imports<4>41567
Ref: 7c41567
Ref: id841567
Node: Operations<4>41758
Ref: operations<4>41871
Ref: 7d41871
Ref: id941871
Ref: 7e42051
Ref: stl sort42051
Ref: 7f42128
Ref: stl stable_sort42128
Ref: 8042265
Ref: stl partial_sort42265
Ref: 8142554
Ref: stl partial_sort_copy42554
Ref: 8243062
Ref: stl nth_element43062
Ref: 8343554
Ref: stl lower_bound43554
Ref: 8443755
Ref: stl upper_bound43755
Ref: 8543955
Ref: stl equal_range43955
Ref: 8644163
Ref: stl binary_search44163
Node: Examples<5>44278
Ref: examples<5>44372
Ref: 8744372
Ref: id1044372
Node: STL Merge Algorithms44450
Ref: stl merge algorithms44571
Ref: 8844571
Ref: stl-merge-algorithms44571
Node: Imports<5>44827
Ref: imports<5>44921
Ref: 8944921
Ref: id1144921
Node: Operations<5>45113
Ref: operations<5>45227
Ref: 8a45227
Ref: id1245227
Ref: 8b45901
Ref: stl merge45901
Ref: 8c46111
Ref: stl inplace_merge46111
Ref: 8d46270
Ref: stl includes46270
Ref: 8e46438
Ref: stl set_union46438
Ref: 8f46740
Ref: stl set_intersection46740
Ref: 9047057
Ref: stl set_difference47057
Ref: 9147368
Ref: stl set_symmetric_difference47368
Node: Examples<6>47717
Ref: examples<6>47812
Ref: 9247812
Ref: id1347812
Node: STL Heap Algorithms47891
Ref: stl heap algorithms48015
Ref: 9348015
Ref: stl-heap-algorithms48015
Node: Imports<6>48226
Ref: imports<6>48319
Ref: 9448319
Ref: id1448319
Node: Operations<6>48512
Ref: operations<6>48625
Ref: 9548625
Ref: id1548625
Ref: 9648848
Ref: stl make_heap48848
Ref: 9749104
Ref: stl push_heap49104
Ref: 9849240
Ref: stl pop_heap49240
Ref: 9949414
Ref: stl sort_heap49414
Node: Examples<7>49509
Ref: examples<7>49603
Ref: 9a49603
Ref: id1649603
Node: Min/Max STL Algorithms49683
Ref: min/max stl algorithms49809
Ref: 9b49809
Ref: min-max-stl-algorithms49809
Node: Imports<7>50034
Ref: imports<7>50130
Ref: 9c50130
Ref: id1750130
Node: Operations<7>50325
Ref: operations<7>50441
Ref: 9d50441
Ref: id1850441
Ref: 9e50664
Ref: stl min_element50664
Ref: 9f50824
Ref: stl max_element50824
Ref: a050984
Ref: stl lexicographical_compare50984
Ref: a151527
Ref: stl next_permutation51527
Ref: a251878
Ref: stl prev_permutation51878
Node: Examples<8>51970
Ref: examples<8>52067
Ref: a352067
Ref: id1952067
Node: STL Numeric Algorithms52149
Ref: stl numeric algorithms52266
Ref: a452266
Ref: stl-numeric-algorithms52266
Node: Imports<8>52489
Ref: imports<8>52585
Ref: a552585
Ref: id2052585
Node: Operations<8>52781
Ref: operations<8>52897
Ref: a652897
Ref: id2152897
Ref: a752930
Ref: stl accumulate52930
Ref: a853069
Ref: stl inner_product53069
Ref: a953427
Ref: stl partial_sum53427
Ref: aa53714
Ref: stl adjacent_difference53714
Node: Examples<9>54067
Ref: examples<9>54164
Ref: ab54164
Ref: id2254164
Node: Trace Mode54247
Ref: trace mode54347
Ref: ac54347
Ref: trace-mode54347
Ref: ad54872
Ref: stl set_sv_trace54872
Ref: ae54987
Ref: stl sv_trace_enabled54987
Ref: af55076
Ref: stl set_px_trace55076
Ref: b055184
Ref: stl px_trace_enabled55184
Ref: b155402
Ref: stl refc55402
Node: Index55536
Ref: index55605

End Tag Table


Local Variables:
coding: utf-8
End:
