This is pure-xml.info, produced by makeinfo version 4.13 from
pure-xml.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-xml: (pure-xml.info).    Pure-XML - XML/XSLT interface
END-INFO-DIR-ENTRY


File: pure-xml.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-xml
********

  Version 0.6, May 09, 2012

  Albert Graef <<Dr.Graef@t-online.de>>

  XML (http://www.w3.org/TR/xml), the Extensible Markup Language,
facilitates the exchange of complex structured data between
applications and systems. XSLT (http://www.w3.org/TR/xslt) allows you to
transform XML documents to other XML-based formats such as HTML.
Together, XML and XSLT let you create dynamic web content with ease.
Both XML and XSLT are open standards by the W3C consortium
(<http://www.w3.org>).

  Pure's XML interface is based on the libxml2 and libxslt libraries
from the GNOME project. If you have a Linux system then you most likely
have these libraries, otherwise you can get them from
<http://xmlsoft.org>. For Windows users, the required dlls are
available from the GnuWin32 project (<http://gnuwin32.sourceforge.net>)
and are already included in the Pure MSI package.

* Menu:

* Copying::
* Installation::
* Usage::
* Data Structure::
* Operations::
* Index::

 --- The Detailed Node Listing ---

Data Structure

* The Document Tree::
* Document Types::

Operations

* Document Operations::
* Traversing Documents::
* Node Information::
* Node Manipulation::
* Transformations::


File: pure-xml.info,  Node: Copying,  Next: Installation,  Prev: Top,  Up: Top

1 Copying
*********

Copyright (c) 2009 by Albert Graef <<Dr.Graef@t-online.de>>.

  pure-xml is free software: you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

  pure-xml is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
License along with this program.  If not, see
<<http://www.gnu.org/licenses/>>.


File: pure-xml.info,  Node: Installation,  Next: Usage,  Prev: Copying,  Up: Top

2 Installation
**************

Get the latest source from
<http://pure-lang.googlecode.com/files/pure-xml-0.6.tar.gz>.

  Run `make' and then `sudo make install' to compile and install this
module. This requires libxml2, libxslt and Pure.


File: pure-xml.info,  Node: Usage,  Next: Data Structure,  Prev: Installation,  Up: Top

3 Usage
*******

Use the following declaration to make the operations of this module
available in your programs:

    using xml;

The module defines two namespaces `xml' and `xslt' for the XML and the
XSLT operations, respectively. For convenience, you can open these in
your program as follows:

    using namespace xml, xslt;

A number of complete examples illustrating the use of this module can
be found in the examples directory in the source distribution.


File: pure-xml.info,  Node: Data Structure,  Next: Operations,  Prev: Usage,  Up: Top

4 Data Structure
****************

This module represents XML documents using pointers to the `xmlDoc' and
`xmlNode' structures provided by the libxml2 library. Similarly,
stylesheets are simply pointers to the xmlStylesheet structure from
libxslt (cf. *note Transformations: 8.). This makes it possible to use
these objects directly with the operations of the libxml2 and libsxslt
libraries (via Pure's C interface) if necessary. Note, however, that
these are all "cooked" pointers which take care of freeing themselves
automatically when they are no longer needed, therefore you shouldn't
free them manually.

  You can also check for these types of pointers using the following
predicates:

 -- Function: xml::docp x
     checks whether `x' is an XML document pointer.

 -- Function: xml::nodep x
     checks whether `x' is a pointer to a node in an XML document.

 -- Function: xslt::stylesheetp x
     checks whether `x' is an XSLT stylesheet pointer.

* Menu:

* The Document Tree::
* Document Types::


File: pure-xml.info,  Node: The Document Tree,  Next: Document Types,  Up: Data Structure

4.1 The Document Tree
=====================

An XML document is a rooted tree which can be created, traversed and
manipulated using the operations of this module. There are different
types of nodes in the tree, each carrying their own type of data. In
Pure land, the node data is described using the following "node info"
constructors.

 -- constructor: xml::element tag ns attrs
     An XML element with given (possibly qualified) name `tag', a
     (possibly empty) list of namespace declarations `ns' and a
     (possibly empty) list of attributes `attrs'. Namespace
     declarations normally take the form of a pair of strings
     `(prefix,href)', where `prefix' is the prefix associated with the
     namespace and `href' the corresponding URI (the name of the
     namespace), but they can also be just a string `href' if the
     namespace prefix is missing. Attributes are encoded as
     `key=>value' pairs, where `key' is the attribute name and `value'
     the associated value; both `key' and `value' are strings.

 -- constructor: xml::element_text tag ns attrs content
     A convenience function which denotes a combination of an element
     node with a text child. This is only used when creating a new
     node, and indicates that a text node child is to be added to the
     node automatically.

 -- constructor: xml::attr key val
     An attribute node. These only occur as results of the `select' and
     `attrs' functions, and cannot be inserted directly into a document.

 -- constructor: xml::text content
     A text node with the given content (a string).

 -- constructor: xml::cdata content
     Like *note xml text: 12, but contains unparsed character data.

 -- constructor: xml::comment content
     A comment.

 -- constructor: xml::entity_ref name
     An entity reference (`&name;').

 -- constructor: xml::pi name content
     Processing instructions. `name' is the application name, `content'
     the text of the processing instructions.


File: pure-xml.info,  Node: Document Types,  Prev: The Document Tree,  Up: Data Structure

4.2 Document Types
==================

Besides the node types described above, there are some additional node
types used in the document type definition
(http://www.w3.org/TR/REC-xml/#dt-doctype) (DTD), which can be extracted
from a document using the `int_subset' and `ext_subset' functions.
These are for inspection purposes only; it is not possible to change
the DTD of a document in-place. (However, you can create a new document
and attach a DTD to it, using the `new_doc' function.)

 -- constructor: xml::doctype name extid
     DTDs are represented using this special type of node, where `name'
     is the name of the root element, and `extid' is a pair consisting
     of the external identifier and the URI of the DTD (or just the URI
     if there is no external identifier). The *note xml doctype: 1b.
     node has as its children zero or more of the following kinds of
     DTD declaration nodes (these are just straightforward abstract
     syntax for the !ELEMENT, !ATTLIST and !ENTITY declarations inside
     a DTD declaration; see the XML specification for details).

  _Element declarations:_ Here, `name' is the element tag and `content'
the definition of the element structure, see *note element content: 1e.
below. XML supports various kinds of element types, please refer to
document type definition (http://www.w3.org/TR/REC-xml/#dt-doctype) in
the XML specification for details.

 -- constructor: xml::undefined_element name
     An undefined element. This is in libxml2, but not in the XML
     specification, you shouldn't see this in normal operation.

 -- constructor: xml::empty_element name
     An element without any content.

 -- constructor: xml::any_element name
     An element with unrestricted content.

 -- constructor: xml::mixed_element name content
     A "mixed" element which can contain character data, optionally
     interspersed with child elements, as given in the `content'
     specification.

 -- constructor: xml::std_element name content
     A standard element consisting _only_ of child elements, as given
     in the `content' specification.

  _Attribute declarations:_ These are used to declare the attributes of
an element. `elem_name' is the name of an element which describes the
attribute type, `name' is the name of the attribute itself, and
`default' specifies the default value of the attribute, see *note
attribute defaults: 26. below. XML supports a bunch of different
attribute types, please refer to document type definition
(http://www.w3.org/TR/REC-xml/#dt-doctype) in the XML specification for
details.

 -- constructor: xml::cdata_attr elem_name name default

 -- constructor: xml::id_attr elem_name name default

 -- constructor: xml::idref_attr elem_name name default

 -- constructor: xml::idrefs_attr elem_name name default

 -- constructor: xml::entity_attr elem_name name default

 -- constructor: xml::entities_attr elem_name name default

 -- constructor: xml::nmtoken_attr elem_name name default

 -- constructor: xml::nmtokens_attr elem_name name default

 -- constructor: xml::enum_attr elem_name name vals default

 -- constructor: xml::notation_attr elem_name name vals default

  _Entity declarations:_ These are used for internal and external entity
declarations. `name' is the entity name and `content' its definition.
External entities also have an `extid' (external identifier/URI pair)
identifying the entity.

 -- constructor: xml::int_entity name content

 -- constructor: xml::int_param_entity name content

 -- constructor: xml::ext_entity name extid content

 -- constructor: xml::ext_param_entity name extid content

  The element content type (`content' argument of the *note element
declaration: 1d. nodes) is a kind of regular expression formed with tags
(specified as strings) and the following constructors:

 -- constructor: xml::pcdata: text data ("#PCDATA")

 -- constructor: xml::sequence xs: concatenation ("x,y,z")

 -- constructor: xml::union xs: alternatives ("x|y|z")

 -- constructor: xml::opt x: optional element ("x?")

 -- constructor: xml::mult x: repeated element ("x*")

 -- constructor: xml::plus x: non-optional repeated element ("x+")

  Attribute defaults (the `default' argument of *note attribute
declaration: 25.  nodes) are represented using the following
constructor symbols:

 -- constructor: xml::required
     a required attribute, i.e., the user must specify this

 -- constructor: xml::implied
     an implied attribute, i.e., the user does not have to specify this

 -- constructor: xml::default val
     an attribute with the given default value `val'

 -- constructor: xml::fixed val
     an attribute with the given fixed value `val'


File: pure-xml.info,  Node: Operations,  Next: Index,  Prev: Data Structure,  Up: Top

5 Operations
************

This module provides all operations necessary to create, inspect and
manipulate XML documents residing either in memory or on disk.
Operations for formatting XML documents using XSLT stylesheets are also
available.

* Menu:

* Document Operations::
* Traversing Documents::
* Node Information::
* Node Manipulation::
* Transformations::


File: pure-xml.info,  Node: Document Operations,  Next: Traversing Documents,  Up: Operations

5.1 Document Operations
=======================

The following functions allow you to create new XML documents, load them
from or save them to a file or a string, and provide general information
about a document.

 -- Function: xml::new_doc version dtd info
     This function creates an XML document. It returns a pointer to the
     new document. `version' is a string denoting the XML version (or
     `""' to indicate the default). `info' is the *note node info: e.
     of the root node (which should denote an element node). `dtd'
     denotes the document type which can be `()' to denote an empty
     DTD, a string (the URI/filename of the DTD), or a pair
     `(pubid,sysid)' where `pubid' denotes the public identifier of the
     DTD and `sysid' its system identifier (URI).

     Note that only simple kinds of documents with an internal DTD can
     be created this way. Use the `load_file' or `load_string' function
     below to create a skeleton document if a more elaborate prolog is
     required.

 -- Function: xml::load_file name flags
 -- Function: xml::load_string s flags
     Load an XML document from a file `name' or a string `s'. `flags'
     denotes the parser flags, a bitwise disjunction of any of the
     following constants, or 0 for the default:

        - `xml::DTDLOAD': load DTD

        - `xml::DTDVALID': validate

        - `xml::PEDANTIC': pedantic parse

        - `xml::SUBENT': substitute entities

        - `xml::NOBLANKS': suppress blank nodes

     The return value is the document pointer. These operations may
     also fail if there is a fatal error parsing the document.

 -- Function: xml::save_file name doc encoding compression
 -- Function: xml::save_string doc
     Save an XML document `doc' to a file or a string. When saving to a
     file, `encoding' denotes the desired encoding (or `""' for the
     default), `compression' the desired level of zlib compression (0
     means none, 9 is maximum, -1 indicates the default). Note that with
     *note xml save_string: 49, the result is always encoded as UTF-8.

 -- Function: xml::doc_info doc
     Retrieve general information about a document. Returns a tuple
     `(version,encoding,url,compression,standalone)', where `version' is
     the XML version of the document, `encoding' the external encoding
     (if any), `url' the name/location of the document (if any),
     `compression' the level of zlib compression, and `standalone' is a
     flag indicating whether the document contains any external markup
     declarations "which affect the information passed from the XML
     processor to the application", see the section on the standalone
     document declaration (http://www.w3.org/TR/REC-xml/#sec-rmd) in
     the XML spec for details. (Apparently, in libxml2 `standalone' is
     either a truth value or one of the special values -1, indicating
     that there's no XML declaration in the prolog, or -2, indicating
     that there's an XML declaration but no `standalone' attribute.)

 -- Function: xml::int_subset doc
 -- Function: xml::ext_subset doc
     Retrieve the internal and external DTD subset of a document.
     Returns a `doctype' node (fails if there's no corresponding DTD).

  *Example*

  Read the sample.xml document distributed with the sources (ignoring
blank nodes) and retrieve the document info:

    > using xml;
    > let sample = xml::load_file "sample.xml" xml::NOBLANKS;
    > xml::doc_info sample;
    "1.0","","sample.xml",0,-2



File: pure-xml.info,  Node: Traversing Documents,  Next: Node Information,  Prev: Document Operations,  Up: Operations

5.2 Traversing Documents
========================

These operations are used to traverse the document tree, i.e., the
nodes of the document. They take either a document pointer `doc' or a
node pointer `node' as argument, and yield a corresponding node pointer
(or a document pointer, in the case of *note xml doc: 4f.). The node
pointers can then be used with the *note Node Information: 50. and
*note Node Manipulation: 51. operations described below.

 -- Function: xml::root doc
     the root node of `doc'

 -- Function: xml::doc node
     the document `node' belongs to

 -- Function: xml::parent node
     the parent of `node'

 -- Function: xml::first node
 -- Function: xml::last node
     first and last child node

 -- Function: xml::next node
 -- Function: xml::prev node
     next and previous sibling

 -- Function: xml::first_attr node
 -- Function: xml::last_attr node
     first and last attribute node

  All these operations fail if the corresponding target node does not
exist, or if the type of the given node is not supported by this
implementation.

  There are also two convenience functions to retrieve the children and
attribute nodes of a node:

 -- Function: xml::children node
     returns the list of all child nodes of `node'

 -- Function: xml::attrs node
     returns the list of all attribute nodes of `node'

  Moreover, given a node pointer `node', `node!i' can be used to
retrieve the `i'th child of `node'.

  *Example*

  Peek at the root node of the sample document and its children:

    > let r = xml::root sample; r;
    #<pointer 0xe15e10>
    > xml::node_info r;
    xml::element "story" [] []
    > #xml::children r;
    5
    > xml::node_info (r!0);
    xml::cdata "<greeting>Hello, world!</greeting>"



File: pure-xml.info,  Node: Node Information,  Next: Node Manipulation,  Prev: Traversing Documents,  Up: Operations

5.3 Node Information
====================

These operations retrieve information about the nodes of an XML
document.

 -- Function: xml::select doc xpath
 -- Function: xml::select doc (xpath,ns)
     Retrieve nodes using an XPath (http://www.w3.org/TR/xpath)
     specification. Given an XPath (a string) `xpath', this operation
     returns the list of all matching nodes in the given document
     `doc'. You can also specify a node as the first argument, in which
     case the document of the given node is searched and paths are
     interpreted relative to the given node (rather than the root node
     of the document).

     Moreover, instead of just an XPath you can also specify a pair
     `(xpath,ns)' consisting of an XPath `xpath' and a list `ns' of
     `prefix=>uri' string pairs which describe the namespaces to be
     recognized in the XPath expression. This is necessary to select
     nodes by qualified tag or attribute names. Note that only the
     namespace URIs must match up with those used in the queried
     document; the corresponding namespace prefixes can be chosen
     freely, so you can use whatever prefixes are convenient to
     formulate the XPath query. However, for each namespace prefix used
     in the XPath expression (not the document!), there _must_ be a
     corresponding binding in the `ns' list. Otherwise the underlying
     libxml2 function will complain about an undefined namespace prefix
     and *note xml select: 5c. will fail.


 -- Function: xml::node_info node
     Retrieve the node data from `node'. Returns a *note node info: e.
     value, as described in *note Data Structure: 7. above. Fails if
     the node does not belong to one of the supported node types.

 -- Function: xml::is_blank_node
     Checks whether a node is a blank node (empty or whitespace only)
     and thus possibly ignorable.

 -- Function: xml::node_base node
     Returns the base URI of the given node.

 -- Function: xml::node_path node
     Returns the path of a node in the document, in the format accepted
     by `select'.

 -- Function: xml::node_content node
     Returns the text carried by the node, if any (after entity
     substitution).

  In addition, you can retrieve and change attributes of element nodes
with the following operations:

 -- Function: xml::node_attr node name
     Retrieves the value of the attribute with the given `name' (after
     entity substitution).

 -- Function: xml::set_node_attr node name value
 -- Function: xml::unset_node_attr node name
     Sets or unsets an attribute value.

  *Examples*

  Set and unset a node attribute:

    > xml::set_node_attr r "foo" "4711";
    ()
    > xml::node_info r;
    xml::element "story" [] ["foo"=>"4711"]
    > xml::node_attr r "foo";
    "4711"
    > xml::unset_node_attr r "foo";
    ()
    > xml::node_info r;
    xml::element "story" [] []

The `select' function is _very_ powerful, and probably the single most
important operation of this module if you want to extract information
from an existing XML document without traversing the entire structure.
Here is a very simple example of its use:

    > [xml::node_content n, xml::node_path n | n = xml::select sample "//author"];
    [("John Fleck","/story/storyinfo/author")]

Note that if the XPath expression contains qualified names, the
corresponding namespace prefixes and their URIs must be given in the
second argument along with the XPath, as follows:

    xml::select doc ("//foo:bar", ["foo"=>"http://www.foo.org"]);



File: pure-xml.info,  Node: Node Manipulation,  Next: Transformations,  Prev: Node Information,  Up: Operations

5.4 Node Manipulation
=====================

These operations enable you to manipulate the document structure by
adding a new node to the document tree (specified through its *note
node info: e.), and by removing (unlinking) existing nodes from the
tree.

 -- Function: xml::replace node info
     Add the new node specified by `info' in place of the given node
     `node'.

 -- Function: xml::add_first node info
 -- Function: xml::add_last node info
     Add the new node as the first or last child of `node',
     respectively.

 -- Function: xml::add_next node info
 -- Function: xml::add_prev node info
     Add the new node as the next or previous sibling of `node',
     respectively.

  The operations above all return a pointer to the new XML node object.

 -- Function: xml::unlink node
     Deletes an existing node from the document tree. Returns `()'.

  *Examples*

  Replace the first child of the root node in the sample document:

    > xml::node_info (r!0);
    xml::cdata "<greeting>Hello, world!</greeting>"
    > xml::replace (r!0) (xml::text "bla bla");
    #<pointer 0xd40d80>
    > xml::node_info (r!0);
    xml::text "bla bla"

Delete that node:

    > xml::unlink (r!0);
    ()
    > xml::node_info (r!0);
    xml::comment "This is a sample document for testing the xml interface."



File: pure-xml.info,  Node: Transformations,  Prev: Node Manipulation,  Up: Operations

5.5 Transformations
===================

The following operations provide basic XSLT support. As already
mentioned, stylesheets are represented as pointers to the
xsltStylesheet structure provided by libxslt. Note that, in difference
to XML document pointers, this is an opaque type, i.e., there is no
direct means to inspect and manipulate parsed stylesheets in memory
using the operations of this module. However, a stylesheet is just a
special kind of XML document and thus can be manipulated after reading
the stylesheet as an ordinary XML document. The *note load_stylesheet:
6c. function then allows you to convert the document pointer to an XSLT
Stylesheet object.

  Applying a stylesheet to an XML document generally involves the
following steps:

  1. Load and parse the stylesheet using *note load_stylesheet: 6c. The
     parameter to *note load_stylesheet: 6c. can be either the name of a
     stylesheet file or a corresponding document pointer. The function
     returns a pointer to the stylesheet object which is used in the
     subsequent processing.

  2. Invoke *note apply_stylesheet: 6d. on the stylesheet and the target
     document.  This returns a new document containing the transformed
     XML document.

  3. Run *note save_result_file: 6e. or *note save_result_string: 6f.
     on the result and the stylesheet to save the transformed document
     in a file or a string.

  Here is a brief summary of the XSLT operations. Please check the XSLT
(http://www.w3.org/TR/xslt) documentation for details of the
transformation process.

 -- Function: xslt::load_stylesheet x
     Load a stylesheet. `x' can be either an XML document pointer, or a
     string denoting the desired `.xsl' file.

 -- Function: xslt::apply_stylesheet style doc params
     Apply the stylesheet `style' to the given document `doc' with the
     given parameters `params'. The third argument is a (possibly empty)
     list of `key=>value' string pairs which allows you to pass
     additional parameters to the stylesheet.

 -- Function: xslt::save_result_file name doc style compression
 -- Function: xslt::save_result_string doc style
     Save the transformation result `doc' obtained with the stylesheet
     `style' to a file or a string. This works pretty much like
     `save_file' or `save_string', but also keeps track of some
     output-related information contained in the stylesheet.

  *Example*

  Load the recipes.xml document and the recipes.xsl stylesheet
distributed with the sources:

    > let recipes = xml::load_file "recipes.xml" xml::DTDVALID;
    > let style = xslt::load_stylesheet "recipes.xsl";

Apply the stylesheet to the document and save the result in a html file:

    > let res = xslt::apply_stylesheet style recipes [];
    > xslt::save_result_file "recipes.html" res style 0;
    ()

That's all. You can now have a look at recipes.html in your favourite
web browser.


File: pure-xml.info,  Node: Index,  Prev: Operations,  Up: Top

Index
*****

 [index ]
* Menu:

* attribute declaration:                 Document Types.      (line  49)
* attribute defaults:                    Document Types.      (line 107)
* dtd:                                   Document Types.      (line   6)
* element content:                       Document Types.      (line  91)
* element declaration:                   Document Types.      (line  24)
* entity declaration:                    Document Types.      (line  78)
* node info:                             The Document Tree.   (line  12)
* xml add_first function:                Node Manipulation.   (line  15)
* xml add_last function:                 Node Manipulation.   (line  15)
* xml add_next function:                 Node Manipulation.   (line  20)
* xml add_prev function:                 Node Manipulation.   (line  20)
* xml any_element constructor:           Document Types.      (line  37)
* xml attr constructor:                  The Document Tree.   (line  30)
* xml attrs function:                    Traversing Documents.
                                                              (line  44)
* xml cdata constructor:                 The Document Tree.   (line  37)
* xml cdata_attr constructor:            Document Types.      (line  58)
* xml children function:                 Traversing Documents.
                                                              (line  41)
* xml comment constructor:               The Document Tree.   (line  40)
* xml default constructor:               Document Types.      (line 117)
* xml doc function:                      Traversing Documents.
                                                              (line  16)
* xml doc_info function:                 Document Operations. (line  52)
* xml docp function:                     Data Structure.      (line  19)
* xml doctype constructor:               Document Types.      (line  14)
* xml element constructor:               The Document Tree.   (line  12)
* xml element_text constructor:          The Document Tree.   (line  24)
* xml empty_element constructor:         Document Types.      (line  34)
* xml entities_attr constructor:         Document Types.      (line  68)
* xml entity_attr constructor:           Document Types.      (line  66)
* xml entity_ref constructor:            The Document Tree.   (line  43)
* xml enum_attr constructor:             Document Types.      (line  74)
* xml ext_entity constructor:            Document Types.      (line  87)
* xml ext_param_entity constructor:      Document Types.      (line  89)
* xml ext_subset function:               Document Operations. (line  67)
* xml first function:                    Traversing Documents.
                                                              (line  22)
* xml first_attr function:               Traversing Documents.
                                                              (line  30)
* xml fixed constructor:                 Document Types.      (line 120)
* xml id_attr constructor:               Document Types.      (line  60)
* xml idref_attr constructor:            Document Types.      (line  62)
* xml idrefs_attr constructor:           Document Types.      (line  64)
* xml implied constructor:               Document Types.      (line 114)
* xml int_entity constructor:            Document Types.      (line  83)
* xml int_param_entity constructor:      Document Types.      (line  85)
* xml int_subset function:               Document Operations. (line  67)
* xml is_blank_node function:            Node Information.    (line  39)
* xml last function:                     Traversing Documents.
                                                              (line  22)
* xml last_attr function:                Traversing Documents.
                                                              (line  30)
* xml load_file function:                Document Operations. (line  25)
* xml load_string function:              Document Operations. (line  25)
* xml mixed_element constructor:         Document Types.      (line  40)
* xml module:                            Top.                 (line   6)
* xml mult constructor:                  Document Types.      (line 103)
* xml new_doc function:                  Document Operations. (line  10)
* xml next function:                     Traversing Documents.
                                                              (line  26)
* xml nmtoken_attr constructor:          Document Types.      (line  70)
* xml nmtokens_attr constructor:         Document Types.      (line  72)
* xml node_attr function:                Node Information.    (line  57)
* xml node_base function:                Node Information.    (line  43)
* xml node_content function:             Node Information.    (line  50)
* xml node_info function:                Node Information.    (line  34)
* xml node_path function:                Node Information.    (line  46)
* xml nodep function:                    Data Structure.      (line  22)
* xml notation_attr constructor:         Document Types.      (line  76)
* xml opt constructor:                   Document Types.      (line 101)
* xml parent function:                   Traversing Documents.
                                                              (line  19)
* xml pcdata constructor:                Document Types.      (line  95)
* xml pi constructor:                    The Document Tree.   (line  46)
* xml plus constructor:                  Document Types.      (line 105)
* xml prev function:                     Traversing Documents.
                                                              (line  26)
* xml replace function:                  Node Manipulation.   (line  11)
* xml required constructor:              Document Types.      (line 111)
* xml root function:                     Traversing Documents.
                                                              (line  13)
* xml save_file function:                Document Operations. (line  44)
* xml save_string function:              Document Operations. (line  44)
* xml select function:                   Node Information.    (line   9)
* xml sequence constructor:              Document Types.      (line  97)
* xml set_node_attr function:            Node Information.    (line  61)
* xml std_element constructor:           Document Types.      (line  45)
* xml text constructor:                  The Document Tree.   (line  34)
* xml undefined_element constructor:     Document Types.      (line  30)
* xml union constructor:                 Document Types.      (line  99)
* xml unlink function:                   Node Manipulation.   (line  27)
* xml unset_node_attr function:          Node Information.    (line  61)
* xslt apply_stylesheet function:        Transformations.     (line  42)
* xslt load_stylesheet function:         Transformations.     (line  38)
* xslt save_result_file function:        Transformations.     (line  48)
* xslt save_result_string function:      Transformations.     (line  48)
* xslt stylesheetp function:             Data Structure.      (line  25)



Tag Table:
Node: Top259
Ref: 0827
Ref: xml827
Ref: 1827
Ref: xslt827
Node: Copying1520
Ref: copying1602
Ref: 21602
Ref: module-xml1602
Ref: 31602
Ref: pure-xml-xml-xslt-interface1602
Ref: 41602
Node: Installation2319
Ref: installation2403
Ref: 52403
Node: Usage2643
Ref: usage2734
Ref: 62734
Node: Data Structure3197
Ref: data structure3286
Ref: 73286
Ref: data-structure3286
Ref: 93980
Ref: xml docp3980
Ref: a4059
Ref: xml nodep4059
Ref: b4154
Ref: xslt stylesheetp4154
Node: The Document Tree4295
Ref: the document tree4388
Ref: c4388
Ref: the-document-tree4388
Ref: d4725
Ref: index-04725
Ref: e4725
Ref: node-info4725
Ref: f4725
Ref: xml element4725
Ref: 105417
Ref: xml element_text5417
Ref: 115706
Ref: xml attr5706
Ref: 125887
Ref: xml text5887
Ref: 135975
Ref: xml cdata5975
Ref: 146080
Ref: xml comment6080
Ref: 156135
Ref: xml entity_ref6135
Ref: 166211
Ref: xml pi6211
Node: Document Types6368
Ref: document types6461
Ref: 176461
Ref: document-types6461
Ref: 186500
Ref: index-16500
Ref: 196500
Ref: dtd6500
Ref: 1a6951
Ref: document-type-definition6951
Ref: 1b6951
Ref: xml doctype6951
Ref: 1c7549
Ref: index-27549
Ref: 1d7549
Ref: element-declaration7549
Ref: 1f7868
Ref: xml undefined_element7868
Ref: 208044
Ref: xml empty_element8044
Ref: 218123
Ref: xml any_element8123
Ref: 228206
Ref: xml mixed_element8206
Ref: 238409
Ref: xml std_element8409
Ref: 248564
Ref: index-38564
Ref: 258564
Ref: attribute-declaration8564
Ref: 279041
Ref: xml cdata_attr9041
Ref: 289098
Ref: xml id_attr9098
Ref: 299152
Ref: xml idref_attr9152
Ref: 2a9209
Ref: xml idrefs_attr9209
Ref: 2b9267
Ref: xml entity_attr9267
Ref: 2c9325
Ref: xml entities_attr9325
Ref: 2d9385
Ref: xml nmtoken_attr9385
Ref: 2e9444
Ref: xml nmtokens_attr9444
Ref: 2f9504
Ref: xml enum_attr9504
Ref: 309565
Ref: xml notation_attr9565
Ref: 319630
Ref: index-49630
Ref: 329630
Ref: entity-declaration9630
Ref: 339868
Ref: xml int_entity9868
Ref: 349915
Ref: xml int_param_entity9915
Ref: 359968
Ref: xml ext_entity9968
Ref: 3610021
Ref: xml ext_param_entity10021
Ref: 3710080
Ref: index-510080
Ref: 1e10080
Ref: element-content10080
Ref: 3810277
Ref: xml pcdata10277
Ref: 3910330
Ref: xml sequence10330
Ref: 3a10390
Ref: xml union10390
Ref: 3b10446
Ref: xml opt10446
Ref: 3c10500
Ref: xml mult10500
Ref: 3d10555
Ref: xml plus10555
Ref: 3e10623
Ref: index-610623
Ref: 2610623
Ref: attribute-defaults10623
Ref: 3f10770
Ref: xml required10770
Ref: 4010862
Ref: xml implied10862
Ref: 4110965
Ref: xml default10965
Ref: 4211053
Ref: xml fixed11053
Node: Operations11137
Ref: operations11226
Ref: 4311226
Node: Document Operations11591
Ref: document operations11688
Ref: 4411688
Ref: document-operations11688
Ref: 4511902
Ref: xml new_doc11902
Ref: 4612706
Ref: xml load_file12706
Ref: 4712746
Ref: xml load_string12746
Ref: 4813314
Ref: xml save_file13314
Ref: 4913373
Ref: xml save_string13373
Ref: 4a13763
Ref: xml doc_info13763
Ref: 4b14703
Ref: standalone-document-declaration14703
Ref: 4c14703
Ref: xml int_subset14703
Ref: 4d14737
Ref: xml ext_subset14737
Node: Traversing Documents15178
Ref: traversing documents15300
Ref: 4e15300
Ref: traversing-documents15300
Ref: 5215754
Ref: xml root15754
Ref: 4f15811
Ref: xml doc15811
Ref: 5315876
Ref: xml parent15876
Ref: 5415934
Ref: xml first15934
Ref: 5515964
Ref: xml last15964
Ref: 5616025
Ref: xml next16025
Ref: 5716054
Ref: xml prev16054
Ref: 5816115
Ref: xml first_attr16115
Ref: 5916150
Ref: xml last_attr16150
Ref: 5a16472
Ref: xml children16472
Ref: 5b16557
Ref: xml attrs16557
Node: Node Information17050
Ref: node information17170
Ref: 5017170
Ref: node-information17170
Ref: 5c17288
Ref: xml select17288
Ref: 5d18659
Ref: xpath18659
Ref: 5e18660
Ref: xml node_info18660
Ref: 5f18901
Ref: xml is_blank_node18901
Ref: 6019039
Ref: xml node_base19039
Ref: 6119119
Ref: xml node_path19119
Ref: 6219244
Ref: xml node_content19244
Ref: 6319469
Ref: xml node_attr19469
Ref: 6419607
Ref: xml set_node_attr19607
Ref: 6519656
Ref: xml unset_node_attr19656
Node: Node Manipulation20685
Ref: node manipulation20800
Ref: 5120800
Ref: node-manipulation20800
Ref: 6621056
Ref: xml replace21056
Ref: 6721176
Ref: xml add_first21176
Ref: 6821215
Ref: xml add_last21215
Ref: 6921333
Ref: xml add_next21333
Ref: 6a21371
Ref: xml add_prev21371
Ref: 6b21567
Ref: xml unlink21567
Node: Transformations22111
Ref: transformations22201
Ref: 822201
Ref: 6c23764
Ref: xslt load_stylesheet23764
Ref: 6d23921
Ref: xslt apply_stylesheet23921
Ref: 6e24230
Ref: xslt save_result_file24230
Ref: 6f24294
Ref: xslt save_result_string24294
Node: Index25111
Ref: index25177

End Tag Table


Local Variables:
coding: utf-8
End:
