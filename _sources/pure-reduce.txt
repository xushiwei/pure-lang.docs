
====================================================
A REDUCE Interface for the Pure Programming Language
====================================================

.. default-domain:: pure
.. module:: reduce

Version 0.1, |today|

| Albert Graef <Dr.Graef@t-online.de>
| Kurt Pagani <kp@scios.ch>

This is a module providing access to the REDUCE_ computer algebra system from
Pure. It is based on the `PROC interface`_ (a "procedural" interface to embed
REDUCE as a C library). More background information and a discussion of the
interface can be found in the `Embedding REDUCE`_ thread on the Pure mailing
list.

.. _REDUCE: http://www.reduce-algebra.com/
.. _PROC interface: http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup
.. _Embedding REDUCE: http://groups.google.com/group/pure-lang/browse_thread/thread/c11e82ca2e9e8cbb

The interface can be found in reduce.pure (in particular, have a look at the
`high-level interface`_ defined near the end of the module), some basic
examples are in reduce_examp.pure. Please note that at present, this module is
still highly experimental and under heavy development. But the basic
functionality appears to work, and you're welcome to discuss the new interface
on the mailing list and/or submit bug reports and patches.

Installation
============

Get the latest source from
http://pure-lang.googlecode.com/files/pure-reduce-0.1.tar.gz.

You'll need both the embedded REDUCE library (named reduce.so, reduce.dylib or
reduce.dll, depending on the system you have) and a REDUCE image file
(reduce.img) to make this module work. A Makefile is included with this
package so that you can build these yourself from the REDUCE sources. (In
principle, this only needs to be done once for the initial installation of
this module, but you may want to repeat this procedure every once in a while
to get the latest REDUCE version.)

Check out the latest REDUCE version from its svn repository with the following
command:

.. code-block:: console

   svn co https://reduce-algebra.svn.sourceforge.net/svnroot/reduce-algebra/trunk/ reduce-algebra

This may take a while; REDUCE is a *big* package. Once it's finished, just
drop the resulting reduce-algebra directory into the pure-reduce source
directory. Run ``make`` and then (if needed) ``make install`` in the
pure-reduce source directory. You should also run ``make check`` which runs a
few tests in order to check that the interface works ok (this can be done
without installing the package, but needs the REDUCE image and library).

.. note:: In case the above procedure doesn't work for you, there are more
   detailed instructions by Kurt Pagani on how to compile the relevant parts
   of REDUCE, see the accompanying pure_reduce.txt file for details.
..

High-Level Interface
====================

The goal here is to make it easy to run REDUCE from Pure; to these ends,
the most important features of the low-level PROC interface are wrapped in
a convenient way. Currently the following variables and functions are
provided:

.. variable:: REDUCE_PATH

   This variable holds a colon-delimited search path used to locate the
   REDUCE image file (see :func:`reduce::start` below). By default this
   includes the current directory and the Pure library directory.

.. function:: reduce::start image::string args::smatrix

   Initializes the REDUCE system. This is done automatically when loading
   this module, so normally you shouldn't have to call this manually,
   unless the image file isn't found or you want to restart the REDUCE
   system with your own image file or your own set of options. In any
   case, this needs to be executed once before calling any other operation
   of this module. When calling this operation manually, you need to
   specify the name of the REDUCE image file and any desired extra
   arguments as a string vector. Unless the filename contains a slash,
   :func:`reduce::start` searches the directories in :var:`REDUCE_PATH` for
   the image file. An exception is raised if the image file isn't found.

.. function:: reduce::finish

   Finalizes the REDUCE system. You can call this to release the resources
   of the REDUCE system. (:func:`reduce::start` also invokes this
   automatically if a REDUCE instance is already running, so it isn't
   necessary to call :func:`reduce::finish` in this case.)

.. function:: reduce::verbosity n

   Sets the verbosity level; 0 means no messages at all (which is the
   default when using this module), and the following values may be or'ed
   together to pick what you need:

   | 1: messages whenever garbage collection happens
   | 2:  messages whenever a module of code is loaded
   | 4: extra details in the garbage collector messages

.. function:: reduce::load name::string

   Loads REDUCE packages. Please check the REDUCE documentation for
   details.

.. function:: reduce::switch name:string val::int

   Lets you change global REDUCE options. Please check the REDUCE
   documentation for details.

For convenience, the following operations are in the default namespace:

.. function:: simplify x

   This is the main entry point. It takes a REDUCE expression in Pure
   format and tries to simplify it using REDUCE. The result is then
   converted back to Pure format. Note that you need to quote ``x`` if you
   want to prevent it from being evaluated on the Pure side.

.. function:: lisp x

   This can be used to execute arbitrary Lisp code, which is sometimes
   necessary to perform special functions in the REDUCE system such as
   declarations. The result is always a Pure list or an atomic value. Note
   that you need to quote ``x`` if you want to prevent it from being
   evaluated on the Pure side. Use this with care; at present, the PROC
   interface isn't very forgiving if you try to execute invalid Lisp code;
   it will most likely crash in such cases.

.. function:: declare x ys

   Declare symbol properties. Currently, the following common kinds of
   declarations are supported::

     declare operator [foo,bar,...];
     declare depend [y,x,...];
     declare nodepend [y,x,...];
     declare property [x,y,...];

   In the latter form, ``property`` can be any of ``even``, ``odd``,
   ``linear`` and ``symmetric``. ``ys`` can also be a singleton symbol if
   the declaration permits this. Please see the Reduce manual for details.

In Pure land, REDUCE expressions are represented using standard curried
notation; some special conversions are applied to make arithmetic
operations such as +, * etc. work as expected. For convenience, the REDUCE
terms ``arbconst n``, ``arbint n`` and ``arbcomplex n`` are converted
from/to Greek symbols ``αn``, ``βn`` and ``ζn``. (All these automatic
conversions can also be turned off on the output side by disabling the
``mapped`` compilation option; this may be useful for debugging purposes.)

Here is a simple example showing how to start up REDUCE and do some
calculations::

  > using reduce;
  Reduce (Free CSL version), 27-Sep-12 ...
  > simplify $ df ((x+5)^3) x;
  3*x^2+30*x+75
  > simplify $ solve (x^2+7) x;
  [x==sqrt 7*i,x==-sqrt 7*i]

Another example showing how to execute Lisp code::

  > lisp ('list a b c d e);
  [a,b,c,d,e]
  > lisp ('cdr [a,b,[c,d],e]);
  [b,[c,d],e]

Note that Lisp forms are represented in curried notation. Free symbols are
quoted automatically, and Pure lists are converted to corresponding Lisp
lists. If the result is a Lisp list, it will be converted back to a Pure
list. The following example illustrates how you can use the :func:`lisp`
function to declare an operator symbol and change or query its properties::

  > lisp ('operator [myop]);
  []
  > lisp ('flag [myop] odd);
  []
  > lisp ('prop myop);
  [odd:t,simpfn:simpiden]
  > simplify (myop (-x));
  -myop x

The same can also be done with the :func:`declare` function as follows::

  > declare operator myop;
  []
  > declare odd myop;
  []
  > simplify (myop (-x));
  -myop x

Please see reduce_examp.pure and tests.pure for more examples.

