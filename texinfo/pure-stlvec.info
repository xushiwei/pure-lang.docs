This is pure-stlvec.info, produced by makeinfo version 4.13 from
pure-stlvec.texi.

Generated by Sphinx

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-stlvec: (pure-stlvec.info).    pure-stlvec
END-INFO-DIR-ENTRY


File: pure-stlvec.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-stlvec
***********

  Version 0.3, March 05, 2012

    Peter Summerland <<p.summerland@gmail.com>> 
  Pure's interface to C++ vectors, specialized to hold pointers to
arbitrary Pure expressions, and the C++ Standard Template Library
algorithms that act on them.

* Menu:

* Copying::
* Installation::
* Overview::
* Error Handling::
* Operations Included in the stlvec Module::
* STL Nonmodifying Algorithms::
* STL Modifying Algorithms::
* STL Sort Algorithms::
* STL Merge Algorithms::
* STL Heap Algorithms::
* Min/Max STL Algorithms::
* STL Numeric Algorithms::
* Reference Counting::
* Backward Compatibilty::
* Index::

 --- The Detailed Node Listing ---

Overview

* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Data Structure::
* Types::
* Copy-On-Write Semantics::
* Documentation::
* Parameter Names::

Error Handling

* Exception Symbols::
* Examples::

Operations Included in the stlvec Module

* Imports::
* Operations in the Global Namespace::
* Operations in the stl Namespace::
* Examples: Examples<2>.

STL Nonmodifying Algorithms

* Imports: Imports<2>.
* Operations::
* Examples: Examples<3>.

STL Modifying Algorithms

* Imports: Imports<3>.
* Operations: Operations<2>.
* Examples: Examples<4>.

STL Sort Algorithms

* Imports: Imports<4>.
* Operations: Operations<3>.
* Examples: Examples<5>.

STL Merge Algorithms

* Imports: Imports<5>.
* Operations: Operations<4>.
* Examples: Examples<6>.

STL Heap Algorithms

* Imports: Imports<6>.
* Operations: Operations<5>.
* Examples: Examples<7>.

Min/Max STL Algorithms

* Imports: Imports<7>.
* Operations: Operations<6>.
* Examples: Examples<8>.

STL Numeric Algorithms

* Imports: Imports<8>.
* Operations: Operations<7>.
* Examples: Examples<9>.

Backward Compatibilty

* stlvec-0 3::


File: pure-stlvec.info,  Node: Copying,  Next: Installation,  Prev: Top,  Up: Top

1 Copying
*********

    Copyright (c) 2011 by Peter Summerland <<p.summerland@gmail.com>>. 
All rights reserved.

  pure-stlvec is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  pure-stlvec is distributed under a BSD-style license, see the COPYING
file for details.


File: pure-stlvec.info,  Node: Installation,  Next: Overview,  Prev: Copying,  Up: Top

2 Installation
**************

pure-stlvec-0.3 is included in the "umbrella" addon, pure-stllib, which
is available at <http://code.google.com/p/pure-lang/downloads/list>.
After you have downloaded and installed `pure-stllib', you will be able
to use pure-stlvec (and `pure-stlmap', as well).


File: pure-stlvec.info,  Node: Overview,  Next: Error Handling,  Prev: Installation,  Up: Top

3 Overview
**********

The C++ Standard Template Library ("STL") is a library of generic
containers (data structures designed for storing other objects) and a
rich set of generic algorithms that operate on them. pure-stlvec
provides an interface to one of its most useful containers, "vector",
adopted to hold pointers to Pure expressions. The interface provides
Pure programmers with a mutable container "stlvec", that, like the
STL's vector, holds a sequence of objects that can be accessed in
constant time according to their position in the sequence.

* Menu:

* Modules::
* Simple Examples::
* Members and Sequences of Members::
* STL Iterators and Value Semantics::
* Iterator Tuples::
* Predefined Iterator Tuple Indexes::
* Back Insert Iterators::
* Data Structure::
* Types::
* Copy-On-Write Semantics::
* Documentation::
* Parameter Names::


File: pure-stlvec.info,  Node: Modules,  Next: Simple Examples,  Up: Overview

3.1 Modules
===========

The usual operations for creating, accessing and modifying stlvecs are
provided by the stlvec module. Most of the operations are similar in
name and function to those provided by the Pure Library for other
containers. As is the case for their Pure Library counterparts, these
operations are in the global namespace. There are a few operations that
have been placed in the stl namespace usually because they do not have
Pure Library counterparts.

  In addition to the stlvec module, pure-stlvec provides a group of
modules, stlvec::modifying, stlvec::nonmodifying, stlvec::sort,
stlvec::merge, stlvec::heap, stlvec::minmax and stlvec::numeric, that
are straight wrappers the STL algorithms (specialized to work with STL
vectors of pointers to Pure expressions). This grouping of the STL
algorithms follows that found at
http://www.cplusplus.com/reference/algorithm/. This web page contains a
table that summarizes of all of the algorithms in one place.

  pure-stlvec provides an "umbrella" module, stlvec::algorithms, that
pulls in all of the STL algorithm interface modules in one go. The STL
algorithm wrapper functions reside in the stl namespace and have the
same names as their counterparts in the STL.


File: pure-stlvec.info,  Node: Simple Examples,  Next: Members and Sequences of Members,  Prev: Modules,  Up: Overview

3.2 Simple Examples
===================

Here are some examples that use the basic operations provided by the
stlvec module.

    > using stlvec;

    > let sv1 = stlvec (0..4); members sv1;
    [0,1,2,3,4]

    > insert (sv1,stl::svend) (5..7); members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,3,4,5,6,7]

    > sv1!3;
    3

    > sv1!![2,4,6];
    [2,4,6]

    > replace sv1 3 33; members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,33,4,5,6,7]

    > stl::erase (sv1,2,5); members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,5,6,7]

    > insert (sv1,2) [2,3,4];  members sv1;
    STLVEC #<pointer 0xaf4d2c0>
    [0,1,2,3,4,5,6,7]

    > let pure_vector = stl::vector (sv1,1,5); pure_vector;
    {1,2,3,4}

    > stlvec pure_vector;
    STLVEC #<pointer 0x9145a38>

    > members ans;
    [1,2,3,4]

     > map (+10) sv1;
    [10,11,12,13,14,15,16,17]

    > map (+10) (sv1,2,5);
    [12,13,14]

    > foldl (+) 0 sv1;
    28

    > [x+10 | x = sv1; x mod 2];
    [11,13,15,17]

    > {x+10 | x = (sv1,2,6); x mod 2};
    {13,15}

Here are some examples that use STL algorithms.

    > using stlvec::algorithms;

    > stl::reverse (sv1,2,6); members sv1;
    ()
    [0,1,5,4,3,2,6,7]

    > stl::stable_sort sv1 (>); members sv1;
    ()
    [7,6,5,4,3,2,1,0]

    > stl::random_shuffle sv1; members sv1;
    ()
    [1,3,5,4,0,7,6,2]

    > stl::partition sv1 (<3); members (sv1,0,ans); members sv1;
    3
    [1,2,0]
    [1,2,0,4,5,7,6,3]

    > stl::transform sv1 (sv1,0) (*2); members sv1;
    -1
    [2,4,0,8,10,14,12,6]

    > let sv2 = emptystlvec;

    > stl::transform sv1 (sv2,stl::svback) (div 2); members sv2;
    -1
    [1,2,0,4,5,7,6,3]

Many more examples can be found in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Members and Sequences of Members,  Next: STL Iterators and Value Semantics,  Prev: Simple Examples,  Up: Overview

3.3 Members and Sequences of Members
====================================

Throughout the documentation for pure-stlvec, the member of a stlvec
that is at the nth position in the sequence of expressions stored in
the stlvec is referred to as its nth member or nth element. The nth
member of a stlvec, sv, is sometimes denoted by sv!n.  The sequence of
members of sv starting at position i up to but not including j is
denoted by sv[i,j). There is a "past-the-end" symbol, stl::svend, that
denotes the position after that occupied by the last member contained
by a stlvec.

  For example, if sv contains the sequence "a", "b", "c" "d" and "e",
sv!0 is "a", sv[1,3) is the sequence consisting of "b" followed by "c"
and v[3,stl::svend) denotes the sequence consisting of "d" followed by
"e".


File: pure-stlvec.info,  Node: STL Iterators and Value Semantics,  Next: Iterator Tuples,  Prev: Members and Sequences of Members,  Up: Overview

3.4 STL Iterators and Value Semantics
=====================================

In C++ a programmer accesses a STL container's elements by means of
"iterators", which can be thought of as pointers to the container's
elements. A single iterator can be used to access a specific element,
and a pair of iterators can be used to access a "range" of elements. By
convention, such a range includes the member pointed to by the first
iterator and all succeeding members up to but not including the member
pointed to by the second iterator. Each container has a past-the-end
iterator that can be used to specifiy ranges that include the
container's last member.

  In the case of vectors there is an obvious correspondence between an
iterator that points to an element and the element's position (starting
at zero) in the vector.  pure-stlvec uses this correspondence to
designate a stlvec's members in a way that makes it relatively easy to
see how pure-stlvec's functions are acting on the stlvec's underlying
STL vector by referencing the STL's documentation. Thus, if sv is a
stlvec, and j is an int, "replace sv j x" uses the STL to replace the
element pointed to by the iterator for position j of sv's underlying
STL vector. If, in addition, k is an int, stl::sort (sv,j,k) (<) uses
the STL to sort the elements in the range designated by the "jth" and
"kth" iterators for sv's underlying STL vector. This range, written as
sv[j,k), is the subsequence of sv that begins with the element at
position j and ends with the element at position (k-1).

  Besides iterators, another cornerstone of the STL is its "value
semantics", i.e., all of the STL containers are mutable and if a
container is copied, all of its elements are copied. pure-stlvec deals
with the STL's value semantics by introducing mutable and nonmutable
stlvecs, and by storing smart pointers to objects (which have cheap
copies) rather than the actual objects.


File: pure-stlvec.info,  Node: Iterator Tuples,  Next: Predefined Iterator Tuple Indexes,  Prev: STL Iterators and Value Semantics,  Up: Overview

3.5 Iterator Tuples
===================

As mentioned in the previous section, in C++ ranges are specified by a
pair of STL iterators.

  In pure-stlvec ranges of elements in a stlvec are specified by
"iterator tuples" rather than, say, actual pointers to STL iterators.
Iterator tuples consist of the name of a stlvec followed by one of more
ints that indicate positions (starting from zero) of the stlvec's
elements.

  To illustrate how iterator tuples are used, consider the STL
stable_sort function, which sorts objects in the range [first, last) in
the order imposed by comp. Its C++ signature looks like this:

     void stable_sort ( RandomAccessIterator first,
     RandomAccessIterator last, Compare comp )

  The corresponding pure-stlvec function, from the stlvec::sort module,
looks like this:

     stable_sort (msv, first, last) comp

  where msv is a mutable stlvec, and first and last are ints. The first
thing that the Pure stable_sort does is create a pair of C++ iterators
that point to the elements in msv's underlying STL vector that occupy
the positions designated by first and last.  Next it wraps the Pure
comp function in a C++ function object that, along with the two
iterators, is passed to the C++ stable_sort function.

  For convenience, (sv,stl::svbeg, stl::svend) can be written simply as
sv. Thus, if first were stl::svbeg (or 0), and last were stl::svend (or
#msv, the number of elements in msv), the last Pure call could be
written:

     stable_sort msv comp

  It should be noted that often the STL library provides a default
version of its functions, which like stable_sort, use a comparator or
other callback function provided by the caller. E.g., the C++
stable_sort has a default version that assumes the "<" operator can be
used on the elements held by the container in question:

     void stable_sort ( RandomAccessIterator first,
     RandomAccessIterator last)

  The corresponding functions provided by the pure-stlvec modules
rarely, if ever, supply a default version. A typical example is
stlvec::sort's stable_sort which must be called with a comparator
callback function:

     stable_sort msv (<);

  Note also that the comparator (e.g., (<)), or other function being
passed to a pure-stlvec algorithm wrapper is almost always the last
parameter. This is the opposite of what is required for similar Pure
functions, but is consistent with the STL calling conventions.


File: pure-stlvec.info,  Node: Predefined Iterator Tuple Indexes,  Next: Back Insert Iterators,  Prev: Iterator Tuples,  Up: Overview

3.6 Predefined Iterator Tuple Indexes
=====================================

The following integer constants are defined in the stl namespace for use
in iterator tuples.

 -- constant: stl::svbeg = 0
 -- constant: stl::svend = -1
 -- constant: stl::svback = -2

  These three symbols are declared as nonfix. `svend' corresponds to
STL's past-end iterator for STL vectors. It makes it possible to
specify ranges that include the last element of an stlvec. I.e., the
iterator tuple (sv,stl::svbeg,stl::svend) would specify sv[0,n), where
n is the number of elements in sv. In order to understand the purpose
of `svback', it is necessary to understand a bit about STL's "back
insert iterators."


File: pure-stlvec.info,  Node: Back Insert Iterators,  Next: Data Structure,  Prev: Predefined Iterator Tuple Indexes,  Up: Overview

3.7 Back Insert Iterators
=========================

Many of the STL algorithms insert members into a target range
designated by an iterator that points to the first member of the target
range. Consistent with raw C usage, it is ok to copy over existing
elements the target stlvec. E.g.,:

    > using stlvec::modifying;

    > let v1 = stlvec (0..2);

    > let v2 = stlvec ("a".."g");

    > stl::copy v1 (v2,2) $$ members v2;
    ["a","b",0,1,2,"f","g"]

This is great for C++ programmers, but for Pure programmers it is almost
always preferable to append the copied items to the end of a target
stlvec, rather than overwriting all or part or part of it. This can be
accomplished using stl::svback. E.g.,:

    > stl::copy v1 (v2,stl::svback) $$ members v2;
    ["a","b",0,1,2,"f","g",0,1,2]

In short, when a pure-stlvec function detects "stl::svback" in a target
iterator tuple, it constructs a STL "back inserter iterator" and passes
it on to the corresponding wrapped STL function.


File: pure-stlvec.info,  Node: Data Structure,  Next: Types,  Prev: Back Insert Iterators,  Up: Overview

3.8 Data Structure
==================

Currently, stlvecs are of the form (STLVEC x) or (CONST_STLVEC x), where
STLVEC AND CONST_STLVEC are defined as nonfix symbols in the global
namespace and x is a pointer to the underlying STL vector. The stlvec
module defines corresponding type tags, stlvec and const_stlvec, so the
programmer never needs to worry about the underlying representaton.

  This representation may change in the future, and must not be relied
upon by client modules. In particular, one must never attempt to use the
embedded pointer directly.

  As the names suggest, stlvecs are mutable and const_stlvecs are
immutable. Functions that modify a stlvec will simply fail unless the
stlvec is mutable.

    > let v = const_stlvec $ stlvec (0..3); v2;
    CONST_STLVEC #<pointer 0x8c1dbf0>

    > replace v 0 100; // fails
    replace (CONST_STLVEC #<pointer 0x9f07690> 0 100



File: pure-stlvec.info,  Node: Types,  Next: Copy-On-Write Semantics,  Prev: Data Structure,  Up: Overview

3.9 Types
=========

pure-stlvec introduces six type tags, all of which are in the global
namespace:

 -- type: mutable_stlvec
     The type for a mutable stlvec.

 -- type: const_stlvec
     The type for an immutable stlvec.

 -- type: stlvec
     The type for a stlvec, mutable or immutable.

 -- type: mutable_svit
     The type for an iterator tuple whose underlying stlvec is mutable.

 -- type: const_svit
     The type for an iterator tuple whose underlying stlvec is
     immutable.

 -- type: svit
     The type for an iterator tuple. The underlying stlvec can be
     mutable or immutable.


File: pure-stlvec.info,  Node: Copy-On-Write Semantics,  Next: Documentation,  Prev: Types,  Up: Overview

3.10 Copy-On-Write Semantics
============================

The pure-stlvec module functions do not implement automatic
copy-on-write semantics. Functions that modify stlvec parameters will
simply fail if they are passed a const_stlvec when they expect a
mutable_stlvec.

  For those that prefer immutable data structures, stlvecs can be
converted to const_stlvecs (usually after they have been created and
modified within a function) by the `const_stlvec' function. This
function converts a mutable stlvec to an immutable stlvec without
changing the underlying STL vector.

  Typically, a "pure" function that "modifies" a stlvec passed to it as
an argument will first copy the input stlvec to a new locally scoped
(mutable) stlvec using the stlvec function. It will then modify the new
stlvec and use const_stlvec to make the new stlvec immutable before it
is returned. It should be noted that several of the STL algorithms have
"copy" versions which place their results directly into a new stlvec,
which can eliminate the need to copy the input stlvec. E.g.:

    > let sv1 = stlvec ("a".."e");

    > let sv2 = emptystlvec;

    > stl::reverse_copy sv1 (sv2,stl::svback) $$ members sv2;
    ["e","d","c","b","a"]

Without reverse_copy, one would have had to copy sv1 into sv2 and then
reverse sv2.

  If desired, in Pure it is easy to write functions that have automatic
copy-on-write semantics. E.g.,

    > my_replace csv::const_stlvec i x = my_replace (stlvec csv) i x;
    > my_replace sv::stlvec i x = replace sv i x;



File: pure-stlvec.info,  Node: Documentation,  Next: Parameter Names,  Prev: Copy-On-Write Semantics,  Up: Overview

3.11 Documentation
==================

The pure-stllib directory includes a rudimentary cheatsheet,
pure-stllib-cheatsheet.pdf, that shows the signatures of all of the
functions provided by pure-stlvec (and by `pure-stlmap' as well).

  The documentation of the functions provided by the stlvec module are
reasonably complete.  In contrast, the descriptions of functions
provided by the STL algorithm modules are purposely simplified (and may
not, therefore, be technically accurate). This reflects that fact that
the functions provided by pure-stlvec have an obvious correspondence to
the functions provided by the STL, and the STL is extremely well
documented. Furthermore, using the Pure interpreter, it is very easy to
simply play around with with any of the pure-stlvec functions if there
are doubts, especially with respect to "corner cases."  Often this
leads to a deeper understanding compared to reading a precise technical
description.

  A good book on the STL is STL Tutorial and Reference Guide, Second
Edition, by David R. Musser, Gillmer J. Derge and Atul Saini. A summary
of all of the STL algorithms can be found at
<http://www.cplusplus.com/reference/stl/>.


File: pure-stlvec.info,  Node: Parameter Names,  Prev: Documentation,  Up: Overview

3.12 Parameter Names
====================

In the descriptions of functions that follow, parameter names used in
function descriptions represent specific types of Pure objects:

sv
     stlvec (mutable or immutable)

csv
     const (i.e., immutable) stlvec

msv
     mutable stlvec

x
     an arbitrary Pure expression

xs
     a list of arbitrary Pure expressions

count, sz, n
     whole numbers to indicate a number of elements, size of a vector,
     etc

i,j
     whole numbers used to designate indexes into a stlvec

f,m,l
     whole numbers (or stl::beg or stl::svend) designating the "first",
     "middle" or "last" iterators in a stlvec iterator tuple

p
     a whole number (or other iterator constant such as stl::svend or
     stl::svback) used in a two element iterator tuple (e.g., (sv,p))

(sv,p)
     an iterator tuple that will be mapped to an iterator that points
     to the pth position of sv's underlying STL vector, v, (or to a
     back iterator on v if p is stl::svback)

(sv,f,l)
     an iterator tuple that will be mapped to the pair of iterators
     that are designated by (sv,f) and (sv,l)

(sv,f,m,l)
     an iterator tuple that will be mapped to the iterators that are
     designated by (sv,f), (sv,m) and (sv,l)

sv[f,l)
     the range of members beginning with that at (sv,f) up to but not
     including that at (con,l)

comp
     a function that accepts two objects and returns true if the first
     argument is less than the second (in the strict weak ordering
     defined by comp), and false otherwise

unary_pred
     a function that accepts one object and returns true or false

bin_pred
     a function that accepts two objects and returns true or false

unary_fun
     a function that accepts one objects and returns another

bin_fun
     a function that accepts two objects and returns another

gen_fun
     a function of one parameter that produces a sequence of objects,
     one for each call

  For readability, and to correspond with the STL documentation, the
words "first", "middle", and "last", or variants such as "first1" are
often used instead of f,m,l.


File: pure-stlvec.info,  Node: Error Handling,  Next: Operations Included in the stlvec Module,  Prev: Overview,  Up: Top

4 Error Handling
****************

The functions provided this module handle errors by throwing exceptions.

* Menu:

* Exception Symbols::
* Examples::


File: pure-stlvec.info,  Node: Exception Symbols,  Next: Examples,  Up: Error Handling

4.1 Exception Symbols
=====================

 -- constructor: bad_argument
     This exception is thrown when a function is passed an unexpected
     value. A subtle error to watch for is a malformed iterator tuple
     (e.g., one with the wrong number of elements).

 -- constructor: bad_function
     This exception is thrown when a purported Pure call-back function
     is not even callable.

 -- constructor: failed_cond
     This exception is thrown when a Pure call-back predicate returns a
     value that is not an int.

 -- constructor: out_of_bounds
     This exception is thrown if the specified index is out of bounds.

 -- constructor: range_overflow
     This exception is thrown by functions that write over part of a
     target stlvec (e.g., copy) when the target range too small to
     accommodate the result.

 -- constructor: range_overlap
     This exception is thrown by algorithm functions that write over
     part of a target stlvec when the target and source ranges overlap
     in a way that is not allowed.

  In addition, any exception thrown by a Pure callback function passed
to a pure-stlvec function will be caught and be rethrown by the
pure-stlvec function.


File: pure-stlvec.info,  Node: Examples,  Prev: Exception Symbols,  Up: Error Handling

4.2 Examples
============

    > using stlvec, stlvec::modifying;

    > let sv1 = stlvec (0..4); members sv1;
    [0,1,2,3,4]

    > let sv2 = stlvec ("a".."e"); members sv2;
    ["a","b","c","d","e"]

    > sv1!10;
    <stdin>, line 25: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,10);
    <stdin>, line 26: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,2,3); // sb (sv2,pos)
    <stdin>, line 22: unhandled exception 'bad_argument' ...

    > stl::copy sv1 (sv2,2);
    <stdin>, line 23: unhandled exception 'range_overflow' ...

    > stl::copy sv2 (sv2,2);
    <stdin>, line 24: unhandled exception 'range_overlap' ...

    > stl::copy (sv1,1,3) (sv2,0); members sv2; // ok
    2
    [1,2,"c","d","e"]

    > stl::sort sv2 (>); // apples and oranges
    <stdin>, line 31: unhandled exception 'failed_cond'

    > listmap (\x->throw DOA) sv1; // callback function throws exception
    <stdin>, line 34: unhandled exception 'DOA' ...



File: pure-stlvec.info,  Node: Operations Included in the stlvec Module,  Next: STL Nonmodifying Algorithms,  Prev: Error Handling,  Up: Top

5 Operations Included in the stlvec Module
******************************************

The stlvec module provides functions for creating, accessing and
modifying stlvecs. In general, operations that have the same name as a
corresponding function in the Pure standard library are in the global
namespace. The remaining functions, which are usually specific to
stlvecs, are in the stl namespace.

  Please note that "stlvec to stlvec" functions are provided by the
pure-stl algorithm modules. Thus, for example, the stlvec module does
not provide a function that maps one stlvec onto a new stlvec. That
functionality, and more, is provided by stl::transform, which can be
found in the stlvec::modifying module.

* Menu:

* Imports::
* Operations in the Global Namespace::
* Operations in the stl Namespace::
* Examples: Examples<2>.


File: pure-stlvec.info,  Node: Imports,  Next: Operations in the Global Namespace,  Up: Operations Included in the stlvec Module

5.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec;



File: pure-stlvec.info,  Node: Operations in the Global Namespace,  Next: Operations in the stl Namespace,  Prev: Imports,  Up: Operations Included in the stlvec Module

5.2 Operations in the Global Namespace
======================================

When reading the function descriptions that follow, please bear in mind
that whenever a function is passed an iterator tuple of the form
(sv,first, last), first and last can be dropped, leaving (sv), or
simply sv. The function will treat the "unary" iterator tuple (sv) as
(sv, stl::svbeg, stl::svend).

 -- Function: emptystlvec
     return an empty stlvec

 -- Function: stlvec source
     create a new stlvec that contains the elements of source; source
     can be a stlvec, an iterator tuple(sv,first,last), a list or a
     vector (i.e., a matrix consisting of a single row or column). The
     underlying STL vector is always a new STL vector. I.e., if source
     is a stlvec the new stlvec does not share source's underlying STL
     vector.

 -- Function: mkstlvec x count
     create a new stlvec consisting of count x's.

 -- Function: const_stlvec source
     create a new const_stlvec that contains the elements of source;
     source can be a stlvec, an iterator tuple(sv,first,last), a list
     or a vector (i.e., a matrix consisting of a single row or column).
     If source is a stlvec (mutable or const), the new const_stlvec
     shares source's underlying STL vector.

 -- Function: # sv
     return the number of elements in sv.

  Note that # applied to an iterator tuple like (sv,b,e) will just
return the number of elements in the tuple. Use stl::bounds if you need
to know the number of elements in the range denoted by an iterator
tuple.

 -- Function: sv ! i
     return the ith member of sv

  Note that !k applied to an iterator tuple like (sv,b,e) will just
return the kth element of the tuple. In addition, in stlvec, integers
used to denote postions (as in !k) or in iterators, _always_, are
relative to the beginning of the underlying vector. So it makes no
sense to apply ! to an iterator tuple.

 -- Function: first sv
 -- Function: last sv
     first and last member of sv

 -- Function: members (sv, first, last)
     return a list of values stored in sv[first,last)

 -- Function: replace msv i x
     replace the ith member of msv by x and return x; throws
     out_of_bounds if i is less than 0 or great or equal to the number
     of elements in msv

 -- Function: update msv i x
     the same as replace except that update returns msv instead of x.
     This function is DEPRECATED.

 -- Function: append sv x
     append x to the end of sv

 -- Function: insert (msv,p) xs
 -- Function: insert (msv,p) (sv,first,last)
     insert members of the list xs or the range sv[first, last) into
     msv, all preceding the pth member of msv. Members are shifted to
     make room for the inserted members

 -- Function: rmfirst msv
 -- Function: rmlast msv
     remove the first or last member from msv

 -- Function: erase (msv,first,last)
 -- Function: erase (msv,p)
 -- Function: erase msv
     remove msv[first,last) from msv, remove msv!p from msv, or make msv
     empty. Members are shifted to occupy vacated slots

 -- Function: sv1 == sv2
 -- Function: sv1 ~= sv2
     (x == y) is the same as stl::allpairs (==) x y and x ~= y is simply
     ~(allpairs (==) x y)

  Note that `==' and `~==' are not defined for iterator tuples (the
rules would never be executed because == is defined on tuples in the
Prelude).

  The stlvec module provides convenience functions that apply map,
catmap, foldl, etc, to directly access Pure expressions stored in a
stlvec.

 -- Function: map unary_fun (sv, first, last)
     one pass equivalent of map unary_fun $ members (sv, first, last)

 -- Function: listmap unary_fun (sv, first, last)
     same as map, used in list comprehensions

 -- Function: catmap unary_fun (sv, first, last)
     one pass equivalent of catmap unary_fun $ members (sv, first, last)

 -- Function: do unary_fun (sv, first, last)
     one pass equivalent of do unary_fun $ members (sv, first, last)

 -- Function: foldl bin_fun x (sv, first, last)
     one pass equivalent of foldl bin_fun x $ members (sv, first, last)

 -- Function: foldl1 bin_fun (sv, first, last)
     one pass equivalent of foldl1 bin_fun $ members (sv, first, last)

 -- Function: filter unary_pred (sv, first, last)
     one pass equivalent of filter unary_pred $ members (sv, first,
     last)

  The following four functions map (or catmap) stlvecs onto row and col
matrixes, primarily for use in matrix comprehensions.

 -- Function: rowmap unary_fun (sv, first, last)

 -- Function: rowcatmap unary_fun (sv, first, last)

 -- Function: colmap unary_fun (sv, first, last)

 -- Function: colcatmap unary_fun (sv, first, last)


File: pure-stlvec.info,  Node: Operations in the stl Namespace,  Next: Examples<2>,  Prev: Operations in the Global Namespace,  Up: Operations Included in the stlvec Module

5.3 Operations in the stl Namespace
===================================

 -- Function: stl::empty sv
     test whether sv is empty

 -- Function: stl::vector (sv,first,last)
     create a Pure vector that contains the members of sv[first,last)

 -- Function: stl::allpairs bin_pred (sv1, first1, last1) (sv2, first2,
          last2)
     returns true if bin_pred is true for all corresponding members of
     sv1[first1, last1) and sv2[first2, last2)

 -- Function: stl::bounds (sv,first,last)
     throws out-of-bounds if first or last is out of bounds. returns
     the tuple (sv,first,last) except that if first is stl::begin it
     will be replaced by 0 and if last is stl::svend it will be
     replaced by the number of elements in sv.

 -- Function: stl::reserve msv count
     modify the underlying STL vector to have at least count slots,
     useful for packing data into a fixed size vector and possibly to
     speed up the addition of new members

 -- Function: stl::capacity sv
     return the number of slots (as opposed to the number of elements)
     held by the underlying STL vector


File: pure-stlvec.info,  Node: Examples<2>,  Prev: Operations in the stl Namespace,  Up: Operations Included in the stlvec Module

5.4 Examples
============

See ut_stlvec.pure and ut_global_stlvec.pure in the pure-stlvec/ut
directory.


File: pure-stlvec.info,  Node: STL Nonmodifying Algorithms,  Next: STL Modifying Algorithms,  Prev: Operations Included in the stlvec Module,  Up: Top

6 STL Nonmodifying Algorithms
*****************************

The stlvec::nonmodifying module provides an interface to the STL's
non-modifying sequence operations.

* Menu:

* Imports: Imports<2>.
* Operations::
* Examples: Examples<3>.


File: pure-stlvec.info,  Node: Imports<2>,  Next: Operations,  Up: STL Nonmodifying Algorithms

6.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::nonmodifying;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations,  Next: Examples<3>,  Prev: Imports<2>,  Up: STL Nonmodifying Algorithms

6.2 Operations
==============

 -- Function: stl::for_each (sv, first, last) unary_fun
     applies unary_fun to each of the elements in sv[first,last)

 -- Function: stl::find (sv, first, last) x
     returns the position of the first element in sv[first,last) for
     which (==x) is true (or stl::svend if not found)

 -- Function: stl::find_if (sv, first, last) unary_pred
     returns the position of the first element in sv[first,last) for
     which unary_pred is true (or stl::svend if not found)

 -- Function: stl::find_first_of (sv1, first1, last1) (sv2, first2,
          last2) bin_pred
     Returns the position of the first element, x, in sv1[first1,last1)
     for which there exists y in sv2[first2,last2) and (bin_pred x y)
     is true (or stl::svend if no such x exists).

 -- Function: stl::adjacent_find (sv, first, last) bin_pred
     search sv[first,last) for the first occurrence of two consecutive
     elements (x,y) for which (bin_pred x y) is true. Returns the
     position of x, if found, or stl::svend if not found)

 -- Function: stl::count (sv, first, last) x
     returns the number of elements in the range sv[first,last) for
     which (x==) is true

 -- Function: stl::count_if (sv, first, last) unary_pred
     returns the number of elements in the range sv[first,last) for
     which unary_pred is true

 -- Function: stl::mismatch (sv1, first1, last1) (sv2, first2) bin_pred
     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1 until it
     finds i and j such that bin_pred (sv1!i) (sv2!j) is false and
     returns (i,j). If bin_pred is true for all of the pairs of
     elements, i will be stl::svend and j will be first2 + n (or
     stl::svend)

 -- Function: stl::equal (sv1, first1, last1) (sv2, first2) bin_pred
     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1, and returns
     true if bin_pred is true for each pair

 -- Function: stl::search (sv1, first1, last1) (sv2, first2) bin_pred
     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the first occurrence of the sequence defined
     by sv2[first2,last2), and returns the position in sv1 of its first
     element (or stl::svend if not found)

 -- Function: stl::search_n (sv, first, last) count x bin_pred
     using bin_pred to determine equality of the elements, searches
     sv[first,last) for a sequence of count elements that equal x. If
     such a sequence is found, it returns the position of the first of
     its elements, otherwise it returns stl::svend

 -- Function: stl::find_end (sv1, first1, last1) (sv2, first2, last2)
          bin_pred
     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the last occurrence of sv2[first2,last2).
     Returns the position of the first element in sv1 of the occurrence
     (or stl::svend if not found).


File: pure-stlvec.info,  Node: Examples<3>,  Prev: Operations,  Up: STL Nonmodifying Algorithms

6.3 Examples
============

See ut_nonmodifying.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Modifying Algorithms,  Next: STL Sort Algorithms,  Prev: STL Nonmodifying Algorithms,  Up: Top

7 STL Modifying Algorithms
**************************

The stlvec::modifying module provides an interface to the STL's
modifying algorithms.

* Menu:

* Imports: Imports<3>.
* Operations: Operations<2>.
* Examples: Examples<4>.


File: pure-stlvec.info,  Node: Imports<3>,  Next: Operations<2>,  Up: STL Modifying Algorithms

7.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::modifying;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<2>,  Next: Examples<4>,  Prev: Imports<3>,  Up: STL Modifying Algorithms

7.2 Operations
==============

 -- Function: stl::copy (sv, first1, last1) (msv, first2)
     copies the elements in sv[first1,last1) into the range whose first
     element is (msv,first2)

 -- Function: stl::copy_backward (sv,first1,last1) (msv,last2)
     copies the elements in sv[first1,last1), moving backward from
     (last1), into the range msv[first2,last2) where first2 is last2
     minus the number of elements in sv[first1,last1)

 -- Function: stl::swap_ranges (sv,first,last) (msv, p)
     exchanges the elements in sv[first, last) with those in msv[p,
     p+n) where n is last - first

 -- Function: stl::transform (sv,first,last) (msv, p) unary_fun
     applies unary_fun to the elements of sv[first,last) and places the
     resulting sequence in msv[p, p+n) where n is last - first. If sv
     is mutable, msv and sv can be the same stlvec. Returns (msv,p+n)

 -- Function: stl::transform_2 (sv1,first1,last1) (sv2,first2) (msv, p)
          bin_fun
     applies bin_fun to corresponding pairs of elements of
     sv1[first1,last1) sv2[first2,n) and and places the resulting
     sequence in msv[p, p+n) where n is last1 - first1. Returns
     (msv,p+n)

 -- Function: stl::replace_if (msv,first,last) unary_pred x
     replace the elements of msv[first,last) that satistfy unary_pred
     with x

 -- Function: stl::replace_copy (sv,first,last) (msv,p) x y
     same as `replace' (msv,first,last) x y except that the modified
     sequence is placed in msv[p,p+last-first)

 -- Function: stl::replace_copy_if (sv,first,last) (msv,p) unary_pred x
     same as *note replace_if: 65. except that the modified sequence is
     placed in msv[p,p+last-first)

 -- Function: stl::fill (msv,first,last) x
     replace all elements in msv[first,last) with x

 -- Function: stl::fill_n (msv,first) n x
     replace the elements of msv[first,first+n) with x

 -- Function: stl::generate (msv,first,last) gen_fun
     replace the elements in msv[first,last) with the sequence
     generated by successive calls to gen_fun (), e.g.,

         > let count = ref 0;

         > g _ = n when n = get count + 1; put count n; end;

         > let sv = mkstlvec 0 10;

         > stl::generate sv g $$ members sv;
         [1,2,3,4,5,6,7,8,9,10]



 -- Function: stl::generate_n (msv,first) n gen_fun
     replace all elements in msv[first,first+n) with the sequence
     generated by successive calls to gen_fen

 -- Function: stl::remove (msv,first,last) x
     same as *note remove_if: 6d. (msv,first,last) (==x).

 -- Function: stl::remove_if (msv,first,last) unary_pred
     remove elements in msv[first,last) that satisfy unary_pred. If n
     elements do not satisfy unary_pred, they are moved to
     msv[first,first+n), preserving their relative order. The content
     of msv[first+n,svend) is undefined. Returns first+n, or stl::svend
     if first+n is greater than the number of elements in msv

 -- Function: stl::remove_copy (sv,first,last) (msv,first) x
     same as *note remove: 6c. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::remove_copy_if (sv,first,last) (msv,first) unary_pred
     same as *note remove_if: 6d. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::unique (msv,first,last) bin_pred
     eliminates consecutive duplicates from sv[first,last), using
     bin_pred to test for equality. The purged sequence is moved to
     sv[first,first+n) preserving their relative order, where n is the
     size of the purged sequence. Returns first+n or stl::svend if
     first+n is greater than the number of elements in msv

 -- Function: stl::unique_copy (sv,first,last) (msv,first) bin_pred
     same as *note unique: 70. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Function: stl::reverse (msv,first,last)
     Reverses the order of the elements in sv[first,last).

 -- Function: stl::reverse_copy (sv,first,last) (msv,first)
     same as *note reverse: 72. except that the reversed sequence is
     copied to (msv,first) and sv[first,last) is not changed.

 -- Function: stl::rotate (msv,first,middle,last)
     rotates the elements of msv[first,middle,last] so that middle
     becomes the first element of msv[first,last].

 -- Function: stl::rotate_copy (msv,first,middle,last) (msv,first)
     same as rotate except that the rotated sequence is copied to
     (msv,first) and sv[first,last) is not changed.

 -- Function: stl::random_shuffle (msv,first,last)
     randomly reorders the elements in msv[first,last)

 -- Function: stl::partition (msv,first,last) unary_pred
     places the elements in msv[first,last) that satisfy unary_pred
     before those that don't. Returns middle, where msv [first,middle)
     contains all of the elements that satisfy unary_pre, and msv
     [middle, last) contains those that do not

 -- Function: stl::stable_partition (msv,first,last) unary_pred
     same as partition except that the relative positions of the
     elements in each group are preserved


File: pure-stlvec.info,  Node: Examples<4>,  Prev: Operations<2>,  Up: STL Modifying Algorithms

7.3 Examples
============

See ut_modifying.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Sort Algorithms,  Next: STL Merge Algorithms,  Prev: STL Modifying Algorithms,  Up: Top

8 STL Sort Algorithms
*********************

The stlvec::sort module provides an interface to the STL's sorting and
binary search algorithms.

* Menu:

* Imports: Imports<4>.
* Operations: Operations<3>.
* Examples: Examples<5>.


File: pure-stlvec.info,  Node: Imports<4>,  Next: Operations<3>,  Up: STL Sort Algorithms

8.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::sort;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<3>,  Next: Examples<5>,  Prev: Imports<4>,  Up: STL Sort Algorithms

8.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering function, comp. The functions (<) and (>) are commonly passed
as comp.

 -- Function: stl::sort (msv, first, last) comp
     sorts msv[first, last)

 -- Function: stl::stable_sort (msv, first, last) comp
     sorts msv[first, last), preserving the relative order of equal
     members

 -- Function: stl::partial_sort (msv, first, middle, last) comp
     fills msv[first, middle) with the elements of msv[first,last) that
     would appear there if msv[first,last) were sorted using comp and
     fills msv[middle,last) with the remaining elements in unspecified
     order

 -- Function: stl::partial_sort_copy (sv, first1, last1) (msv, first2,
          last2) comp
     let n be the number of elements in sv[first1, last1) and r be the
     number of elements in msv[first2, last2). If r < n, *note
     partial_sort_copy: 80. fills msv[first2, last2) with the first r
     elements of what sv[first1, last1) would be if it had been sorted.
     If r >= n, it fills msv[first2, first2+n) with the elements of
     sv[first1, last1) in sorted order. sv[first1,last1) is unchanged

 -- Function: stl::nth_element (msv, first, middle, last) comp
     rearranges the elements of msv[first, last) as follows. Let n be
     middle - first, and let x be the nth smallest element of
     msv[first, last). After the function is called, sv!middle will be
     x. All of the elements of msv[first, middle) will be less than x
     and all of the elements of msv[middle+1, last) will be greater
     than x

  The next four functions assume that sv[first, last) is ordered by
comp.

 -- Function: stl::lower_bound (sv, first, last) x comp
     returns an int designating the first position into which x can be
     inserted into sv[first, last) while maintaining the sorted ordering

 -- Function: stl::upper_bound (sv, first, last) x comp
     returns an int designating the last position into which x can be
     inserted into sv[first, last) while maintaining the sorted ordering

 -- Function: stl::equal_range (sv, first, last) x comp
     returns a pair of ints, (lower, upper) where lower and upper would
     have been returned by separate calls to lower_bound and
     upper_bound.

 -- Function: stl::binary_search (sv, first, last) x comp
     returns true if x is an element of sv[first, last)


File: pure-stlvec.info,  Node: Examples<5>,  Prev: Operations<3>,  Up: STL Sort Algorithms

8.3 Examples
============

See ut_sort.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Merge Algorithms,  Next: STL Heap Algorithms,  Prev: STL Sort Algorithms,  Up: Top

9 STL Merge Algorithms
**********************

The stlvec::merge module provides an interface to the STL's merge
algorithms. These algorithms operate on sorted ranges.

* Menu:

* Imports: Imports<5>.
* Operations: Operations<4>.
* Examples: Examples<6>.


File: pure-stlvec.info,  Node: Imports<5>,  Next: Operations<4>,  Up: STL Merge Algorithms

9.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::merge;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<4>,  Next: Examples<6>,  Prev: Imports<5>,  Up: STL Merge Algorithms

9.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering function, comp (as for the Pure library sort function). They
only work properly on input ranges that have been previously sorted
using comp. The set operations generally do not check for range
overflow because it is not generally possible to determine the length
of the result of a set operation until after it is completed. In most
cases you will get a nasty segmentation fault if the result is bigger
than the target range. The best way to avoid this possibility it to use
a back iterator to specifify the target range.

  See parameter naming conventions at ..

 -- Function: stl::merge (sv1,first1,last1) (sv2,first2,last2) (msv,p)
          comp
     merges the two sorted ranges into the sorted range msv[p,p+n)
     where n is the total length of the merged sequence

 -- Function: stl::inplace_merge (msv,first, middle, last) comp
     merges msv[first,middle) and msv[middle,last) into the sorted range
     msv[first,last)

 -- Function: stl::includes (sv1,first1,last1) (sv2,first2,last2) comp
     returns true if every element of sv2[first2,last2) is an element
     of sv1[first1,last1)

 -- Function: stl::set_union (sv1,first1,last1) (sv2,first2,last2)
          (msv,p) comp
     places the sorted union of sv1[first1,last1) and sv2[first2,last2)
     into msv[p,p+n) where n is the number of elements in the sorted
     union, and returns the past-the-end position of the sorted union

 -- Function: stl::set_intersection (sv1,first1,last1)
          (sv2,first2,last2) (msv,p) comp
     places the sorted intersection of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of
     elements in the sorted intersection, and returns p+n (or
     stl::svend, if applicable)

 -- Function: stl::set_difference (sv1,first1,last1) (sv2,first2,last2)
          (msv,p) comp
     places the sorted difference of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of
     elements in the sorted difference, and returns p+n (or stl::svend,
     if applicable)

 -- Function: stl::set_symmetric_difference (sv1,first1,last1)
          (sv2,first2,last2) (msv,p) comp
     places the sorted symmetric_difference of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of
     elements in the sorted symmetric_difference, and returns returns
     p+n (or stl::svend, if applicable)


File: pure-stlvec.info,  Node: Examples<6>,  Prev: Operations<4>,  Up: STL Merge Algorithms

9.3 Examples
============

See ut_merge.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Heap Algorithms,  Next: Min/Max STL Algorithms,  Prev: STL Merge Algorithms,  Up: Top

10 STL Heap Algorithms
**********************

The stlvec::heap module provides an interface to the STL's heap
operations.

* Menu:

* Imports: Imports<6>.
* Operations: Operations<5>.
* Examples: Examples<7>.


File: pure-stlvec.info,  Node: Imports<6>,  Next: Operations<5>,  Up: STL Heap Algorithms

10.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::heap;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<5>,  Next: Examples<7>,  Prev: Imports<6>,  Up: STL Heap Algorithms

10.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering function, comp (as for the Pure library sort function). The
functions (<) and (>) are commonly passed as comp.

 -- Function: stl::make_heap (msv,first,last) comp
     rearranges the elements of msv[first,last) so that they are a
     heap, i.e., after this msv!first will be the largest element in
     msv[first,last), and push_heap and pop_heap will work properly

 -- Function: stl::push_heap (msv,first,last) comp
     makes msv[first,last) a heap (assuming that msv[first,last-1) was
     a heap)

 -- Function: stl::pop_heap (msv,first,last) comp
     swaps msv!first with msv!(last-1), and makes msv[first,last-1) a
     heap (assuming that msv[first,last) was a heap)

 -- Function: stl::sort_heap (msv,first,last) comp
     sorts the elements in msv[first,last)


File: pure-stlvec.info,  Node: Examples<7>,  Prev: Operations<5>,  Up: STL Heap Algorithms

10.3 Examples
=============

See ut_heap.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Min/Max STL Algorithms,  Next: STL Numeric Algorithms,  Prev: STL Heap Algorithms,  Up: Top

11 Min/Max STL Algorithms
*************************

The stlvec::minmax module provides an interface to a few additional STL
algorithms.

* Menu:

* Imports: Imports<7>.
* Operations: Operations<6>.
* Examples: Examples<8>.


File: pure-stlvec.info,  Node: Imports<7>,  Next: Operations<6>,  Up: Min/Max STL Algorithms

11.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::minmax;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<6>,  Next: Examples<8>,  Prev: Imports<7>,  Up: Min/Max STL Algorithms

11.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering function, comp (as for the Pure library sort function). The
functions (<) and (>) are commonly passed as comp.

 -- Function: stl::min_element (sv,first,last) comp
     returns the position of the minimal element of sv[first,last)
     under the ordering defined by comp

 -- Function: stl::max_element (sv,first,last) comp
     returns the position of the maximal element of sv[first,last)
     under the ordering defined by comp

 -- Function: stl::lexicographical_compare (sv1,first1,last1)
          (sv2,first2,last2) comp
     compares sv1[first1,last1) and sv2[first2,last2) element by element
     according to the ordering defined by comp, and returns true if the
     first sequence is less than the second

  Algorithms are provided for stepping through all the permutations the
elements of a stlvec. For these purposes, the first permutation has the
elements of msv[first,last) sorted in ascending order and the last has
the elements sorted in descending order.

 -- Function: stl::next_permutation (msv,first,last) comp
     rearranges msv[first,last) to produce the next permutation, in the
     ordering imposed by comp. If msv[first,last) is not the last
     permutation, change msv[first,last) to the next permutation and
     return true. Otherwise, change it to the first permutation and
     return true

 -- Function: stl::prev_permutation (msv,first,last) comp
     next_permutation in reverse


File: pure-stlvec.info,  Node: Examples<8>,  Prev: Operations<6>,  Up: Min/Max STL Algorithms

11.3 Examples
=============

See ut_minmax.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Numeric Algorithms,  Next: Reference Counting,  Prev: Min/Max STL Algorithms,  Up: Top

12 STL Numeric Algorithms
*************************

The stlvec::numeric module provides an interface to the STL's numeric
algorithms.

* Menu:

* Imports: Imports<8>.
* Operations: Operations<7>.
* Examples: Examples<9>.


File: pure-stlvec.info,  Node: Imports<8>,  Next: Operations<7>,  Up: STL Numeric Algorithms

12.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

    using stlvec::numeric;

All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<7>,  Next: Examples<9>,  Prev: Imports<8>,  Up: STL Numeric Algorithms

12.2 Operations
===============

 -- Function: stl::accumulate (sv,first,last) x bin_fun
     accumulate bin_fun over x and the members of sv[first,last), like
     foldl

 -- Function: stl::inner_product (sv1,first1,last1) (sv2,first2,last2)
          x bin_fun1 bin_fun2
     initialize ret with x. Traverse pairs of elements of
     sv1[first1,last1) and sv2[first2,last2), denoted by (e1, e2),
     replacing ret with (bin_fun1 ret $ bin_fun2 e1 e2). The number
     pairs traversed is equal to the size of sv1[first1,last1)

 -- Function: stl::partial_sum (sv,first,last) (msv, p) bin_fun
     accumulate bin_fun f over the elements of sv1[first1,last1),
     placing itermediate results in msv[p,p+n), where n is last -
     first, and returns q where m is q - n and msv[m,q) is the
     intermediate sequence

 -- Function: stl::adjacent_difference (sv,first,last) (msv, p) bin_fun
     produce a sequence of new elements by applying bin_fun to adjacent
     elements of sv[first,last), placing the new elements in
     msv[p,p+n), where n is last - first, with the intermediate
     results, and returns q where m is q - n and msv[m,q) is the new
     sequence


File: pure-stlvec.info,  Node: Examples<9>,  Prev: Operations<7>,  Up: STL Numeric Algorithms

12.3 Examples
=============

See ut_numeric.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Reference Counting,  Next: Backward Compatibilty,  Prev: STL Numeric Algorithms,  Up: Top

13 Reference Counting
*********************

The following function, also in the stl namespace, is available if you
want to observe how pure-stlvec maintains reference counts for items in
its containers.

 -- Function: stl::refc x
     returns the x's reference count (maintained by the Pure runtime for
     garbage collection purposes)


File: pure-stlvec.info,  Node: Backward Compatibilty,  Next: Index,  Prev: Reference Counting,  Up: Top

14 Backward Compatibilty
************************

This section documents changes in stlvec that might have introduced
backward compatiblity issues.

* Menu:

* stlvec-0 3::


File: pure-stlvec.info,  Node: stlvec-0 3,  Up: Backward Compatibilty

14.1 stlvec-0.3
===============

Version 0.3 reflects some changes made to make stlvec consistent with
its sister package, stlmap.

  The `update' function was deprecated. Please use `replace' instead.

  The `replace' function was added to the stlvec module. This function
is the same as `update' except that "`replace' sv i x" returns x
instead of sv.

  The `stl::replace' function was removed from the stlvec/modifying
module. You can use "*note stl replace_if: 65. (sv,first,last) (x==) y"
instead of "`stl::replace' (sv,first,last) x y" to replace all
instances of x in the specified range.

  The function `null' was removed and `stl::empty' was added to replace
it.

  The function `list' was removed. You can use `members' instead.

  All of the tracing functions were removed.


File: pure-stlvec.info,  Node: Index,  Prev: Backward Compatibilty,  Up: Top

Index
*****

 [index ]
* Menu:

* # prefix function:                     Operations in the Global Namespace.
                                                              (line  33)
* == infix function:                     Operations in the Global Namespace.
                                                              (line  85)
* append function:                       Operations in the Global Namespace.
                                                              (line  66)
* bad_argument constructor:              Exception Symbols.   (line   6)
* bad_function constructor:              Exception Symbols.   (line  11)
* catmap function:                       Operations in the Global Namespace.
                                                              (line 104)
* colcatmap function:                    Operations in the Global Namespace.
                                                              (line 129)
* colmap function:                       Operations in the Global Namespace.
                                                              (line 127)
* const_stlvec function:                 Operations in the Global Namespace.
                                                              (line  26)
* const_stlvec type:                     Types.               (line  12)
* const_svit type:                       Types.               (line  21)
* do function:                           Operations in the Global Namespace.
                                                              (line 107)
* emptystlvec function:                  Operations in the Global Namespace.
                                                              (line  12)
* erase function:                        Operations in the Global Namespace.
                                                              (line  79)
* failed_cond constructor:               Exception Symbols.   (line  15)
* filter function:                       Operations in the Global Namespace.
                                                              (line 116)
* first function:                        Operations in the Global Namespace.
                                                              (line  50)
* foldl function:                        Operations in the Global Namespace.
                                                              (line 110)
* foldl1 function:                       Operations in the Global Namespace.
                                                              (line 113)
* infix function:                        Operations in the Global Namespace.
                                                              (line  41)
* insert function:                       Operations in the Global Namespace.
                                                              (line  69)
* last function:                         Operations in the Global Namespace.
                                                              (line  50)
* listmap function:                      Operations in the Global Namespace.
                                                              (line 101)
* map function:                          Operations in the Global Namespace.
                                                              (line  98)
* members function:                      Operations in the Global Namespace.
                                                              (line  54)
* mkstlvec function:                     Operations in the Global Namespace.
                                                              (line  23)
* mutable_stlvec type:                   Types.               (line   9)
* mutable_svit type:                     Types.               (line  18)
* out_of_bounds constructor:             Exception Symbols.   (line  19)
* range_overflow constructor:            Exception Symbols.   (line  22)
* range_overlap constructor:             Exception Symbols.   (line  27)
* replace function:                      Operations in the Global Namespace.
                                                              (line  57)
* rmfirst function:                      Operations in the Global Namespace.
                                                              (line  75)
* rmlast function:                       Operations in the Global Namespace.
                                                              (line  75)
* rowcatmap function:                    Operations in the Global Namespace.
                                                              (line 125)
* rowmap function:                       Operations in the Global Namespace.
                                                              (line 123)
* stl accumulate function:               Operations<7>.       (line   6)
* stl adjacent_difference function:      Operations<7>.       (line  23)
* stl adjacent_find function:            Operations.          (line  23)
* stl allpairs function:                 Operations in the stl Namespace.
                                                              (line  12)
* stl binary_search function:            Operations<3>.       (line  56)
* stl bounds function:                   Operations in the stl Namespace.
                                                              (line  17)
* stl capacity function:                 Operations in the stl Namespace.
                                                              (line  28)
* stl copy function:                     Operations<2>.       (line   6)
* stl copy_backward function:            Operations<2>.       (line  10)
* stl count function:                    Operations.          (line  28)
* stl count_if function:                 Operations.          (line  32)
* stl empty function:                    Operations in the stl Namespace.
                                                              (line   6)
* stl equal function:                    Operations.          (line  44)
* stl equal_range function:              Operations<3>.       (line  51)
* stl fill function:                     Operations<2>.       (line  43)
* stl fill_n function:                   Operations<2>.       (line  46)
* stl find function:                     Operations.          (line   9)
* stl find_end function:                 Operations.          (line  61)
* stl find_first_of function:            Operations.          (line  17)
* stl find_if function:                  Operations.          (line  13)
* stl for_each function:                 Operations.          (line   6)
* stl generate function:                 Operations<2>.       (line  49)
* stl generate_n function:               Operations<2>.       (line  64)
* stl includes function:                 Operations<4>.       (line  27)
* stl inner_product function:            Operations<7>.       (line  10)
* stl inplace_merge function:            Operations<4>.       (line  23)
* stl lexicographical_compare function:  Operations<6>.       (line  18)
* stl lower_bound function:              Operations<3>.       (line  43)
* stl make_heap function:                Operations<5>.       (line  10)
* stl max_element function:              Operations<6>.       (line  14)
* stl merge function:                    Operations<4>.       (line  18)
* stl min_element function:              Operations<6>.       (line  10)
* stl mismatch function:                 Operations.          (line  36)
* stl next_permutation function:         Operations<6>.       (line  29)
* stl nth_element function:              Operations<3>.       (line  32)
* stl partial_sort function:             Operations<3>.       (line  17)
* stl partial_sort_copy function:        Operations<3>.       (line  23)
* stl partial_sum function:              Operations<7>.       (line  17)
* stl partition function:                Operations<2>.       (line 115)
* stl pop_heap function:                 Operations<5>.       (line  19)
* stl prev_permutation function:         Operations<6>.       (line  36)
* stl push_heap function:                Operations<5>.       (line  15)
* stl random_shuffle function:           Operations<2>.       (line 112)
* stl refc function:                     Reference Counting.  (line  10)
* stl remove function:                   Operations<2>.       (line  68)
* stl remove_copy function:              Operations<2>.       (line  78)
* stl remove_copy_if function:           Operations<2>.       (line  82)
* stl remove_if function:                Operations<2>.       (line  71)
* stl replace_copy function:             Operations<2>.       (line  35)
* stl replace_copy_if function:          Operations<2>.       (line  39)
* stl replace_if function:               Operations<2>.       (line  31)
* stl reserve function:                  Operations in the stl Namespace.
                                                              (line  23)
* stl reverse function:                  Operations<2>.       (line  97)
* stl reverse_copy function:             Operations<2>.       (line 100)
* stl rotate function:                   Operations<2>.       (line 104)
* stl rotate_copy function:              Operations<2>.       (line 108)
* stl search function:                   Operations.          (line  49)
* stl search_n function:                 Operations.          (line  55)
* stl set_difference function:           Operations<4>.       (line  44)
* stl set_intersection function:         Operations<4>.       (line  37)
* stl set_symmetric_difference function: Operations<4>.       (line  51)
* stl set_union function:                Operations<4>.       (line  31)
* stl sort function:                     Operations<3>.       (line  10)
* stl sort_heap function:                Operations<5>.       (line  23)
* stl stable_partition function:         Operations<2>.       (line 121)
* stl stable_sort function:              Operations<3>.       (line  13)
* stl svback constant:                   Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl svbeg constant:                    Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl svend constant:                    Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl swap_ranges function:              Operations<2>.       (line  15)
* stl transform function:                Operations<2>.       (line  19)
* stl transform_2 function:              Operations<2>.       (line  24)
* stl unique function:                   Operations<2>.       (line  86)
* stl unique_copy function:              Operations<2>.       (line  93)
* stl upper_bound function:              Operations<3>.       (line  47)
* stl vector function:                   Operations in the stl Namespace.
                                                              (line   9)
* stlvec function:                       Operations in the Global Namespace.
                                                              (line  15)
* stlvec module:                         Top.                 (line   6)
* stlvec type:                           Types.               (line  15)
* svit type:                             Types.               (line  25)
* update function:                       Operations in the Global Namespace.
                                                              (line  62)
* ~= infix function:                     Operations in the Global Namespace.
                                                              (line  85)



Tag Table:
Node: Top253
Ref: 0587
Ref: pure587
Node: Copying2228
Ref: copying2313
Ref: 12313
Ref: module-stlvec2313
Ref: 22313
Ref: 32313
Node: Installation2701
Ref: installation2791
Ref: 42791
Node: Overview3085
Ref: overview3182
Ref: 53182
Node: Modules4034
Ref: modules4115
Ref: 64115
Node: Simple Examples5350
Ref: simple examples5472
Ref: 75472
Ref: simple-examples5472
Node: Members and Sequences of Members7206
Ref: members and sequences of members7354
Ref: 87354
Ref: members-and-sequences-of-members7354
Node: STL Iterators and Value Semantics8145
Ref: stl iterators and value semantics8293
Ref: 98293
Ref: stl-iterators-and-value-semantics8293
Node: Iterator Tuples10215
Ref: iterator tuples10364
Ref: a10364
Ref: iterator-tuples10364
Node: Predefined Iterator Tuple Indexes12786
Ref: predefined iterator tuple indexes12923
Ref: b12923
Ref: predefined-iterator-tuple-indexes12923
Ref: c13094
Ref: stl svbeg13094
Ref: d13123
Ref: stl svend13123
Ref: e13153
Ref: stl svback13153
Node: Back Insert Iterators13616
Ref: back insert iterators13752
Ref: f13752
Ref: back-insert-iterators13752
Node: Data Structure14742
Ref: data structure14850
Ref: 1014850
Ref: data-structure14850
Node: Types15743
Ref: types15853
Ref: 1115853
Ref: 1215955
Ref: mutable_stlvec/type15955
Ref: 1316017
Ref: const_stlvec/type16017
Ref: 1416080
Ref: stlvec/type16080
Ref: 1516148
Ref: mutable_svit/type16148
Ref: 1616244
Ref: const_svit/type16244
Ref: 1716345
Ref: svit/type16345
Node: Copy-On-Write Semantics16454
Ref: copy-on-write semantics16563
Ref: 1816563
Ref: copy-on-write-semantics16563
Node: Documentation18091
Ref: documentation18210
Ref: 1918210
Node: Parameter Names19387
Ref: parameter names19474
Ref: 1a19474
Ref: parameter-names19474
Node: Error Handling21587
Ref: error handling21712
Ref: 1b21712
Ref: error-handling21712
Node: Exception Symbols21866
Ref: exception symbols21956
Ref: 1c21956
Ref: exception-symbols21956
Ref: 1d22001
Ref: bad_argument22001
Ref: 1e22224
Ref: bad_function22224
Ref: 1f22353
Ref: failed_cond/stlvec22353
Ref: 2022486
Ref: out_of_bounds/stlvec22486
Ref: 2122589
Ref: range_overflow22589
Ref: 2222787
Ref: range_overlap22787
Node: Examples23152
Ref: examples23242
Ref: 2323242
Node: Operations Included in the stlvec Module24223
Ref: operations included in the stlvec module24367
Ref: 2424367
Ref: operations-included-in-the-stlvec-module24367
Node: Imports25199
Ref: imports25331
Ref: 2525331
Node: Operations in the Global Namespace25469
Ref: operations in the global namespace25641
Ref: 2625641
Ref: operations-in-the-global-namespace25641
Ref: 2726024
Ref: emptystlvec26024
Ref: 2826079
Ref: stlvec26079
Ref: 2926472
Ref: mkstlvec26472
Ref: 2a26554
Ref: const_stlvec26554
Ref: 2b26912
Ref: #/stlvec26912
Ref: 2c27188
Ref: !/stlvec27188
Ref: 2d27554
Ref: first/stlvec27554
Ref: 2e27577
Ref: last/stlvec27577
Ref: 2f27633
Ref: members/stlvec27633
Ref: 3027728
Ref: replace/stlvec27728
Ref: 3127915
Ref: update/stlvec27915
Ref: 3228049
Ref: append/stlvec28049
Ref: 3328107
Ref: insert/stlvec28107
Ref: 3428139
Ref: insert28139
Ref: 3528364
Ref: rmfirst/stlvec28364
Ref: 3628390
Ref: rmlast/stlvec28390
Ref: 3728462
Ref: erase28462
Ref: 3828681
Ref: ==/stlvec28681
Ref: 3928706
Ref: ~=/stlvec28706
Ref: 3a29123
Ref: map/stlvec29123
Ref: 3b29240
Ref: listmap/stlvec29240
Ref: 3c29337
Ref: catmap/stlvec29337
Ref: 3d29460
Ref: do/stlvec29460
Ref: 3e29575
Ref: foldl/stlvec29575
Ref: 3f29696
Ref: foldl1/stlvec29696
Ref: 4029815
Ref: filter/stlvec29815
Ref: 4130072
Ref: rowmap/stlvec30072
Ref: 4230122
Ref: rowcatmap/stlvec30122
Ref: 4330175
Ref: colmap/stlvec30175
Ref: 4430225
Ref: colcatmap/stlvec30225
Node: Operations in the stl Namespace30278
Ref: operations in the stl namespace30454
Ref: 4530454
Ref: operations-in-the-stl-namespace30454
Ref: 4630527
Ref: stl empty/stlvec30527
Ref: 4730586
Ref: stl vector30586
Ref: 4830699
Ref: stl allpairs30699
Ref: 4930907
Ref: stl bounds30907
Ref: 4a31199
Ref: stl reserve31199
Ref: 4b31417
Ref: stl capacity31417
Node: Examples<2>31559
Ref: examples<2>31692
Ref: 4c31692
Ref: id131692
Node: STL Nonmodifying Algorithms31798
Ref: stl nonmodifying algorithms31952
Ref: 4d31952
Ref: stl-nonmodifying-algorithms31952
Node: Imports<2>32189
Ref: imports<2>32287
Ref: 4e32287
Ref: id232287
Node: Operations32486
Ref: operations32604
Ref: 4f32604
Ref: 5032635
Ref: stl for_each32635
Ref: 5132757
Ref: stl find32757
Ref: 5232925
Ref: stl find_if32925
Ref: 5333110
Ref: stl find_first_of33110
Ref: 5433397
Ref: stl adjacent_find33397
Ref: 5533653
Ref: stl count33653
Ref: 5633792
Ref: stl count_if33792
Ref: 5733948
Ref: stl mismatch33948
Ref: 5834374
Ref: stl equal34374
Ref: 5934632
Ref: stl search34632
Ref: 5a34957
Ref: stl search_n34957
Ref: 5b35281
Ref: stl find_end35281
Node: Examples<3>35615
Ref: examples<3>35714
Ref: 5c35714
Ref: id335714
Node: STL Modifying Algorithms35800
Ref: stl modifying algorithms35933
Ref: 5d35933
Ref: stl-modifying-algorithms35933
Node: Imports<3>36162
Ref: imports<3>36260
Ref: 5e36260
Ref: id436260
Node: Operations<2>36456
Ref: operations<2>36574
Ref: 5f36574
Ref: id536574
Ref: 6036605
Ref: stl copy36605
Ref: 6136765
Ref: stl copy_backward36765
Ref: 6237019
Ref: stl swap_ranges37019
Ref: 6337178
Ref: stl transform37178
Ref: 6437455
Ref: stl transform_237455
Ref: 6537750
Ref: stl replace_if37750
Ref: 6637893
Ref: stl replace_copy37893
Ref: 6738070
Ref: stl replace_copy_if38070
Ref: 6838250
Ref: stl fill38250
Ref: 6938346
Ref: stl fill_n38346
Ref: 6a38444
Ref: stl generate38444
Ref: 6b38826
Ref: stl generate_n38826
Ref: 6c38991
Ref: stl remove38991
Ref: 6d39095
Ref: stl remove_if39095
Ref: 6e39486
Ref: stl remove_copy39486
Ref: 6f39675
Ref: stl remove_copy_if39675
Ref: 7039879
Ref: stl unique39879
Ref: 7140263
Ref: stl unique_copy40263
Ref: 7240459
Ref: stl reverse40459
Ref: 7340563
Ref: stl reverse_copy40563
Ref: 7440755
Ref: stl rotate40755
Ref: 7540924
Ref: stl rotate_copy40924
Ref: 7641110
Ref: stl random_shuffle41110
Ref: 7741217
Ref: stl partition41217
Ref: 7841527
Ref: stl stable_partition41527
Node: Examples<4>41699
Ref: examples<4>41798
Ref: 7941798
Ref: id641798
Node: STL Sort Algorithms41881
Ref: stl sort algorithms42007
Ref: 7a42007
Ref: stl-sort-algorithms42007
Node: Imports<4>42237
Ref: imports<4>42330
Ref: 7b42330
Ref: id742330
Node: Operations<3>42521
Ref: operations<3>42634
Ref: 7c42634
Ref: id842634
Ref: 7d42814
Ref: stl sort42814
Ref: 7e42891
Ref: stl stable_sort42891
Ref: 7f43028
Ref: stl partial_sort43028
Ref: 8043317
Ref: stl partial_sort_copy43317
Ref: 8143825
Ref: stl nth_element43825
Ref: 8244317
Ref: stl lower_bound44317
Ref: 8344518
Ref: stl upper_bound44518
Ref: 8444718
Ref: stl equal_range44718
Ref: 8544926
Ref: stl binary_search44926
Node: Examples<5>45041
Ref: examples<5>45135
Ref: 8645135
Ref: id945135
Node: STL Merge Algorithms45213
Ref: stl merge algorithms45334
Ref: 8745334
Ref: stl-merge-algorithms45334
Node: Imports<5>45590
Ref: imports<5>45684
Ref: 8845684
Ref: id1045684
Node: Operations<4>45876
Ref: operations<4>45990
Ref: 8945990
Ref: id1145990
Ref: 8a46663
Ref: stl merge46663
Ref: 8b46873
Ref: stl inplace_merge46873
Ref: 8c47032
Ref: stl includes47032
Ref: 8d47200
Ref: stl set_union47200
Ref: 8e47502
Ref: stl set_intersection47502
Ref: 8f47819
Ref: stl set_difference47819
Ref: 9048130
Ref: stl set_symmetric_difference48130
Node: Examples<6>48479
Ref: examples<6>48574
Ref: 9148574
Ref: id1248574
Node: STL Heap Algorithms48653
Ref: stl heap algorithms48777
Ref: 9248777
Ref: stl-heap-algorithms48777
Node: Imports<6>48988
Ref: imports<6>49081
Ref: 9349081
Ref: id1349081
Node: Operations<5>49274
Ref: operations<5>49387
Ref: 9449387
Ref: id1449387
Ref: 9549609
Ref: stl make_heap49609
Ref: 9649865
Ref: stl push_heap49865
Ref: 9750001
Ref: stl pop_heap50001
Ref: 9850175
Ref: stl sort_heap50175
Node: Examples<7>50270
Ref: examples<7>50364
Ref: 9950364
Ref: id1550364
Node: Min/Max STL Algorithms50444
Ref: min/max stl algorithms50570
Ref: 9a50570
Ref: min-max-stl-algorithms50570
Node: Imports<7>50795
Ref: imports<7>50891
Ref: 9b50891
Ref: id1650891
Node: Operations<6>51086
Ref: operations<6>51202
Ref: 9c51202
Ref: id1751202
Ref: 9d51424
Ref: stl min_element51424
Ref: 9e51584
Ref: stl max_element51584
Ref: 9f51744
Ref: stl lexicographical_compare51744
Ref: a052287
Ref: stl next_permutation52287
Ref: a152638
Ref: stl prev_permutation52638
Node: Examples<8>52730
Ref: examples<8>52827
Ref: a252827
Ref: id1852827
Node: STL Numeric Algorithms52909
Ref: stl numeric algorithms53034
Ref: a353034
Ref: stl-numeric-algorithms53034
Node: Imports<8>53257
Ref: imports<8>53353
Ref: a453353
Ref: id1953353
Node: Operations<7>53549
Ref: operations<7>53665
Ref: a553665
Ref: id2053665
Ref: a653698
Ref: stl accumulate53698
Ref: a753837
Ref: stl inner_product53837
Ref: a854195
Ref: stl partial_sum54195
Ref: a954482
Ref: stl adjacent_difference54482
Node: Examples<9>54835
Ref: examples<9>54932
Ref: aa54932
Ref: id2154932
Node: Reference Counting55015
Ref: reference counting55139
Ref: ab55139
Ref: reference-counting55139
Ref: ac55344
Ref: stl refc55344
Node: Backward Compatibilty55478
Ref: backward compatibilty55585
Ref: ad55585
Ref: backward-compatibilty55585
Node: stlvec-0 355760
Ref: ae55833
Ref: stlvec-0-355833
Node: Index56621
Ref: index56701

End Tag Table


Local Variables:
coding: utf-8
End:
